{"version":3,"file":"object-utils.js","sourceRoot":"","sources":["object-utils.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,YAAY,EAAC,MAAM,UAAU,CAAC;AAEtC,kFAAkF;AAClF,oFAAoF;AACpF,mDAAmD;AACnD,EAAE;AACF,oEAAoE;AACpE,yCAAyC;AACzC,MAAM,UAAU,OAAO,CAAC,GAAO;IAC7B,IAAI,CAAC,GAAG,EAAE,CAAC;QACT,OAAO,EAAE,CAAC;IACZ,CAAC;IACD,GAAG,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;IACxB,MAAM,UAAU,GAAG,MAAM,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC;IAEnD,sFAAsF;IACtF,MAAM,gBAAgB,GAAG,MAAM,CAAC,yBAAyB,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;IAE5F,MAAM,UAAU,GAAG,CAAC,WAAW,CAAC,CAAC;IACjC,MAAM,iBAAiB,GAAG,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;QAC5E,IAAI,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;YACpC,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,YAAY,GAAG,gBAAgB,CAAC,UAAU,CAAC,CAAC;QAElD,OAAO,YAAY,CAAC,GAAG,IAAI,YAAY,CAAC,GAAG,CAAC;IAC9C,CAAC,CAAC,CAAC;IAEH,OAAO,UAAU,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;AAC9C,CAAC;AAED;;;;;GAKG;AACH,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,QAAa,EAAE,QAAgB,EAAkC,EAAE,CAC/F,MAAM,CAAC,wBAAwB,CAAC,QAAQ,EAAE,QAAQ,CAAC;IACnD,MAAM,CAAC,wBAAwB,CAAC,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {unwrapSignal} from '../utils';\n\n// Intentionally do not include all the prototype (Except for getters and setters)\n// because it contains inherited methods (hasOwnProperty, etc.). Also ignore symbols\n// because it is tricky to pass a path to a symbol.\n//\n// We'd have to go through a serialization and deserialization logic\n// which will add unnecessary complexity.\nexport function getKeys(obj: {}): string[] {\n  if (!obj) {\n    return [];\n  }\n  obj = unwrapSignal(obj);\n  const properties = Object.getOwnPropertyNames(obj);\n\n  // Object.getPrototypeOf can return null, on empty objectwithout prototype for example\n  const prototypeMembers = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(obj) ?? {});\n\n  const ignoreList = ['__proto__'];\n  const gettersAndSetters = Object.keys(prototypeMembers).filter((methodName) => {\n    if (ignoreList.includes(methodName)) {\n      return false;\n    }\n    const targetMethod = prototypeMembers[methodName];\n\n    return targetMethod.get || targetMethod.set;\n  });\n\n  return properties.concat(gettersAndSetters);\n}\n\n/**\n * This helper function covers the common scenario as well as the getters and setters\n * @param instance The target object\n * @param propName The string representation of the target property name\n * @returns The Descriptor object of the property\n */\nexport const getDescriptor = (instance: any, propName: string): PropertyDescriptor | undefined =>\n  Object.getOwnPropertyDescriptor(instance, propName) ||\n  Object.getOwnPropertyDescriptor(Object.getPrototypeOf(instance), propName);\n"]}