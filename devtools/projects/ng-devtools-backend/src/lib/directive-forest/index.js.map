{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,aAAa,EAAC,MAAM,SAAS,CAAC;AACtC,OAAO,EAAC,aAAa,EAAC,MAAM,eAAe,CAAC;AAE5C,OAAO,EACL,uBAAuB,EACvB,sCAAsC,EACtC,sBAAsB,GACvB,MAAM,SAAS,CAAC;AAEjB,2EAA2E;AAC3E,MAAM,aAAa,GAAG,IAAI,aAAa,EAAE,CAAC;AAC1C,MAAM,aAAa,GAAG,IAAI,aAAa,EAAE,CAAC;AAC1C,MAAM,UAAU,GAAG,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;AAElD,MAAM,cAAc,GAAG,CAAC,OAAgB,EAAwC,EAAE;IAChF,KAAK,MAAM,CAAC,IAAI,UAAU,EAAE,CAAC;QAC3B,IAAI,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC;YACxB,OAAO,CAAC,CAAC;QACX,CAAC;IACH,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,gCAAgC,GAAG,CAAC,QAAmB,EAAE,EAAE;IACtE,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;QAClC,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,OAAO,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;QAClC,uDAAuD;QACvD,8EAA8E;QAC9E,MAAM,QAAQ,GAAG,cAAc,CAAC,OAAO,CAAC,CAAC;QACzC,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,OAAO,QAAQ,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;IACtC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentTreeNode} from '../interfaces';\nimport {LTreeStrategy} from './ltree';\nimport {RTreeStrategy} from './render-tree';\n\nexport {\n  getDirectiveHostElement,\n  getLViewFromDirectiveOrElementInstance,\n  METADATA_PROPERTY_NAME,\n} from './ltree';\n\n// The order of the strategies matters. Lower indices have higher priority.\nconst rTreeStrategy = new RTreeStrategy();\nconst lTreeStrategy = new LTreeStrategy();\nconst strategies = [rTreeStrategy, lTreeStrategy];\n\nconst selectStrategy = (element: Element): RTreeStrategy | LTreeStrategy | null => {\n  for (const s of strategies) {\n    if (s.supports(element)) {\n      return s;\n    }\n  }\n  return null;\n};\n\nexport const buildDirectiveForestWithStrategy = (elements: Element[]) => {\n  if (!elements || !elements.length) {\n    return [];\n  }\n\n  let i = 0;\n  return elements.flatMap((element) => {\n    // Different roots can have different Angular versions.\n    // Different versions depend on different component tree discovery strategies.\n    const strategy = selectStrategy(element);\n    if (!strategy) {\n      return [];\n    }\n\n    return strategy.build(element, i++);\n  });\n};\n"]}