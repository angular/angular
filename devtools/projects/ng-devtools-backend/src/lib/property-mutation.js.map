{"version":3,"file":"property-mutation.js","sourceRoot":"","sources":["property-mutation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {Signal, WritableSignal} from '@angular/core';\nimport {isSignal} from './utils';\n\n/** Represents a property access operation. */\ninterface PropertyAccess {\n  /**\n   * The receiver of the property access (`foo` in `foo.bar`).\n   * If the receiver was a signal, this is not the signal function, but instead its\n   * underlying data.\n   */\n  receiver: any;\n\n  /** The key used in the property access (`'bar'` in `foo.bar`). */\n  key: string;\n\n  /**\n   * The value of the property access (result of `foo.bar`).\n   * If the value is a signal, this is still the signal *function*, not its\n   * underlying data.\n   */\n  value: any;\n}\n\n/**\n * Mutates the nested property under the provided object and assigns the new value.\n * Supports both plain objects/arrays as well deep mutations within a signal.\n *\n * @param obj The object to assign to.\n * @param keyPath An array of strings representing nested properties to be\n *     assigned.\n * @param newValue The value to assign.\n *\n * Example:\n *\n * ```typescript\n * const obj = {foo: {bar: [1]}};\n * mutateNestedProp(obj, ['foo', 'bar', '0'], 2);\n * obj.foo.bar[0]; // 2\n * ```\n *\n * When no signals are present, this performs a basic property assignment.\n *\n * ```typescript\n * mutateNestedProp(obj, ['foo', 'bar', '0'], 1);\n * // Equivalent to:\n * obj.foo.bar[0] = 1;\n * ```\n *\n * Signals are handled by performing an immutable copy of their contents.\n *\n * ```typescript\n * mutateNestedProp(obj, ['foo', 'bar', '1'], 2);\n * // If `foo` is a signal, equivalent to:\n * obj.foo.set({\n *   ...obj.foo(),\n *   bar: [\n *     ...obj.foo().bar.slice(0, 1),\n *     2,\n *     ...obj.foo().bar.slice(2),\n *   ],\n * });\n * ```\n *\n * The algorithm works by walking the full list of properties and looking for a\n * signal function. If one is found, we apply an immutable update on its contents\n * and call `.set` with the result. If no signals are found, we get the last\n * receiver in the chain and assign the value directly\n * (`receiver[prop] = newValue;`).\n */\nexport function mutateNestedProp(obj: any, keyPath: string[], newValue: unknown): void {\n  if (keyPath.length === 0) throw new Error('At least one key is required.');\n\n  const nestedProps = Array.from(getNestedProps(obj, keyPath));\n\n  // Check for nested signals.\n  const signalCount = nestedProps.filter((prop) => isSignal(prop.value)).length;\n  if (signalCount > 1) throw new Error('Cannot mutate nested signals.');\n\n  // Check for a single signal.\n  const signalIndex = nestedProps.findIndex((prop) => isSignal(prop.value));\n  if (signalIndex !== -1) {\n    const sig = nestedProps[signalIndex];\n    const props = nestedProps.slice(signalIndex + 1);\n\n    if (!isWritableSignal(sig.value)) {\n      const propPath = nestedProps\n        .slice(0, signalIndex + 1)\n        .map((prop) => prop.key)\n        .join('.');\n      throw new Error(`Cannot mutate a readonly signal at \\`${propPath}\\`.`);\n    }\n\n    sig.value.set(immutableUpdate(props, newValue));\n    return;\n  }\n\n  // No signals in this key path, just assign to the last receiver.\n  // First check to ensure there this is not a getter.\n  const finalProp = nestedProps[nestedProps.length - 1];\n  const descriptor = getInheritedPropertyDescriptor(finalProp.receiver, finalProp.key);\n  if (descriptor && descriptor.get && !descriptor.set) {\n    throw new Error(`Cannot mutate getter property: ${finalProp.key}`);\n  }\n\n  finalProp.receiver[finalProp.key] = newValue;\n}\n\n/** Walk the object properties and generate {@link PropertyAccess} objects. */\nfunction* getNestedProps(\n  receiver: any,\n  keyPath: ReadonlyArray<string>,\n): Generator<PropertyAccess, void, void> {\n  const keys = Array.from(keyPath);\n  while (keys.length !== 0) {\n    const key = keys.shift()!;\n\n    if (Array.isArray(receiver) && parseInt(key) >= receiver.length) {\n      throw new Error(`Cannot access index ${key} for array of length ${receiver.length}.`);\n    }\n\n    if (!(key in receiver)) {\n      throw new Error(`Property \\`${key}\\` is not defined on the object.`);\n    }\n\n    const value = receiver[key];\n    yield {\n      receiver,\n      key,\n      value,\n    };\n\n    receiver = isSignal(value) ? value() : value;\n  }\n}\n\n/**\n * Apply an immutable update assigning `newValue` to the list of properties\n * provided. Generates new objects and retains existing properties while\n * overwriting the specific nested property given.\n */\nfunction immutableUpdate(props: PropertyAccess[], newValue: unknown): any {\n  if (props.length === 0) return newValue;\n  const [prop, ...remainingProps] = props;\n\n  if (Array.isArray(prop.receiver)) {\n    const index = parseInt(prop.key);\n\n    return [\n      ...prop.receiver.slice(0, index),\n      immutableUpdate(remainingProps, newValue),\n      ...prop.receiver.slice(index + 1),\n    ];\n  } else if (typeof prop.receiver === 'object') {\n    assertSafeToImmutablyUpdate(prop.receiver);\n    return {\n      ...prop.receiver,\n      [prop.key]: immutableUpdate(remainingProps, newValue),\n    };\n  } else {\n    throw new Error(`Cannot immutably update type: ${prop.receiver.constructor.name}`);\n  }\n}\n\n/**\n * Gets the {@link PropertyDescriptor} for the given name, even if inherited from the\n * prototype. This is effectively equivalent to\n * {@link Object.getOwnPropertyDescriptor}, except it is not limited to \"own\"\n * properties.\n */\nfunction getInheritedPropertyDescriptor(\n  obj: {} | null,\n  prop: string,\n): PropertyDescriptor | undefined {\n  if (obj === null) return undefined;\n\n  const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n  if (descriptor) return descriptor;\n\n  return getInheritedPropertyDescriptor(Object.getPrototypeOf(obj), prop);\n}\n\n/** Assert that a given signal is writable. */\nfunction isWritableSignal<Value>(sig: Signal<Value>): sig is WritableSignal<Value> {\n  return 'set' in sig;\n}\n\n/**\n * Assert that the given object may be safely updated in an immutable fashion.\n *\n * Objects with user-defined prototypes may not be immutably updated because they\n * would lose their prototypes.\n *\n * ```typescript\n * ({...new MyFoo()}).doSomething(); // Doesn't work.\n * ```\n */\nfunction assertSafeToImmutablyUpdate(obj: {}): void {\n  // `new MyClass()` case.\n  if (obj.constructor !== Object) {\n    throw new Error(`Cannot immutably update type: ${obj.constructor.name}`);\n  }\n\n  // `{ get foo() { return 'foo'; } }` case.\n  // Need to check all inherited property descriptors, not just own descriptors.\n  for (const prop in obj) {\n    const descriptor = getInheritedPropertyDescriptor(obj, prop);\n    if (!descriptor) continue;\n\n    if (descriptor.get || descriptor.set) {\n      throw new Error('Cannot immutably update object with getters or setters.');\n    }\n  }\n}\n"]}