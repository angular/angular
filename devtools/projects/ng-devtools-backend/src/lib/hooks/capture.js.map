{"version":3,"file":"capture.js","sourceRoot":"","sources":["capture.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  DirectiveProfile,\n  ElementPosition,\n  ElementProfile,\n  LifecycleProfile,\n  ProfilerFrame,\n} from '../../../../protocol';\n\nimport {getDirectiveName} from '../highlighter';\nimport {ComponentTreeNode} from '../interfaces';\nimport {isCustomElement, runOutsideAngular} from '../utils';\n\nimport {initializeOrGetDirectiveForestHooks} from '.';\nimport {DirectiveForestHooks} from './hooks';\nimport {Hooks} from './profiler';\n\nlet inProgress = false;\nlet inChangeDetection = false;\nlet eventMap: Map<any, DirectiveProfile>;\nlet frameDuration = 0;\nlet hooks: Partial<Hooks> = {};\n\nexport const start = (onFrame: (frame: ProfilerFrame) => void): void => {\n  if (inProgress) {\n    throw new Error('Recording already in progress');\n  }\n  eventMap = new Map<any, DirectiveProfile>();\n  inProgress = true;\n  hooks = getHooks(onFrame);\n  initializeOrGetDirectiveForestHooks().profiler.subscribe(hooks);\n};\n\nexport const stop = (): ProfilerFrame => {\n  const directiveForestHooks = initializeOrGetDirectiveForestHooks();\n  const result = flushBuffer(directiveForestHooks);\n  initializeOrGetDirectiveForestHooks().profiler.unsubscribe(hooks);\n  hooks = {};\n  inProgress = false;\n  return result;\n};\n\nconst startEvent = (map: Record<string, number>, directive: any, label: string) => {\n  const name = getDirectiveName(directive);\n  const key = `${name}#${label}`;\n  map[key] = performance.now();\n};\n\nconst getEventStart = (map: Record<string, number>, directive: any, label: string) => {\n  const name = getDirectiveName(directive);\n  const key = `${name}#${label}`;\n  return map[key];\n};\n\nconst getHooks = (onFrame: (frame: ProfilerFrame) => void): Partial<Hooks> => {\n  const timeStartMap: Record<string, number> = {};\n  return {\n    // We flush here because it's possible the current node to overwrite\n    // an existing removed node.\n    onCreate(\n      directive: any,\n      node: Node,\n      _: number,\n      isComponent: boolean,\n      position: ElementPosition,\n    ): void {\n      eventMap.set(directive, {\n        isElement: isCustomElement(node),\n        name: getDirectiveName(directive),\n        isComponent,\n        lifecycle: {},\n        outputs: {},\n      });\n    },\n    onChangeDetectionStart(component: any, node: Node): void {\n      startEvent(timeStartMap, component, 'changeDetection');\n      if (!inChangeDetection) {\n        inChangeDetection = true;\n        const source = getChangeDetectionSource();\n        runOutsideAngular(() => {\n          Promise.resolve().then(() => {\n            inChangeDetection = false;\n            onFrame(flushBuffer(initializeOrGetDirectiveForestHooks(), source));\n          });\n        });\n      }\n      if (!eventMap.has(component)) {\n        eventMap.set(component, {\n          isElement: isCustomElement(node),\n          name: getDirectiveName(component),\n          isComponent: true,\n          changeDetection: 0,\n          lifecycle: {},\n          outputs: {},\n        });\n      }\n    },\n    onChangeDetectionEnd(component: any): void {\n      const profile = eventMap.get(component);\n\n      if (profile) {\n        let current = profile.changeDetection;\n        if (current === undefined) {\n          current = 0;\n        }\n        const startTimestamp = getEventStart(timeStartMap, component, 'changeDetection');\n        if (startTimestamp === undefined) {\n          return;\n        }\n        const duration = performance.now() - startTimestamp;\n        profile.changeDetection = current + duration;\n        frameDuration += duration;\n      } else {\n        console.warn('Could not find profile for', component);\n      }\n    },\n    onDestroy(\n      directive: any,\n      node: Node,\n      _: number,\n      isComponent: boolean,\n      __: ElementPosition,\n    ): void {\n      // Make sure we reflect such directives in the report.\n      if (!eventMap.has(directive)) {\n        eventMap.set(directive, {\n          isElement: isComponent && isCustomElement(node),\n          name: getDirectiveName(directive),\n          isComponent,\n          lifecycle: {},\n          outputs: {},\n        });\n      }\n    },\n    onLifecycleHookStart(\n      directive: any,\n      hookName: keyof LifecycleProfile,\n      node: Node,\n      __: number,\n      isComponent: boolean,\n    ): void {\n      startEvent(timeStartMap, directive, hookName);\n      if (!eventMap.has(directive)) {\n        eventMap.set(directive, {\n          isElement: isCustomElement(node),\n          name: getDirectiveName(directive),\n          isComponent,\n          lifecycle: {},\n          outputs: {},\n        });\n      }\n    },\n    onLifecycleHookEnd(\n      directive: any,\n      hookName: keyof LifecycleProfile,\n      _: Node,\n      __: number,\n      ___: boolean,\n    ): void {\n      const dir = eventMap.get(directive);\n      const startTimestamp = getEventStart(timeStartMap, directive, hookName);\n      if (startTimestamp === undefined) {\n        return;\n      }\n      if (!dir) {\n        console.warn('Could not find directive in onLifecycleHook callback', directive, hookName);\n        return;\n      }\n      const duration = performance.now() - startTimestamp;\n      dir.lifecycle[hookName] = (dir.lifecycle[hookName] || 0) + duration;\n      frameDuration += duration;\n    },\n    onOutputStart(\n      componentOrDirective: any,\n      outputName: string,\n      node: Node,\n      isComponent: boolean,\n    ): void {\n      startEvent(timeStartMap, componentOrDirective, outputName);\n      if (!eventMap.has(componentOrDirective)) {\n        eventMap.set(componentOrDirective, {\n          isElement: isCustomElement(node),\n          name: getDirectiveName(componentOrDirective),\n          isComponent,\n          lifecycle: {},\n          outputs: {},\n        });\n      }\n    },\n    onOutputEnd(componentOrDirective: any, outputName: string): void {\n      const name = outputName;\n      const entry = eventMap.get(componentOrDirective);\n      const startTimestamp = getEventStart(timeStartMap, componentOrDirective, name);\n      if (startTimestamp === undefined) {\n        return;\n      }\n      if (!entry) {\n        console.warn(\n          'Could not find directive or component in onOutputEnd callback',\n          componentOrDirective,\n          outputName,\n        );\n        return;\n      }\n      const duration = performance.now() - startTimestamp;\n      entry.outputs[name] = (entry.outputs[name] || 0) + duration;\n      frameDuration += duration;\n    },\n  };\n};\n\nconst insertOrMerge = (lastFrame: ElementProfile, profile: DirectiveProfile) => {\n  let exists = false;\n  lastFrame.directives.forEach((d) => {\n    if (d.name === profile.name) {\n      exists = true;\n      let current = d.changeDetection;\n      if (current === undefined) {\n        current = 0;\n      }\n      d.changeDetection = current + (profile.changeDetection ?? 0);\n      for (const key of Object.keys(profile.lifecycle) as (keyof LifecycleProfile)[]) {\n        if (!d.lifecycle[key]) {\n          d.lifecycle[key] = 0;\n        }\n        d.lifecycle[key]! += profile.lifecycle[key]!;\n      }\n      for (const key of Object.keys(profile.outputs)) {\n        if (!d.outputs[key]) {\n          d.outputs[key] = 0;\n        }\n        d.outputs[key] += profile.outputs[key];\n      }\n    }\n  });\n  if (!exists) {\n    lastFrame.directives.push(profile);\n  }\n};\n\nconst insertElementProfile = (\n  frames: ElementProfile[],\n  position: ElementPosition,\n  profile?: DirectiveProfile,\n) => {\n  if (!profile) {\n    return;\n  }\n  const original = frames;\n  for (let i = 0; i < position.length - 1; i++) {\n    const pos = position[i];\n    if (!frames[pos]) {\n      // TODO(mgechev): consider how to ensure we don't hit this case\n      console.warn('Unable to find parent node for', profile, original);\n      return;\n    }\n    frames = frames[pos].children;\n  }\n  const lastIdx = position[position.length - 1];\n  let lastFrame: ElementProfile = {\n    children: [],\n    directives: [],\n    type: 'element',\n  };\n  if (frames[lastIdx]) {\n    lastFrame = frames[lastIdx];\n  } else {\n    frames[lastIdx] = lastFrame;\n  }\n  insertOrMerge(lastFrame, profile);\n};\n\nconst prepareInitialFrame = (source: string, duration: number) => {\n  const frame: ProfilerFrame = {\n    source,\n    duration,\n    directives: [],\n  };\n  const directiveForestHooks = initializeOrGetDirectiveForestHooks();\n  const directiveForest = directiveForestHooks.getIndexedDirectiveForest();\n  const traverse = (node: ComponentTreeNode, children = frame.directives) => {\n    let position: ElementPosition | undefined;\n    if (node.component) {\n      position = directiveForestHooks.getDirectivePosition(node.component.instance);\n    } else if (node.directives[0]) {\n      position = directiveForestHooks.getDirectivePosition(node.directives[0].instance);\n    } else if (node.defer) {\n      position = directiveForestHooks.getDirectivePosition(node.defer);\n    }\n\n    if (position === undefined) {\n      return;\n    }\n    const directives = node.directives.map((d) => {\n      return {\n        isComponent: false,\n        isElement: false,\n        name: getDirectiveName(d.instance),\n        outputs: {},\n        lifecycle: {},\n      };\n    });\n    if (node.component) {\n      directives.push({\n        isElement: node.component.isElement,\n        isComponent: true,\n        lifecycle: {},\n        outputs: {},\n        name: getDirectiveName(node.component.instance),\n      });\n    }\n    const result: ElementProfile = {\n      children: [],\n      directives,\n      type: node.defer ? 'defer' : 'element',\n    };\n    children[position[position.length - 1]] = result;\n    node.children.forEach((n) => traverse(n, result.children));\n  };\n  directiveForest.forEach((n) => traverse(n));\n  return frame;\n};\n\nconst flushBuffer = (directiveForestHooks: DirectiveForestHooks, source: string = '') => {\n  const items = Array.from(eventMap.keys());\n  const positions: ElementPosition[] = [];\n  const positionDirective = new Map<ElementPosition, any>();\n  items.forEach((dir) => {\n    const position = directiveForestHooks.getDirectivePosition(dir);\n    if (position === undefined) {\n      return;\n    }\n    positions.push(position);\n    positionDirective.set(position, dir);\n  });\n  positions.sort(lexicographicOrder);\n\n  const result = prepareInitialFrame(source, frameDuration);\n  frameDuration = 0;\n\n  positions.forEach((position) => {\n    const dir = positionDirective.get(position);\n    insertElementProfile(result.directives, position, eventMap.get(dir));\n  });\n  eventMap = new Map<any, DirectiveProfile>();\n  return result;\n};\n\nconst getChangeDetectionSource = () => {\n  const zone = (window as any).Zone;\n  if (!zone || !zone.currentTask) {\n    return '';\n  }\n  return zone.currentTask.source;\n};\n\nconst lexicographicOrder = (a: ElementPosition, b: ElementPosition) => {\n  if (a.length < b.length) {\n    return -1;\n  }\n  if (a.length > b.length) {\n    return 1;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] < b[i]) {\n      return -1;\n    }\n    if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n  return 0;\n};\n"]}