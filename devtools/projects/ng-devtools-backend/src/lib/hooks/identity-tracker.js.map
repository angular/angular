{"version":3,"file":"identity-tracker.js","sourceRoot":"","sources":["identity-tracker.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DevToolsNode, ElementPosition} from '../../../../protocol';\n\nimport {buildDirectiveForest} from '../component-tree/component-tree';\nimport {ComponentInstanceType, ComponentTreeNode, DirectiveInstanceType} from '../interfaces';\n\nexport declare interface Type<T> extends Function {\n  new (...args: any[]): T;\n}\n\ninterface TreeNode {\n  parent: TreeNode;\n  directive?: Type<any>;\n  children: TreeNode[];\n}\n\nexport type NodeArray = {\n  directive: any;\n  isComponent: boolean;\n}[];\n\nexport class IdentityTracker {\n  private static _instance: IdentityTracker;\n\n  private _directiveIdCounter = 0;\n  private _currentDirectivePosition = new Map<any, ElementPosition>();\n  private _currentDirectiveId = new Map<any, number>();\n  isComponent = new Map<any, boolean>();\n\n  // private constructor for Singleton Pattern\n  private constructor() {}\n\n  static getInstance(): IdentityTracker {\n    if (!IdentityTracker._instance) {\n      IdentityTracker._instance = new IdentityTracker();\n    }\n    return IdentityTracker._instance;\n  }\n\n  getDirectivePosition(dir: any): ElementPosition | undefined {\n    return this._currentDirectivePosition.get(dir);\n  }\n\n  getDirectiveId(dir: any): number | undefined {\n    return this._currentDirectiveId.get(dir);\n  }\n\n  hasDirective(dir: any): boolean {\n    return this._currentDirectiveId.has(dir);\n  }\n\n  index(): {\n    newNodes: NodeArray;\n    removedNodes: NodeArray;\n    indexedForest: IndexedNode[];\n    directiveForest: ComponentTreeNode[];\n  } {\n    const directiveForest = buildDirectiveForest();\n    const indexedForest = indexForest(directiveForest);\n    const newNodes: NodeArray = [];\n    const removedNodes: NodeArray = [];\n    const allNodes = new Set<any>();\n    indexedForest.forEach((root) => this._index(root, null, newNodes, allNodes));\n    this._currentDirectiveId.forEach((_: number, dir: any) => {\n      if (!allNodes.has(dir)) {\n        removedNodes.push({directive: dir, isComponent: !!this.isComponent.get(dir)});\n        // We can't clean these up because during profiling\n        // they might be requested for removed components\n        // this._currentDirectiveId.delete(dir);\n        // this._currentDirectivePosition.delete(dir);\n      }\n    });\n    return {newNodes, removedNodes, indexedForest, directiveForest};\n  }\n\n  private _index(\n    node: IndexedNode,\n    parent: TreeNode | null,\n    newNodes: {directive: any; isComponent: boolean}[],\n    allNodes: Set<any>,\n  ): void {\n    if (node.component) {\n      allNodes.add(node.component.instance);\n      this.isComponent.set(node.component.instance, true);\n      this._indexNode(node.component.instance, node.position, newNodes);\n    }\n    (node.directives || []).forEach((dir) => {\n      allNodes.add(dir.instance);\n      this.isComponent.set(dir.instance, false);\n      this._indexNode(dir.instance, node.position, newNodes);\n    });\n    if (node.defer) {\n      this._indexNode(node.defer, node.position, newNodes);\n    }\n    node.children.forEach((child) => this._index(child, parent, newNodes, allNodes));\n  }\n\n  private _indexNode(directive: any, position: ElementPosition, newNodes: NodeArray): void {\n    this._currentDirectivePosition.set(directive, position);\n    if (!this._currentDirectiveId.has(directive)) {\n      newNodes.push({directive, isComponent: !!this.isComponent.get(directive)});\n      this._currentDirectiveId.set(directive, this._directiveIdCounter++);\n    }\n  }\n\n  destroy(): void {\n    this._currentDirectivePosition = new Map<any, ElementPosition>();\n    this._currentDirectiveId = new Map<any, number>();\n  }\n}\n\nexport interface IndexedNode extends DevToolsNode<DirectiveInstanceType, ComponentInstanceType> {\n  position: ElementPosition;\n  children: IndexedNode[];\n}\n\nconst indexTree = <T extends DevToolsNode<DirectiveInstanceType, ComponentInstanceType>>(\n  node: T,\n  idx: number,\n  parentPosition: number[] = [],\n): IndexedNode => {\n  const position = parentPosition.concat([idx]);\n  return {\n    position,\n    element: node.element,\n    component: node.component,\n    directives: node.directives.map((d) => ({position, ...d})),\n    children: node.children.map((n, i) => indexTree(n, i, position)),\n    nativeElement: node.nativeElement,\n    hydration: node.hydration,\n    defer: node.defer,\n  } as IndexedNode;\n};\n\nexport const indexForest = <T extends DevToolsNode<DirectiveInstanceType, ComponentInstanceType>>(\n  forest: T[],\n): IndexedNode[] => forest.map((n, i) => indexTree(n, i));\n"]}