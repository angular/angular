{"version":3,"file":"property-expanded-directive-properties.js","sourceRoot":"","sources":["property-expanded-directive-properties.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAyB,QAAQ,EAAC,MAAM,4BAA4B,CAAC;AAI5E,MAAM,CAAC,MAAM,8BAA8B,GAAG,CAAC,IAAgB,EAAgB,EAAE;IAC/E,MAAM,WAAW,GAAG,CAAC,IAAgB,EAAE,EAAE;QACvC,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;YAClF,OAAO,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CACnC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAgB,EAAmD,EAAE;gBACzE,OAAO;oBACL,IAAI,EAAE,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;oBACxD,QAAQ,EAAE,WAAW,CAAC,CAAC,CAAC;iBACzB,CAAC;YACJ,CAAC,CACF,CAAC;QACJ,CAAC;QACD,OAAO,EAAE,CAAC;IACZ,CAAC,CAAC;IAEF,MAAM,qBAAqB,GAAG,CAAC,KAAmC,EAAE,EAAE;QACpE,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;YACrC,OAAO;gBACL,IAAI;gBACJ,QAAQ,EAAE,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;aACnC,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IAEF,MAAM,OAAO,GAAiC,EAAE,CAAC;IAEjD,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE,CAAC;QACxB,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACrB,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC;YACnB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACrB,CAAC;QACD,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC;IACvC,CAAC;IAED,OAAO,qBAAqB,CAAC,OAAO,CAAC,CAAC;AACxC,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Descriptor, NestedProp, PropType} from '../../../../../../protocol';\n\nimport {FlatNode} from './element-property-resolver';\n\nexport const getExpandedDirectiveProperties = (data: FlatNode[]): NestedProp[] => {\n  const getChildren = (prop: Descriptor) => {\n    if ((prop.type === PropType.Object || prop.type === PropType.Array) && prop.value) {\n      return Object.entries(prop.value).map(\n        ([k, v]: [string, any]): {name: number | string; children: NestedProp[]} => {\n          return {\n            name: prop.type === PropType.Array ? parseInt(k, 10) : k,\n            children: getChildren(v),\n          };\n        },\n      );\n    }\n    return [];\n  };\n\n  const getExpandedProperties = (props: {[name: string]: Descriptor}) => {\n    return Object.keys(props).map((name) => {\n      return {\n        name,\n        children: getChildren(props[name]),\n      };\n    });\n  };\n\n  const parents: {[name: string]: Descriptor} = {};\n\n  for (const node of data) {\n    let prop = node.prop;\n    while (prop.parent) {\n      prop = prop.parent;\n    }\n    parents[prop.name] = prop.descriptor;\n  }\n\n  return getExpandedProperties(parents);\n};\n"]}