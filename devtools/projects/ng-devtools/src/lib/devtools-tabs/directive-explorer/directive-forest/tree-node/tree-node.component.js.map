{"version":3,"file":"tree-node.component.js","sourceRoot":"","sources":["tree-node.component.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  afterRenderEffect,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  ElementRef,\n  inject,\n  input,\n  output,\n  Renderer2,\n  viewChild,\n} from '@angular/core';\nimport {DOCUMENT} from '@angular/common';\n\nimport {MatIcon} from '@angular/material/icon';\nimport {MatTooltip} from '@angular/material/tooltip';\nimport {FlatTreeControl} from '@angular/cdk/tree';\n\nimport {FlatNode} from '../component-data-source';\nimport {getDirectivesArrayString, getFullNodeNameString} from '../directive-forest-utils';\n\nconst PADDING_LEFT_STEP = 15; // px\n\nexport type NodeTextMatch = {\n  startIdx: number;\n  endIdx: number;\n};\n\n@Component({\n  selector: 'ng-tree-node',\n  templateUrl: './tree-node.component.html',\n  styleUrls: ['./tree-node.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [MatIcon, MatTooltip],\n  host: {\n    '[style.padding-left]': 'paddingLeft()',\n    '[class.selected]': 'isSelected',\n    '[class.highlighted]': 'isHighlighted',\n    '[class.new-node]': 'node().newItem',\n    '(click)': 'selectNode.emit(this.node())',\n    '(dblclick)': 'selectDomElement.emit(this.node())',\n    '(mouseenter)': 'highlightNode.emit(this.node())',\n    '(mouseleave)': 'removeHighlight.emit()',\n  },\n})\nexport class TreeNodeComponent {\n  private readonly renderer = inject(Renderer2);\n  private readonly doc = inject(DOCUMENT);\n\n  protected readonly nodeName = viewChild.required<ElementRef>('nodeName');\n\n  protected readonly node = input.required<FlatNode>();\n  protected readonly selectedNode = input.required<FlatNode | null>();\n  protected readonly highlightedId = input.required<number | null>();\n  protected readonly treeControl = input.required<FlatTreeControl<FlatNode>>();\n  protected readonly textMatches = input<NodeTextMatch[]>([]);\n\n  protected readonly selectNode = output<FlatNode>();\n  protected readonly selectDomElement = output<FlatNode>();\n  protected readonly highlightNode = output<FlatNode>();\n  protected readonly removeHighlight = output<void>();\n\n  protected readonly paddingLeft = computed(\n    () => (this.node().level + 1) * PADDING_LEFT_STEP + 'px',\n  );\n  protected readonly isElement = computed(() => {\n    const cmp = this.node().original.component;\n    return cmp && cmp.isElement;\n  });\n  protected readonly directivesArrayString = computed(() => getDirectivesArrayString(this.node()));\n  private readonly nodeNameString = computed(() => getFullNodeNameString(this.node()));\n\n  private matchedText: HTMLElement | null = null;\n\n  protected readonly PADDING_LEFT_STEP = PADDING_LEFT_STEP;\n\n  constructor() {\n    afterRenderEffect({write: () => this.handleMatchedText()});\n  }\n\n  protected get isSelected(): boolean {\n    const selectedNode = this.selectedNode();\n    return !!selectedNode && selectedNode.id === this.node().id;\n  }\n\n  protected get isHighlighted(): boolean {\n    return !!this.highlightedId() && this.highlightedId() === this.node().original.component?.id;\n  }\n\n  private handleMatchedText() {\n    if (this.matchedText) {\n      this.renderer.removeChild(this.nodeName().nativeElement, this.matchedText);\n      this.matchedText = null;\n    }\n\n    const textMatches = this.textMatches();\n    if (textMatches.length) {\n      this.buildMatchedTextElement(textMatches);\n    }\n  }\n\n  private buildMatchedTextElement(textMatches: NodeTextMatch[]) {\n    const matchedText = this.renderer.createElement('span');\n    this.renderer.addClass(matchedText, 'matched-text');\n\n    const name = this.nodeNameString();\n    let lastMatchEndIdx = 0;\n\n    for (const {startIdx, endIdx} of textMatches) {\n      if (lastMatchEndIdx < startIdx) {\n        // Filler/non-marked text\n        this.appendText(matchedText, name.slice(lastMatchEndIdx, startIdx), false);\n      }\n      this.appendText(matchedText, name.slice(startIdx, endIdx), true);\n      lastMatchEndIdx = endIdx;\n    }\n\n    this.matchedText = matchedText;\n    this.renderer.appendChild(this.nodeName().nativeElement, this.matchedText);\n  }\n\n  private appendText(parent: HTMLElement, text: string, markedText = false) {\n    let textNode: Element | Text;\n    if (!markedText) {\n      textNode = this.doc.createTextNode(text);\n    } else {\n      textNode = this.renderer.createElement('mark');\n      textNode.textContent = text;\n    }\n    this.renderer.appendChild(parent, textNode);\n  }\n}\n"]}