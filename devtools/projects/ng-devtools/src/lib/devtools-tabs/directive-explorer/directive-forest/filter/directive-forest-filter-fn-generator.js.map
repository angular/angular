{"version":3,"file":"directive-forest-filter-fn-generator.js","sourceRoot":"","sources":["directive-forest-filter-fn-generator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FilterFn, FilterFnGenerator, FilterMatch} from './filter.component';\n\n//\n// Types & Constants\n//\n\ntype TokenType =\n  | 'opening_bracket'\n  | 'closing_bracket'\n  | 'chevron_left'\n  | 'chevron_right'\n  | 'slash'\n  | 'space'\n  | 'text';\n\ninterface Token {\n  type: TokenType;\n  value: string;\n  idx: number;\n}\n\nconst TERMINAL_CHAR = ['[', ']', '<', '>', '/', ' '];\nconst CHAR_TO_TOKEN: {[key: string]: TokenType} = {\n  '[': 'opening_bracket',\n  ']': 'closing_bracket',\n  '<': 'chevron_left',\n  '>': 'chevron_right',\n  '/': 'slash',\n  ' ': 'space',\n};\n\ninterface ParsedValue {\n  value: string;\n  idx: number;\n}\n\nexport interface ParsedFilter {\n  component?: ParsedValue;\n  directives: ParsedValue[];\n  element?: ParsedValue;\n}\n\n//\n// Helpers\n//\n\nfunction toParserValue(token: Token): ParsedValue {\n  return {\n    value: token.value,\n    idx: token.idx,\n  };\n}\n\nfunction checkForMatch(filter?: ParsedValue, target?: ParsedValue): FilterMatch | null {\n  if (!filter || !target) {\n    return null;\n  }\n  const startIdx = target.value.indexOf(filter.value);\n\n  if (startIdx > -1) {\n    const start = startIdx + target.idx;\n    return {\n      startIdx: start,\n      endIdx: start + filter.value.length,\n    };\n  }\n  return null;\n}\n\n//\n// Lexer/Tokenizer\n//\n\nexport function tokenizeDirectiveForestFilter(text: string): Token[] {\n  const tokens: Token[] = [];\n  let buffer = '';\n\n  const attemptToPushToken = (i: number) => {\n    if (buffer) {\n      tokens.push({\n        value: buffer,\n        type: 'text',\n        idx: i - buffer.length,\n      });\n      buffer = '';\n    }\n  };\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n\n    if (TERMINAL_CHAR.includes(char)) {\n      attemptToPushToken(i);\n      tokens.push({\n        type: CHAR_TO_TOKEN[char],\n        value: char,\n        idx: i,\n      });\n    } else {\n      buffer += char;\n    }\n  }\n\n  attemptToPushToken(text.length);\n\n  return tokens;\n}\n\n//\n// Parser\n//\n\nexport function parseDirectiveForestFilter(tokens: Token[]): ParsedFilter {\n  const filter: ParsedFilter = {\n    directives: [],\n  };\n\n  if (!tokens.length) {\n    return filter;\n  }\n\n  let tokenIdx = 0;\n  let token: Token | undefined;\n  const nextToken = () => tokens[tokenIdx++];\n  const hasTokens = () => tokenIdx < tokens.length;\n\n  const parseComponent = () => {\n    return token ? toParserValue(token) : undefined;\n  };\n\n  const parseDirectives = () => {\n    const directives = [];\n\n    while (hasTokens()) {\n      token = nextToken();\n      if (token.type === 'text') {\n        directives.push(toParserValue(token));\n      }\n      if (token.type === 'closing_bracket') {\n        break;\n      }\n    }\n\n    return directives;\n  };\n\n  const parseElement = () => {\n    while (hasTokens()) {\n      token = nextToken();\n      if (token.type === 'text') {\n        return toParserValue(token);\n      }\n    }\n    return;\n  };\n\n  while (hasTokens()) {\n    token = nextToken();\n    switch (token.type) {\n      case 'opening_bracket':\n        filter.directives = filter.directives.concat(parseDirectives());\n        break;\n      case 'text':\n        filter.component = parseComponent();\n        break;\n      case 'chevron_left':\n        filter.element = parseElement();\n        break;\n    }\n  }\n\n  return filter;\n}\n\n//\n// `FilterFn` Generator\n//\n\n/** Generates a `FilterFn`, that performs token matching, for the directive-forest filter. */\nexport const directiveForestFilterFnGenerator: FilterFnGenerator = (filter: string): FilterFn => {\n  const filterTokens = tokenizeDirectiveForestFilter(filter.toLowerCase());\n  const parsedFilter = parseDirectiveForestFilter(filterTokens);\n\n  return (target: string) => {\n    if (!filter) {\n      return [];\n    }\n    if (!parsedFilter.element && !parsedFilter.component && !parsedFilter.directives.length) {\n      // Fallback – standard string search.\n      const match = checkForMatch(\n        {value: filter.toLowerCase(), idx: 0},\n        {value: target.toLowerCase(), idx: 0},\n      );\n      return match ? [match] : [];\n    }\n\n    const matches = [];\n    const targetTokens = tokenizeDirectiveForestFilter(target.toLowerCase());\n    const parsedTarget = parseDirectiveForestFilter(targetTokens);\n\n    if (parsedFilter.element) {\n      const elementMatch = checkForMatch(parsedFilter.element, parsedTarget.element);\n      // The element cannot have component and/or directive(s).\n      if (elementMatch) {\n        return [elementMatch];\n      }\n    }\n\n    if (parsedFilter.component) {\n      const componentMatch = checkForMatch(parsedFilter.component, parsedTarget.component);\n      if (!componentMatch) {\n        return [];\n      }\n      matches.push(componentMatch);\n    }\n\n    if (parsedFilter.directives.length) {\n      let matchesCount = 0;\n      for (const targetDir of parsedTarget.directives) {\n        for (const filterDir of parsedFilter.directives) {\n          const dirMatch = checkForMatch(filterDir, targetDir);\n          if (dirMatch) {\n            matches.push(dirMatch);\n            matchesCount++;\n          }\n        }\n      }\n      // Should have full directives match.\n      if (matchesCount < parsedFilter.directives.length) {\n        return [];\n      }\n    }\n\n    return matches;\n  };\n};\n"]}