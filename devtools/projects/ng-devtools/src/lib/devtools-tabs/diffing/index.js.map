{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AASH,MAAM,CAAC,MAAM,IAAI,GAAG,CAClB,MAAgC,EAChC,CAAM,EACN,CAAM,EAC+C,EAAE;IACvD,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACf,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAEf,MAAM,UAAU,GAAc,EAAE,CAAC;IACjC,MAAM,UAAU,GAAQ,EAAE,CAAC;IAE3B,mEAAmE;IACnE,4DAA4D;IAC5D,mDAAmD;IACnD,MAAM,CAAC,gBAAgB,CAAC,CAAC,MAAM,EAAE,EAAE;QACjC,IAAI,MAAM,CAAC,YAAY,KAAK,IAAI,EAAE,CAAC;YACjC,OAAO;QACT,CAAC;QACD,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,EAAE,CAAC;YAClC,OAAO;QACT,CAAC;QACD,sDAAsD;QACtD,uDAAuD;QACvD,sDAAsD;QACtD,sDAAsD;QACtD,sDAAsD;QACtD,0DAA0D;QAC1D,yDAAyD;QACzD,gEAAgE;QAChE,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;YACtC,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;QACnD,CAAC;aAAM,CAAC;YACN,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,EAAkB,CAAC;QAC9C,CAAC;QACD,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,CAAkB,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACpE,kEAAkE;YAClE,IAAI,MAAM,CAAC,YAAY,KAAK,IAAI,EAAE,CAAC;gBACjC,OAAO;YACT,CAAC;YACA,CAAC,CAAC,MAAM,CAAC,YAAY,CAAS,CAAC,IAAI,CAAC,GAAI,CAAC,CAAC,MAAM,CAAC,YAAY,CAAS,CAAC,IAAI,CAAC,CAAC;QAChF,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;YACtC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,GAAG,IAAK,CAAC;QAClC,CAAC;QACD,UAAU,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC;QACvC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;IAC1C,CAAC,CAAC,CAAC;IAEH,4DAA4D;IAC5D,MAAM,QAAQ,GAAQ,EAAE,CAAC;IACzB,MAAM,YAAY,GAAQ,EAAE,CAAC;IAC7B,MAAM,CAAC,gBAAgB,CAAC,CAAC,MAAM,EAAE,EAAE;QACjC,IAAI,MAAM,CAAC,YAAY,KAAK,IAAI,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,EAAE,CAAC;YAClE,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC;YACrC,UAAU,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC;YACvC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC7B,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,kBAAkB,CAAC,CAAC,MAAM,EAAE,EAAE;QACnC,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,EAAE,CAAC;YAClC,OAAO;QACT,CAAC;QACD,IAAI,MAAM,CAAC,YAAY,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;YACtE,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,GAAG,IAAK,CAAC;QAClC,CAAC;QACD,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QACvC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;YAClB,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACjB,CAAC;IACH,CAAC;IAED,OAAO,EAAC,QAAQ,EAAE,YAAY,EAAE,UAAU,EAAC,CAAC;AAC9C,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DefaultIterableDiffer} from '@angular/core';\n\nexport interface MovedRecord {\n  currentIndex: number;\n  previousIndex: number;\n}\n\nexport const diff = <T>(\n  differ: DefaultIterableDiffer<T>,\n  a: T[],\n  b: T[],\n): {newItems: T[]; removedItems: T[]; movedItems: T[]} => {\n  differ.diff(a);\n  differ.diff(b);\n\n  const alreadySet: boolean[] = [];\n  const movedItems: T[] = [];\n\n  // We first have to set the moved items to their correct positions.\n  // Keep in mind that the track by function may not guarantee\n  // that we haven't changed any of the items' props.\n  differ.forEachMovedItem((record) => {\n    if (record.currentIndex === null) {\n      return;\n    }\n    if (record.previousIndex === null) {\n      return;\n    }\n    // We want to preserve the reference so that a default\n    // track by function used by the CDK, for instance, can\n    // recognize that this item's identity hasn't changed.\n    // At the same time, since we don't have the guarantee\n    // that we haven't already set the previousIndex while\n    // iterating, we need to check that. If we have, we assign\n    // this array item to a new object. We don't want to risk\n    // changing the properties of an object we'll use in the future.\n    if (!alreadySet[record.previousIndex]) {\n      a[record.currentIndex] = a[record.previousIndex];\n    } else {\n      a[record.currentIndex] = {} as unknown as T;\n    }\n    Object.keys(b[record.currentIndex] as unknown as {}).forEach((prop) => {\n      // TypeScript's type inference didn't follow the check from above.\n      if (record.currentIndex === null) {\n        return;\n      }\n      (a[record.currentIndex] as any)[prop] = (b[record.currentIndex] as any)[prop];\n    });\n    if (!alreadySet[record.previousIndex]) {\n      a[record.previousIndex] = null!;\n    }\n    alreadySet[record.currentIndex] = true;\n    movedItems.push(a[record.currentIndex]);\n  });\n\n  // Now we can set the new items and remove the deleted ones.\n  const newItems: T[] = [];\n  const removedItems: T[] = [];\n  differ.forEachAddedItem((record) => {\n    if (record.currentIndex !== null && record.previousIndex === null) {\n      a[record.currentIndex] = record.item;\n      alreadySet[record.currentIndex] = true;\n      newItems.push(record.item);\n    }\n  });\n\n  differ.forEachRemovedItem((record) => {\n    if (record.previousIndex === null) {\n      return;\n    }\n    if (record.currentIndex === null && !alreadySet[record.previousIndex]) {\n      a[record.previousIndex] = null!;\n    }\n    removedItems.push(record.item);\n  });\n\n  for (let i = a.length - 1; i >= 0; i--) {\n    if (a[i] === null) {\n      a.splice(i, 1);\n    }\n  }\n\n  return {newItems, removedItems, movedItems};\n};\n"]}