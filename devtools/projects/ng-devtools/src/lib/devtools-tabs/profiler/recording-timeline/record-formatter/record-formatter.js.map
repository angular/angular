{"version":3,"file":"record-formatter.js","sourceRoot":"","sources":["record-formatter.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAoBH,MAAM,OAAgB,eAAe;IAInC,QAAQ,CAAC,OAAuB;QAC9B,IAAI,OAAO,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;YAC7B,OAAO,QAAQ,CAAC;QAClB,CAAC;QAED,MAAM,IAAI,GAAG,OAAO,CAAC,UAAU;aAC5B,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC;aAC5B,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;aAClB,IAAI,CAAC,IAAI,CAAC,CAAC;QACd,MAAM,UAAU,GAAG;YACjB,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;SAChF,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACb,OAAO,UAAU,KAAK,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,UAAU,GAAG,CAAC;IAC7D,CAAC;IAED,QAAQ,CAAC,OAAuB;QAC9B,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;YACjC,MAAM,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,iBAAiB,CAAC,SAA2B;QAC3C,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,IAAI,OAAO,GAAG,SAAS,CAAC,eAAe,CAAC;QACxC,IAAI,OAAO,KAAK,SAAS,EAAE,CAAC;YAC1B,OAAO,GAAG,CAAC,CAAC;QACd,CAAC;QACD,MAAM,IAAI,OAAO,CAAC;QAClB,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,gBAAgB,EAAE,EAAE;YAC9D,MAAM,KAAK,GAAG,UAAU,CAAC,gBAAgB,CAAC,CAAC;YAC3C,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC;gBAClB,MAAM,IAAI,KAAK,CAAC;YAClB,CAAC;QACH,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAChB,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DirectiveProfile, ElementProfile, type ProfilerFrame} from '../../../../../../../protocol';\n\nexport interface TimelineView<T> {\n  timeline: AppEntry<T>[];\n}\n\nexport interface AppEntry<T> {\n  app: T[];\n  timeSpent: number;\n  source: string;\n}\n\nexport interface GraphNode {\n  toolTip: string;\n  style: Record<string, unknown>;\n  frame: ProfilerFrame;\n}\n\nexport abstract class RecordFormatter<T> {\n  abstract formatFrame(frame: ProfilerFrame): T;\n  abstract addFrame(nodes: T | T[], elements: ElementProfile[]): number | void;\n\n  getLabel(element: ElementProfile): string {\n    if (element.type === 'defer') {\n      return '@defer';\n    }\n\n    const name = element.directives\n      .filter((d) => d.isComponent)\n      .map((c) => c.name)\n      .join(', ');\n    const attributes = [\n      ...new Set(element.directives.filter((d) => !d.isComponent).map((d) => d.name)),\n    ].join(', ');\n    return attributes === '' ? name : `${name}[${attributes}]`;\n  }\n\n  getValue(element: ElementProfile): number {\n    let result = 0;\n    element.directives.forEach((dir) => {\n      result += this.getDirectiveValue(dir);\n    });\n    return result;\n  }\n\n  getDirectiveValue(directive: DirectiveProfile): number {\n    let result = 0;\n    let current = directive.changeDetection;\n    if (current === undefined) {\n      current = 0;\n    }\n    result += current;\n    Object.values(directive.lifecycle).forEach((lifecycleProfile) => {\n      const value = parseFloat(lifecycleProfile);\n      if (!isNaN(value)) {\n        result += value;\n      }\n    });\n    return result;\n  }\n}\n"]}