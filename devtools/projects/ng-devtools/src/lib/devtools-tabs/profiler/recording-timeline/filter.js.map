{"version":3,"file":"filter.js","sourceRoot":"","sources":["filter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ProfilerFrame} from '../../../../../../protocol';\n\nexport type Filter = (nodes: ProfilerFrame) => boolean;\n\nexport const noopFilter = (_: ProfilerFrame) => true;\n\ninterface Query<Arguments = unknown> {\n  readonly name: QueryType;\n  parseArguments(args: string[]): Arguments | undefined;\n  apply(node: ProfilerFrame, args: Arguments): boolean;\n}\n\ntype Operator = '>' | '<' | '=' | '<=' | '>=';\n\nconst ops: {[operator in Operator]: (a: number, b: number) => boolean} = {\n  '>'(a: number, b: number): boolean {\n    return a > b;\n  },\n  '<'(a: number, b: number): boolean {\n    return a < b;\n  },\n  '='(a: number, b: number): boolean {\n    return a === b;\n  },\n  '<='(a: number, b: number): boolean {\n    return a <= b;\n  },\n  '>='(a: number, b: number): boolean {\n    return a >= b;\n  },\n};\n\ntype DurationArgument = [Operator, number];\ntype SourceArgument = string;\n\nconst enum QueryType {\n  Duration = 'duration',\n  Source = 'source',\n}\n\ntype QueryArguments = DurationArgument | SourceArgument;\n\nconst operatorRe = /^(>=|<=|=|<|>|)/;\nclass DurationQuery implements Query<DurationArgument> {\n  readonly name = QueryType.Duration;\n  parseArguments([arg]: string[]): DurationArgument | undefined {\n    arg = arg.trim();\n    const operator = (arg.match(operatorRe) ?? [null])[0];\n    if (!operator) {\n      return undefined;\n    }\n    const num = parseFloat(arg.replace(operatorRe, '').trim());\n    if (isNaN(num)) {\n      return undefined;\n    }\n    return [operator as Operator, num] as DurationArgument;\n  }\n\n  apply(node: ProfilerFrame, args: DurationArgument): boolean {\n    return ops[args[0]](node.duration, args[1]);\n  }\n}\n\nclass SourceQuery implements Query<SourceArgument> {\n  readonly name = QueryType.Source;\n  parseArguments([arg]: string[]): SourceArgument {\n    return arg;\n  }\n\n  apply(node: ProfilerFrame, args: SourceArgument): boolean {\n    return node.source.indexOf(args) >= 0;\n  }\n}\n\nconst queryMap: {[query in QueryType]: Query} = [new DurationQuery(), new SourceQuery()].reduce(\n  (map, query) => {\n    map[query.name] = query;\n    return map;\n  },\n  {} as {[query in QueryType]: Query},\n);\n\nconst queryRe = new RegExp(`!?s*(${QueryType.Duration}|${QueryType.Source})$`, 'g');\n\ntype Predicate = true | false;\ntype QueryAST = [Predicate, QueryType, QueryArguments];\n\n/**\n * Parses a query in the form:\n *  filter := ('!'? query)*\n *  query := 'sort': [a-z]* | 'duration': operator duration\n *  operator := '=' | '>' | '<' | '>=' | '<='\n *  duration := [0-9]* 'ms'?\n *\n * @param query string that represents the search query\n * @returns tuples representing the query type and its arguments\n */\nexport const parseFilter = (query: string): QueryAST[] => {\n  const parts = query.split(':').map((part) => part.trim());\n  if (parts.length <= 1) {\n    return [];\n  }\n  const result: QueryAST[] = [];\n  for (let i = 0; i < parts.length - 1; i++) {\n    const part = parts[i];\n    if (!queryRe.test(part)) {\n      continue;\n    }\n    const match = part.match(/(\\w+)$/);\n    if (!match) {\n      continue;\n    }\n    const operator = queryMap[match[0] as QueryType];\n    if (!operator) {\n      continue;\n    }\n    const operandString = parts[i + 1].replace(queryRe, '').trim();\n    const operand = operator.parseArguments([operandString]) as QueryArguments;\n    if (!operand) {\n      continue;\n    }\n    const hasNegation = /^(.*?)\\s*!\\s*\\w+/.test(part);\n    result.push([!hasNegation, operator.name, operand]);\n  }\n  return result;\n};\n\nexport const createFilter = (query: string) => {\n  const queries = parseFilter(query);\n  return (frame: ProfilerFrame) => {\n    return queries.every(([predicate, queryName, args]) => {\n      const currentQuery = queryMap[queryName];\n      if (!currentQuery) {\n        return true;\n      }\n      const result = currentQuery.apply(frame, args);\n      return predicate ? result : !result;\n    });\n  };\n};\n"]}