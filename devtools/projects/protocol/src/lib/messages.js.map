{"version":3,"file":"messages.js","sourceRoot":"","sources":["messages.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAkIH,MAAM,CAAN,IAAY,QAgBX;AAhBD,WAAY,QAAQ;IAClB,2CAAM,CAAA;IACN,2CAAM,CAAA;IACN,uCAAI,CAAA;IACJ,iDAAS,CAAA;IACT,2CAAM,CAAA;IACN,+CAAQ,CAAA;IACR,6CAAO,CAAA;IACP,2CAAM,CAAA;IACN,+CAAQ,CAAA;IACR,2CAAM,CAAA;IACN,wCAAI,CAAA;IACJ,0CAAK,CAAA;IACL,sCAAG,CAAA;IACH,sCAAG,CAAA;IACH,8CAAO,CAAA;AACT,CAAC,EAhBW,QAAQ,KAAR,QAAQ,QAgBnB;AAiFD,MAAM,CAAN,IAAY,kBAGX;AAHD,WAAY,kBAAkB;IAC5B,yDAAG,CAAA;IACH,qEAAS,CAAA;AACX,CAAC,EAHW,kBAAkB,KAAlB,kBAAkB,QAG7B","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ɵFramework as Framework,\n  ɵAcxViewEncapsulation as AcxViewEncapsulation,\n  InjectionToken,\n  InjectOptions,\n  Injector,\n  Type,\n  ViewEncapsulation as AngularViewEncapsulation,\n} from '@angular/core';\n\nexport interface DebugSignalGraphNode {\n  id: string;\n  kind: string;\n  epoch: number;\n  label?: string;\n  preview: Descriptor;\n  debuggable: boolean;\n}\n\nexport interface DebugSignalGraphEdge {\n  /**\n   * Index of a signal node in the `nodes` array that is a consumer of the signal produced by the producer node.\n   */\n  consumer: number;\n\n  /**\n   * Index of a signal node in the `nodes` array that is a producer of the signal consumed by the consumer node.\n   */\n  producer: number;\n}\n\n/**\n * A debug representation of the signal graph.\n */\nexport interface DebugSignalGraph {\n  nodes: DebugSignalGraphNode[];\n  edges: DebugSignalGraphEdge[];\n}\n\nexport interface SignalNodePosition {\n  element: ElementPosition;\n  signalId: string;\n}\n\nexport interface DirectiveType {\n  name: string;\n  id: number;\n}\n\nexport interface ComponentType {\n  name: string;\n  isElement: boolean;\n  id: number;\n}\n\nexport type HydrationStatus =\n  // null represent the absence of hydration status (a node created via CSR)\n  | null\n  | {status: 'hydrated' | 'skipped' | 'dehydrated'}\n  | {\n      status: 'mismatched';\n      expectedNodeDetails: string | null;\n      actualNodeDetails: string | null;\n    };\n\nexport type CurrentDeferBlock = 'placeholder' | 'loading' | 'error';\n\nexport interface DeferInfo {\n  id: string;\n  state: 'placeholder' | 'loading' | 'complete' | 'error' | 'initial';\n  currentBlock: CurrentDeferBlock | null;\n  triggers: {\n    defer: string[];\n    hydrate: string[];\n    prefetch: string[];\n  };\n  blocks: BlockDetails;\n}\n\nexport interface BlockDetails {\n  hasErrorBlock: boolean;\n  placeholderBlock: null | {minimumTime: number | null};\n  loadingBlock: null | {minimumTime: number | null; afterTime: number | null};\n}\n\n// TODO: refactor to remove nativeElement as it is not serializable\n// and only really exists on the ng-devtools-backend\nexport interface DevToolsNode<DirType = DirectiveType, CmpType = ComponentType> {\n  element: string;\n  directives: DirType[];\n  component: CmpType | null;\n  children: DevToolsNode<DirType, CmpType>[];\n  nativeElement?: Node;\n  resolutionPath?: SerializedInjector[];\n  hydration: HydrationStatus;\n  defer: DeferInfo | null;\n  onPush?: boolean;\n}\n\nexport interface SerializedInjector {\n  id: string;\n  name: string;\n  type: 'imported-module' | 'environment' | 'element' | 'null' | 'hidden';\n  node?: DevToolsNode;\n  providers?: number;\n}\n\nexport interface SerializedProviderRecord {\n  token: string;\n  type: 'type' | 'existing' | 'class' | 'value' | 'factory' | 'multi';\n  multi: boolean;\n  isViewProvider: boolean;\n  index?: number | number[];\n}\n\n/**\n * Duplicate of the InjectedService interface from Angular framework to prevent\n * needing to publicly expose the interface from the framework.\n */\nexport interface InjectedService {\n  token?: Type<unknown> | InjectionToken<unknown>;\n  value: unknown;\n  flags?: InjectOptions;\n  providedIn: Injector;\n}\n\nexport type ContainerType = 'WritableSignal' | 'ReadonlySignal' | null;\n\nexport enum PropType {\n  Number,\n  String,\n  Null,\n  Undefined,\n  Symbol,\n  HTMLNode,\n  Boolean,\n  BigInt,\n  Function,\n  Object,\n  Date,\n  Array,\n  Set,\n  Map,\n  Unknown,\n}\n\nexport interface Descriptor {\n  expandable: boolean;\n  value?: any;\n  editable: boolean;\n  type: PropType;\n  preview: string;\n  containerType: ContainerType;\n}\n\nexport interface DirectivesProperties {\n  [name: string]: Properties;\n}\n\n/** Directive metadata shared by all frameworks. */\nexport interface BaseDirectiveMetadata {\n  framework: Framework;\n  name?: string;\n}\n\n/** Directive metadata specific to Angular. */\nexport interface AngularDirectiveMetadata extends BaseDirectiveMetadata {\n  framework: Framework.Angular;\n  inputs: {[name: string]: string};\n  outputs: {[name: string]: string};\n  encapsulation?: AngularViewEncapsulation;\n  onPush?: boolean;\n  dependencies?: SerializedInjectedService[];\n}\n\n/** Directive metadata specific to ACX. */\nexport interface AcxDirectiveMetadata extends BaseDirectiveMetadata {\n  framework: Framework.ACX;\n  inputs: {[name: string]: string};\n  outputs: {[name: string]: string};\n  encapsulation?: AcxViewEncapsulation;\n  onPush?: boolean;\n}\n\n/** Directive metadata specific to Wiz. */\nexport interface WizComponentMetadata extends BaseDirectiveMetadata {\n  framework: Framework.Wiz;\n  props: {[name: string]: string};\n}\n\n/** Directive metadata for all supported frameworks. */\nexport type DirectiveMetadata =\n  | AngularDirectiveMetadata\n  | AcxDirectiveMetadata\n  | WizComponentMetadata;\n\nexport interface SerializedInjectedService {\n  token: string;\n  value: string;\n  position: number[];\n  flags?: InjectOptions;\n  resolutionPath?: SerializedInjector[];\n}\n\nexport interface Properties {\n  props: {[name: string]: Descriptor};\n  metadata?: DirectiveMetadata;\n}\n\nexport type ElementPosition = number[];\n\nexport interface DirectivePosition {\n  element: ElementPosition;\n  directive?: number;\n}\n\nexport interface NestedProp {\n  name: string | number;\n  children: NestedProp[];\n}\n\nexport interface ComponentExplorerViewProperties {\n  [directive: string]: NestedProp[];\n}\n\nexport enum PropertyQueryTypes {\n  All,\n  Specified,\n}\n\nexport interface AllPropertiesQuery {\n  type: PropertyQueryTypes.All;\n}\n\nexport interface SelectedPropertiesQuery {\n  type: PropertyQueryTypes.Specified;\n  properties: ComponentExplorerViewProperties;\n}\n\nexport type PropertyQuery = AllPropertiesQuery | SelectedPropertiesQuery;\n\nexport interface ComponentExplorerViewQuery {\n  selectedElement: ElementPosition;\n  propertyQuery: PropertyQuery;\n}\n\nexport interface ComponentExplorerView {\n  forest: DevToolsNode[];\n  properties?: DirectivesProperties;\n}\n\nexport interface LifecycleProfile {\n  ngOnInit?: number;\n  ngOnDestroy?: number;\n  ngOnChanges?: number;\n  ngDoCheck?: number;\n  ngAfterContentInit?: number;\n  ngAfterContentChecked?: number;\n  ngAfterViewInit?: number;\n  ngAfterViewChecked?: number;\n}\n\nexport interface OutputProfile {\n  [outputName: string]: number;\n}\n\nexport interface DirectiveProfile {\n  name: string;\n  isElement: boolean;\n  isComponent: boolean;\n  lifecycle: LifecycleProfile;\n  outputs: OutputProfile;\n  changeDetection?: number;\n}\n\nexport interface ElementProfile {\n  directives: DirectiveProfile[];\n  children: ElementProfile[];\n  type: 'defer' | 'element';\n}\n\nexport interface ProfilerFrame {\n  source: string;\n  duration: number;\n  directives: ElementProfile[];\n}\n\nexport interface UpdatedStateData {\n  directiveId: DirectivePosition;\n  keyPath: string[];\n  newValue: any;\n}\n\nexport interface Route {\n  name?: string;\n  hash?: string;\n  specificity?: string;\n  handler?: string;\n  pathMatch?: 'prefix' | 'full';\n  canActivateGuards?: string[];\n  canActivateChildGuards?: string[];\n  canMatchGuards?: string[];\n  canDeactivateGuards?: string[];\n  providers?: string[];\n  title?: string;\n  children?: Array<Route>;\n  data?: any;\n  path: string;\n  component: string;\n  isActive: boolean;\n  isAux: boolean;\n  isLazy: boolean;\n  isRedirect: boolean;\n}\n\nexport interface AngularDetection {\n  // This is necessary because the runtime\n  // message listener handles messages globally\n  // including from other extensions. We don't\n  // want to set icon and/or popup based on\n  // a message coming from an unrelated extension.\n  isAngularDevTools: true;\n  isIvy: boolean;\n  isAngular: boolean;\n  isDebugMode: boolean;\n  isSupportedAngularVersion: boolean;\n}\n\nexport type Topic = keyof Events;\n\nexport interface SupportedApis {\n  profiler: boolean;\n  dependencyInjection: boolean;\n  routes: boolean;\n  signals: boolean;\n  transferState: boolean;\n  signalPropertiesInspection: boolean;\n}\n\nexport type TransferStateValue =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | Record<string, unknown>\n  | unknown[];\n\nexport interface Events {\n  handshake: () => void;\n  shutdown: () => void;\n  queryNgAvailability: () => void;\n  ngAvailability: (config: {\n    version: string | undefined;\n    devMode: boolean;\n    ivy: boolean;\n    hydration: boolean;\n    supportedApis: SupportedApis;\n  }) => void;\n\n  inspectorStart: () => void;\n  inspectorEnd: () => void;\n\n  getSignalGraph: (query: ElementPosition) => void;\n  latestSignalGraph: (graph: DebugSignalGraph) => void;\n\n  getSignalNestedProperties: (position: SignalNodePosition, path: string[]) => void;\n  signalNestedProperties: (position: SignalNodePosition, data: Properties, path: string[]) => void;\n\n  getNestedProperties: (position: DirectivePosition, path: string[]) => void;\n  nestedProperties: (position: DirectivePosition, data: Properties, path: string[]) => void;\n\n  setSelectedComponent: (position: ElementPosition) => void;\n  getRoutes: () => void;\n  updateRouterTree: (routes: Route[]) => void;\n  navigateRoute: (route: string) => void;\n\n  componentTreeDirty: () => void;\n  getLatestComponentExplorerView: (query?: ComponentExplorerViewQuery) => void;\n  latestComponentExplorerView: (view: ComponentExplorerView) => void;\n\n  updateState: (value: UpdatedStateData) => void;\n\n  startProfiling: () => void;\n  stopProfiling: () => void;\n  sendProfilerChunk: (results: ProfilerFrame) => void;\n  profilerResults: (results: ProfilerFrame) => void;\n\n  createHighlightOverlay: (position: ElementPosition) => void;\n  removeHighlightOverlay: () => void;\n\n  createHydrationOverlay: () => void;\n  removeHydrationOverlay: () => void;\n\n  highlightComponent: (id: number) => void;\n  selectComponent: (id: number) => void;\n  removeComponentHighlight: () => void;\n\n  enableTimingAPI: () => void;\n  disableTimingAPI: () => void;\n\n  // todo: type properly\n  getInjectorProviders: (injector: SerializedInjector) => void;\n  latestInjectorProviders: (\n    injector: SerializedInjector,\n    providers: SerializedProviderRecord[],\n  ) => void;\n\n  logProvider: (injector: SerializedInjector, providers: SerializedProviderRecord) => void;\n\n  getTransferState: () => void;\n  transferStateData: (data: Record<string, TransferStateValue> | null) => void;\n\n  contentScriptConnected: (frameId: number, name: string, url: string) => void;\n  contentScriptDisconnected: (frameId: number, name: string, url: string) => void;\n  enableFrameConnection: (frameId: number, tabId: number) => void;\n  frameConnected: (frameId: number) => void;\n  detectAngular: (detectionResult: AngularDetection) => void;\n  backendReady: () => void;\n\n  log: (logEvent: {message: string; level: 'log' | 'warn' | 'debug' | 'error'}) => void;\n}\n"]}