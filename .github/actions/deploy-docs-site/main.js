import {createRequire as __cjsCompatRequire} from 'module';
const require = __cjsCompatRequire(import.meta.url);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a7, b3) => (typeof require !== "undefined" ? require : a7)[b3]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// 
var require_utils = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCommandProperties = exports.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports.toCommandProperties = toCommandProperties;
  }
});

// 
var require_command = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.issue = exports.issueCommand = void 0;
    var os3 = __importStar(__require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os3.EOL);
    }
    exports.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s5) {
      return (0, utils_1.toCommandValue)(s5).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s5) {
      return (0, utils_1.toCommandValue)(s5).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// 
var require_file_command = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
    var crypto = __importStar(__require("crypto"));
    var fs = __importStar(__require("fs"));
    var os3 = __importStar(__require("os"));
    var utils_1 = require_utils();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os3.EOL}`, {
        encoding: "utf8"
      });
    }
    exports.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
      const convertedValue = (0, utils_1.toCommandValue)(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os3.EOL}${convertedValue}${os3.EOL}${delimiter}`;
    }
    exports.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// 
var require_proxy = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkBypass = exports.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        try {
          return new DecodedURL(proxyVar);
        } catch (_a) {
          if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
            return new DecodedURL(`http://${proxyVar}`);
        }
      } else {
        return void 0;
      }
    }
    exports.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x2) => x2.trim().toUpperCase()).filter((x2) => x2)) {
        if (upperNoProxyItem === "*" || upperReqHosts.some((x2) => x2 === upperNoProxyItem || x2.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x2.endsWith(`${upperNoProxyItem}`))) {
          return true;
        }
      }
      return false;
    }
    exports.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
    var DecodedURL = class extends URL {
      constructor(url, base) {
        super(url, base);
        this._decodedUsername = decodeURIComponent(super.username);
        this._decodedPassword = decodeURIComponent(super.password);
      }
      get username() {
        return this._decodedUsername;
      }
      get password() {
        return this._decodedPassword;
      }
    };
  }
});

// 
var require_tunnel = __commonJS({
  ""(exports) {
    "use strict";
    var net = __require("net");
    var tls = __require("tls");
    var http = __require("http");
    var https = __require("https");
    var events = __require("events");
    var assert2 = __require("assert");
    var util = __require("util");
    exports.httpOverHttp = httpOverHttp;
    exports.httpsOverHttp = httpsOverHttp;
    exports.httpOverHttps = httpOverHttps;
    exports.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i6 = 0, len = self2.requests.length; i6 < len; ++i6) {
          var pending = self2.requests[i6];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i6, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug("got illegal response body from proxy");
          socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        debug("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i6 = 1, len = arguments.length; i6 < len; ++i6) {
        var overrides = arguments[i6];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j2 = 0, keyLen = keys.length; j2 < keyLen; ++j2) {
            var k3 = keys[j2];
            if (overrides[k3] !== void 0) {
              target[k3] = overrides[k3];
            }
          }
        }
      }
      return target;
    }
    var debug;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports.debug = debug;
  }
});

// 
var require_tunnel2 = __commonJS({
  ""(exports, module2) {
    module2.exports = require_tunnel();
  }
});

// 
var require_lib = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
    var http = __importStar(__require("http"));
    var https = __importStar(__require("https"));
    var pm = __importStar(require_proxy());
    var tunnel = __importStar(require_tunnel2());
    var undici_1 = __require("undici");
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2["Accept"] = "accept";
      Headers2["ContentType"] = "content-type";
    })(Headers || (exports.Headers = Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            });
            this.message.on("end", () => {
              resolve(output.toString());
            });
          }));
        });
      }
      readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const chunks = [];
            this.message.on("data", (chunk) => {
              chunks.push(chunk);
            });
            this.message.on("end", () => {
              resolve(Buffer.concat(chunks));
            });
          }));
        });
      }
    };
    exports.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent2, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent2;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler2 of this.handlers) {
                if (handler2.canHandleAuthentication(response)) {
                  authenticationHandler = handler2;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve(res);
              }
            }
            this.requestRawWithCallback(info, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info, data, onResult) {
        if (typeof data === "string") {
          if (!info.options.headers) {
            info.options.headers = {};
          }
          info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info.httpModule.request(info.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on("error", function(err) {
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers) {
          for (const handler2 of this.handlers) {
            handler2.prepareRequest(info.options);
          }
        }
        return info;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys2(this.requestOptions.headers), lowercaseKeys2(headers || {}));
        }
        return lowercaseKeys2(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys2(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (!useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (!agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
          token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
        }));
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
            rejectUnauthorized: false
          });
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve) => setTimeout(() => resolve(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a7 = new Date(value);
                if (!isNaN(a7.valueOf())) {
                  return a7;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve(response);
            }
          }));
        });
      }
    };
    exports.HttpClient = HttpClient;
    var lowercaseKeys2 = (obj) => Object.keys(obj).reduce((c3, k3) => (c3[k3.toLowerCase()] = obj[k3], c3), {});
  }
});

// 
var require_auth = __commonJS({
  ""(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// 
var require_oidc_utils = __commonJS({
  ""(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core();
    var OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = _OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            (0, core_1.debug)(`ID token url is ${id_token_url}`);
            const id_token = yield _OidcClient.getCall(id_token_url);
            (0, core_1.setSecret)(id_token);
            return id_token;
          } catch (error) {
            throw new Error(`Error message: ${error.message}`);
          }
        });
      }
    };
    exports.OidcClient = OidcClient;
  }
});

// 
var require_summary = __commonJS({
  ""(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
    var os_1 = __require("os");
    var fs_1 = __require("fs");
    var { access, appendFile: appendFile2, writeFile: writeFile2 } = fs_1.promises;
    exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile2 : appendFile2;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports.markdownSummary = _summary;
    exports.summary = _summary;
  }
});

// 
var require_path_utils = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
    var path = __importStar(__require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path.sep);
    }
    exports.toPlatformPath = toPlatformPath;
  }
});

// 
var require_io_util = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o8, k22, { enumerable: true, get: function() {
        return m8[k3];
      } });
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
    var fs = __importStar(__require("fs"));
    var path = __importStar(__require("path"));
    _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
    exports.IS_WINDOWS = process.platform === "win32";
    exports.UV_FS_O_EXLOCK = 268435456;
    exports.READONLY = fs.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield exports.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports.exists = exists;
    function isDirectory(fsPath, useStat = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
        return stats.isDirectory();
      });
    }
    exports.isDirectory = isDirectory;
    function isRooted(p5) {
      p5 = normalizeSeparators(p5);
      if (!p5) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports.IS_WINDOWS) {
        return p5.startsWith("\\") || /^[A-Z]:/i.test(p5);
      }
      return p5.startsWith("/");
    }
    exports.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield exports.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            const upperExt = path.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield exports.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
              try {
                const directory = path.dirname(filePath);
                const upperName = path.basename(filePath).toUpperCase();
                for (const actualName of yield exports.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p5) {
      p5 = p5 || "";
      if (exports.IS_WINDOWS) {
        p5 = p5.replace(/\//g, "\\");
        return p5.replace(/\\\\+/g, "\\");
      }
      return p5.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
    exports.getCmdPath = getCmdPath;
  }
});

// 
var require_io = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o8, k22, { enumerable: true, get: function() {
        return m8[k3];
      } });
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
    var assert_1 = __require("assert");
    var path = __importStar(__require("path"));
    var ioUtil = __importStar(require_io_util());
    function cp2(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force) {
          return;
        }
        const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
        if (!(yield ioUtil.exists(source))) {
          throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
          if (!recursive) {
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
          } else {
            yield cpDirRecursive(source, newDest, 0, force);
          }
        } else {
          if (path.relative(source, newDest) === "") {
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          }
          yield copyFile(source, newDest, force);
        }
      });
    }
    exports.cp = cp2;
    function mv(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = true;
          if (yield ioUtil.isDirectory(dest)) {
            dest = path.join(dest, path.basename(source));
            destExists = yield ioUtil.exists(dest);
          }
          if (destExists) {
            if (options.force == null || options.force) {
              yield rmRF(dest);
            } else {
              throw new Error("Destination already exists");
            }
          }
        }
        yield mkdirP(path.dirname(dest));
        yield ioUtil.rename(source, dest);
      });
    }
    exports.mv = mv;
    function rmRF(inputPath) {
      return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
          if (/[*"<>|]/.test(inputPath)) {
            throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
          }
        }
        try {
          yield ioUtil.rm(inputPath, {
            force: true,
            maxRetries: 3,
            recursive: true,
            retryDelay: 300
          });
        } catch (err) {
          throw new Error(`File was unable to be removed ${err}`);
        }
      });
    }
    exports.rmRF = rmRF;
    function mkdirP(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided");
        yield ioUtil.mkdir(fsPath, { recursive: true });
      });
    }
    exports.mkdirP = mkdirP;
    function which2(tool, check) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        if (check) {
          const result = yield which2(tool, false);
          if (!result) {
            if (ioUtil.IS_WINDOWS) {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
            } else {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
            }
          }
          return result;
        }
        const matches = yield findInPath(tool);
        if (matches && matches.length > 0) {
          return matches[0];
        }
        return "";
      });
    }
    exports.which = which2;
    function findInPath(tool) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
          for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
            if (extension) {
              extensions.push(extension);
            }
          }
        }
        if (ioUtil.isRooted(tool)) {
          const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          if (filePath) {
            return [filePath];
          }
          return [];
        }
        if (tool.includes(path.sep)) {
          return [];
        }
        const directories = [];
        if (process.env.PATH) {
          for (const p5 of process.env.PATH.split(path.delimiter)) {
            if (p5) {
              directories.push(p5);
            }
          }
        }
        const matches = [];
        for (const directory of directories) {
          const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
          if (filePath) {
            matches.push(filePath);
          }
        }
        return matches;
      });
    }
    exports.findInPath = findInPath;
    function readCopyOptions(options) {
      const force = options.force == null ? true : options.force;
      const recursive = Boolean(options.recursive);
      const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
      return { force, recursive, copySourceDirectory };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++;
        yield mkdirP(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
          const srcFile = `${sourceDir}/${fileName}`;
          const destFile = `${destDir}/${fileName}`;
          const srcFileStat = yield ioUtil.lstat(srcFile);
          if (srcFileStat.isDirectory()) {
            yield cpDirRecursive(srcFile, destFile, currentDepth, force);
          } else {
            yield copyFile(srcFile, destFile, force);
          }
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile(srcFile, destFile, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile);
            yield ioUtil.unlink(destFile);
          } catch (e5) {
            if (e5.code === "EPERM") {
              yield ioUtil.chmod(destFile, "0666");
              yield ioUtil.unlink(destFile);
            }
          }
          const symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else if (!(yield ioUtil.exists(destFile)) || force) {
          yield ioUtil.copyFile(srcFile, destFile);
        }
      });
    }
  }
});

// 
var require_toolrunner = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o8, k22, { enumerable: true, get: function() {
        return m8[k3];
      } });
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argStringToArray = exports.ToolRunner = void 0;
    var os3 = __importStar(__require("os"));
    var events = __importStar(__require("events"));
    var child = __importStar(__require("child_process"));
    var path = __importStar(__require("path"));
    var io = __importStar(require_io());
    var ioUtil = __importStar(require_io_util());
    var timers_1 = __require("timers");
    var IS_WINDOWS = process.platform === "win32";
    var ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
      }
      _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
          this.options.listeners.debug(message);
        }
      }
      _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (const a7 of args) {
              cmd += ` ${a7}`;
            }
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (const a7 of args) {
              cmd += ` ${a7}`;
            }
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (const a7 of args) {
              cmd += ` ${this._windowsQuoteCmdArg(a7)}`;
            }
          }
        } else {
          cmd += toolPath;
          for (const a7 of args) {
            cmd += ` ${a7}`;
          }
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s5 = strBuffer + data.toString();
          let n3 = s5.indexOf(os3.EOL);
          while (n3 > -1) {
            const line = s5.substring(0, n3);
            onLine(line);
            s5 = s5.substring(n3 + os3.EOL.length);
            n3 = s5.indexOf(os3.EOL);
          }
          return s5;
        } catch (err) {
          this._debug(`error processing line. Failed with error ${err}`);
          return "";
        }
      }
      _getSpawnFileName() {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            return process.env["COMSPEC"] || "cmd.exe";
          }
        }
        return this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
            for (const a7 of this.args) {
              argline += " ";
              argline += options.windowsVerbatimArguments ? a7 : this._windowsQuoteCmdArg(a7);
            }
            argline += '"';
            return [argline];
          }
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile()) {
          return this._uvQuoteCmdArg(arg);
        }
        if (!arg) {
          return '""';
        }
        const cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
          if (cmdSpecialChars.some((x2) => x2 === char)) {
            needsQuotes = true;
            break;
          }
        }
        if (!needsQuotes) {
          return arg;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i6 = arg.length; i6 > 0; i6--) {
          reverse += arg[i6 - 1];
          if (quoteHit && arg[i6 - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i6 - 1] === '"') {
            quoteHit = true;
            reverse += '"';
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg) {
          return '""';
        }
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
          return arg;
        }
        if (!arg.includes('"') && !arg.includes("\\")) {
          return `"${arg}"`;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i6 = arg.length; i6 > 0; i6--) {
          reverse += arg[i6 - 1];
          if (quoteHit && arg[i6 - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i6 - 1] === '"') {
            quoteHit = true;
            reverse += "\\";
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        const result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || false,
          windowsVerbatimArguments: options.windowsVerbatimArguments || false,
          failOnStdErr: options.failOnStdErr || false,
          ignoreReturnCode: options.ignoreReturnCode || false,
          delay: options.delay || 1e4
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
          result.argv0 = `"${toolPath}"`;
        }
        return result;
      }
      /**
       * Exec a tool.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     tool     path to tool to exec
       * @param     options  optional exec options.  See ExecOptions
       * @returns   number
       */
      exec() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
            this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
          }
          this.toolPath = yield io.which(this.toolPath, true);
          return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this._debug(`exec tool: ${this.toolPath}`);
            this._debug("arguments:");
            for (const arg of this.args) {
              this._debug(`   ${arg}`);
            }
            const optionsNonNull = this._cloneExecOptions(this.options);
            if (!optionsNonNull.silent && optionsNonNull.outStream) {
              optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os3.EOL);
            }
            const state = new ExecState(optionsNonNull, this.toolPath);
            state.on("debug", (message) => {
              this._debug(message);
            });
            if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
              return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
            }
            const fileName = this._getSpawnFileName();
            const cp2 = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
            let stdbuffer = "";
            if (cp2.stdout) {
              cp2.stdout.on("data", (data) => {
                if (this.options.listeners && this.options.listeners.stdout) {
                  this.options.listeners.stdout(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(data);
                }
                stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.stdline) {
                    this.options.listeners.stdline(line);
                  }
                });
              });
            }
            let errbuffer = "";
            if (cp2.stderr) {
              cp2.stderr.on("data", (data) => {
                state.processStderr = true;
                if (this.options.listeners && this.options.listeners.stderr) {
                  this.options.listeners.stderr(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                  const s5 = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                  s5.write(data);
                }
                errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.errline) {
                    this.options.listeners.errline(line);
                  }
                });
              });
            }
            cp2.on("error", (err) => {
              state.processError = err.message;
              state.processExited = true;
              state.processClosed = true;
              state.CheckComplete();
            });
            cp2.on("exit", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            cp2.on("close", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              state.processClosed = true;
              this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            state.on("done", (error, exitCode) => {
              if (stdbuffer.length > 0) {
                this.emit("stdline", stdbuffer);
              }
              if (errbuffer.length > 0) {
                this.emit("errline", errbuffer);
              }
              cp2.removeAllListeners();
              if (error) {
                reject(error);
              } else {
                resolve(exitCode);
              }
            });
            if (this.options.input) {
              if (!cp2.stdin) {
                throw new Error("child process missing stdin");
              }
              cp2.stdin.end(this.options.input);
            }
          }));
        });
      }
    };
    exports.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      const args = [];
      let inQuotes = false;
      let escaped = false;
      let arg = "";
      function append(c3) {
        if (escaped && c3 !== '"') {
          arg += "\\";
        }
        arg += c3;
        escaped = false;
      }
      for (let i6 = 0; i6 < argString.length; i6++) {
        const c3 = argString.charAt(i6);
        if (c3 === '"') {
          if (!escaped) {
            inQuotes = !inQuotes;
          } else {
            append(c3);
          }
          continue;
        }
        if (c3 === "\\" && escaped) {
          append(c3);
          continue;
        }
        if (c3 === "\\" && inQuotes) {
          escaped = true;
          continue;
        }
        if (c3 === " " && !inQuotes) {
          if (arg.length > 0) {
            args.push(arg);
            arg = "";
          }
          continue;
        }
        append(c3);
      }
      if (arg.length > 0) {
        args.push(arg.trim());
      }
      return args;
    }
    exports.argStringToArray = argStringToArray;
    var ExecState = class _ExecState extends events.EventEmitter {
      constructor(options, toolPath) {
        super();
        this.processClosed = false;
        this.processError = "";
        this.processExitCode = 0;
        this.processExited = false;
        this.processStderr = false;
        this.delay = 1e4;
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
          throw new Error("toolPath must not be empty");
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
          this.delay = options.delay;
        }
      }
      CheckComplete() {
        if (this.done) {
          return;
        }
        if (this.processClosed) {
          this._setResult();
        } else if (this.processExited) {
          this.timeout = timers_1.setTimeout(_ExecState.HandleTimeout, this.delay, this);
        }
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error;
        if (this.processExited) {
          if (this.processError) {
            error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
          } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
            error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
          } else if (this.processStderr && this.options.failOnStdErr) {
            error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
          }
        }
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.done = true;
        this.emit("done", error, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (state.done) {
          return;
        }
        if (!state.processClosed && state.processExited) {
          const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    };
  }
});

// 
var require_exec = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o8, k22, { enumerable: true, get: function() {
        return m8[k3];
      } });
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getExecOutput = exports.exec = void 0;
    var string_decoder_1 = __require("string_decoder");
    var tr2 = __importStar(require_toolrunner());
    function exec(commandLine, args, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const commandArgs = tr2.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
          throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr2.ToolRunner(toolPath, args, options);
        return runner.exec();
      });
    }
    exports.exec = exec;
    function getExecOutput(commandLine, args, options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function* () {
        let stdout = "";
        let stderr = "";
        const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
        const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
        const stdErrListener = (data) => {
          stderr += stderrDecoder.write(data);
          if (originalStdErrListener) {
            originalStdErrListener(data);
          }
        };
        const stdOutListener = (data) => {
          stdout += stdoutDecoder.write(data);
          if (originalStdoutListener) {
            originalStdoutListener(data);
          }
        };
        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
        const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        stdout += stdoutDecoder.end();
        stderr += stderrDecoder.end();
        return {
          exitCode,
          stdout,
          stderr
        };
      });
    }
    exports.getExecOutput = getExecOutput;
  }
});

// 
var require_platform = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
    var os_1 = __importDefault(__require("os"));
    var exec = __importStar(require_exec());
    var getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
        silent: true
      });
      const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
        silent: true
      });
      return {
        name: name.trim(),
        version: version.trim()
      };
    });
    var getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      const { stdout } = yield exec.getExecOutput("sw_vers", void 0, {
        silent: true
      });
      const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
      const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "";
      return {
        name,
        version
      };
    });
    var getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout } = yield exec.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
        silent: true
      });
      const [name, version] = stdout.trim().split("\n");
      return {
        name,
        version
      };
    });
    exports.platform = os_1.default.platform();
    exports.arch = os_1.default.arch();
    exports.isWindows = exports.platform === "win32";
    exports.isMacOS = exports.platform === "darwin";
    exports.isLinux = exports.platform === "linux";
    function getDetails() {
      return __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
          platform: exports.platform,
          arch: exports.arch,
          isWindows: exports.isWindows,
          isMacOS: exports.isMacOS,
          isLinux: exports.isLinux
        });
      });
    }
    exports.getDetails = getDetails;
  }
});

// 
var require_core = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os3 = __importStar(__require("os"));
    var path = __importStar(__require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode || (exports.ExitCode = ExitCode = {}));
    function exportVariable(name, val) {
      const convertedVal = (0, utils_1.toCommandValue)(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
      }
      (0, command_1.issueCommand)("set-env", { name }, convertedVal);
    }
    exports.exportVariable = exportVariable;
    function setSecret2(secret) {
      (0, command_1.issueCommand)("add-mask", {}, secret);
    }
    exports.setSecret = setSecret2;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        (0, file_command_1.issueFileCommand)("PATH", inputPath);
      } else {
        (0, command_1.issueCommand)("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
    }
    exports.addPath = addPath;
    function getInput3(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports.getInput = getInput3;
    function getMultilineInput(name, options) {
      const inputs = getInput3(name, options).split("\n").filter((x2) => x2 !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput3(name, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports.getBooleanInput = getBooleanInput;
    function setOutput(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      process.stdout.write(os3.EOL);
      (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports.setOutput = setOutput;
    function setCommandEcho(enabled) {
      (0, command_1.issue)("echo", enabled ? "on" : "off");
    }
    exports.setCommandEcho = setCommandEcho;
    function setFailed2(message) {
      process.exitCode = ExitCode.Failure;
      error(message);
    }
    exports.setFailed = setFailed2;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports.isDebug = isDebug;
    function debug(message) {
      (0, command_1.issueCommand)("debug", {}, message);
    }
    exports.debug = debug;
    function error(message, properties = {}) {
      (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.error = error;
    function warning(message, properties = {}) {
      (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.warning = warning;
    function notice(message, properties = {}) {
      (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.notice = notice;
    function info(message) {
      process.stdout.write(message + os3.EOL);
    }
    exports.info = info;
    function startGroup(name) {
      (0, command_1.issue)("group", name);
    }
    exports.startGroup = startGroup;
    function endGroup() {
      (0, command_1.issue)("endgroup");
    }
    exports.endGroup = endGroup;
    function group(name, fn2) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn2();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports.group = group;
    function saveState(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
    exports.platform = __importStar(require_platform());
  }
});

// 
var require_context = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Context = void 0;
    var fs_1 = __require("fs");
    var os_1 = __require("os");
    var Context = class {
      /**
       * Hydrate the context from the environment
       */
      constructor() {
        var _a, _b, _c;
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
          if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH)) {
            this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
          } else {
            const path = process.env.GITHUB_EVENT_PATH;
            process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
          }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10);
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
      }
      get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
      }
      get repo() {
        if (process.env.GITHUB_REPOSITORY) {
          const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
          return { owner, repo };
        }
        if (this.payload.repository) {
          return {
            owner: this.payload.repository.owner.login,
            repo: this.payload.repository.name
          };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
      }
    };
    exports.Context = Context;
  }
});

// 
var require_utils2 = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getApiBaseUrl = exports.getProxyFetch = exports.getProxyAgentDispatcher = exports.getProxyAgent = exports.getAuthString = void 0;
    var httpClient = __importStar(require_lib());
    var undici_1 = __require("undici");
    function getAuthString(token, options) {
      if (!token && !options.auth) {
        throw new Error("Parameter token or opts.auth is required");
      } else if (token && options.auth) {
        throw new Error("Parameters token and opts.auth may not both be specified");
      }
      return typeof options.auth === "string" ? options.auth : `token ${token}`;
    }
    exports.getAuthString = getAuthString;
    function getProxyAgent(destinationUrl) {
      const hc = new httpClient.HttpClient();
      return hc.getAgent(destinationUrl);
    }
    exports.getProxyAgent = getProxyAgent;
    function getProxyAgentDispatcher(destinationUrl) {
      const hc = new httpClient.HttpClient();
      return hc.getAgentDispatcher(destinationUrl);
    }
    exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
    function getProxyFetch(destinationUrl) {
      const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
      const proxyFetch = (url, opts) => __awaiter(this, void 0, void 0, function* () {
        return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
      });
      return proxyFetch;
    }
    exports.getProxyFetch = getProxyFetch;
    function getApiBaseUrl() {
      return process.env["GITHUB_API_URL"] || "https://api.github.com";
    }
    exports.getApiBaseUrl = getApiBaseUrl;
  }
});

// 
var require_dist_node = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getUserAgent2() {
      if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
      }
      if (typeof process === "object" && process.version !== void 0) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
      }
      return "<environment undetectable>";
    }
    exports.getUserAgent = getUserAgent2;
  }
});

// 
var require_register = __commonJS({
  ""(exports, module2) {
    module2.exports = register2;
    function register2(state, name, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name)) {
        return name.reverse().reduce(function(callback, name2) {
          return register2.bind(null, state, name2, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name]) {
          return method(options);
        }
        return state.registry[name].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// 
var require_add = __commonJS({
  ""(exports, module2) {
    module2.exports = addHook2;
    function addHook2(state, kind, name, hook2) {
      var orig = hook2;
      if (!state.registry[name]) {
        state.registry[name] = [];
      }
      if (kind === "before") {
        hook2 = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook2 = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook2 = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
            return orig(error, options);
          });
        };
      }
      state.registry[name].push({
        hook: hook2,
        orig
      });
    }
  }
});

// 
var require_remove = __commonJS({
  ""(exports, module2) {
    module2.exports = removeHook2;
    function removeHook2(state, name, method) {
      if (!state.registry[name]) {
        return;
      }
      var index = state.registry[name].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index === -1) {
        return;
      }
      state.registry[name].splice(index, 1);
    }
  }
});

// 
var require_before_after_hook = __commonJS({
  ""(exports, module2) {
    var register2 = require_register();
    var addHook2 = require_add();
    var removeHook2 = require_remove();
    var bind2 = Function.bind;
    var bindable2 = bind2.bind(bind2);
    function bindApi2(hook2, state, name) {
      var removeHookRef = bindable2(removeHook2, null).apply(
        null,
        name ? [state, name] : [state]
      );
      hook2.api = { remove: removeHookRef };
      hook2.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name ? [state, kind, name] : [state, kind];
        hook2[kind] = hook2.api[kind] = bindable2(addHook2, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register2.bind(null, singularHookState, singularHookName);
      bindApi2(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook2 = register2.bind(null, state);
      bindApi2(hook2, state);
      return hook2;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn(
          '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
        );
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// 
var require_dist_node2 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      endpoint: () => endpoint2
    });
    module2.exports = __toCommonJS(dist_src_exports);
    var import_universal_user_agent5 = require_dist_node();
    var VERSION9 = "9.0.6";
    var userAgent2 = `octokit-endpoint.js/${VERSION9} ${(0, import_universal_user_agent5.getUserAgent)()}`;
    var DEFAULTS2 = {
      method: "GET",
      baseUrl: "https://api.github.com",
      headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent2
      },
      mediaType: {
        format: ""
      }
    };
    function lowercaseKeys2(object) {
      if (!object) {
        return {};
      }
      return Object.keys(object).reduce((newObj, key) => {
        newObj[key.toLowerCase()] = object[key];
        return newObj;
      }, {});
    }
    function isPlainObject3(value) {
      if (typeof value !== "object" || value === null)
        return false;
      if (Object.prototype.toString.call(value) !== "[object Object]")
        return false;
      const proto2 = Object.getPrototypeOf(value);
      if (proto2 === null)
        return true;
      const Ctor = Object.prototype.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
      return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
    }
    function mergeDeep2(defaults, options) {
      const result = Object.assign({}, defaults);
      Object.keys(options).forEach((key) => {
        if (isPlainObject3(options[key])) {
          if (!(key in defaults))
            Object.assign(result, { [key]: options[key] });
          else
            result[key] = mergeDeep2(defaults[key], options[key]);
        } else {
          Object.assign(result, { [key]: options[key] });
        }
      });
      return result;
    }
    function removeUndefinedProperties2(obj) {
      for (const key in obj) {
        if (obj[key] === void 0) {
          delete obj[key];
        }
      }
      return obj;
    }
    function merge2(defaults, route, options) {
      if (typeof route === "string") {
        let [method, url] = route.split(" ");
        options = Object.assign(url ? { method, url } : { url: method }, options);
      } else {
        options = Object.assign({}, route);
      }
      options.headers = lowercaseKeys2(options.headers);
      removeUndefinedProperties2(options);
      removeUndefinedProperties2(options.headers);
      const mergedOptions = mergeDeep2(defaults || {}, options);
      if (options.url === "/graphql") {
        if (defaults && defaults.mediaType.previews?.length) {
          mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
            (preview) => !mergedOptions.mediaType.previews.includes(preview)
          ).concat(mergedOptions.mediaType.previews);
        }
        mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
      }
      return mergedOptions;
    }
    function addQueryParameters2(url, parameters) {
      const separator = /\?/.test(url) ? "&" : "?";
      const names = Object.keys(parameters);
      if (names.length === 0) {
        return url;
      }
      return url + separator + names.map((name) => {
        if (name === "q") {
          return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
        }
        return `${name}=${encodeURIComponent(parameters[name])}`;
      }).join("&");
    }
    var urlVariableRegex2 = /\{[^{}}]+\}/g;
    function removeNonChars2(variableName) {
      return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
    }
    function extractUrlVariableNames2(url) {
      const matches = url.match(urlVariableRegex2);
      if (!matches) {
        return [];
      }
      return matches.map(removeNonChars2).reduce((a7, b3) => a7.concat(b3), []);
    }
    function omit2(object, keysToOmit) {
      const result = { __proto__: null };
      for (const key of Object.keys(object)) {
        if (keysToOmit.indexOf(key) === -1) {
          result[key] = object[key];
        }
      }
      return result;
    }
    function encodeReserved2(str) {
      return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
          part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
        }
        return part;
      }).join("");
    }
    function encodeUnreserved2(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, function(c3) {
        return "%" + c3.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeValue2(operator, value, key) {
      value = operator === "+" || operator === "#" ? encodeReserved2(value) : encodeUnreserved2(value);
      if (key) {
        return encodeUnreserved2(key) + "=" + value;
      } else {
        return value;
      }
    }
    function isDefined2(value) {
      return value !== void 0 && value !== null;
    }
    function isKeyOperator2(operator) {
      return operator === ";" || operator === "&" || operator === "?";
    }
    function getValues2(context2, operator, key, modifier) {
      var value = context2[key], result = [];
      if (isDefined2(value) && value !== "") {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          value = value.toString();
          if (modifier && modifier !== "*") {
            value = value.substring(0, parseInt(modifier, 10));
          }
          result.push(
            encodeValue2(operator, value, isKeyOperator2(operator) ? key : "")
          );
        } else {
          if (modifier === "*") {
            if (Array.isArray(value)) {
              value.filter(isDefined2).forEach(function(value2) {
                result.push(
                  encodeValue2(operator, value2, isKeyOperator2(operator) ? key : "")
                );
              });
            } else {
              Object.keys(value).forEach(function(k3) {
                if (isDefined2(value[k3])) {
                  result.push(encodeValue2(operator, value[k3], k3));
                }
              });
            }
          } else {
            const tmp = [];
            if (Array.isArray(value)) {
              value.filter(isDefined2).forEach(function(value2) {
                tmp.push(encodeValue2(operator, value2));
              });
            } else {
              Object.keys(value).forEach(function(k3) {
                if (isDefined2(value[k3])) {
                  tmp.push(encodeUnreserved2(k3));
                  tmp.push(encodeValue2(operator, value[k3].toString()));
                }
              });
            }
            if (isKeyOperator2(operator)) {
              result.push(encodeUnreserved2(key) + "=" + tmp.join(","));
            } else if (tmp.length !== 0) {
              result.push(tmp.join(","));
            }
          }
        }
      } else {
        if (operator === ";") {
          if (isDefined2(value)) {
            result.push(encodeUnreserved2(key));
          }
        } else if (value === "" && (operator === "&" || operator === "?")) {
          result.push(encodeUnreserved2(key) + "=");
        } else if (value === "") {
          result.push("");
        }
      }
      return result;
    }
    function parseUrl2(template) {
      return {
        expand: expand2.bind(null, template)
      };
    }
    function expand2(template, context2) {
      var operators = ["+", "#", ".", "/", ";", "?", "&"];
      template = template.replace(
        /\{([^\{\}]+)\}|([^\{\}]+)/g,
        function(_4, expression, literal) {
          if (expression) {
            let operator = "";
            const values = [];
            if (operators.indexOf(expression.charAt(0)) !== -1) {
              operator = expression.charAt(0);
              expression = expression.substr(1);
            }
            expression.split(/,/g).forEach(function(variable) {
              var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
              values.push(getValues2(context2, operator, tmp[1], tmp[2] || tmp[3]));
            });
            if (operator && operator !== "+") {
              var separator = ",";
              if (operator === "?") {
                separator = "&";
              } else if (operator !== "#") {
                separator = operator;
              }
              return (values.length !== 0 ? operator : "") + values.join(separator);
            } else {
              return values.join(",");
            }
          } else {
            return encodeReserved2(literal);
          }
        }
      );
      if (template === "/") {
        return template;
      } else {
        return template.replace(/\/$/, "");
      }
    }
    function parse2(options) {
      let method = options.method.toUpperCase();
      let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
      let headers = Object.assign({}, options.headers);
      let body;
      let parameters = omit2(options, [
        "method",
        "baseUrl",
        "url",
        "headers",
        "request",
        "mediaType"
      ]);
      const urlVariableNames = extractUrlVariableNames2(url);
      url = parseUrl2(url).expand(parameters);
      if (!/^http/.test(url)) {
        url = options.baseUrl + url;
      }
      const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
      const remainingParameters = omit2(parameters, omittedParameters);
      const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
      if (!isBinaryRequest) {
        if (options.mediaType.format) {
          headers.accept = headers.accept.split(/,/).map(
            (format) => format.replace(
              /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
              `application/vnd$1$2.${options.mediaType.format}`
            )
          ).join(",");
        }
        if (url.endsWith("/graphql")) {
          if (options.mediaType.previews?.length) {
            const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
            headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
              const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
              return `application/vnd.github.${preview}-preview${format}`;
            }).join(",");
          }
        }
      }
      if (["GET", "HEAD"].includes(method)) {
        url = addQueryParameters2(url, remainingParameters);
      } else {
        if ("data" in remainingParameters) {
          body = remainingParameters.data;
        } else {
          if (Object.keys(remainingParameters).length) {
            body = remainingParameters;
          }
        }
      }
      if (!headers["content-type"] && typeof body !== "undefined") {
        headers["content-type"] = "application/json; charset=utf-8";
      }
      if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
        body = "";
      }
      return Object.assign(
        { method, url, headers },
        typeof body !== "undefined" ? { body } : null,
        options.request ? { request: options.request } : null
      );
    }
    function endpointWithDefaults2(defaults, route, options) {
      return parse2(merge2(defaults, route, options));
    }
    function withDefaults4(oldDefaults, newDefaults) {
      const DEFAULTS22 = merge2(oldDefaults, newDefaults);
      const endpoint22 = endpointWithDefaults2.bind(null, DEFAULTS22);
      return Object.assign(endpoint22, {
        DEFAULTS: DEFAULTS22,
        defaults: withDefaults4.bind(null, DEFAULTS22),
        merge: merge2.bind(null, DEFAULTS22),
        parse: parse2
      });
    }
    var endpoint2 = withDefaults4(null, DEFAULTS2);
  }
});

// 
var require_dist_node3 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Deprecation = class extends Error {
      constructor(message) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "Deprecation";
      }
    };
    exports.Deprecation = Deprecation;
  }
});

// 
var require_wrappy = __commonJS({
  ""(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn2, cb) {
      if (fn2 && cb)
        return wrappy(fn2)(cb);
      if (typeof fn2 !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn2).forEach(function(k3) {
        wrapper[k3] = fn2[k3];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i6 = 0; i6 < args.length; i6++) {
          args[i6] = arguments[i6];
        }
        var ret = fn2.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k3) {
            ret[k3] = cb2[k3];
          });
        }
        return ret;
      }
    }
  }
});

// 
var require_once = __commonJS({
  ""(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn2) {
      var f6 = function() {
        if (f6.called)
          return f6.value;
        f6.called = true;
        return f6.value = fn2.apply(this, arguments);
      };
      f6.called = false;
      return f6;
    }
    function onceStrict(fn2) {
      var f6 = function() {
        if (f6.called)
          throw new Error(f6.onceError);
        f6.called = true;
        return f6.value = fn2.apply(this, arguments);
      };
      var name = fn2.name || "Function wrapped with `once`";
      f6.onceError = name + " shouldn't be called more than once";
      f6.called = false;
      return f6;
    }
  }
});

// 
var require_dist_node4 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      RequestError: () => RequestError2
    });
    module2.exports = __toCommonJS(dist_src_exports);
    var import_deprecation = require_dist_node3();
    var import_once = __toESM2(require_once());
    var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
    var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
    var RequestError2 = class extends Error {
      constructor(message, statusCode, options) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "HttpError";
        this.status = statusCode;
        let headers;
        if ("headers" in options && typeof options.headers !== "undefined") {
          headers = options.headers;
        }
        if ("response" in options) {
          this.response = options.response;
          headers = options.response.headers;
        }
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
          requestCopy.headers = Object.assign({}, options.request.headers, {
            authorization: options.request.headers.authorization.replace(
              /(?<! ) .*$/,
              " [REDACTED]"
            )
          });
        }
        requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
        Object.defineProperty(this, "code", {
          get() {
            logOnceCode(
              new import_deprecation.Deprecation(
                "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
              )
            );
            return statusCode;
          }
        });
        Object.defineProperty(this, "headers", {
          get() {
            logOnceHeaders(
              new import_deprecation.Deprecation(
                "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
              )
            );
            return headers || {};
          }
        });
      }
    };
  }
});

// 
var require_dist_node5 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      request: () => request2
    });
    module2.exports = __toCommonJS(dist_src_exports);
    var import_endpoint2 = require_dist_node2();
    var import_universal_user_agent5 = require_dist_node();
    var VERSION9 = "8.4.1";
    function isPlainObject3(value) {
      if (typeof value !== "object" || value === null)
        return false;
      if (Object.prototype.toString.call(value) !== "[object Object]")
        return false;
      const proto2 = Object.getPrototypeOf(value);
      if (proto2 === null)
        return true;
      const Ctor = Object.prototype.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
      return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
    }
    var import_request_error2 = require_dist_node4();
    function getBufferResponse(response) {
      return response.arrayBuffer();
    }
    function fetchWrapper2(requestOptions) {
      var _a, _b, _c, _d;
      const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
      const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
      if (isPlainObject3(requestOptions.body) || Array.isArray(requestOptions.body)) {
        requestOptions.body = JSON.stringify(requestOptions.body);
      }
      let headers = {};
      let status;
      let url;
      let { fetch: fetch2 } = globalThis;
      if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
        fetch2 = requestOptions.request.fetch;
      }
      if (!fetch2) {
        throw new Error(
          "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
        );
      }
      return fetch2(requestOptions.url, {
        method: requestOptions.method,
        body: requestOptions.body,
        redirect: (_c = requestOptions.request) == null ? void 0 : _c.redirect,
        headers: requestOptions.headers,
        signal: (_d = requestOptions.request) == null ? void 0 : _d.signal,
        // duplex must be set if request.body is ReadableStream or Async Iterables.
        // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
        ...requestOptions.body && { duplex: "half" }
      }).then(async (response) => {
        url = response.url;
        status = response.status;
        for (const keyAndValue of response.headers) {
          headers[keyAndValue[0]] = keyAndValue[1];
        }
        if ("deprecation" in headers) {
          const matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/);
          const deprecationLink = matches && matches.pop();
          log.warn(
            `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
          );
        }
        if (status === 204 || status === 205) {
          return;
        }
        if (requestOptions.method === "HEAD") {
          if (status < 400) {
            return;
          }
          throw new import_request_error2.RequestError(response.statusText, status, {
            response: {
              url,
              status,
              headers,
              data: void 0
            },
            request: requestOptions
          });
        }
        if (status === 304) {
          throw new import_request_error2.RequestError("Not modified", status, {
            response: {
              url,
              status,
              headers,
              data: await getResponseData2(response)
            },
            request: requestOptions
          });
        }
        if (status >= 400) {
          const data = await getResponseData2(response);
          const error = new import_request_error2.RequestError(toErrorMessage2(data), status, {
            response: {
              url,
              status,
              headers,
              data
            },
            request: requestOptions
          });
          throw error;
        }
        return parseSuccessResponseBody ? await getResponseData2(response) : response.body;
      }).then((data) => {
        return {
          status,
          url,
          headers,
          data
        };
      }).catch((error) => {
        if (error instanceof import_request_error2.RequestError)
          throw error;
        else if (error.name === "AbortError")
          throw error;
        let message = error.message;
        if (error.name === "TypeError" && "cause" in error) {
          if (error.cause instanceof Error) {
            message = error.cause.message;
          } else if (typeof error.cause === "string") {
            message = error.cause;
          }
        }
        throw new import_request_error2.RequestError(message, 500, {
          request: requestOptions
        });
      });
    }
    async function getResponseData2(response) {
      const contentType = response.headers.get("content-type");
      if (/application\/json/.test(contentType)) {
        return response.json().catch(() => response.text()).catch(() => "");
      }
      if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
        return response.text();
      }
      return getBufferResponse(response);
    }
    function toErrorMessage2(data) {
      if (typeof data === "string")
        return data;
      let suffix;
      if ("documentation_url" in data) {
        suffix = ` - ${data.documentation_url}`;
      } else {
        suffix = "";
      }
      if ("message" in data) {
        if (Array.isArray(data.errors)) {
          return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
        }
        return `${data.message}${suffix}`;
      }
      return `Unknown error: ${JSON.stringify(data)}`;
    }
    function withDefaults4(oldEndpoint, newDefaults) {
      const endpoint2 = oldEndpoint.defaults(newDefaults);
      const newApi = function(route, parameters) {
        const endpointOptions = endpoint2.merge(route, parameters);
        if (!endpointOptions.request || !endpointOptions.request.hook) {
          return fetchWrapper2(endpoint2.parse(endpointOptions));
        }
        const request22 = (route2, parameters2) => {
          return fetchWrapper2(
            endpoint2.parse(endpoint2.merge(route2, parameters2))
          );
        };
        Object.assign(request22, {
          endpoint: endpoint2,
          defaults: withDefaults4.bind(null, endpoint2)
        });
        return endpointOptions.request.hook(request22, endpointOptions);
      };
      return Object.assign(newApi, {
        endpoint: endpoint2,
        defaults: withDefaults4.bind(null, endpoint2)
      });
    }
    var request2 = withDefaults4(import_endpoint2.endpoint, {
      headers: {
        "user-agent": `octokit-request.js/${VERSION9} ${(0, import_universal_user_agent5.getUserAgent)()}`
      }
    });
  }
});

// 
var require_dist_node6 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      GraphqlResponseError: () => GraphqlResponseError2,
      graphql: () => graphql22,
      withCustomRequest: () => withCustomRequest2
    });
    module2.exports = __toCommonJS(index_exports);
    var import_request32 = require_dist_node5();
    var import_universal_user_agent5 = require_dist_node();
    var VERSION9 = "7.1.1";
    var import_request22 = require_dist_node5();
    var import_request5 = require_dist_node5();
    function _buildMessageForResponseErrors2(data) {
      return `Request failed due to following response errors:
` + data.errors.map((e5) => ` - ${e5.message}`).join("\n");
    }
    var GraphqlResponseError2 = class extends Error {
      constructor(request2, headers, response) {
        super(_buildMessageForResponseErrors2(response));
        this.request = request2;
        this.headers = headers;
        this.response = response;
        this.name = "GraphqlResponseError";
        this.errors = response.errors;
        this.data = response.data;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
    var NON_VARIABLE_OPTIONS2 = [
      "method",
      "baseUrl",
      "url",
      "headers",
      "request",
      "query",
      "mediaType"
    ];
    var FORBIDDEN_VARIABLE_OPTIONS2 = ["query", "method", "url"];
    var GHES_V3_SUFFIX_REGEX2 = /\/api\/v3\/?$/;
    function graphql3(request2, query2, options) {
      if (options) {
        if (typeof query2 === "string" && "query" in options) {
          return Promise.reject(
            new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
          );
        }
        for (const key in options) {
          if (!FORBIDDEN_VARIABLE_OPTIONS2.includes(key))
            continue;
          return Promise.reject(
            new Error(
              `[@octokit/graphql] "${key}" cannot be used as variable name`
            )
          );
        }
      }
      const parsedOptions = typeof query2 === "string" ? Object.assign({ query: query2 }, options) : query2;
      const requestOptions = Object.keys(
        parsedOptions
      ).reduce((result, key) => {
        if (NON_VARIABLE_OPTIONS2.includes(key)) {
          result[key] = parsedOptions[key];
          return result;
        }
        if (!result.variables) {
          result.variables = {};
        }
        result.variables[key] = parsedOptions[key];
        return result;
      }, {});
      const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
      if (GHES_V3_SUFFIX_REGEX2.test(baseUrl)) {
        requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX2, "/api/graphql");
      }
      return request2(requestOptions).then((response) => {
        if (response.data.errors) {
          const headers = {};
          for (const key of Object.keys(response.headers)) {
            headers[key] = response.headers[key];
          }
          throw new GraphqlResponseError2(
            requestOptions,
            headers,
            response.data
          );
        }
        return response.data.data;
      });
    }
    function withDefaults4(request2, newDefaults) {
      const newRequest = request2.defaults(newDefaults);
      const newApi = (query2, options) => {
        return graphql3(newRequest, query2, options);
      };
      return Object.assign(newApi, {
        defaults: withDefaults4.bind(null, newRequest),
        endpoint: newRequest.endpoint
      });
    }
    var graphql22 = withDefaults4(import_request32.request, {
      headers: {
        "user-agent": `octokit-graphql.js/${VERSION9} ${(0, import_universal_user_agent5.getUserAgent)()}`
      },
      method: "POST",
      url: "/graphql"
    });
    function withCustomRequest2(customRequest) {
      return withDefaults4(customRequest, {
        method: "POST",
        url: "/graphql"
      });
    }
  }
});

// 
var require_dist_node7 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      createTokenAuth: () => createTokenAuth3
    });
    module2.exports = __toCommonJS(dist_src_exports);
    var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
    var REGEX_IS_INSTALLATION = /^ghs_/;
    var REGEX_IS_USER_TO_SERVER = /^ghu_/;
    async function auth2(token) {
      const isApp = token.split(/\./).length === 3;
      const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
      const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
      const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
      return {
        type: "token",
        token,
        tokenType
      };
    }
    function withAuthorizationPrefix2(token) {
      if (token.split(/\./).length === 3) {
        return `bearer ${token}`;
      }
      return `token ${token}`;
    }
    async function hook2(token, request2, route, parameters) {
      const endpoint2 = request2.endpoint.merge(
        route,
        parameters
      );
      endpoint2.headers.authorization = withAuthorizationPrefix2(token);
      return request2(endpoint2);
    }
    var createTokenAuth3 = function createTokenAuth22(token) {
      if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
      }
      if (typeof token !== "string") {
        throw new Error(
          "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
        );
      }
      token = token.replace(/^(token|bearer) +/i, "");
      return Object.assign(auth2.bind(null, token), {
        hook: hook2.bind(null, token)
      });
    };
  }
});

// 
var require_dist_node8 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Octokit: () => Octokit3
    });
    module2.exports = __toCommonJS(index_exports);
    var import_universal_user_agent5 = require_dist_node();
    var import_before_after_hook2 = require_before_after_hook();
    var import_request5 = require_dist_node5();
    var import_graphql2 = require_dist_node6();
    var import_auth_token2 = require_dist_node7();
    var VERSION9 = "5.2.2";
    var noop2 = () => {
    };
    var consoleWarn2 = console.warn.bind(console);
    var consoleError2 = console.error.bind(console);
    function createLogger2(logger = {}) {
      if (typeof logger.debug !== "function") {
        logger.debug = noop2;
      }
      if (typeof logger.info !== "function") {
        logger.info = noop2;
      }
      if (typeof logger.warn !== "function") {
        logger.warn = consoleWarn2;
      }
      if (typeof logger.error !== "function") {
        logger.error = consoleError2;
      }
      return logger;
    }
    var userAgentTrail2 = `octokit-core.js/${VERSION9} ${(0, import_universal_user_agent5.getUserAgent)()}`;
    var Octokit3 = class {
      static {
        this.VERSION = VERSION9;
      }
      static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
          constructor(...args) {
            const options = args[0] || {};
            if (typeof defaults === "function") {
              super(defaults(options));
              return;
            }
            super(
              Object.assign(
                {},
                defaults,
                options,
                options.userAgent && defaults.userAgent ? {
                  userAgent: `${options.userAgent} ${defaults.userAgent}`
                } : null
              )
            );
          }
        };
        return OctokitWithDefaults;
      }
      static {
        this.plugins = [];
      }
      /**
       * Attach a plugin (or many) to your Octokit instance.
       *
       * @example
       * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
       */
      static plugin(...newPlugins) {
        const currentPlugins = this.plugins;
        const NewOctokit = class extends this {
          static {
            this.plugins = currentPlugins.concat(
              newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
            );
          }
        };
        return NewOctokit;
      }
      constructor(options = {}) {
        const hook2 = new import_before_after_hook2.Collection();
        const requestDefaults = {
          baseUrl: import_request5.request.endpoint.DEFAULTS.baseUrl,
          headers: {},
          request: Object.assign({}, options.request, {
            // @ts-ignore internal usage only, no need to type
            hook: hook2.bind(null, "request")
          }),
          mediaType: {
            previews: [],
            format: ""
          }
        };
        requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail2}` : userAgentTrail2;
        if (options.baseUrl) {
          requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
          requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
          requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = import_request5.request.defaults(requestDefaults);
        this.graphql = (0, import_graphql2.withCustomRequest)(this.request).defaults(requestDefaults);
        this.log = createLogger2(options.log);
        this.hook = hook2;
        if (!options.authStrategy) {
          if (!options.auth) {
            this.auth = async () => ({
              type: "unauthenticated"
            });
          } else {
            const auth2 = (0, import_auth_token2.createTokenAuth)(options.auth);
            hook2.wrap("request", auth2.hook);
            this.auth = auth2;
          }
        } else {
          const { authStrategy, ...otherOptions } = options;
          const auth2 = authStrategy(
            Object.assign(
              {
                request: this.request,
                log: this.log,
                // we pass the current octokit instance as well as its constructor options
                // to allow for authentication strategies that return a new octokit instance
                // that shares the same internal state as the current one. The original
                // requirement for this was the "event-octokit" authentication strategy
                // of https://github.com/probot/octokit-auth-probot.
                octokit: this,
                octokitOptions: otherOptions
              },
              options.auth
            )
          );
          hook2.wrap("request", auth2.hook);
          this.auth = auth2;
        }
        const classConstructor = this.constructor;
        for (let i6 = 0; i6 < classConstructor.plugins.length; ++i6) {
          Object.assign(this, classConstructor.plugins[i6](this, options));
        }
      }
    };
  }
});

// 
var require_dist_node9 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      legacyRestEndpointMethods: () => legacyRestEndpointMethods2,
      restEndpointMethods: () => restEndpointMethods2
    });
    module2.exports = __toCommonJS(dist_src_exports);
    var VERSION9 = "10.4.1";
    var Endpoints2 = {
      actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: [
          "POST /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        addCustomLabelsToSelfHostedRunnerForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgVariable: [
          "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        approveWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
        ],
        cancelWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
        ],
        createEnvironmentVariable: [
          "POST /repositories/{repository_id}/environments/{environment_name}/variables"
        ],
        createOrUpdateEnvironmentSecret: [
          "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
        ],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        createOrgVariable: ["POST /orgs/{org}/actions/variables"],
        createRegistrationTokenForOrg: [
          "POST /orgs/{org}/actions/runners/registration-token"
        ],
        createRegistrationTokenForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/registration-token"
        ],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/remove-token"
        ],
        createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
        createWorkflowDispatch: [
          "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        ],
        deleteActionsCacheById: [
          "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
        ],
        deleteActionsCacheByKey: [
          "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
        ],
        deleteArtifact: [
          "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
        ],
        deleteEnvironmentSecret: [
          "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
        ],
        deleteEnvironmentVariable: [
          "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        deleteRepoVariable: [
          "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
        ],
        deleteSelfHostedRunnerFromOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}"
        ],
        deleteSelfHostedRunnerFromRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: [
          "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        disableSelectedRepositoryGithubActionsOrganization: [
          "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        disableWorkflow: [
          "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
        ],
        downloadArtifact: [
          "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
        ],
        downloadJobLogsForWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
        ],
        downloadWorkflowRunAttemptLogs: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
        ],
        downloadWorkflowRunLogs: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        enableSelectedRepositoryGithubActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        enableWorkflow: [
          "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
        ],
        forceCancelWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
        ],
        generateRunnerJitconfigForOrg: [
          "POST /orgs/{org}/actions/runners/generate-jitconfig"
        ],
        generateRunnerJitconfigForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
        ],
        getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
        getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
        getActionsCacheUsageByRepoForOrg: [
          "GET /orgs/{org}/actions/cache/usage-by-repository"
        ],
        getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
        getAllowedActionsOrganization: [
          "GET /orgs/{org}/actions/permissions/selected-actions"
        ],
        getAllowedActionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getCustomOidcSubClaimForRepo: [
          "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
        ],
        getEnvironmentPublicKey: [
          "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
        ],
        getEnvironmentSecret: [
          "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
        ],
        getEnvironmentVariable: [
          "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
        ],
        getGithubActionsDefaultWorkflowPermissionsOrganization: [
          "GET /orgs/{org}/actions/permissions/workflow"
        ],
        getGithubActionsDefaultWorkflowPermissionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        getGithubActionsPermissionsOrganization: [
          "GET /orgs/{org}/actions/permissions"
        ],
        getGithubActionsPermissionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions"
        ],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
        getPendingDeploymentsForRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        getRepoPermissions: [
          "GET /repos/{owner}/{repo}/actions/permissions",
          {},
          { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
        ],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
        getReviewsForRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
        ],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowAccessToRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/access"
        ],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunAttempt: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
        ],
        getWorkflowRunUsage: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
        ],
        getWorkflowUsage: [
          "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
        ],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listEnvironmentSecrets: [
          "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
        ],
        listEnvironmentVariables: [
          "GET /repositories/{repository_id}/environments/{environment_name}/variables"
        ],
        listJobsForWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
        ],
        listJobsForWorkflowRunAttempt: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
        ],
        listLabelsForSelfHostedRunnerForOrg: [
          "GET /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        listLabelsForSelfHostedRunnerForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listOrgVariables: ["GET /orgs/{org}/actions/variables"],
        listRepoOrganizationSecrets: [
          "GET /repos/{owner}/{repo}/actions/organization-secrets"
        ],
        listRepoOrganizationVariables: [
          "GET /repos/{owner}/{repo}/actions/organization-variables"
        ],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/downloads"
        ],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        listSelectedReposForOrgVariable: [
          "GET /orgs/{org}/actions/variables/{name}/repositories"
        ],
        listSelectedRepositoriesEnabledGithubActionsOrganization: [
          "GET /orgs/{org}/actions/permissions/repositories"
        ],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
        ],
        listWorkflowRuns: [
          "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
        ],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunJobForWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
        ],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        reRunWorkflowFailedJobs: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        removeCustomLabelFromSelfHostedRunnerForOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeCustomLabelFromSelfHostedRunnerForRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgVariable: [
          "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        reviewCustomGatesForRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
        ],
        reviewPendingDeploymentsForRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        setAllowedActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/selected-actions"
        ],
        setAllowedActionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        setCustomLabelsForSelfHostedRunnerForOrg: [
          "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        setCustomLabelsForSelfHostedRunnerForRepo: [
          "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        setCustomOidcSubClaimForRepo: [
          "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
        ],
        setGithubActionsDefaultWorkflowPermissionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/workflow"
        ],
        setGithubActionsDefaultWorkflowPermissionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        setGithubActionsPermissionsOrganization: [
          "PUT /orgs/{org}/actions/permissions"
        ],
        setGithubActionsPermissionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgVariable: [
          "PUT /orgs/{org}/actions/variables/{name}/repositories"
        ],
        setSelectedRepositoriesEnabledGithubActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/repositories"
        ],
        setWorkflowAccessToRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/access"
        ],
        updateEnvironmentVariable: [
          "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
        ],
        updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
        updateRepoVariable: [
          "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
        ]
      },
      activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: [
          "DELETE /notifications/threads/{thread_id}/subscription"
        ],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: [
          "GET /notifications/threads/{thread_id}/subscription"
        ],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: [
          "GET /users/{username}/events/orgs/{org}"
        ],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: [
          "GET /users/{username}/received_events/public"
        ],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/notifications"
        ],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: [
          "PUT /notifications/threads/{thread_id}/subscription"
        ],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
      },
      apps: {
        addRepoToInstallation: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
        ],
        addRepoToInstallationForAuthenticatedUser: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        checkToken: ["POST /applications/{client_id}/token"],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: [
          "POST /app/installations/{installation_id}/access_tokens"
        ],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: [
          "GET /marketplace_listing/accounts/{account_id}"
        ],
        getSubscriptionPlanForAccountStubbed: [
          "GET /marketplace_listing/stubbed/accounts/{account_id}"
        ],
        getUserInstallation: ["GET /users/{username}/installation"],
        getWebhookConfigForApp: ["GET /app/hook/config"],
        getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: [
          "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
        ],
        listInstallationReposForAuthenticatedUser: [
          "GET /user/installations/{installation_id}/repositories"
        ],
        listInstallationRequestsForAuthenticatedApp: [
          "GET /app/installation-requests"
        ],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: [
          "GET /user/marketplace_purchases/stubbed"
        ],
        listWebhookDeliveries: ["GET /app/hook/deliveries"],
        redeliverWebhookDelivery: [
          "POST /app/hook/deliveries/{delivery_id}/attempts"
        ],
        removeRepoFromInstallation: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
        ],
        removeRepoFromInstallationForAuthenticatedUser: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        scopeToken: ["POST /applications/{client_id}/token/scoped"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: [
          "DELETE /app/installations/{installation_id}/suspended"
        ],
        updateWebhookConfigForApp: ["PATCH /app/hook/config"]
      },
      billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: [
          "GET /users/{username}/settings/billing/actions"
        ],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: [
          "GET /users/{username}/settings/billing/packages"
        ],
        getSharedStorageBillingOrg: [
          "GET /orgs/{org}/settings/billing/shared-storage"
        ],
        getSharedStorageBillingUser: [
          "GET /users/{username}/settings/billing/shared-storage"
        ]
      },
      checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs"],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
        listAnnotations: [
          "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
        ],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
        listForSuite: [
          "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
        ],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
        rerequestRun: [
          "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
        ],
        rerequestSuite: [
          "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
        ],
        setSuitesPreferences: [
          "PATCH /repos/{owner}/{repo}/check-suites/preferences"
        ],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
      },
      codeScanning: {
        deleteAnalysis: [
          "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
        ],
        getAlert: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
          {},
          { renamedParameters: { alert_id: "alert_number" } }
        ],
        getAnalysis: [
          "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
        ],
        getCodeqlDatabase: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
        ],
        getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
        getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
        listAlertInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
        ],
        listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listAlertsInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
          {},
          { renamed: ["codeScanning", "listAlertInstances"] }
        ],
        listCodeqlDatabases: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
        ],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
        ],
        updateDefaultSetup: [
          "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
        ],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
      },
      codesOfConduct: {
        getAllCodesOfConduct: ["GET /codes_of_conduct"],
        getConductCode: ["GET /codes_of_conduct/{key}"]
      },
      codespaces: {
        addRepositoryForSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        checkPermissionsForDevcontainer: [
          "GET /repos/{owner}/{repo}/codespaces/permissions_check"
        ],
        codespaceMachinesForAuthenticatedUser: [
          "GET /user/codespaces/{codespace_name}/machines"
        ],
        createForAuthenticatedUser: ["POST /user/codespaces"],
        createOrUpdateOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}"
        ],
        createWithPrForAuthenticatedUser: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
        ],
        createWithRepoForAuthenticatedUser: [
          "POST /repos/{owner}/{repo}/codespaces"
        ],
        deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
        deleteFromOrganization: [
          "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        deleteSecretForAuthenticatedUser: [
          "DELETE /user/codespaces/secrets/{secret_name}"
        ],
        exportForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/exports"
        ],
        getCodespacesForUserInOrg: [
          "GET /orgs/{org}/members/{username}/codespaces"
        ],
        getExportDetailsForAuthenticatedUser: [
          "GET /user/codespaces/{codespace_name}/exports/{export_id}"
        ],
        getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
        getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
        getPublicKeyForAuthenticatedUser: [
          "GET /user/codespaces/secrets/public-key"
        ],
        getRepoPublicKey: [
          "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
        ],
        getRepoSecret: [
          "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        getSecretForAuthenticatedUser: [
          "GET /user/codespaces/secrets/{secret_name}"
        ],
        listDevcontainersInRepositoryForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/devcontainers"
        ],
        listForAuthenticatedUser: ["GET /user/codespaces"],
        listInOrganization: [
          "GET /orgs/{org}/codespaces",
          {},
          { renamedParameters: { org_id: "org" } }
        ],
        listInRepositoryForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces"
        ],
        listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
        listRepositoriesForSecretForAuthenticatedUser: [
          "GET /user/codespaces/secrets/{secret_name}/repositories"
        ],
        listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        preFlightWithRepoForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/new"
        ],
        publishForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/publish"
        ],
        removeRepositoryForSecretForAuthenticatedUser: [
          "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        repoMachinesForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/machines"
        ],
        setRepositoriesForSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
        stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
        stopInOrganization: [
          "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
        ],
        updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
      },
      copilot: {
        addCopilotSeatsForTeams: [
          "POST /orgs/{org}/copilot/billing/selected_teams"
        ],
        addCopilotSeatsForUsers: [
          "POST /orgs/{org}/copilot/billing/selected_users"
        ],
        cancelCopilotSeatAssignmentForTeams: [
          "DELETE /orgs/{org}/copilot/billing/selected_teams"
        ],
        cancelCopilotSeatAssignmentForUsers: [
          "DELETE /orgs/{org}/copilot/billing/selected_users"
        ],
        getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
        getCopilotSeatDetailsForUser: [
          "GET /orgs/{org}/members/{username}/copilot"
        ],
        listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
      },
      dependabot: {
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        createOrUpdateOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
        getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
        getRepoPublicKey: [
          "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
        ],
        getRepoSecret: [
          "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        listAlertsForEnterprise: [
          "GET /enterprises/{enterprise}/dependabot/alerts"
        ],
        listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
        listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
        ]
      },
      dependencyGraph: {
        createRepositorySnapshot: [
          "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
        ],
        diffRange: [
          "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
        ],
        exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
      },
      emojis: { get: ["GET /emojis"] },
      gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
      },
      git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
      },
      gitignore: {
        getAllTemplates: ["GET /gitignore/templates"],
        getTemplate: ["GET /gitignore/templates/{name}"]
      },
      interactions: {
        getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
        getRestrictionsForYourPublicRepos: [
          "GET /user/interaction-limits",
          {},
          { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
        ],
        removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
        removeRestrictionsForRepo: [
          "DELETE /repos/{owner}/{repo}/interaction-limits"
        ],
        removeRestrictionsForYourPublicRepos: [
          "DELETE /user/interaction-limits",
          {},
          { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
        ],
        setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
        setRestrictionsForYourPublicRepos: [
          "PUT /user/interaction-limits",
          {},
          { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
        ]
      },
      issues: {
        addAssignees: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        checkUserCanBeAssignedToIssue: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
        ],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
        ],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: [
          "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
        ],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: [
          "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
        ],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
        ],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: [
          "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
        ],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        removeAssignees: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        removeLabel: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
        ],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: [
          "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
        ]
      },
      licenses: {
        get: ["GET /licenses/{license}"],
        getAllCommonlyUsed: ["GET /licenses"],
        getForRepo: ["GET /repos/{owner}/{repo}/license"]
      },
      markdown: {
        render: ["POST /markdown"],
        renderRaw: [
          "POST /markdown/raw",
          { headers: { "content-type": "text/plain; charset=utf-8" } }
        ]
      },
      meta: {
        get: ["GET /meta"],
        getAllVersions: ["GET /versions"],
        getOctocat: ["GET /octocat"],
        getZen: ["GET /zen"],
        root: ["GET /"]
      },
      migrations: {
        cancelImport: [
          "DELETE /repos/{owner}/{repo}/import",
          {},
          {
            deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
          }
        ],
        deleteArchiveForAuthenticatedUser: [
          "DELETE /user/migrations/{migration_id}/archive"
        ],
        deleteArchiveForOrg: [
          "DELETE /orgs/{org}/migrations/{migration_id}/archive"
        ],
        downloadArchiveForOrg: [
          "GET /orgs/{org}/migrations/{migration_id}/archive"
        ],
        getArchiveForAuthenticatedUser: [
          "GET /user/migrations/{migration_id}/archive"
        ],
        getCommitAuthors: [
          "GET /repos/{owner}/{repo}/import/authors",
          {},
          {
            deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
          }
        ],
        getImportStatus: [
          "GET /repos/{owner}/{repo}/import",
          {},
          {
            deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
          }
        ],
        getLargeFiles: [
          "GET /repos/{owner}/{repo}/import/large_files",
          {},
          {
            deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
          }
        ],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
        listForAuthenticatedUser: ["GET /user/migrations"],
        listForOrg: ["GET /orgs/{org}/migrations"],
        listReposForAuthenticatedUser: [
          "GET /user/migrations/{migration_id}/repositories"
        ],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
        listReposForUser: [
          "GET /user/migrations/{migration_id}/repositories",
          {},
          { renamed: ["migrations", "listReposForAuthenticatedUser"] }
        ],
        mapCommitAuthor: [
          "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
          {},
          {
            deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
          }
        ],
        setLfsPreference: [
          "PATCH /repos/{owner}/{repo}/import/lfs",
          {},
          {
            deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
          }
        ],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        startImport: [
          "PUT /repos/{owner}/{repo}/import",
          {},
          {
            deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
          }
        ],
        unlockRepoForAuthenticatedUser: [
          "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
        ],
        unlockRepoForOrg: [
          "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
        ],
        updateImport: [
          "PATCH /repos/{owner}/{repo}/import",
          {},
          {
            deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
          }
        ]
      },
      oidc: {
        getOidcCustomSubTemplateForOrg: [
          "GET /orgs/{org}/actions/oidc/customization/sub"
        ],
        updateOidcCustomSubTemplateForOrg: [
          "PUT /orgs/{org}/actions/oidc/customization/sub"
        ]
      },
      orgs: {
        addSecurityManagerTeam: [
          "PUT /orgs/{org}/security-managers/teams/{team_slug}"
        ],
        assignTeamToOrgRole: [
          "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        ],
        assignUserToOrgRole: [
          "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
        ],
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: [
          "PUT /orgs/{org}/outside_collaborators/{username}"
        ],
        createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
        createOrUpdateCustomPropertiesValuesForRepos: [
          "PATCH /orgs/{org}/properties/values"
        ],
        createOrUpdateCustomProperty: [
          "PUT /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        createWebhook: ["POST /orgs/{org}/hooks"],
        delete: ["DELETE /orgs/{org}"],
        deleteCustomOrganizationRole: [
          "DELETE /orgs/{org}/organization-roles/{role_id}"
        ],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        enableOrDisableSecurityProductOnAllOrgRepos: [
          "POST /orgs/{org}/{security_product}/{enablement}"
        ],
        get: ["GET /orgs/{org}"],
        getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
        getCustomProperty: [
          "GET /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
        getWebhookDelivery: [
          "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
        listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
        listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
        listOrgRoles: ["GET /orgs/{org}/organization-roles"],
        listOrganizationFineGrainedPermissions: [
          "GET /orgs/{org}/organization-fine-grained-permissions"
        ],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPatGrantRepositories: [
          "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
        ],
        listPatGrantRequestRepositories: [
          "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
        ],
        listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
        listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
        listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        patchCustomOrganizationRole: [
          "PATCH /orgs/{org}/organization-roles/{role_id}"
        ],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
          "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeCustomProperty: [
          "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: [
          "DELETE /orgs/{org}/outside_collaborators/{username}"
        ],
        removePublicMembershipForAuthenticatedUser: [
          "DELETE /orgs/{org}/public_members/{username}"
        ],
        removeSecurityManagerTeam: [
          "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
        ],
        reviewPatGrantRequest: [
          "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
        ],
        reviewPatGrantRequestsInBulk: [
          "POST /orgs/{org}/personal-access-token-requests"
        ],
        revokeAllOrgRolesTeam: [
          "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
        ],
        revokeAllOrgRolesUser: [
          "DELETE /orgs/{org}/organization-roles/users/{username}"
        ],
        revokeOrgRoleTeam: [
          "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        ],
        revokeOrgRoleUser: [
          "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
        ],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: [
          "PUT /orgs/{org}/public_members/{username}"
        ],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: [
          "PATCH /user/memberships/orgs/{org}"
        ],
        updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
        updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
        updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
      },
      packages: {
        deletePackageForAuthenticatedUser: [
          "DELETE /user/packages/{package_type}/{package_name}"
        ],
        deletePackageForOrg: [
          "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        deletePackageForUser: [
          "DELETE /users/{username}/packages/{package_type}/{package_name}"
        ],
        deletePackageVersionForAuthenticatedUser: [
          "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForOrg: [
          "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForUser: [
          "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
          {},
          { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions",
          {},
          {
            renamed: [
              "packages",
              "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
            ]
          }
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}/versions"
        ],
        getPackageForAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}"
        ],
        getPackageForOrganization: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        getPackageForUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}"
        ],
        getPackageVersionForAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForOrganization: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        listDockerMigrationConflictingPackagesForAuthenticatedUser: [
          "GET /user/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForOrganization: [
          "GET /orgs/{org}/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForUser: [
          "GET /users/{username}/docker/conflicts"
        ],
        listPackagesForAuthenticatedUser: ["GET /user/packages"],
        listPackagesForOrganization: ["GET /orgs/{org}/packages"],
        listPackagesForUser: ["GET /users/{username}/packages"],
        restorePackageForAuthenticatedUser: [
          "POST /user/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForOrg: [
          "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForUser: [
          "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageVersionForAuthenticatedUser: [
          "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForOrg: [
          "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForUser: [
          "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ]
      },
      projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
        createCard: ["POST /projects/columns/{column_id}/cards"],
        createColumn: ["POST /projects/{project_id}/columns"],
        createForAuthenticatedUser: ["POST /user/projects"],
        createForOrg: ["POST /orgs/{org}/projects"],
        createForRepo: ["POST /repos/{owner}/{repo}/projects"],
        delete: ["DELETE /projects/{project_id}"],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
        deleteColumn: ["DELETE /projects/columns/{column_id}"],
        get: ["GET /projects/{project_id}"],
        getCard: ["GET /projects/columns/cards/{card_id}"],
        getColumn: ["GET /projects/columns/{column_id}"],
        getPermissionForUser: [
          "GET /projects/{project_id}/collaborators/{username}/permission"
        ],
        listCards: ["GET /projects/columns/{column_id}/cards"],
        listCollaborators: ["GET /projects/{project_id}/collaborators"],
        listColumns: ["GET /projects/{project_id}/columns"],
        listForOrg: ["GET /orgs/{org}/projects"],
        listForRepo: ["GET /repos/{owner}/{repo}/projects"],
        listForUser: ["GET /users/{username}/projects"],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
        moveColumn: ["POST /projects/columns/{column_id}/moves"],
        removeCollaborator: [
          "DELETE /projects/{project_id}/collaborators/{username}"
        ],
        update: ["PATCH /projects/{project_id}"],
        updateCard: ["PATCH /projects/columns/cards/{card_id}"],
        updateColumn: ["PATCH /projects/columns/{column_id}"]
      },
      pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
        ],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        deletePendingReview: [
          "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        deleteReviewComment: [
          "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ],
        dismissReview: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
        ],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
        ],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        listReviewComments: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: [
          "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        requestReviewers: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        submitReview: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
        ],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
        ],
        updateReview: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        updateReviewComment: [
          "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ]
      },
      rateLimit: { get: ["GET /rate_limit"] },
      reactions: {
        createForCommitComment: [
          "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        createForIssue: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
        ],
        createForIssueComment: [
          "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        createForPullRequestReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        createForRelease: [
          "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        createForTeamDiscussionCommentInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        createForTeamDiscussionInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ],
        deleteForCommitComment: [
          "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForIssue: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
        ],
        deleteForIssueComment: [
          "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForPullRequestComment: [
          "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForRelease: [
          "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussion: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussionComment: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
        ],
        listForCommitComment: [
          "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        listForIssueComment: [
          "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        listForPullRequestReviewComment: [
          "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        listForRelease: [
          "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        listForTeamDiscussionCommentInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        listForTeamDiscussionInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ]
      },
      repos: {
        acceptInvitation: [
          "PATCH /user/repository_invitations/{invitation_id}",
          {},
          { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
        ],
        acceptInvitationForAuthenticatedUser: [
          "PATCH /user/repository_invitations/{invitation_id}"
        ],
        addAppAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          { mapToData: "apps" }
        ],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          { mapToData: "contexts" }
        ],
        addTeamAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          { mapToData: "teams" }
        ],
        addUserAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          { mapToData: "users" }
        ],
        cancelPagesDeployment: [
          "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
        ],
        checkAutomatedSecurityFixes: [
          "GET /repos/{owner}/{repo}/automated-security-fixes"
        ],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkVulnerabilityAlerts: [
          "GET /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        compareCommitsWithBasehead: [
          "GET /repos/{owner}/{repo}/compare/{basehead}"
        ],
        createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
        createCommitComment: [
          "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        createCommitSignatureProtection: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentBranchPolicy: [
          "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        createDeploymentProtectionRule: [
          "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        createDeploymentStatus: [
          "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateCustomPropertiesValues: [
          "PATCH /repos/{owner}/{repo}/properties/values"
        ],
        createOrUpdateEnvironment: [
          "PUT /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createOrgRuleset: ["POST /orgs/{org}/rulesets"],
        createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
        createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
        createUsingTemplate: [
          "POST /repos/{template_owner}/{template_repo}/generate"
        ],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: [
          "DELETE /user/repository_invitations/{invitation_id}",
          {},
          { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
        ],
        declineInvitationForAuthenticatedUser: [
          "DELETE /user/repository_invitations/{invitation_id}"
        ],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        deleteAdminBranchProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        deleteAnEnvironment: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        deleteBranchProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: [
          "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
        ],
        deleteDeploymentBranchPolicy: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: [
          "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
        deletePullRequestReviewProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: [
          "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        deleteTagProtection: [
          "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
        ],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: [
          "DELETE /repos/{owner}/{repo}/automated-security-fixes"
        ],
        disableDeploymentProtectionRule: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        disablePrivateVulnerabilityReporting: [
          "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        disableVulnerabilityAlerts: [
          "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        downloadArchive: [
          "GET /repos/{owner}/{repo}/zipball/{ref}",
          {},
          { renamed: ["repos", "downloadZipballArchive"] }
        ],
        downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
        downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
        enableAutomatedSecurityFixes: [
          "PUT /repos/{owner}/{repo}/automated-security-fixes"
        ],
        enablePrivateVulnerabilityReporting: [
          "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        enableVulnerabilityAlerts: [
          "PUT /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        generateReleaseNotes: [
          "POST /repos/{owner}/{repo}/releases/generate-notes"
        ],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        getAdminBranchProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        getAllDeploymentProtectionRules: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
        getAllStatusCheckContexts: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
        ],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
        getAppsWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
        ],
        getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: [
          "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
        ],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getCustomDeploymentProtectionRule: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentBranchPolicy: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        getDeploymentStatus: [
          "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
        ],
        getEnvironment: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
        getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
        getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
        getOrgRulesets: ["GET /orgs/{org}/rulesets"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getPagesDeployment: [
          "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
        ],
        getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getRepoRuleSuite: [
          "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
        ],
        getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
        getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
        getStatusChecksProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        getTeamsWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
        ],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
        ],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        getWebhookConfigForRepo: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        getWebhookDelivery: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        listActivities: ["GET /repos/{owner}/{repo}/activity"],
        listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
        ],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: [
          "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
        ],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listCustomDeploymentRuleIntegrations: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
        ],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentBranchPolicies: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        listDeploymentStatuses: [
          "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
        ],
        listReleaseAssets: [
          "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
        ],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhookDeliveries: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
        ],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
          "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeAppAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          { mapToData: "apps" }
        ],
        removeCollaborator: [
          "DELETE /repos/{owner}/{repo}/collaborators/{username}"
        ],
        removeStatusCheckContexts: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          { mapToData: "contexts" }
        ],
        removeStatusCheckProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        removeTeamAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          { mapToData: "teams" }
        ],
        removeUserAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          { mapToData: "users" }
        ],
        renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        setAppAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          { mapToData: "apps" }
        ],
        setStatusCheckContexts: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          { mapToData: "contexts" }
        ],
        setTeamAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          { mapToData: "teams" }
        ],
        setUserAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          { mapToData: "users" }
        ],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateDeploymentBranchPolicy: [
          "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: [
          "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
        updatePullRequestReviewProtection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: [
          "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        updateStatusCheckPotection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
          {},
          { renamed: ["repos", "updateStatusCheckProtection"] }
        ],
        updateStatusCheckProtection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        updateWebhookConfigForRepo: [
          "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        uploadReleaseAsset: [
          "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
          { baseUrl: "https://uploads.github.com" }
        ]
      },
      search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits"],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics"],
        users: ["GET /search/users"]
      },
      secretScanning: {
        getAlert: [
          "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ],
        listAlertsForEnterprise: [
          "GET /enterprises/{enterprise}/secret-scanning/alerts"
        ],
        listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
        listLocationsForAlert: [
          "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
        ],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ]
      },
      securityAdvisories: {
        createFork: [
          "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
        ],
        createPrivateVulnerabilityReport: [
          "POST /repos/{owner}/{repo}/security-advisories/reports"
        ],
        createRepositoryAdvisory: [
          "POST /repos/{owner}/{repo}/security-advisories"
        ],
        createRepositoryAdvisoryCveRequest: [
          "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
        ],
        getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
        getRepositoryAdvisory: [
          "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ],
        listGlobalAdvisories: ["GET /advisories"],
        listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
        listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
        updateRepositoryAdvisory: [
          "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ]
      },
      teams: {
        addOrUpdateMembershipForUserInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        addOrUpdateProjectPermissionsInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
        ],
        addOrUpdateRepoPermissionsInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        checkPermissionsForProjectInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
        ],
        checkPermissionsForRepoInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        deleteDiscussionInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        getDiscussionInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        getMembershipForUserInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/invitations"
        ],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        removeProjectInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
        ],
        removeRepoInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        updateDiscussionCommentInOrg: [
          "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        updateDiscussionInOrg: [
          "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
      },
      users: {
        addEmailForAuthenticated: [
          "POST /user/emails",
          {},
          { renamed: ["users", "addEmailForAuthenticatedUser"] }
        ],
        addEmailForAuthenticatedUser: ["POST /user/emails"],
        addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: [
          "POST /user/gpg_keys",
          {},
          { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
        ],
        createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: [
          "POST /user/keys",
          {},
          { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
        ],
        createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
        createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
        deleteEmailForAuthenticated: [
          "DELETE /user/emails",
          {},
          { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
        ],
        deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: [
          "DELETE /user/gpg_keys/{gpg_key_id}",
          {},
          { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
        ],
        deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: [
          "DELETE /user/keys/{key_id}",
          {},
          { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
        ],
        deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
        deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
        deleteSshSigningKeyForAuthenticatedUser: [
          "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: [
          "GET /user/gpg_keys/{gpg_key_id}",
          {},
          { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
        ],
        getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: [
          "GET /user/keys/{key_id}",
          {},
          { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
        ],
        getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
        getSshSigningKeyForAuthenticatedUser: [
          "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        list: ["GET /users"],
        listBlockedByAuthenticated: [
          "GET /user/blocks",
          {},
          { renamed: ["users", "listBlockedByAuthenticatedUser"] }
        ],
        listBlockedByAuthenticatedUser: ["GET /user/blocks"],
        listEmailsForAuthenticated: [
          "GET /user/emails",
          {},
          { renamed: ["users", "listEmailsForAuthenticatedUser"] }
        ],
        listEmailsForAuthenticatedUser: ["GET /user/emails"],
        listFollowedByAuthenticated: [
          "GET /user/following",
          {},
          { renamed: ["users", "listFollowedByAuthenticatedUser"] }
        ],
        listFollowedByAuthenticatedUser: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: [
          "GET /user/gpg_keys",
          {},
          { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
        ],
        listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: [
          "GET /user/public_emails",
          {},
          { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
        ],
        listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: [
          "GET /user/keys",
          {},
          { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
        ],
        listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
        listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
        listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
        listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
        listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
        setPrimaryEmailVisibilityForAuthenticated: [
          "PATCH /user/email/visibility",
          {},
          { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: [
          "PATCH /user/email/visibility"
        ],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"]
      }
    };
    var endpoints_default2 = Endpoints2;
    var endpointMethodsMap2 = /* @__PURE__ */ new Map();
    for (const [scope, endpoints] of Object.entries(endpoints_default2)) {
      for (const [methodName, endpoint2] of Object.entries(endpoints)) {
        const [route, defaults, decorations] = endpoint2;
        const [method, url] = route.split(/ /);
        const endpointDefaults = Object.assign(
          {
            method,
            url
          },
          defaults
        );
        if (!endpointMethodsMap2.has(scope)) {
          endpointMethodsMap2.set(scope, /* @__PURE__ */ new Map());
        }
        endpointMethodsMap2.get(scope).set(methodName, {
          scope,
          methodName,
          endpointDefaults,
          decorations
        });
      }
    }
    var handler2 = {
      has({ scope }, methodName) {
        return endpointMethodsMap2.get(scope).has(methodName);
      },
      getOwnPropertyDescriptor(target, methodName) {
        return {
          value: this.get(target, methodName),
          // ensures method is in the cache
          configurable: true,
          writable: true,
          enumerable: true
        };
      },
      defineProperty(target, methodName, descriptor) {
        Object.defineProperty(target.cache, methodName, descriptor);
        return true;
      },
      deleteProperty(target, methodName) {
        delete target.cache[methodName];
        return true;
      },
      ownKeys({ scope }) {
        return [...endpointMethodsMap2.get(scope).keys()];
      },
      set(target, methodName, value) {
        return target.cache[methodName] = value;
      },
      get({ octokit, scope, cache }, methodName) {
        if (cache[methodName]) {
          return cache[methodName];
        }
        const method = endpointMethodsMap2.get(scope).get(methodName);
        if (!method) {
          return void 0;
        }
        const { endpointDefaults, decorations } = method;
        if (decorations) {
          cache[methodName] = decorate2(
            octokit,
            scope,
            methodName,
            endpointDefaults,
            decorations
          );
        } else {
          cache[methodName] = octokit.request.defaults(endpointDefaults);
        }
        return cache[methodName];
      }
    };
    function endpointsToMethods2(octokit) {
      const newMethods = {};
      for (const scope of endpointMethodsMap2.keys()) {
        newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler2);
      }
      return newMethods;
    }
    function decorate2(octokit, scope, methodName, defaults, decorations) {
      const requestWithDefaults = octokit.request.defaults(defaults);
      function withDecorations(...args) {
        let options = requestWithDefaults.endpoint.merge(...args);
        if (decorations.mapToData) {
          options = Object.assign({}, options, {
            data: options[decorations.mapToData],
            [decorations.mapToData]: void 0
          });
          return requestWithDefaults(options);
        }
        if (decorations.renamed) {
          const [newScope, newMethodName] = decorations.renamed;
          octokit.log.warn(
            `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
          );
        }
        if (decorations.deprecated) {
          octokit.log.warn(decorations.deprecated);
        }
        if (decorations.renamedParameters) {
          const options2 = requestWithDefaults.endpoint.merge(...args);
          for (const [name, alias] of Object.entries(
            decorations.renamedParameters
          )) {
            if (name in options2) {
              octokit.log.warn(
                `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
              );
              if (!(alias in options2)) {
                options2[alias] = options2[name];
              }
              delete options2[name];
            }
          }
          return requestWithDefaults(options2);
        }
        return requestWithDefaults(...args);
      }
      return Object.assign(withDecorations, requestWithDefaults);
    }
    function restEndpointMethods2(octokit) {
      const api = endpointsToMethods2(octokit);
      return {
        rest: api
      };
    }
    restEndpointMethods2.VERSION = VERSION9;
    function legacyRestEndpointMethods2(octokit) {
      const api = endpointsToMethods2(octokit);
      return {
        ...api,
        rest: api
      };
    }
    legacyRestEndpointMethods2.VERSION = VERSION9;
  }
});

// 
var require_dist_node10 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      composePaginateRest: () => composePaginateRest2,
      isPaginatingEndpoint: () => isPaginatingEndpoint,
      paginateRest: () => paginateRest2,
      paginatingEndpoints: () => paginatingEndpoints
    });
    module2.exports = __toCommonJS(dist_src_exports);
    var VERSION9 = "9.2.2";
    function normalizePaginatedListResponse2(response) {
      if (!response.data) {
        return {
          ...response,
          data: []
        };
      }
      const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
      if (!responseNeedsNormalization)
        return response;
      const incompleteResults = response.data.incomplete_results;
      const repositorySelection = response.data.repository_selection;
      const totalCount = response.data.total_count;
      delete response.data.incomplete_results;
      delete response.data.repository_selection;
      delete response.data.total_count;
      const namespaceKey = Object.keys(response.data)[0];
      const data = response.data[namespaceKey];
      response.data = data;
      if (typeof incompleteResults !== "undefined") {
        response.data.incomplete_results = incompleteResults;
      }
      if (typeof repositorySelection !== "undefined") {
        response.data.repository_selection = repositorySelection;
      }
      response.data.total_count = totalCount;
      return response;
    }
    function iterator2(octokit, route, parameters) {
      const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
      const requestMethod = typeof route === "function" ? route : octokit.request;
      const method = options.method;
      const headers = options.headers;
      let url = options.url;
      return {
        [Symbol.asyncIterator]: () => ({
          async next() {
            if (!url)
              return { done: true };
            try {
              const response = await requestMethod({ method, url, headers });
              const normalizedResponse = normalizePaginatedListResponse2(response);
              url = ((normalizedResponse.headers.link || "").match(
                /<([^<>]+)>;\s*rel="next"/
              ) || [])[1];
              return { value: normalizedResponse };
            } catch (error) {
              if (error.status !== 409)
                throw error;
              url = "";
              return {
                value: {
                  status: 200,
                  headers: {},
                  data: []
                }
              };
            }
          }
        })
      };
    }
    function paginate2(octokit, route, parameters, mapFn) {
      if (typeof parameters === "function") {
        mapFn = parameters;
        parameters = void 0;
      }
      return gather2(
        octokit,
        [],
        iterator2(octokit, route, parameters)[Symbol.asyncIterator](),
        mapFn
      );
    }
    function gather2(octokit, results, iterator22, mapFn) {
      return iterator22.next().then((result) => {
        if (result.done) {
          return results;
        }
        let earlyExit = false;
        function done() {
          earlyExit = true;
        }
        results = results.concat(
          mapFn ? mapFn(result.value, done) : result.value.data
        );
        if (earlyExit) {
          return results;
        }
        return gather2(octokit, results, iterator22, mapFn);
      });
    }
    var composePaginateRest2 = Object.assign(paginate2, {
      iterator: iterator2
    });
    var paginatingEndpoints = [
      "GET /advisories",
      "GET /app/hook/deliveries",
      "GET /app/installation-requests",
      "GET /app/installations",
      "GET /assignments/{assignment_id}/accepted_assignments",
      "GET /classrooms",
      "GET /classrooms/{classroom_id}/assignments",
      "GET /enterprises/{enterprise}/dependabot/alerts",
      "GET /enterprises/{enterprise}/secret-scanning/alerts",
      "GET /events",
      "GET /gists",
      "GET /gists/public",
      "GET /gists/starred",
      "GET /gists/{gist_id}/comments",
      "GET /gists/{gist_id}/commits",
      "GET /gists/{gist_id}/forks",
      "GET /installation/repositories",
      "GET /issues",
      "GET /licenses",
      "GET /marketplace_listing/plans",
      "GET /marketplace_listing/plans/{plan_id}/accounts",
      "GET /marketplace_listing/stubbed/plans",
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
      "GET /networks/{owner}/{repo}/events",
      "GET /notifications",
      "GET /organizations",
      "GET /orgs/{org}/actions/cache/usage-by-repository",
      "GET /orgs/{org}/actions/permissions/repositories",
      "GET /orgs/{org}/actions/runners",
      "GET /orgs/{org}/actions/secrets",
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/actions/variables",
      "GET /orgs/{org}/actions/variables/{name}/repositories",
      "GET /orgs/{org}/blocks",
      "GET /orgs/{org}/code-scanning/alerts",
      "GET /orgs/{org}/codespaces",
      "GET /orgs/{org}/codespaces/secrets",
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/copilot/billing/seats",
      "GET /orgs/{org}/dependabot/alerts",
      "GET /orgs/{org}/dependabot/secrets",
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/events",
      "GET /orgs/{org}/failed_invitations",
      "GET /orgs/{org}/hooks",
      "GET /orgs/{org}/hooks/{hook_id}/deliveries",
      "GET /orgs/{org}/installations",
      "GET /orgs/{org}/invitations",
      "GET /orgs/{org}/invitations/{invitation_id}/teams",
      "GET /orgs/{org}/issues",
      "GET /orgs/{org}/members",
      "GET /orgs/{org}/members/{username}/codespaces",
      "GET /orgs/{org}/migrations",
      "GET /orgs/{org}/migrations/{migration_id}/repositories",
      "GET /orgs/{org}/organization-roles/{role_id}/teams",
      "GET /orgs/{org}/organization-roles/{role_id}/users",
      "GET /orgs/{org}/outside_collaborators",
      "GET /orgs/{org}/packages",
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      "GET /orgs/{org}/personal-access-token-requests",
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
      "GET /orgs/{org}/personal-access-tokens",
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
      "GET /orgs/{org}/projects",
      "GET /orgs/{org}/properties/values",
      "GET /orgs/{org}/public_members",
      "GET /orgs/{org}/repos",
      "GET /orgs/{org}/rulesets",
      "GET /orgs/{org}/rulesets/rule-suites",
      "GET /orgs/{org}/secret-scanning/alerts",
      "GET /orgs/{org}/security-advisories",
      "GET /orgs/{org}/teams",
      "GET /orgs/{org}/teams/{team_slug}/discussions",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
      "GET /orgs/{org}/teams/{team_slug}/invitations",
      "GET /orgs/{org}/teams/{team_slug}/members",
      "GET /orgs/{org}/teams/{team_slug}/projects",
      "GET /orgs/{org}/teams/{team_slug}/repos",
      "GET /orgs/{org}/teams/{team_slug}/teams",
      "GET /projects/columns/{column_id}/cards",
      "GET /projects/{project_id}/collaborators",
      "GET /projects/{project_id}/columns",
      "GET /repos/{owner}/{repo}/actions/artifacts",
      "GET /repos/{owner}/{repo}/actions/caches",
      "GET /repos/{owner}/{repo}/actions/organization-secrets",
      "GET /repos/{owner}/{repo}/actions/organization-variables",
      "GET /repos/{owner}/{repo}/actions/runners",
      "GET /repos/{owner}/{repo}/actions/runs",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
      "GET /repos/{owner}/{repo}/actions/secrets",
      "GET /repos/{owner}/{repo}/actions/variables",
      "GET /repos/{owner}/{repo}/actions/workflows",
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
      "GET /repos/{owner}/{repo}/activity",
      "GET /repos/{owner}/{repo}/assignees",
      "GET /repos/{owner}/{repo}/branches",
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
      "GET /repos/{owner}/{repo}/code-scanning/alerts",
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      "GET /repos/{owner}/{repo}/code-scanning/analyses",
      "GET /repos/{owner}/{repo}/codespaces",
      "GET /repos/{owner}/{repo}/codespaces/devcontainers",
      "GET /repos/{owner}/{repo}/codespaces/secrets",
      "GET /repos/{owner}/{repo}/collaborators",
      "GET /repos/{owner}/{repo}/comments",
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/commits",
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
      "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
      "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
      "GET /repos/{owner}/{repo}/commits/{ref}/status",
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
      "GET /repos/{owner}/{repo}/contributors",
      "GET /repos/{owner}/{repo}/dependabot/alerts",
      "GET /repos/{owner}/{repo}/dependabot/secrets",
      "GET /repos/{owner}/{repo}/deployments",
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
      "GET /repos/{owner}/{repo}/environments",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
      "GET /repos/{owner}/{repo}/events",
      "GET /repos/{owner}/{repo}/forks",
      "GET /repos/{owner}/{repo}/hooks",
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
      "GET /repos/{owner}/{repo}/invitations",
      "GET /repos/{owner}/{repo}/issues",
      "GET /repos/{owner}/{repo}/issues/comments",
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/issues/events",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
      "GET /repos/{owner}/{repo}/keys",
      "GET /repos/{owner}/{repo}/labels",
      "GET /repos/{owner}/{repo}/milestones",
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
      "GET /repos/{owner}/{repo}/notifications",
      "GET /repos/{owner}/{repo}/pages/builds",
      "GET /repos/{owner}/{repo}/projects",
      "GET /repos/{owner}/{repo}/pulls",
      "GET /repos/{owner}/{repo}/pulls/comments",
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
      "GET /repos/{owner}/{repo}/releases",
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
      "GET /repos/{owner}/{repo}/rules/branches/{branch}",
      "GET /repos/{owner}/{repo}/rulesets",
      "GET /repos/{owner}/{repo}/rulesets/rule-suites",
      "GET /repos/{owner}/{repo}/secret-scanning/alerts",
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
      "GET /repos/{owner}/{repo}/security-advisories",
      "GET /repos/{owner}/{repo}/stargazers",
      "GET /repos/{owner}/{repo}/subscribers",
      "GET /repos/{owner}/{repo}/tags",
      "GET /repos/{owner}/{repo}/teams",
      "GET /repos/{owner}/{repo}/topics",
      "GET /repositories",
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
      "GET /repositories/{repository_id}/environments/{environment_name}/variables",
      "GET /search/code",
      "GET /search/commits",
      "GET /search/issues",
      "GET /search/labels",
      "GET /search/repositories",
      "GET /search/topics",
      "GET /search/users",
      "GET /teams/{team_id}/discussions",
      "GET /teams/{team_id}/discussions/{discussion_number}/comments",
      "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
      "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
      "GET /teams/{team_id}/invitations",
      "GET /teams/{team_id}/members",
      "GET /teams/{team_id}/projects",
      "GET /teams/{team_id}/repos",
      "GET /teams/{team_id}/teams",
      "GET /user/blocks",
      "GET /user/codespaces",
      "GET /user/codespaces/secrets",
      "GET /user/emails",
      "GET /user/followers",
      "GET /user/following",
      "GET /user/gpg_keys",
      "GET /user/installations",
      "GET /user/installations/{installation_id}/repositories",
      "GET /user/issues",
      "GET /user/keys",
      "GET /user/marketplace_purchases",
      "GET /user/marketplace_purchases/stubbed",
      "GET /user/memberships/orgs",
      "GET /user/migrations",
      "GET /user/migrations/{migration_id}/repositories",
      "GET /user/orgs",
      "GET /user/packages",
      "GET /user/packages/{package_type}/{package_name}/versions",
      "GET /user/public_emails",
      "GET /user/repos",
      "GET /user/repository_invitations",
      "GET /user/social_accounts",
      "GET /user/ssh_signing_keys",
      "GET /user/starred",
      "GET /user/subscriptions",
      "GET /user/teams",
      "GET /users",
      "GET /users/{username}/events",
      "GET /users/{username}/events/orgs/{org}",
      "GET /users/{username}/events/public",
      "GET /users/{username}/followers",
      "GET /users/{username}/following",
      "GET /users/{username}/gists",
      "GET /users/{username}/gpg_keys",
      "GET /users/{username}/keys",
      "GET /users/{username}/orgs",
      "GET /users/{username}/packages",
      "GET /users/{username}/projects",
      "GET /users/{username}/received_events",
      "GET /users/{username}/received_events/public",
      "GET /users/{username}/repos",
      "GET /users/{username}/social_accounts",
      "GET /users/{username}/ssh_signing_keys",
      "GET /users/{username}/starred",
      "GET /users/{username}/subscriptions"
    ];
    function isPaginatingEndpoint(arg) {
      if (typeof arg === "string") {
        return paginatingEndpoints.includes(arg);
      } else {
        return false;
      }
    }
    function paginateRest2(octokit) {
      return {
        paginate: Object.assign(paginate2.bind(null, octokit), {
          iterator: iterator2.bind(null, octokit)
        })
      };
    }
    paginateRest2.VERSION = VERSION9;
  }
});

// 
var require_utils3 = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
    var Context = __importStar(require_context());
    var Utils = __importStar(require_utils2());
    var core_1 = require_dist_node8();
    var plugin_rest_endpoint_methods_1 = require_dist_node9();
    var plugin_paginate_rest_1 = require_dist_node10();
    exports.context = new Context.Context();
    var baseUrl = Utils.getApiBaseUrl();
    exports.defaults = {
      baseUrl,
      request: {
        agent: Utils.getProxyAgent(baseUrl),
        fetch: Utils.getProxyFetch(baseUrl)
      }
    };
    exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
    function getOctokitOptions(token, options) {
      const opts = Object.assign({}, options || {});
      const auth2 = Utils.getAuthString(token, opts);
      if (auth2) {
        opts.auth = auth2;
      }
      return opts;
    }
    exports.getOctokitOptions = getOctokitOptions;
  }
});

// 
var require_github = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOctokit = exports.context = void 0;
    var Context = __importStar(require_context());
    var utils_1 = require_utils3();
    exports.context = new Context.Context();
    function getOctokit(token, options, ...additionalPlugins) {
      const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
      return new GitHubWithPlugins((0, utils_1.getOctokitOptions)(token, options));
    }
    exports.getOctokit = getOctokit;
  }
});

// 
var require_tmp = __commonJS({
  ""(exports, module2) {
    var fs = __require("fs");
    var os3 = __require("os");
    var path = __require("path");
    var crypto = __require("crypto");
    var _c = { fs: fs.constants, os: os3.constants };
    var RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    var TEMPLATE_PATTERN = /XXXXXX/;
    var DEFAULT_TRIES = 3;
    var CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR);
    var IS_WIN32 = os3.platform() === "win32";
    var EBADF = _c.EBADF || _c.os.errno.EBADF;
    var ENOENT = _c.ENOENT || _c.os.errno.ENOENT;
    var DIR_MODE = 448;
    var FILE_MODE = 384;
    var EXIT = "exit";
    var _removeObjects = [];
    var FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);
    var _gracefulCleanup = false;
    function rimraf(dirPath, callback) {
      return fs.rm(dirPath, { recursive: true }, callback);
    }
    function FN_RIMRAF_SYNC(dirPath) {
      return fs.rmSync(dirPath, { recursive: true });
    }
    function tmpName(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      _assertAndSanitizeOptions(opts, function(err, sanitizedOptions) {
        if (err)
          return cb(err);
        let tries = sanitizedOptions.tries;
        (function _getUniqueName() {
          try {
            const name = _generateTmpName(sanitizedOptions);
            fs.stat(name, function(err2) {
              if (!err2) {
                if (tries-- > 0)
                  return _getUniqueName();
                return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
              }
              cb(null, name);
            });
          } catch (err2) {
            cb(err2);
          }
        })();
      });
    }
    function tmpNameSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const sanitizedOptions = _assertAndSanitizeOptionsSync(opts);
      let tries = sanitizedOptions.tries;
      do {
        const name = _generateTmpName(sanitizedOptions);
        try {
          fs.statSync(name);
        } catch (e5) {
          return name;
        }
      } while (tries-- > 0);
      throw new Error("Could not get a unique tmp filename, max tries reached");
    }
    function file(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err2, fd) {
          if (err2)
            return cb(err2);
          if (opts.discardDescriptor) {
            return fs.close(fd, function _discardCallback(possibleErr) {
              return cb(possibleErr, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts, false));
            });
          } else {
            const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
            cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
          }
        });
      });
    }
    function fileSync2(options) {
      const args = _parseArguments(options), opts = args[0];
      const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
      const name = tmpNameSync(opts);
      let fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
      if (opts.discardDescriptor) {
        fs.closeSync(fd);
        fd = void 0;
      }
      return {
        name,
        fd,
        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
      };
    }
    function dir(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err2) {
          if (err2)
            return cb(err2);
          cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
        });
      });
    }
    function dirSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const name = tmpNameSync(opts);
      fs.mkdirSync(name, opts.mode || DIR_MODE);
      return {
        name,
        removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
      };
    }
    function _removeFileAsync(fdPath, next) {
      const _handler = function(err) {
        if (err && !_isENOENT(err)) {
          return next(err);
        }
        next();
      };
      if (0 <= fdPath[0])
        fs.close(fdPath[0], function() {
          fs.unlink(fdPath[1], _handler);
        });
      else
        fs.unlink(fdPath[1], _handler);
    }
    function _removeFileSync(fdPath) {
      let rethrownException = null;
      try {
        if (0 <= fdPath[0])
          fs.closeSync(fdPath[0]);
      } catch (e5) {
        if (!_isEBADF(e5) && !_isENOENT(e5))
          throw e5;
      } finally {
        try {
          fs.unlinkSync(fdPath[1]);
        } catch (e5) {
          if (!_isENOENT(e5))
            rethrownException = e5;
        }
      }
      if (rethrownException !== null) {
        throw rethrownException;
      }
    }
    function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
      const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
      const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return sync ? removeCallbackSync : removeCallback;
    }
    function _prepareTmpDirRemoveCallback(name, opts, sync) {
      const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
      const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
      const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
      const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return sync ? removeCallbackSync : removeCallback;
    }
    function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
      let called = false;
      return function _cleanupCallback(next) {
        if (!called) {
          const toRemove = cleanupCallbackSync || _cleanupCallback;
          const index = _removeObjects.indexOf(toRemove);
          if (index >= 0)
            _removeObjects.splice(index, 1);
          called = true;
          if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
            return removeFunction(fileOrDirName);
          } else {
            return removeFunction(fileOrDirName, next || function() {
            });
          }
        }
      };
    }
    function _garbageCollector() {
      if (!_gracefulCleanup)
        return;
      while (_removeObjects.length) {
        try {
          _removeObjects[0]();
        } catch (e5) {
        }
      }
    }
    function _randomChars(howMany) {
      let value = [], rnd = null;
      try {
        rnd = crypto.randomBytes(howMany);
      } catch (e5) {
        rnd = crypto.pseudoRandomBytes(howMany);
      }
      for (let i6 = 0; i6 < howMany; i6++) {
        value.push(RANDOM_CHARS[rnd[i6] % RANDOM_CHARS.length]);
      }
      return value.join("");
    }
    function _isUndefined(obj) {
      return typeof obj === "undefined";
    }
    function _parseArguments(options, callback) {
      if (typeof options === "function") {
        return [{}, options];
      }
      if (_isUndefined(options)) {
        return [{}, callback];
      }
      const actualOptions = {};
      for (const key of Object.getOwnPropertyNames(options)) {
        actualOptions[key] = options[key];
      }
      return [actualOptions, callback];
    }
    function _resolvePath(name, tmpDir, cb) {
      const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);
      fs.stat(pathToResolve, function(err) {
        if (err) {
          fs.realpath(path.dirname(pathToResolve), function(err2, parentDir) {
            if (err2)
              return cb(err2);
            cb(null, path.join(parentDir, path.basename(pathToResolve)));
          });
        } else {
          fs.realpath(pathToResolve, cb);
        }
      });
    }
    function _resolvePathSync(name, tmpDir) {
      const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);
      try {
        fs.statSync(pathToResolve);
        return fs.realpathSync(pathToResolve);
      } catch (_err) {
        const parentDir = fs.realpathSync(path.dirname(pathToResolve));
        return path.join(parentDir, path.basename(pathToResolve));
      }
    }
    function _generateTmpName(opts) {
      const tmpDir = opts.tmpdir;
      if (!_isUndefined(opts.name)) {
        return path.join(tmpDir, opts.dir, opts.name);
      }
      if (!_isUndefined(opts.template)) {
        return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
      }
      const name = [
        opts.prefix ? opts.prefix : "tmp",
        "-",
        process.pid,
        "-",
        _randomChars(12),
        opts.postfix ? "-" + opts.postfix : ""
      ].join("");
      return path.join(tmpDir, opts.dir, name);
    }
    function _assertOptionsBase(options) {
      if (!_isUndefined(options.name)) {
        const name = options.name;
        if (path.isAbsolute(name))
          throw new Error(`name option must not contain an absolute path, found "${name}".`);
        const basename = path.basename(name);
        if (basename === ".." || basename === "." || basename !== name)
          throw new Error(`name option must not contain a path, found "${name}".`);
      }
      if (!_isUndefined(options.template) && !options.template.match(TEMPLATE_PATTERN)) {
        throw new Error(`Invalid template, found "${options.template}".`);
      }
      if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0) {
        throw new Error(`Invalid tries, found "${options.tries}".`);
      }
      options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
      options.keep = !!options.keep;
      options.detachDescriptor = !!options.detachDescriptor;
      options.discardDescriptor = !!options.discardDescriptor;
      options.unsafeCleanup = !!options.unsafeCleanup;
      options.prefix = _isUndefined(options.prefix) ? "" : options.prefix;
      options.postfix = _isUndefined(options.postfix) ? "" : options.postfix;
    }
    function _getRelativePath(option, name, tmpDir, cb) {
      if (_isUndefined(name))
        return cb(null);
      _resolvePath(name, tmpDir, function(err, resolvedPath) {
        if (err)
          return cb(err);
        const relativePath = path.relative(tmpDir, resolvedPath);
        if (!resolvedPath.startsWith(tmpDir)) {
          return cb(new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`));
        }
        cb(null, relativePath);
      });
    }
    function _getRelativePathSync(option, name, tmpDir) {
      if (_isUndefined(name))
        return;
      const resolvedPath = _resolvePathSync(name, tmpDir);
      const relativePath = path.relative(tmpDir, resolvedPath);
      if (!resolvedPath.startsWith(tmpDir)) {
        throw new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`);
      }
      return relativePath;
    }
    function _assertAndSanitizeOptions(options, cb) {
      _getTmpDir(options, function(err, tmpDir) {
        if (err)
          return cb(err);
        options.tmpdir = tmpDir;
        try {
          _assertOptionsBase(options, tmpDir);
        } catch (err2) {
          return cb(err2);
        }
        _getRelativePath("dir", options.dir, tmpDir, function(err2, dir2) {
          if (err2)
            return cb(err2);
          options.dir = _isUndefined(dir2) ? "" : dir2;
          _getRelativePath("template", options.template, tmpDir, function(err3, template) {
            if (err3)
              return cb(err3);
            options.template = template;
            cb(null, options);
          });
        });
      });
    }
    function _assertAndSanitizeOptionsSync(options) {
      const tmpDir = options.tmpdir = _getTmpDirSync(options);
      _assertOptionsBase(options, tmpDir);
      const dir2 = _getRelativePathSync("dir", options.dir, tmpDir);
      options.dir = _isUndefined(dir2) ? "" : dir2;
      options.template = _getRelativePathSync("template", options.template, tmpDir);
      return options;
    }
    function _isEBADF(error) {
      return _isExpectedError(error, -EBADF, "EBADF");
    }
    function _isENOENT(error) {
      return _isExpectedError(error, -ENOENT, "ENOENT");
    }
    function _isExpectedError(error, errno, code) {
      return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
    }
    function setGracefulCleanup() {
      _gracefulCleanup = true;
    }
    function _getTmpDir(options, cb) {
      return fs.realpath(options && options.tmpdir || os3.tmpdir(), cb);
    }
    function _getTmpDirSync(options) {
      return fs.realpathSync(options && options.tmpdir || os3.tmpdir());
    }
    process.addListener(EXIT, _garbageCollector);
    Object.defineProperty(module2.exports, "tmpdir", {
      enumerable: true,
      configurable: false,
      get: function() {
        return _getTmpDirSync();
      }
    });
    module2.exports.dir = dir;
    module2.exports.dirSync = dirSync;
    module2.exports.file = file;
    module2.exports.fileSync = fileSync2;
    module2.exports.tmpName = tmpName;
    module2.exports.tmpNameSync = tmpNameSync;
    module2.exports.setGracefulCleanup = setGracefulCleanup;
  }
});

// 
var require_array = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitWhen = exports.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports.splitWhen = splitWhen;
  }
});

// 
var require_errno = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports.isEnoentCodeError = isEnoentCodeError;
  }
});

// 
var require_fs = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// 
var require_path = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;
    var os3 = __require("os");
    var path = __require("path");
    var IS_WINDOWS_PLATFORM = os3.platform() === "win32";
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g;
    var DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    var WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path.resolve(cwd, filepath);
    }
    exports.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports.removeLeadingDotSegment = removeLeadingDotSegment;
    exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escapePosixPath = escapePosixPath;
    exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports.convertPosixPathToPattern = convertPosixPathToPattern;
  }
});

// 
var require_is_extglob = __commonJS({
  ""(exports, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// 
var require_is_glob = __commonJS({
  ""(exports, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n3 = str.indexOf(close, index);
            if (n3 !== -1) {
              index = n3 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n3 = str.indexOf(close, index);
            if (n3 !== -1) {
              index = n3 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// 
var require_glob_parent = __commonJS({
  ""(exports, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = __require("path").posix.dirname;
    var isWin32 = __require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// 
var require_utils4 = __commonJS({
  ""(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n3 = 0, type) => {
      const node = block.nodes[n3];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i6 = 0; i6 < arr.length; i6++) {
          const ele = arr[i6];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result.push(ele);
          }
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// 
var require_stringify = __commonJS({
  ""(exports, module2) {
    "use strict";
    var utils = require_utils4();
    module2.exports = (ast, options = {}) => {
      const stringify = (node, parent = {}) => {
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// 
var require_is_number = __commonJS({
  ""(exports, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// 
var require_to_regex_range = __commonJS({
  ""(exports, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a7 = Math.min(min, max);
      let b3 = Math.max(min, max);
      if (Math.abs(a7 - b3) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a: a7, b: b3 };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a7 < 0) {
        let newMin = b3 < 0 ? Math.abs(b3) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a7), state, opts);
        a7 = state.a = 0;
      }
      if (b3 >= 0) {
        positives = splitToPatterns(a7, b3, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i6 = 0; i6 < digits; i6++) {
        let [startDigit, stopDigit] = zipped[i6];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i6 = 0; i6 < ranges.length; i6++) {
        let max2 = ranges[i6];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a7, b3) {
      let arr = [];
      for (let i6 = 0; i6 < a7.length; i6++)
        arr.push([a7[i6], b3[i6]]);
      return arr;
    }
    function compare(a7, b3) {
      return a7 > b3 ? 1 : b3 > a7 ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a7, b3, options) {
      return `[${a7}${b3 - a7 === 1 ? "" : "-"}${b3}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// 
var require_fill_range = __commonJS({
  ""(exports, module2) {
    "use strict";
    var util = __require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options, maxLen) => {
      parts.negatives.sort((a7, b3) => a7 < b3 ? -1 : a7 > b3 ? 1 : 0);
      parts.positives.sort((a7, b3) => a7 < b3 ? -1 : a7 > b3 ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v4) => toMaxLen(String(v4), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v4) => toMaxLen(String(v4), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a7, b3, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a7, b3, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a7);
      if (a7 === b3)
        return start;
      let stop = String.fromCharCode(b3);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a7 = Number(start);
      let b3 = Number(end);
      if (!Number.isInteger(a7) || !Number.isInteger(b3)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a7 === 0)
        a7 = 0;
      if (b3 === 0)
        b3 = 0;
      let descending = a7 > b3;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a7 >= b3 : a7 <= b3) {
        if (options.toRegex === true && step > 1) {
          push(a7);
        } else {
          range.push(pad(format(a7, index), maxLen, toNumber));
        }
        a7 = descending ? a7 - step : a7 + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a7 = `${start}`.charCodeAt(0);
      let b3 = `${end}`.charCodeAt(0);
      let descending = a7 > b3;
      let min = Math.min(a7, b3);
      let max = Math.max(a7, b3);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a7 >= b3 : a7 <= b3) {
        range.push(format(a7, index));
        a7 = descending ? a7 - step : a7 + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// 
var require_compile = __commonJS({
  ""(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils4();
    var compile = (ast, options = {}) => {
      const walk = (node, parent = {}) => {
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          console.log("node.isClose", prefix, node.value);
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// 
var require_expand = __commonJS({
  ""(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils4();
    var append = (queue = "", stash = "", enclose = false) => {
      const result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue) {
        if (Array.isArray(item)) {
          for (const value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand2 = (ast, options = {}) => {
      const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      const walk = (node, parent = {}) => {
        node.queue = [];
        let p5 = parent;
        let q2 = parent.queue;
        while (p5.type !== "brace" && p5.type !== "root" && p5.parent) {
          p5 = p5.parent;
          q2 = p5.queue;
        }
        if (node.invalid || node.dollar) {
          q2.push(append(q2.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q2.push(append(q2.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q2.push(append(q2.pop(), range));
          node.nodes = [];
          return;
        }
        const enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i6 = 0; i6 < node.nodes.length; i6++) {
          const child = node.nodes[i6];
          if (child.type === "comma" && node.type === "brace") {
            if (i6 === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q2.push(append(q2.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand2;
  }
});

// 
var require_constants = __commonJS({
  ""(exports, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// 
var require_parse = __commonJS({
  ""(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse2 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options || {};
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      const length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          const open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse2;
  }
});

// 
var require_braces = __commonJS({
  ""(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand2 = require_expand();
    var parse2 = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern of input) {
          const result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse2(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand2(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// 
var require_constants2 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var path = __require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// 
var require_utils5 = __commonJS({
  ""(exports) {
    "use strict";
    var path = __require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// 
var require_scan = __commonJS({
  ""(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob2 = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob2 = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob2 = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob2)
          glob2 = utils.removeBackslashes(glob2);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n3 = prevIndex ? prevIndex + 1 : start;
          const i6 = slashes[idx];
          const value = input.slice(n3, i6);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i6;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// 
var require_parse2 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils5();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v4) => utils.escapeRegex(v4)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse2 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n3 = 1) => input[state.index + n3];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse2(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m8, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m8;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m8 : `\\${m8}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m8) => {
              return m8.length % 2 === 0 ? "\\\\" : m8 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i6 = arr.length - 1; i6 >= 0; i6--) {
              tokens.pop();
              if (arr[i6].type === "brace") {
                break;
              }
              if (arr[i6].type !== "dots") {
                range.unshift(arr[i6].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t3 of toks) {
              state.output += t3.output || t3.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse2.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse2;
  }
});

// 
var require_picomatch = __commonJS({
  ""(exports, module2) {
    "use strict";
    var path = __require("path");
    var scan = require_scan();
    var parse2 = require_parse2();
    var utils = require_utils5();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob2, options, returnState = false) => {
      if (Array.isArray(glob2)) {
        const fns = glob2.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob: glob2, posix });
        const result = { glob: glob2, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob: glob2, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob2;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob2;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob2, options, posix = utils.isWindows(options)) => {
      const regex = glob2 instanceof RegExp ? glob2 : picomatch.makeRe(glob2, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p5) => picomatch.parse(p5, options));
      return parse2(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse2.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse2(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// 
var require_picomatch2 = __commonJS({
  ""(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// 
var require_micromatch = __commonJS({
  ""(exports, module2) {
    "use strict";
    var util = __require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils5();
    var isEmptyString = (v4) => v4 === "" || v4 === "./";
    var hasBraces = (v4) => {
      const index = v4.indexOf("{");
      return index > -1 && v4.indexOf("}", index) > -1;
    };
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit2 = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i6 = 0; i6 < patterns.length; i6++) {
        let isMatch = picomatch(String(patterns[i6]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit2.add(matched.output);
          } else {
            omit2.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit2.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p5) => p5.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p5) => micromatch.contains(str, p5, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p5) => picomatch(p5, options)(str));
    };
    micromatch.capture = (glob2, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob2), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v4) => v4 === void 0 ? "" : v4);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !hasBraces(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    micromatch.hasBraces = hasBraces;
    module2.exports = micromatch;
  }
});

// 
var require_pattern = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAbsolute = exports.partitionAbsoluteAndRelative = exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
    var path = __require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      const patterns = micromatch.braces(pattern, { expand: true, nodupes: true, keepEscaping: true });
      patterns.sort((a7, b3) => a7.length - b3.length);
      return patterns.filter((pattern2) => pattern2 !== "");
    }
    exports.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports.removeDuplicateSlashes = removeDuplicateSlashes;
    function partitionAbsoluteAndRelative(patterns) {
      const absolute = [];
      const relative = [];
      for (const pattern of patterns) {
        if (isAbsolute(pattern)) {
          absolute.push(pattern);
        } else {
          relative.push(pattern);
        }
      }
      return [absolute, relative];
    }
    exports.partitionAbsoluteAndRelative = partitionAbsoluteAndRelative;
    function isAbsolute(pattern) {
      return path.isAbsolute(pattern);
    }
    exports.isAbsolute = isAbsolute;
  }
});

// 
var require_merge2 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var Stream = __require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i6 = 0, len = arguments.length; i6 < len; i6++) {
          streamsQueue.push(pauseStreams(arguments[i6], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i6 = 0; i6 < streams.length; i6++) {
          pipe(streams[i6]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i6 = 0, len = streams.length; i6 < len; i6++) {
          streams[i6] = pauseStreams(streams[i6], options);
        }
      }
      return streams;
    }
  }
});

// 
var require_stream = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var merge2 = require_merge2();
    function merge3(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports.merge = merge3;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// 
var require_string = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = exports.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports.isEmpty = isEmpty;
  }
});

// 
var require_utils6 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
    var array = require_array();
    exports.array = array;
    var errno = require_errno();
    exports.errno = errno;
    var fs = require_fs();
    exports.fs = fs;
    var path = require_path();
    exports.path = path;
    var pattern = require_pattern();
    exports.pattern = pattern;
    var stream = require_stream();
    exports.stream = stream;
    var string = require_string();
    exports.string = string;
  }
});

// 
var require_tasks = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
    var utils = require_utils6();
    function generate(input, settings) {
      const patterns = processPatterns(input, settings);
      const ignore = processPatterns(settings.ignore, settings);
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports.generate = generate;
    function processPatterns(input, settings) {
      let patterns = input;
      if (settings.braceExpansion) {
        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
      }
      if (settings.baseNameMatch) {
        patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`);
      }
      return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// 
var require_async = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read(path, settings, callback) {
      settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// 
var require_sync = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read(path, settings) {
      const lstat = settings.fs.lstatSync(path);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports.read = read;
  }
});

// 
var require_fs2 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// 
var require_settings = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// 
var require_out = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.statSync = exports.stat = exports.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports.Settings = settings_1.default;
    function stat(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.stat = stat;
    function statSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// 
var require_queue_microtask = __commonJS({
  ""(exports, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// 
var require_run_parallel = __commonJS({
  ""(exports, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i6, err, result) {
        results[i6] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i6) {
          task(function(err, result) {
            each(i6, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// 
var require_constants3 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// 
var require_fs3 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// 
var require_utils7 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fs = void 0;
    var fs = require_fs3();
    exports.fs = fs;
  }
});

// 
var require_common = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = void 0;
    function joinPathSegments(a7, b3, separator) {
      if (a7.endsWith(separator)) {
        return a7 + b3;
      }
      return a7 + separator + b3;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// 
var require_async2 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants3();
    var utils = require_utils7();
    var common = require_common();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// 
var require_sync2 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants3();
    var utils = require_utils7();
    var common = require_common();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports.readdir = readdir;
  }
});

// 
var require_fs4 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// 
var require_settings2 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = __require("path");
    var fsStat = require_out();
    var fs = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// 
var require_out2 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.scandirSync = exports.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports.Settings = settings_1.default;
    function scandir(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.scandir = scandir;
    function scandirSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// 
var require_reusify = __commonJS({
  ""(exports, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// 
var require_queue = __commonJS({
  ""(exports, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context2, worker, _concurrency) {
      if (typeof context2 === "function") {
        _concurrency = worker;
        worker = context2;
        context2 = null;
      }
      if (!(_concurrency >= 1)) {
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop2,
        saturated: noop2,
        pause,
        paused: false,
        get concurrency() {
          return _concurrency;
        },
        set concurrency(value) {
          if (!(value >= 1)) {
            throw new Error("fastqueue concurrency must be equal to or greater than 1");
          }
          _concurrency = value;
          if (self2.paused)
            return;
          for (; queueHead && _running < _concurrency; ) {
            _running++;
            release();
          }
        },
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop2,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        if (queueHead === null) {
          _running++;
          release();
          return;
        }
        for (; queueHead && _running < _concurrency; ) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context2;
        current.release = release;
        current.value = value;
        current.callback = done || noop2;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context2, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context2;
        current.release = release;
        current.value = value;
        current.callback = done || noop2;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context2, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next && _running <= _concurrency) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context2, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop2;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop2;
      }
      function error(handler2) {
        errorHandler = handler2;
      }
    }
    function noop2() {
    }
    function Task() {
      this.value = null;
      this.callback = noop2;
      this.next = null;
      this.release = noop2;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop2;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context2, worker, _concurrency) {
      if (typeof context2 === "function") {
        _concurrency = worker;
        worker = context2;
        context2 = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context2, asyncWrapper, _concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p5 = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p5.catch(noop2);
        return p5;
      }
      function unshift(value) {
        var p5 = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p5.catch(noop2);
        return p5;
      }
      function drained() {
        var p5 = new Promise(function(resolve) {
          process.nextTick(function() {
            if (queue.idle()) {
              resolve();
            } else {
              var previousDrain = queue.drain;
              queue.drain = function() {
                if (typeof previousDrain === "function")
                  previousDrain();
                resolve();
                queue.drain = previousDrain;
              };
            }
          });
        });
        return p5;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// 
var require_common2 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a7, b3, separator) {
      if (a7 === "") {
        return b3;
      }
      if (a7.endsWith(separator)) {
        return a7 + b3;
      }
      return a7 + separator + b3;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// 
var require_reader = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports.default = Reader;
  }
});

// 
var require_async3 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports.default = AsyncReader;
  }
});

// 
var require_async4 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// 
var require_stream2 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports.default = StreamProvider;
  }
});

// 
var require_sync3 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports.default = SyncReader;
  }
});

// 
var require_sync4 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports.default = SyncProvider;
  }
});

// 
var require_settings3 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = __require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// 
var require_out3 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// 
var require_reader2 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = __require("path");
    var fsStat = require_out();
    var utils = require_utils6();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports.default = Reader;
  }
});

// 
var require_stream3 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i6 = 0; i6 < filepaths.length; i6++) {
          stream.write(i6);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports.default = ReaderStream;
  }
});

// 
var require_async5 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options) {
        return new Promise((resolve, reject) => {
          this._walkAsync(root, options, (error, entries) => {
            if (error === null) {
              resolve(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        return new Promise((resolve, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve(entries));
        });
      }
    };
    exports.default = ReaderAsync;
  }
});

// 
var require_matcher = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils6();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        for (const pattern of this._patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports.default = Matcher;
  }
});

// 
var require_partial = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports.default = PartialMatcher;
  }
});

// 
var require_deep = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils6();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports.default = DeepFilter;
  }
});

// 
var require_entry = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils6();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const [absoluteNegative, relativeNegative] = utils.pattern.partitionAbsoluteAndRelative(negative);
        const patterns = {
          positive: {
            all: utils.pattern.convertPatternsToRe(positive, this._micromatchOptions)
          },
          negative: {
            absolute: utils.pattern.convertPatternsToRe(absoluteNegative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true })),
            relative: utils.pattern.convertPatternsToRe(relativeNegative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }))
          }
        };
        return (entry) => this._filter(entry, patterns);
      }
      _filter(entry, patterns) {
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        const isMatched = this._isMatchToPatternsSet(filepath, patterns, entry.dirent.isDirectory());
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(filepath);
        }
        return isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isMatchToPatternsSet(filepath, patterns, isDirectory) {
        const isMatched = this._isMatchToPatterns(filepath, patterns.positive.all, isDirectory);
        if (!isMatched) {
          return false;
        }
        const isMatchedByRelativeNegative = this._isMatchToPatterns(filepath, patterns.negative.relative, isDirectory);
        if (isMatchedByRelativeNegative) {
          return false;
        }
        const isMatchedByAbsoluteNegative = this._isMatchToAbsoluteNegative(filepath, patterns.negative.absolute, isDirectory);
        if (isMatchedByAbsoluteNegative) {
          return false;
        }
        return true;
      }
      _isMatchToAbsoluteNegative(filepath, patternsRe, isDirectory) {
        if (patternsRe.length === 0) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, filepath);
        return this._isMatchToPatterns(fullpath, patternsRe, isDirectory);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory) {
        if (patternsRe.length === 0) {
          return false;
        }
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports.default = EntryFilter;
  }
});

// 
var require_error = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils6();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports.default = ErrorFilter;
  }
});

// 
var require_entry2 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils6();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports.default = EntryTransformer;
  }
});

// 
var require_provider = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = __require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports.default = Provider;
  }
});

// 
var require_async6 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async5();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderAsync;
  }
});

// 
var require_stream4 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderStream;
  }
});

// 
var require_sync5 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports.default = ReaderSync;
  }
});

// 
var require_sync6 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderSync;
  }
});

// 
var require_settings4 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs = __require("fs");
    var os3 = __require("os");
    var CPU_COUNT = Math.max(os3.cpus().length, 1);
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      lstatSync: fs.lstatSync,
      stat: fs.stat,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
        this.ignore = [].concat(this.ignore);
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports.default = Settings;
  }
});

// 
var require_out4 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async6();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils6();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2;
      FastGlob2.globSync = sync;
      FastGlob2.globStream = stream;
      FastGlob2.async = FastGlob2;
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        assertPatternsInput(source);
        return utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      let posix;
      (function(posix2) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapePosixPath(source);
        }
        posix2.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertPosixPathToPattern(source);
        }
        posix2.convertPathToPattern = convertPathToPattern2;
      })(posix = FastGlob2.posix || (FastGlob2.posix = {}));
      let win32;
      (function(win322) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapeWindowsPath(source);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertWindowsPathToPattern(source);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// 
var require_main = __commonJS({
  ""(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var node_exports = {};
    __export2(node_exports, {
      analyzeMetafile: () => analyzeMetafile,
      analyzeMetafileSync: () => analyzeMetafileSync,
      build: () => build,
      buildSync: () => buildSync,
      context: () => context2,
      default: () => node_default,
      formatMessages: () => formatMessages,
      formatMessagesSync: () => formatMessagesSync,
      initialize: () => initialize,
      stop: () => stop,
      transform: () => transform,
      transformSync: () => transformSync,
      version: () => version
    });
    module2.exports = __toCommonJS(node_exports);
    function encodePacket(packet) {
      let visit = (value) => {
        if (value === null) {
          bb.write8(0);
        } else if (typeof value === "boolean") {
          bb.write8(1);
          bb.write8(+value);
        } else if (typeof value === "number") {
          bb.write8(2);
          bb.write32(value | 0);
        } else if (typeof value === "string") {
          bb.write8(3);
          bb.write(encodeUTF8(value));
        } else if (value instanceof Uint8Array) {
          bb.write8(4);
          bb.write(value);
        } else if (value instanceof Array) {
          bb.write8(5);
          bb.write32(value.length);
          for (let item of value) {
            visit(item);
          }
        } else {
          let keys = Object.keys(value);
          bb.write8(6);
          bb.write32(keys.length);
          for (let key of keys) {
            bb.write(encodeUTF8(key));
            visit(value[key]);
          }
        }
      };
      let bb = new ByteBuffer();
      bb.write32(0);
      bb.write32(packet.id << 1 | +!packet.isRequest);
      visit(packet.value);
      writeUInt32LE(bb.buf, bb.len - 4, 0);
      return bb.buf.subarray(0, bb.len);
    }
    function decodePacket(bytes) {
      let visit = () => {
        switch (bb.read8()) {
          case 0:
            return null;
          case 1:
            return !!bb.read8();
          case 2:
            return bb.read32();
          case 3:
            return decodeUTF8(bb.read());
          case 4:
            return bb.read();
          case 5: {
            let count = bb.read32();
            let value2 = [];
            for (let i6 = 0; i6 < count; i6++) {
              value2.push(visit());
            }
            return value2;
          }
          case 6: {
            let count = bb.read32();
            let value2 = {};
            for (let i6 = 0; i6 < count; i6++) {
              value2[decodeUTF8(bb.read())] = visit();
            }
            return value2;
          }
          default:
            throw new Error("Invalid packet");
        }
      };
      let bb = new ByteBuffer(bytes);
      let id = bb.read32();
      let isRequest = (id & 1) === 0;
      id >>>= 1;
      let value = visit();
      if (bb.ptr !== bytes.length) {
        throw new Error("Invalid packet");
      }
      return { id, isRequest, value };
    }
    var ByteBuffer = class {
      constructor(buf = new Uint8Array(1024)) {
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
      }
      _write(delta) {
        if (this.len + delta > this.buf.length) {
          let clone = new Uint8Array((this.len + delta) * 2);
          clone.set(this.buf);
          this.buf = clone;
        }
        this.len += delta;
        return this.len - delta;
      }
      write8(value) {
        let offset = this._write(1);
        this.buf[offset] = value;
      }
      write32(value) {
        let offset = this._write(4);
        writeUInt32LE(this.buf, value, offset);
      }
      write(bytes) {
        let offset = this._write(4 + bytes.length);
        writeUInt32LE(this.buf, bytes.length, offset);
        this.buf.set(bytes, offset + 4);
      }
      _read(delta) {
        if (this.ptr + delta > this.buf.length) {
          throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
      }
      read8() {
        return this.buf[this._read(1)];
      }
      read32() {
        return readUInt32LE(this.buf, this._read(4));
      }
      read() {
        let length = this.read32();
        let bytes = new Uint8Array(length);
        let ptr = this._read(bytes.length);
        bytes.set(this.buf.subarray(ptr, ptr + length));
        return bytes;
      }
    };
    var encodeUTF8;
    var decodeUTF8;
    var encodeInvariant;
    if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
      let encoder = new TextEncoder();
      let decoder = new TextDecoder();
      encodeUTF8 = (text) => encoder.encode(text);
      decodeUTF8 = (bytes) => decoder.decode(bytes);
      encodeInvariant = 'new TextEncoder().encode("")';
    } else if (typeof Buffer !== "undefined") {
      encodeUTF8 = (text) => Buffer.from(text);
      decodeUTF8 = (bytes) => {
        let { buffer, byteOffset, byteLength } = bytes;
        return Buffer.from(buffer, byteOffset, byteLength).toString();
      };
      encodeInvariant = 'Buffer.from("")';
    } else {
      throw new Error("No UTF-8 codec found");
    }
    if (!(encodeUTF8("") instanceof Uint8Array))
      throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
    function readUInt32LE(buffer, offset) {
      return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
    }
    function writeUInt32LE(buffer, value, offset) {
      buffer[offset++] = value;
      buffer[offset++] = value >> 8;
      buffer[offset++] = value >> 16;
      buffer[offset++] = value >> 24;
    }
    var quote = JSON.stringify;
    var buildLogLevelDefault = "warning";
    var transformLogLevelDefault = "silent";
    function validateAndJoinStringArray(values, what) {
      const toJoin = [];
      for (const value of values) {
        validateStringValue(value, what);
        if (value.indexOf(",") >= 0)
          throw new Error(`Invalid ${what}: ${value}`);
        toJoin.push(value);
      }
      return toJoin.join(",");
    }
    var canBeAnything = () => null;
    var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
    var mustBeString = (value) => typeof value === "string" ? null : "a string";
    var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
    var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
    var mustBeValidPortNumber = (value) => typeof value === "number" && value === (value | 0) && value >= 0 && value <= 65535 ? null : "a valid port number";
    var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
    var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
    var mustBeArrayOfStrings = (value) => Array.isArray(value) && value.every((x2) => typeof x2 === "string") ? null : "an array of strings";
    var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
    var mustBeEntryPoints = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
    var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
    var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
    var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
    var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
    var mustBeStringOrArrayOfStrings = (value) => typeof value === "string" || Array.isArray(value) && value.every((x2) => typeof x2 === "string") ? null : "a string or an array of strings";
    var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
    var mustBeStringOrURL = (value) => typeof value === "string" || value instanceof URL ? null : "a string or a URL";
    function getFlag(object, keys, key, mustBeFn) {
      let value = object[key];
      keys[key + ""] = true;
      if (value === void 0)
        return void 0;
      let mustBe = mustBeFn(value);
      if (mustBe !== null)
        throw new Error(`${quote(key)} must be ${mustBe}`);
      return value;
    }
    function checkForInvalidFlags(object, keys, where) {
      for (let key in object) {
        if (!(key in keys)) {
          throw new Error(`Invalid option ${where}: ${quote(key)}`);
        }
      }
    }
    function validateInitializeOptions(options) {
      let keys = /* @__PURE__ */ Object.create(null);
      let wasmURL = getFlag(options, keys, "wasmURL", mustBeStringOrURL);
      let wasmModule = getFlag(options, keys, "wasmModule", mustBeWebAssemblyModule);
      let worker = getFlag(options, keys, "worker", mustBeBoolean);
      checkForInvalidFlags(options, keys, "in initialize() call");
      return {
        wasmURL,
        wasmModule,
        worker
      };
    }
    function validateMangleCache(mangleCache) {
      let validated;
      if (mangleCache !== void 0) {
        validated = /* @__PURE__ */ Object.create(null);
        for (let key in mangleCache) {
          let value = mangleCache[key];
          if (typeof value === "string" || value === false) {
            validated[key] = value;
          } else {
            throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
          }
        }
      }
      return validated;
    }
    function pushLogFlags(flags, options, keys, isTTY2, logLevelDefault) {
      let color = getFlag(options, keys, "color", mustBeBoolean);
      let logLevel = getFlag(options, keys, "logLevel", mustBeString);
      let logLimit = getFlag(options, keys, "logLimit", mustBeInteger);
      if (color !== void 0)
        flags.push(`--color=${color}`);
      else if (isTTY2)
        flags.push(`--color=true`);
      flags.push(`--log-level=${logLevel || logLevelDefault}`);
      flags.push(`--log-limit=${logLimit || 0}`);
    }
    function validateStringValue(value, what, key) {
      if (typeof value !== "string") {
        throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
      }
      return value;
    }
    function pushCommonFlags(flags, options, keys) {
      let legalComments = getFlag(options, keys, "legalComments", mustBeString);
      let sourceRoot = getFlag(options, keys, "sourceRoot", mustBeString);
      let sourcesContent = getFlag(options, keys, "sourcesContent", mustBeBoolean);
      let target = getFlag(options, keys, "target", mustBeStringOrArrayOfStrings);
      let format = getFlag(options, keys, "format", mustBeString);
      let globalName = getFlag(options, keys, "globalName", mustBeString);
      let mangleProps = getFlag(options, keys, "mangleProps", mustBeRegExp);
      let reserveProps = getFlag(options, keys, "reserveProps", mustBeRegExp);
      let mangleQuoted = getFlag(options, keys, "mangleQuoted", mustBeBoolean);
      let minify = getFlag(options, keys, "minify", mustBeBoolean);
      let minifySyntax = getFlag(options, keys, "minifySyntax", mustBeBoolean);
      let minifyWhitespace = getFlag(options, keys, "minifyWhitespace", mustBeBoolean);
      let minifyIdentifiers = getFlag(options, keys, "minifyIdentifiers", mustBeBoolean);
      let lineLimit = getFlag(options, keys, "lineLimit", mustBeInteger);
      let drop = getFlag(options, keys, "drop", mustBeArrayOfStrings);
      let dropLabels = getFlag(options, keys, "dropLabels", mustBeArrayOfStrings);
      let charset = getFlag(options, keys, "charset", mustBeString);
      let treeShaking = getFlag(options, keys, "treeShaking", mustBeBoolean);
      let ignoreAnnotations = getFlag(options, keys, "ignoreAnnotations", mustBeBoolean);
      let jsx = getFlag(options, keys, "jsx", mustBeString);
      let jsxFactory = getFlag(options, keys, "jsxFactory", mustBeString);
      let jsxFragment = getFlag(options, keys, "jsxFragment", mustBeString);
      let jsxImportSource = getFlag(options, keys, "jsxImportSource", mustBeString);
      let jsxDev = getFlag(options, keys, "jsxDev", mustBeBoolean);
      let jsxSideEffects = getFlag(options, keys, "jsxSideEffects", mustBeBoolean);
      let define = getFlag(options, keys, "define", mustBeObject);
      let logOverride = getFlag(options, keys, "logOverride", mustBeObject);
      let supported = getFlag(options, keys, "supported", mustBeObject);
      let pure = getFlag(options, keys, "pure", mustBeArrayOfStrings);
      let keepNames = getFlag(options, keys, "keepNames", mustBeBoolean);
      let platform = getFlag(options, keys, "platform", mustBeString);
      let tsconfigRaw = getFlag(options, keys, "tsconfigRaw", mustBeStringOrObject);
      let absPaths = getFlag(options, keys, "absPaths", mustBeArrayOfStrings);
      if (legalComments)
        flags.push(`--legal-comments=${legalComments}`);
      if (sourceRoot !== void 0)
        flags.push(`--source-root=${sourceRoot}`);
      if (sourcesContent !== void 0)
        flags.push(`--sources-content=${sourcesContent}`);
      if (target)
        flags.push(`--target=${validateAndJoinStringArray(Array.isArray(target) ? target : [target], "target")}`);
      if (format)
        flags.push(`--format=${format}`);
      if (globalName)
        flags.push(`--global-name=${globalName}`);
      if (platform)
        flags.push(`--platform=${platform}`);
      if (tsconfigRaw)
        flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
      if (minify)
        flags.push("--minify");
      if (minifySyntax)
        flags.push("--minify-syntax");
      if (minifyWhitespace)
        flags.push("--minify-whitespace");
      if (minifyIdentifiers)
        flags.push("--minify-identifiers");
      if (lineLimit)
        flags.push(`--line-limit=${lineLimit}`);
      if (charset)
        flags.push(`--charset=${charset}`);
      if (treeShaking !== void 0)
        flags.push(`--tree-shaking=${treeShaking}`);
      if (ignoreAnnotations)
        flags.push(`--ignore-annotations`);
      if (drop)
        for (let what of drop)
          flags.push(`--drop:${validateStringValue(what, "drop")}`);
      if (dropLabels)
        flags.push(`--drop-labels=${validateAndJoinStringArray(dropLabels, "drop label")}`);
      if (absPaths)
        flags.push(`--abs-paths=${validateAndJoinStringArray(absPaths, "abs paths")}`);
      if (mangleProps)
        flags.push(`--mangle-props=${jsRegExpToGoRegExp(mangleProps)}`);
      if (reserveProps)
        flags.push(`--reserve-props=${jsRegExpToGoRegExp(reserveProps)}`);
      if (mangleQuoted !== void 0)
        flags.push(`--mangle-quoted=${mangleQuoted}`);
      if (jsx)
        flags.push(`--jsx=${jsx}`);
      if (jsxFactory)
        flags.push(`--jsx-factory=${jsxFactory}`);
      if (jsxFragment)
        flags.push(`--jsx-fragment=${jsxFragment}`);
      if (jsxImportSource)
        flags.push(`--jsx-import-source=${jsxImportSource}`);
      if (jsxDev)
        flags.push(`--jsx-dev`);
      if (jsxSideEffects)
        flags.push(`--jsx-side-effects`);
      if (define) {
        for (let key in define) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid define: ${key}`);
          flags.push(`--define:${key}=${validateStringValue(define[key], "define", key)}`);
        }
      }
      if (logOverride) {
        for (let key in logOverride) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid log override: ${key}`);
          flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
        }
      }
      if (supported) {
        for (let key in supported) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid supported: ${key}`);
          const value = supported[key];
          if (typeof value !== "boolean")
            throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
          flags.push(`--supported:${key}=${value}`);
        }
      }
      if (pure)
        for (let fn2 of pure)
          flags.push(`--pure:${validateStringValue(fn2, "pure")}`);
      if (keepNames)
        flags.push(`--keep-names`);
    }
    function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
      var _a2;
      let flags = [];
      let entries = [];
      let keys = /* @__PURE__ */ Object.create(null);
      let stdinContents = null;
      let stdinResolveDir = null;
      pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options, keys);
      let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
      let bundle = getFlag(options, keys, "bundle", mustBeBoolean);
      let splitting = getFlag(options, keys, "splitting", mustBeBoolean);
      let preserveSymlinks = getFlag(options, keys, "preserveSymlinks", mustBeBoolean);
      let metafile = getFlag(options, keys, "metafile", mustBeBoolean);
      let outfile = getFlag(options, keys, "outfile", mustBeString);
      let outdir = getFlag(options, keys, "outdir", mustBeString);
      let outbase = getFlag(options, keys, "outbase", mustBeString);
      let tsconfig = getFlag(options, keys, "tsconfig", mustBeString);
      let resolveExtensions = getFlag(options, keys, "resolveExtensions", mustBeArrayOfStrings);
      let nodePathsInput = getFlag(options, keys, "nodePaths", mustBeArrayOfStrings);
      let mainFields = getFlag(options, keys, "mainFields", mustBeArrayOfStrings);
      let conditions = getFlag(options, keys, "conditions", mustBeArrayOfStrings);
      let external = getFlag(options, keys, "external", mustBeArrayOfStrings);
      let packages = getFlag(options, keys, "packages", mustBeString);
      let alias = getFlag(options, keys, "alias", mustBeObject);
      let loader = getFlag(options, keys, "loader", mustBeObject);
      let outExtension = getFlag(options, keys, "outExtension", mustBeObject);
      let publicPath = getFlag(options, keys, "publicPath", mustBeString);
      let entryNames = getFlag(options, keys, "entryNames", mustBeString);
      let chunkNames = getFlag(options, keys, "chunkNames", mustBeString);
      let assetNames = getFlag(options, keys, "assetNames", mustBeString);
      let inject = getFlag(options, keys, "inject", mustBeArrayOfStrings);
      let banner = getFlag(options, keys, "banner", mustBeObject);
      let footer = getFlag(options, keys, "footer", mustBeObject);
      let entryPoints = getFlag(options, keys, "entryPoints", mustBeEntryPoints);
      let absWorkingDir = getFlag(options, keys, "absWorkingDir", mustBeString);
      let stdin = getFlag(options, keys, "stdin", mustBeObject);
      let write = (_a2 = getFlag(options, keys, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
      let allowOverwrite = getFlag(options, keys, "allowOverwrite", mustBeBoolean);
      let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
      keys.plugins = true;
      checkForInvalidFlags(options, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
      if (bundle)
        flags.push("--bundle");
      if (allowOverwrite)
        flags.push("--allow-overwrite");
      if (splitting)
        flags.push("--splitting");
      if (preserveSymlinks)
        flags.push("--preserve-symlinks");
      if (metafile)
        flags.push(`--metafile`);
      if (outfile)
        flags.push(`--outfile=${outfile}`);
      if (outdir)
        flags.push(`--outdir=${outdir}`);
      if (outbase)
        flags.push(`--outbase=${outbase}`);
      if (tsconfig)
        flags.push(`--tsconfig=${tsconfig}`);
      if (packages)
        flags.push(`--packages=${packages}`);
      if (resolveExtensions)
        flags.push(`--resolve-extensions=${validateAndJoinStringArray(resolveExtensions, "resolve extension")}`);
      if (publicPath)
        flags.push(`--public-path=${publicPath}`);
      if (entryNames)
        flags.push(`--entry-names=${entryNames}`);
      if (chunkNames)
        flags.push(`--chunk-names=${chunkNames}`);
      if (assetNames)
        flags.push(`--asset-names=${assetNames}`);
      if (mainFields)
        flags.push(`--main-fields=${validateAndJoinStringArray(mainFields, "main field")}`);
      if (conditions)
        flags.push(`--conditions=${validateAndJoinStringArray(conditions, "condition")}`);
      if (external)
        for (let name of external)
          flags.push(`--external:${validateStringValue(name, "external")}`);
      if (alias) {
        for (let old in alias) {
          if (old.indexOf("=") >= 0)
            throw new Error(`Invalid package name in alias: ${old}`);
          flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
        }
      }
      if (banner) {
        for (let type in banner) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid banner file type: ${type}`);
          flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
        }
      }
      if (footer) {
        for (let type in footer) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid footer file type: ${type}`);
          flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
        }
      }
      if (inject)
        for (let path3 of inject)
          flags.push(`--inject:${validateStringValue(path3, "inject")}`);
      if (loader) {
        for (let ext in loader) {
          if (ext.indexOf("=") >= 0)
            throw new Error(`Invalid loader extension: ${ext}`);
          flags.push(`--loader:${ext}=${validateStringValue(loader[ext], "loader", ext)}`);
        }
      }
      if (outExtension) {
        for (let ext in outExtension) {
          if (ext.indexOf("=") >= 0)
            throw new Error(`Invalid out extension: ${ext}`);
          flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext], "out extension", ext)}`);
        }
      }
      if (entryPoints) {
        if (Array.isArray(entryPoints)) {
          for (let i6 = 0, n3 = entryPoints.length; i6 < n3; i6++) {
            let entryPoint = entryPoints[i6];
            if (typeof entryPoint === "object" && entryPoint !== null) {
              let entryPointKeys = /* @__PURE__ */ Object.create(null);
              let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
              let output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
              checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i6);
              if (input === void 0)
                throw new Error('Missing property "in" for entry point at index ' + i6);
              if (output === void 0)
                throw new Error('Missing property "out" for entry point at index ' + i6);
              entries.push([output, input]);
            } else {
              entries.push(["", validateStringValue(entryPoint, "entry point at index " + i6)]);
            }
          }
        } else {
          for (let key in entryPoints) {
            entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
          }
        }
      }
      if (stdin) {
        let stdinKeys = /* @__PURE__ */ Object.create(null);
        let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader2)
          flags.push(`--loader=${loader2}`);
        if (resolveDir)
          stdinResolveDir = resolveDir;
        if (typeof contents === "string")
          stdinContents = encodeUTF8(contents);
        else if (contents instanceof Uint8Array)
          stdinContents = contents;
      }
      let nodePaths = [];
      if (nodePathsInput) {
        for (let value of nodePathsInput) {
          value += "";
          nodePaths.push(value);
        }
      }
      return {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        nodePaths,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
      let flags = [];
      let keys = /* @__PURE__ */ Object.create(null);
      pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options, keys);
      let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
      let sourcefile = getFlag(options, keys, "sourcefile", mustBeString);
      let loader = getFlag(options, keys, "loader", mustBeString);
      let banner = getFlag(options, keys, "banner", mustBeString);
      let footer = getFlag(options, keys, "footer", mustBeString);
      let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
      checkForInvalidFlags(options, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
      if (sourcefile)
        flags.push(`--sourcefile=${sourcefile}`);
      if (loader)
        flags.push(`--loader=${loader}`);
      if (banner)
        flags.push(`--banner=${banner}`);
      if (footer)
        flags.push(`--footer=${footer}`);
      return {
        flags,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function createChannel(streamIn) {
      const requestCallbacksByKey = {};
      const closeData = { didClose: false, reason: "" };
      let responseCallbacks = {};
      let nextRequestID = 0;
      let nextBuildKey = 0;
      let stdout = new Uint8Array(16 * 1024);
      let stdoutUsed = 0;
      let readFromStdout = (chunk) => {
        let limit = stdoutUsed + chunk.length;
        if (limit > stdout.length) {
          let swap = new Uint8Array(limit * 2);
          swap.set(stdout);
          stdout = swap;
        }
        stdout.set(chunk, stdoutUsed);
        stdoutUsed += chunk.length;
        let offset = 0;
        while (offset + 4 <= stdoutUsed) {
          let length = readUInt32LE(stdout, offset);
          if (offset + 4 + length > stdoutUsed) {
            break;
          }
          offset += 4;
          handleIncomingPacket(stdout.subarray(offset, offset + length));
          offset += length;
        }
        if (offset > 0) {
          stdout.copyWithin(0, offset, stdoutUsed);
          stdoutUsed -= offset;
        }
      };
      let afterClose = (error) => {
        closeData.didClose = true;
        if (error)
          closeData.reason = ": " + (error.message || error);
        const text = "The service was stopped" + closeData.reason;
        for (let id in responseCallbacks) {
          responseCallbacks[id](text, null);
        }
        responseCallbacks = {};
      };
      let sendRequest = (refs, value, callback) => {
        if (closeData.didClose)
          return callback("The service is no longer running" + closeData.reason, null);
        let id = nextRequestID++;
        responseCallbacks[id] = (error, response) => {
          try {
            callback(error, response);
          } finally {
            if (refs)
              refs.unref();
          }
        };
        if (refs)
          refs.ref();
        streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
      };
      let sendResponse = (id, value) => {
        if (closeData.didClose)
          throw new Error("The service is no longer running" + closeData.reason);
        streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
      };
      let handleRequest = async (id, request2) => {
        try {
          if (request2.command === "ping") {
            sendResponse(id, {});
            return;
          }
          if (typeof request2.key === "number") {
            const requestCallbacks = requestCallbacksByKey[request2.key];
            if (!requestCallbacks) {
              return;
            }
            const callback = requestCallbacks[request2.command];
            if (callback) {
              await callback(id, request2);
              return;
            }
          }
          throw new Error(`Invalid command: ` + request2.command);
        } catch (e5) {
          const errors = [extractErrorMessageV8(e5, streamIn, null, void 0, "")];
          try {
            sendResponse(id, { errors });
          } catch {
          }
        }
      };
      let isFirstPacket = true;
      let handleIncomingPacket = (bytes) => {
        if (isFirstPacket) {
          isFirstPacket = false;
          let binaryVersion = String.fromCharCode(...bytes);
          if (binaryVersion !== "0.25.9") {
            throw new Error(`Cannot start service: Host version "${"0.25.9"}" does not match binary version ${quote(binaryVersion)}`);
          }
          return;
        }
        let packet = decodePacket(bytes);
        if (packet.isRequest) {
          handleRequest(packet.id, packet.value);
        } else {
          let callback = responseCallbacks[packet.id];
          delete responseCallbacks[packet.id];
          if (packet.value.error)
            callback(packet.value.error, {});
          else
            callback(null, packet.value);
        }
      };
      let buildOrContext = ({ callName, refs, options, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
        let refCount = 0;
        const buildKey = nextBuildKey++;
        const requestCallbacks = {};
        const buildRefs = {
          ref() {
            if (++refCount === 1) {
              if (refs)
                refs.ref();
            }
          },
          unref() {
            if (--refCount === 0) {
              delete requestCallbacksByKey[buildKey];
              if (refs)
                refs.unref();
            }
          }
        };
        requestCallbacksByKey[buildKey] = requestCallbacks;
        buildRefs.ref();
        buildOrContextImpl(
          callName,
          buildKey,
          sendRequest,
          sendResponse,
          buildRefs,
          streamIn,
          requestCallbacks,
          options,
          isTTY2,
          defaultWD2,
          (err, res) => {
            try {
              callback(err, res);
            } finally {
              buildRefs.unref();
            }
          }
        );
      };
      let transform2 = ({ callName, refs, input, options, isTTY: isTTY2, fs: fs3, callback }) => {
        const details = createObjectStash();
        let start = (inputPath) => {
          try {
            if (typeof input !== "string" && !(input instanceof Uint8Array))
              throw new Error('The input to "transform" must be a string or a Uint8Array');
            let {
              flags,
              mangleCache
            } = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault);
            let request2 = {
              command: "transform",
              flags,
              inputFS: inputPath !== null,
              input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
            };
            if (mangleCache)
              request2.mangleCache = mangleCache;
            sendRequest(refs, request2, (error, response) => {
              if (error)
                return callback(new Error(error), null);
              let errors = replaceDetailsInMessages(response.errors, details);
              let warnings = replaceDetailsInMessages(response.warnings, details);
              let outstanding = 1;
              let next = () => {
                if (--outstanding === 0) {
                  let result = {
                    warnings,
                    code: response.code,
                    map: response.map,
                    mangleCache: void 0,
                    legalComments: void 0
                  };
                  if ("legalComments" in response)
                    result.legalComments = response == null ? void 0 : response.legalComments;
                  if (response.mangleCache)
                    result.mangleCache = response == null ? void 0 : response.mangleCache;
                  callback(null, result);
                }
              };
              if (errors.length > 0)
                return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
              if (response.codeFS) {
                outstanding++;
                fs3.readFile(response.code, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.code = contents;
                    next();
                  }
                });
              }
              if (response.mapFS) {
                outstanding++;
                fs3.readFile(response.map, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.map = contents;
                    next();
                  }
                });
              }
              next();
            });
          } catch (e5) {
            let flags = [];
            try {
              pushLogFlags(flags, options, {}, isTTY2, transformLogLevelDefault);
            } catch {
            }
            const error = extractErrorMessageV8(e5, streamIn, details, void 0, "");
            sendRequest(refs, { command: "error", flags, error }, () => {
              error.detail = details.load(error.detail);
              callback(failureErrorWithLog("Transform failed", [error], []), null);
            });
          }
        };
        if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
          let next = start;
          start = () => fs3.writeFile(input, next);
        }
        start(null);
      };
      let formatMessages2 = ({ callName, refs, messages, options, callback }) => {
        if (!options)
          throw new Error(`Missing second argument in ${callName}() call`);
        let keys = {};
        let kind = getFlag(options, keys, "kind", mustBeString);
        let color = getFlag(options, keys, "color", mustBeBoolean);
        let terminalWidth = getFlag(options, keys, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        if (kind === void 0)
          throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning")
          throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request2 = {
          command: "format-msgs",
          messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
          isWarning: kind === "warning"
        };
        if (color !== void 0)
          request2.color = color;
        if (terminalWidth !== void 0)
          request2.terminalWidth = terminalWidth;
        sendRequest(refs, request2, (error, response) => {
          if (error)
            return callback(new Error(error), null);
          callback(null, response.messages);
        });
      };
      let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {
        if (options === void 0)
          options = {};
        let keys = {};
        let color = getFlag(options, keys, "color", mustBeBoolean);
        let verbose = getFlag(options, keys, "verbose", mustBeBoolean);
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        let request2 = {
          command: "analyze-metafile",
          metafile
        };
        if (color !== void 0)
          request2.color = color;
        if (verbose !== void 0)
          request2.verbose = verbose;
        sendRequest(refs, request2, (error, response) => {
          if (error)
            return callback(new Error(error), null);
          callback(null, response.result);
        });
      };
      return {
        readFromStdout,
        afterClose,
        service: {
          buildOrContext,
          transform: transform2,
          formatMessages: formatMessages2,
          analyzeMetafile: analyzeMetafile2
        }
      };
    }
    function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
      const details = createObjectStash();
      const isContext = callName === "context";
      const handleError = (e5, pluginName) => {
        const flags = [];
        try {
          pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
        } catch {
        }
        const message = extractErrorMessageV8(e5, streamIn, details, void 0, pluginName);
        sendRequest(refs, { command: "error", flags, error: message }, () => {
          message.detail = details.load(message.detail);
          callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
        });
      };
      let plugins;
      if (typeof options === "object") {
        const value = options.plugins;
        if (value !== void 0) {
          if (!Array.isArray(value))
            return handleError(new Error(`"plugins" must be an array`), "");
          plugins = value;
        }
      }
      if (plugins && plugins.length > 0) {
        if (streamIn.isSync)
          return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
        handlePlugins(
          buildKey,
          sendRequest,
          sendResponse,
          refs,
          streamIn,
          requestCallbacks,
          options,
          plugins,
          details
        ).then(
          (result) => {
            if (!result.ok)
              return handleError(result.error, result.pluginName);
            try {
              buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
            } catch (e5) {
              handleError(e5, "");
            }
          },
          (e5) => handleError(e5, "")
        );
        return;
      }
      try {
        buildOrContextContinue(null, (result, done) => done([], []), () => {
        });
      } catch (e5) {
        handleError(e5, "");
      }
      function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
        const writeDefault = streamIn.hasFS;
        const {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          nodePaths,
          mangleCache
        } = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault);
        if (write && !streamIn.hasFS)
          throw new Error(`The "write" option is unavailable in this environment`);
        const request2 = {
          command: "build",
          key: buildKey,
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir: absWorkingDir || defaultWD2,
          nodePaths,
          context: isContext
        };
        if (requestPlugins)
          request2.plugins = requestPlugins;
        if (mangleCache)
          request2.mangleCache = mangleCache;
        const buildResponseToResult = (response, callback2) => {
          const result = {
            errors: replaceDetailsInMessages(response.errors, details),
            warnings: replaceDetailsInMessages(response.warnings, details),
            outputFiles: void 0,
            metafile: void 0,
            mangleCache: void 0
          };
          const originalErrors = result.errors.slice();
          const originalWarnings = result.warnings.slice();
          if (response.outputFiles)
            result.outputFiles = response.outputFiles.map(convertOutputFiles);
          if (response.metafile)
            result.metafile = JSON.parse(response.metafile);
          if (response.mangleCache)
            result.mangleCache = response.mangleCache;
          if (response.writeToStdout !== void 0)
            console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
          runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
            if (originalErrors.length > 0 || onEndErrors.length > 0) {
              const error = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
              return callback2(error, null, onEndErrors, onEndWarnings);
            }
            callback2(null, result, onEndErrors, onEndWarnings);
          });
        };
        let latestResultPromise;
        let provideLatestResult;
        if (isContext)
          requestCallbacks["on-end"] = (id, request22) => new Promise((resolve) => {
            buildResponseToResult(request22, (err, result, onEndErrors, onEndWarnings) => {
              const response = {
                errors: onEndErrors,
                warnings: onEndWarnings
              };
              if (provideLatestResult)
                provideLatestResult(err, result);
              latestResultPromise = void 0;
              provideLatestResult = void 0;
              sendResponse(id, response);
              resolve();
            });
          });
        sendRequest(refs, request2, (error, response) => {
          if (error)
            return callback(new Error(error), null);
          if (!isContext) {
            return buildResponseToResult(response, (err, res) => {
              scheduleOnDisposeCallbacks();
              return callback(err, res);
            });
          }
          if (response.errors.length > 0) {
            return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
          }
          let didDispose = false;
          const result = {
            rebuild: () => {
              if (!latestResultPromise)
                latestResultPromise = new Promise((resolve, reject) => {
                  let settlePromise;
                  provideLatestResult = (err, result2) => {
                    if (!settlePromise)
                      settlePromise = () => err ? reject(err) : resolve(result2);
                  };
                  const triggerAnotherBuild = () => {
                    const request22 = {
                      command: "rebuild",
                      key: buildKey
                    };
                    sendRequest(refs, request22, (error2, response2) => {
                      if (error2) {
                        reject(new Error(error2));
                      } else if (settlePromise) {
                        settlePromise();
                      } else {
                        triggerAnotherBuild();
                      }
                    });
                  };
                  triggerAnotherBuild();
                });
              return latestResultPromise;
            },
            watch: (options2 = {}) => new Promise((resolve, reject) => {
              if (!streamIn.hasFS)
                throw new Error(`Cannot use the "watch" API in this environment`);
              const keys = {};
              const delay = getFlag(options2, keys, "delay", mustBeInteger);
              checkForInvalidFlags(options2, keys, `in watch() call`);
              const request22 = {
                command: "watch",
                key: buildKey
              };
              if (delay)
                request22.delay = delay;
              sendRequest(refs, request22, (error2) => {
                if (error2)
                  reject(new Error(error2));
                else
                  resolve(void 0);
              });
            }),
            serve: (options2 = {}) => new Promise((resolve, reject) => {
              if (!streamIn.hasFS)
                throw new Error(`Cannot use the "serve" API in this environment`);
              const keys = {};
              const port = getFlag(options2, keys, "port", mustBeValidPortNumber);
              const host = getFlag(options2, keys, "host", mustBeString);
              const servedir = getFlag(options2, keys, "servedir", mustBeString);
              const keyfile = getFlag(options2, keys, "keyfile", mustBeString);
              const certfile = getFlag(options2, keys, "certfile", mustBeString);
              const fallback = getFlag(options2, keys, "fallback", mustBeString);
              const cors = getFlag(options2, keys, "cors", mustBeObject);
              const onRequest = getFlag(options2, keys, "onRequest", mustBeFunction);
              checkForInvalidFlags(options2, keys, `in serve() call`);
              const request22 = {
                command: "serve",
                key: buildKey,
                onRequest: !!onRequest
              };
              if (port !== void 0)
                request22.port = port;
              if (host !== void 0)
                request22.host = host;
              if (servedir !== void 0)
                request22.servedir = servedir;
              if (keyfile !== void 0)
                request22.keyfile = keyfile;
              if (certfile !== void 0)
                request22.certfile = certfile;
              if (fallback !== void 0)
                request22.fallback = fallback;
              if (cors) {
                const corsKeys = {};
                const origin = getFlag(cors, corsKeys, "origin", mustBeStringOrArrayOfStrings);
                checkForInvalidFlags(cors, corsKeys, `on "cors" object`);
                if (Array.isArray(origin))
                  request22.corsOrigin = origin;
                else if (origin !== void 0)
                  request22.corsOrigin = [origin];
              }
              sendRequest(refs, request22, (error2, response2) => {
                if (error2)
                  return reject(new Error(error2));
                if (onRequest) {
                  requestCallbacks["serve-request"] = (id, request3) => {
                    onRequest(request3.args);
                    sendResponse(id, {});
                  };
                }
                resolve(response2);
              });
            }),
            cancel: () => new Promise((resolve) => {
              if (didDispose)
                return resolve();
              const request22 = {
                command: "cancel",
                key: buildKey
              };
              sendRequest(refs, request22, () => {
                resolve();
              });
            }),
            dispose: () => new Promise((resolve) => {
              if (didDispose)
                return resolve();
              didDispose = true;
              const request22 = {
                command: "dispose",
                key: buildKey
              };
              sendRequest(refs, request22, () => {
                resolve();
                scheduleOnDisposeCallbacks();
                refs.unref();
              });
            })
          };
          refs.ref();
          callback(null, result);
        });
      }
    }
    var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => {
      let onStartCallbacks = [];
      let onEndCallbacks = [];
      let onResolveCallbacks = {};
      let onLoadCallbacks = {};
      let onDisposeCallbacks = [];
      let nextCallbackID = 0;
      let i6 = 0;
      let requestPlugins = [];
      let isSetupDone = false;
      plugins = [...plugins];
      for (let item of plugins) {
        let keys = {};
        if (typeof item !== "object")
          throw new Error(`Plugin at index ${i6} must be an object`);
        const name = getFlag(item, keys, "name", mustBeString);
        if (typeof name !== "string" || name === "")
          throw new Error(`Plugin at index ${i6} is missing a name`);
        try {
          let setup = getFlag(item, keys, "setup", mustBeFunction);
          if (typeof setup !== "function")
            throw new Error(`Plugin is missing a setup function`);
          checkForInvalidFlags(item, keys, `on plugin ${quote(name)}`);
          let plugin = {
            name,
            onStart: false,
            onEnd: false,
            onResolve: [],
            onLoad: []
          };
          i6++;
          let resolve = (path3, options = {}) => {
            if (!isSetupDone)
              throw new Error('Cannot call "resolve" before plugin setup has completed');
            if (typeof path3 !== "string")
              throw new Error(`The path to resolve must be a string`);
            let keys2 = /* @__PURE__ */ Object.create(null);
            let pluginName = getFlag(options, keys2, "pluginName", mustBeString);
            let importer = getFlag(options, keys2, "importer", mustBeString);
            let namespace = getFlag(options, keys2, "namespace", mustBeString);
            let resolveDir = getFlag(options, keys2, "resolveDir", mustBeString);
            let kind = getFlag(options, keys2, "kind", mustBeString);
            let pluginData = getFlag(options, keys2, "pluginData", canBeAnything);
            let importAttributes = getFlag(options, keys2, "with", mustBeObject);
            checkForInvalidFlags(options, keys2, "in resolve() call");
            return new Promise((resolve2, reject) => {
              const request2 = {
                command: "resolve",
                path: path3,
                key: buildKey,
                pluginName: name
              };
              if (pluginName != null)
                request2.pluginName = pluginName;
              if (importer != null)
                request2.importer = importer;
              if (namespace != null)
                request2.namespace = namespace;
              if (resolveDir != null)
                request2.resolveDir = resolveDir;
              if (kind != null)
                request2.kind = kind;
              else
                throw new Error(`Must specify "kind" when calling "resolve"`);
              if (pluginData != null)
                request2.pluginData = details.store(pluginData);
              if (importAttributes != null)
                request2.with = sanitizeStringMap(importAttributes, "with");
              sendRequest(refs, request2, (error, response) => {
                if (error !== null)
                  reject(new Error(error));
                else
                  resolve2({
                    errors: replaceDetailsInMessages(response.errors, details),
                    warnings: replaceDetailsInMessages(response.warnings, details),
                    path: response.path,
                    external: response.external,
                    sideEffects: response.sideEffects,
                    namespace: response.namespace,
                    suffix: response.suffix,
                    pluginData: details.load(response.pluginData)
                  });
              });
            });
          };
          let promise = setup({
            initialOptions,
            resolve,
            onStart(callback) {
              let registeredText = `This error came from the "onStart" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
              onStartCallbacks.push({ name, callback, note: registeredNote });
              plugin.onStart = true;
            },
            onEnd(callback) {
              let registeredText = `This error came from the "onEnd" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
              onEndCallbacks.push({ name, callback, note: registeredNote });
              plugin.onEnd = true;
            },
            onResolve(options, callback) {
              let registeredText = `This error came from the "onResolve" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
              let keys2 = {};
              let filter = getFlag(options, keys2, "filter", mustBeRegExp);
              let namespace = getFlag(options, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${quote(name)}`);
              if (filter == null)
                throw new Error(`onResolve() call is missing a filter`);
              let id = nextCallbackID++;
              onResolveCallbacks[id] = { name, callback, note: registeredNote };
              plugin.onResolve.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
            },
            onLoad(options, callback) {
              let registeredText = `This error came from the "onLoad" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
              let keys2 = {};
              let filter = getFlag(options, keys2, "filter", mustBeRegExp);
              let namespace = getFlag(options, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${quote(name)}`);
              if (filter == null)
                throw new Error(`onLoad() call is missing a filter`);
              let id = nextCallbackID++;
              onLoadCallbacks[id] = { name, callback, note: registeredNote };
              plugin.onLoad.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
            },
            onDispose(callback) {
              onDisposeCallbacks.push(callback);
            },
            esbuild: streamIn.esbuild
          });
          if (promise)
            await promise;
          requestPlugins.push(plugin);
        } catch (e5) {
          return { ok: false, error: e5, pluginName: name };
        }
      }
      requestCallbacks["on-start"] = async (id, request2) => {
        details.clear();
        let response = { errors: [], warnings: [] };
        await Promise.all(onStartCallbacks.map(async ({ name, callback, note }) => {
          try {
            let result = await callback();
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
              let keys = {};
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${quote(name)}`);
              if (errors != null)
                response.errors.push(...sanitizeMessages(errors, "errors", details, name, void 0));
              if (warnings != null)
                response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name, void 0));
            }
          } catch (e5) {
            response.errors.push(extractErrorMessageV8(e5, streamIn, details, note && note(), name));
          }
        }));
        sendResponse(id, response);
      };
      requestCallbacks["on-resolve"] = async (id, request2) => {
        let response = {}, name = "", callback, note;
        for (let id2 of request2.ids) {
          try {
            ({ name, callback, note } = onResolveCallbacks[id2]);
            let result = await callback({
              path: request2.path,
              importer: request2.importer,
              namespace: request2.namespace,
              resolveDir: request2.resolveDir,
              kind: request2.kind,
              pluginData: details.load(request2.pluginData),
              with: request2.with
            });
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result, keys, "pluginName", mustBeString);
              let path3 = getFlag(result, keys, "path", mustBeString);
              let namespace = getFlag(result, keys, "namespace", mustBeString);
              let suffix = getFlag(result, keys, "suffix", mustBeString);
              let external = getFlag(result, keys, "external", mustBeBoolean);
              let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
              let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
              let watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
              checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${quote(name)}`);
              response.id = id2;
              if (pluginName != null)
                response.pluginName = pluginName;
              if (path3 != null)
                response.path = path3;
              if (namespace != null)
                response.namespace = namespace;
              if (suffix != null)
                response.suffix = suffix;
              if (external != null)
                response.external = external;
              if (sideEffects != null)
                response.sideEffects = sideEffects;
              if (pluginData != null)
                response.pluginData = details.store(pluginData);
              if (errors != null)
                response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
              if (warnings != null)
                response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
              if (watchFiles != null)
                response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null)
                response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e5) {
            response = { id: id2, errors: [extractErrorMessageV8(e5, streamIn, details, note && note(), name)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      requestCallbacks["on-load"] = async (id, request2) => {
        let response = {}, name = "", callback, note;
        for (let id2 of request2.ids) {
          try {
            ({ name, callback, note } = onLoadCallbacks[id2]);
            let result = await callback({
              path: request2.path,
              namespace: request2.namespace,
              suffix: request2.suffix,
              pluginData: details.load(request2.pluginData),
              with: request2.with
            });
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result, keys, "pluginName", mustBeString);
              let contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
              let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
              let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
              let loader = getFlag(result, keys, "loader", mustBeString);
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
              let watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
              checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${quote(name)}`);
              response.id = id2;
              if (pluginName != null)
                response.pluginName = pluginName;
              if (contents instanceof Uint8Array)
                response.contents = contents;
              else if (contents != null)
                response.contents = encodeUTF8(contents);
              if (resolveDir != null)
                response.resolveDir = resolveDir;
              if (pluginData != null)
                response.pluginData = details.store(pluginData);
              if (loader != null)
                response.loader = loader;
              if (errors != null)
                response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
              if (warnings != null)
                response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
              if (watchFiles != null)
                response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null)
                response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e5) {
            response = { id: id2, errors: [extractErrorMessageV8(e5, streamIn, details, note && note(), name)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      let runOnEndCallbacks = (result, done) => done([], []);
      if (onEndCallbacks.length > 0) {
        runOnEndCallbacks = (result, done) => {
          (async () => {
            const onEndErrors = [];
            const onEndWarnings = [];
            for (const { name, callback, note } of onEndCallbacks) {
              let newErrors;
              let newWarnings;
              try {
                const value = await callback(result);
                if (value != null) {
                  if (typeof value !== "object")
                    throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
                  let keys = {};
                  let errors = getFlag(value, keys, "errors", mustBeArray);
                  let warnings = getFlag(value, keys, "warnings", mustBeArray);
                  checkForInvalidFlags(value, keys, `from onEnd() callback in plugin ${quote(name)}`);
                  if (errors != null)
                    newErrors = sanitizeMessages(errors, "errors", details, name, void 0);
                  if (warnings != null)
                    newWarnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                }
              } catch (e5) {
                newErrors = [extractErrorMessageV8(e5, streamIn, details, note && note(), name)];
              }
              if (newErrors) {
                onEndErrors.push(...newErrors);
                try {
                  result.errors.push(...newErrors);
                } catch {
                }
              }
              if (newWarnings) {
                onEndWarnings.push(...newWarnings);
                try {
                  result.warnings.push(...newWarnings);
                } catch {
                }
              }
            }
            done(onEndErrors, onEndWarnings);
          })();
        };
      }
      let scheduleOnDisposeCallbacks = () => {
        for (const cb of onDisposeCallbacks) {
          setTimeout(() => cb(), 0);
        }
      };
      isSetupDone = true;
      return {
        ok: true,
        requestPlugins,
        runOnEndCallbacks,
        scheduleOnDisposeCallbacks
      };
    };
    function createObjectStash() {
      const map = /* @__PURE__ */ new Map();
      let nextID = 0;
      return {
        clear() {
          map.clear();
        },
        load(id) {
          return map.get(id);
        },
        store(value) {
          if (value === void 0)
            return -1;
          const id = nextID++;
          map.set(id, value);
          return id;
        }
      };
    }
    function extractCallerV8(e5, streamIn, ident) {
      let note;
      let tried = false;
      return () => {
        if (tried)
          return note;
        tried = true;
        try {
          let lines = (e5.stack + "").split("\n");
          lines.splice(1, 1);
          let location = parseStackLinesV8(streamIn, lines, ident);
          if (location) {
            note = { text: e5.message, location };
            return note;
          }
        } catch {
        }
      };
    }
    function extractErrorMessageV8(e5, streamIn, stash, note, pluginName) {
      let text = "Internal error";
      let location = null;
      try {
        text = (e5 && e5.message || e5) + "";
      } catch {
      }
      try {
        location = parseStackLinesV8(streamIn, (e5.stack + "").split("\n"), "");
      } catch {
      }
      return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e5) : -1 };
    }
    function parseStackLinesV8(streamIn, lines, ident) {
      let at2 = "    at ";
      if (streamIn.readFileSync && !lines[0].startsWith(at2) && lines[1].startsWith(at2)) {
        for (let i6 = 1; i6 < lines.length; i6++) {
          let line = lines[i6];
          if (!line.startsWith(at2))
            continue;
          line = line.slice(at2.length);
          while (true) {
            let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
            if (match) {
              line = match[1];
              continue;
            }
            match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
            if (match) {
              line = match[1];
              continue;
            }
            match = /^(\S+):(\d+):(\d+)$/.exec(line);
            if (match) {
              let contents;
              try {
                contents = streamIn.readFileSync(match[1], "utf8");
              } catch {
                break;
              }
              let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
              let column = +match[3] - 1;
              let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
              return {
                file: match[1],
                namespace: "file",
                line: +match[2],
                column: encodeUTF8(lineText.slice(0, column)).length,
                length: encodeUTF8(lineText.slice(column, column + length)).length,
                lineText: lineText + "\n" + lines.slice(1).join("\n"),
                suggestion: ""
              };
            }
            break;
          }
        }
      }
      return null;
    }
    function failureErrorWithLog(text, errors, warnings) {
      let limit = 5;
      text += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e5, i6) => {
        if (i6 === limit)
          return "\n...";
        if (!e5.location)
          return `
error: ${e5.text}`;
        let { file, line, column } = e5.location;
        let pluginText = e5.pluginName ? `[plugin: ${e5.pluginName}] ` : "";
        return `
${file}:${line}:${column}: ERROR: ${pluginText}${e5.text}`;
      }).join("");
      let error = new Error(text);
      for (const [key, value] of [["errors", errors], ["warnings", warnings]]) {
        Object.defineProperty(error, key, {
          configurable: true,
          enumerable: true,
          get: () => value,
          set: (value2) => Object.defineProperty(error, key, {
            configurable: true,
            enumerable: true,
            value: value2
          })
        });
      }
      return error;
    }
    function replaceDetailsInMessages(messages, stash) {
      for (const message of messages) {
        message.detail = stash.load(message.detail);
      }
      return messages;
    }
    function sanitizeLocation(location, where, terminalWidth) {
      if (location == null)
        return null;
      let keys = {};
      let file = getFlag(location, keys, "file", mustBeString);
      let namespace = getFlag(location, keys, "namespace", mustBeString);
      let line = getFlag(location, keys, "line", mustBeInteger);
      let column = getFlag(location, keys, "column", mustBeInteger);
      let length = getFlag(location, keys, "length", mustBeInteger);
      let lineText = getFlag(location, keys, "lineText", mustBeString);
      let suggestion = getFlag(location, keys, "suggestion", mustBeString);
      checkForInvalidFlags(location, keys, where);
      if (lineText) {
        const relevantASCII = lineText.slice(
          0,
          (column && column > 0 ? column : 0) + (length && length > 0 ? length : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80)
        );
        if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
          lineText = relevantASCII;
        }
      }
      return {
        file: file || "",
        namespace: namespace || "",
        line: line || 0,
        column: column || 0,
        length: length || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
      };
    }
    function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {
      let messagesClone = [];
      let index = 0;
      for (const message of messages) {
        let keys = {};
        let id = getFlag(message, keys, "id", mustBeString);
        let pluginName = getFlag(message, keys, "pluginName", mustBeString);
        let text = getFlag(message, keys, "text", mustBeString);
        let location = getFlag(message, keys, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys, "notes", mustBeArray);
        let detail = getFlag(message, keys, "detail", canBeAnything);
        let where = `in element ${index} of "${property}"`;
        checkForInvalidFlags(message, keys, where);
        let notesClone = [];
        if (notes) {
          for (const note of notes) {
            let noteKeys = {};
            let noteText = getFlag(note, noteKeys, "text", mustBeString);
            let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where, terminalWidth)
            });
          }
        }
        messagesClone.push({
          id: id || "",
          pluginName: pluginName || fallbackPluginName,
          text: text || "",
          location: sanitizeLocation(location, where, terminalWidth),
          notes: notesClone,
          detail: stash ? stash.store(detail) : -1
        });
        index++;
      }
      return messagesClone;
    }
    function sanitizeStringArray(values, property) {
      const result = [];
      for (const value of values) {
        if (typeof value !== "string")
          throw new Error(`${quote(property)} must be an array of strings`);
        result.push(value);
      }
      return result;
    }
    function sanitizeStringMap(map, property) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key in map) {
        const value = map[key];
        if (typeof value !== "string")
          throw new Error(`key ${quote(key)} in object ${quote(property)} must be a string`);
        result[key] = value;
      }
      return result;
    }
    function convertOutputFiles({ path: path3, contents, hash }) {
      let text = null;
      return {
        path: path3,
        contents,
        hash,
        get text() {
          const binary = this.contents;
          if (text === null || binary !== contents) {
            contents = binary;
            text = decodeUTF8(binary);
          }
          return text;
        }
      };
    }
    function jsRegExpToGoRegExp(regexp) {
      let result = regexp.source;
      if (regexp.flags)
        result = `(?${regexp.flags})${result}`;
      return result;
    }
    var fs = __require("fs");
    var os3 = __require("os");
    var path = __require("path");
    var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
    var isValidBinaryPath = (x2) => !!x2 && x2 !== "/usr/bin/esbuild";
    var packageDarwin_arm64 = "@esbuild/darwin-arm64";
    var packageDarwin_x64 = "@esbuild/darwin-x64";
    var knownWindowsPackages = {
      "win32 arm64 LE": "@esbuild/win32-arm64",
      "win32 ia32 LE": "@esbuild/win32-ia32",
      "win32 x64 LE": "@esbuild/win32-x64"
    };
    var knownUnixlikePackages = {
      "aix ppc64 BE": "@esbuild/aix-ppc64",
      "android arm64 LE": "@esbuild/android-arm64",
      "darwin arm64 LE": "@esbuild/darwin-arm64",
      "darwin x64 LE": "@esbuild/darwin-x64",
      "freebsd arm64 LE": "@esbuild/freebsd-arm64",
      "freebsd x64 LE": "@esbuild/freebsd-x64",
      "linux arm LE": "@esbuild/linux-arm",
      "linux arm64 LE": "@esbuild/linux-arm64",
      "linux ia32 LE": "@esbuild/linux-ia32",
      "linux mips64el LE": "@esbuild/linux-mips64el",
      "linux ppc64 LE": "@esbuild/linux-ppc64",
      "linux riscv64 LE": "@esbuild/linux-riscv64",
      "linux s390x BE": "@esbuild/linux-s390x",
      "linux x64 LE": "@esbuild/linux-x64",
      "linux loong64 LE": "@esbuild/linux-loong64",
      "netbsd arm64 LE": "@esbuild/netbsd-arm64",
      "netbsd x64 LE": "@esbuild/netbsd-x64",
      "openbsd arm64 LE": "@esbuild/openbsd-arm64",
      "openbsd x64 LE": "@esbuild/openbsd-x64",
      "sunos x64 LE": "@esbuild/sunos-x64"
    };
    var knownWebAssemblyFallbackPackages = {
      "android arm LE": "@esbuild/android-arm",
      "android x64 LE": "@esbuild/android-x64",
      "openharmony arm64 LE": "@esbuild/openharmony-arm64"
    };
    function pkgAndSubpathForCurrentPlatform() {
      let pkg;
      let subpath;
      let isWASM = false;
      let platformKey = `${process.platform} ${os3.arch()} ${os3.endianness()}`;
      if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
      } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
      } else if (platformKey in knownWebAssemblyFallbackPackages) {
        pkg = knownWebAssemblyFallbackPackages[platformKey];
        subpath = "bin/esbuild";
        isWASM = true;
      } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
      }
      return { pkg, subpath, isWASM };
    }
    function pkgForSomeOtherPlatform() {
      const libMainJS = __require.resolve("esbuild");
      const nodeModulesDirectory = path.dirname(path.dirname(path.dirname(libMainJS)));
      if (path.basename(nodeModulesDirectory) === "node_modules") {
        for (const unixKey in knownUnixlikePackages) {
          try {
            const pkg = knownUnixlikePackages[unixKey];
            if (fs.existsSync(path.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
        for (const windowsKey in knownWindowsPackages) {
          try {
            const pkg = knownWindowsPackages[windowsKey];
            if (fs.existsSync(path.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
      }
      return null;
    }
    function downloadedBinPath(pkg, subpath) {
      const esbuildLibDir = path.dirname(__require.resolve("esbuild"));
      return path.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path.basename(subpath)}`);
    }
    function generateBinPath() {
      if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
        if (!fs.existsSync(ESBUILD_BINARY_PATH)) {
          console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
        } else {
          return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
        }
      }
      const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
      let binPath;
      try {
        binPath = __require.resolve(`${pkg}/${subpath}`);
      } catch (e5) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs.existsSync(binPath)) {
          try {
            __require.resolve(pkg);
          } catch {
            const otherPkg = pkgForSomeOtherPlatform();
            if (otherPkg) {
              let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              }
              throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
            }
            throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
          }
          throw e5;
        }
      }
      if (/\.zip\//.test(binPath)) {
        let pnpapi;
        try {
          pnpapi = __require("pnpapi");
        } catch (e5) {
        }
        if (pnpapi) {
          const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
          const binTargetPath = path.join(
            root,
            "node_modules",
            ".cache",
            "esbuild",
            `pnpapi-${pkg.replace("/", "-")}-${"0.25.9"}-${path.basename(subpath)}`
          );
          if (!fs.existsSync(binTargetPath)) {
            fs.mkdirSync(path.dirname(binTargetPath), { recursive: true });
            fs.copyFileSync(binPath, binTargetPath);
            fs.chmodSync(binTargetPath, 493);
          }
          return { binPath: binTargetPath, isWASM };
        }
      }
      return { binPath, isWASM };
    }
    var child_process = __require("child_process");
    var crypto = __require("crypto");
    var path2 = __require("path");
    var fs2 = __require("fs");
    var os22 = __require("os");
    var tty3 = __require("tty");
    var worker_threads;
    if (process.env.ESBUILD_WORKER_THREADS !== "0") {
      try {
        worker_threads = __require("worker_threads");
      } catch {
      }
      let [major, minor] = process.versions.node.split(".");
      if (
        // <v12.17.0 does not work
        +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
      ) {
        worker_threads = void 0;
      }
    }
    var _a;
    var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.25.9";
    var esbuildCommandAndArgs = () => {
      if ((!ESBUILD_BINARY_PATH || false) && (path2.basename(__filename) !== "main.js" || path2.basename(__dirname) !== "lib")) {
        throw new Error(
          `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
        );
      }
      if (false) {
        return ["node", [path2.join(__dirname, "..", "bin", "esbuild")]];
      } else {
        const { binPath, isWASM } = generateBinPath();
        if (isWASM) {
          return ["node", [binPath]];
        } else {
          return [binPath, []];
        }
      }
    };
    var isTTY = () => tty3.isatty(2);
    var fsSync = {
      readFile(tempFile, callback) {
        try {
          let contents = fs2.readFileSync(tempFile, "utf8");
          try {
            fs2.unlinkSync(tempFile);
          } catch {
          }
          callback(null, contents);
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs2.writeFileSync(tempFile, contents);
          callback(tempFile);
        } catch {
          callback(null);
        }
      }
    };
    var fsAsync = {
      readFile(tempFile, callback) {
        try {
          fs2.readFile(tempFile, "utf8", (err, contents) => {
            try {
              fs2.unlink(tempFile, () => callback(err, contents));
            } catch {
              callback(err, contents);
            }
          });
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs2.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
        } catch {
          callback(null);
        }
      }
    };
    var version = "0.25.9";
    var build = (options) => ensureServiceIsRunning().build(options);
    var context2 = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
    var transform = (input, options) => ensureServiceIsRunning().transform(input, options);
    var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);
    var analyzeMetafile = (messages, options) => ensureServiceIsRunning().analyzeMetafile(messages, options);
    var buildSync = (options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options);
      }
      let result;
      runServiceSync((service) => service.buildOrContext({
        callName: "buildSync",
        refs: null,
        options,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var transformSync = (input, options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input, options);
      }
      let result;
      runServiceSync((service) => service.transform({
        callName: "transformSync",
        refs: null,
        input,
        options: options || {},
        isTTY: isTTY(),
        fs: fsSync,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var formatMessagesSync = (messages, options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages, options);
      }
      let result;
      runServiceSync((service) => service.formatMessages({
        callName: "formatMessagesSync",
        refs: null,
        messages,
        options,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var analyzeMetafileSync = (metafile, options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options);
      }
      let result;
      runServiceSync((service) => service.analyzeMetafile({
        callName: "analyzeMetafileSync",
        refs: null,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var stop = () => {
      if (stopService)
        stopService();
      if (workerThreadService)
        workerThreadService.stop();
      return Promise.resolve();
    };
    var initializeWasCalled = false;
    var initialize = (options) => {
      options = validateInitializeOptions(options || {});
      if (options.wasmURL)
        throw new Error(`The "wasmURL" option only works in the browser`);
      if (options.wasmModule)
        throw new Error(`The "wasmModule" option only works in the browser`);
      if (options.worker)
        throw new Error(`The "worker" option only works in the browser`);
      if (initializeWasCalled)
        throw new Error('Cannot call "initialize" more than once');
      ensureServiceIsRunning();
      initializeWasCalled = true;
      return Promise.resolve();
    };
    var defaultWD = process.cwd();
    var longLivedService;
    var stopService;
    var ensureServiceIsRunning = () => {
      if (longLivedService)
        return longLivedService;
      let [command, args] = esbuildCommandAndArgs();
      let child = child_process.spawn(command, args.concat(`--service=${"0.25.9"}`, "--ping"), {
        windowsHide: true,
        stdio: ["pipe", "pipe", "inherit"],
        cwd: defaultWD
      });
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          child.stdin.write(bytes, (err) => {
            if (err)
              afterClose(err);
          });
        },
        readFileSync: fs2.readFileSync,
        isSync: false,
        hasFS: true,
        esbuild: node_exports
      });
      child.stdin.on("error", afterClose);
      child.on("error", afterClose);
      const stdin = child.stdin;
      const stdout = child.stdout;
      stdout.on("data", readFromStdout);
      stdout.on("end", afterClose);
      stopService = () => {
        stdin.destroy();
        stdout.destroy();
        child.kill();
        initializeWasCalled = false;
        longLivedService = void 0;
        stopService = void 0;
      };
      let refCount = 0;
      child.unref();
      if (stdin.unref) {
        stdin.unref();
      }
      if (stdout.unref) {
        stdout.unref();
      }
      const refs = {
        ref() {
          if (++refCount === 1)
            child.ref();
        },
        unref() {
          if (--refCount === 0)
            child.unref();
        }
      };
      longLivedService = {
        build: (options) => new Promise((resolve, reject) => {
          service.buildOrContext({
            callName: "build",
            refs,
            options,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve(res)
          });
        }),
        context: (options) => new Promise((resolve, reject) => service.buildOrContext({
          callName: "context",
          refs,
          options,
          isTTY: isTTY(),
          defaultWD,
          callback: (err, res) => err ? reject(err) : resolve(res)
        })),
        transform: (input, options) => new Promise((resolve, reject) => service.transform({
          callName: "transform",
          refs,
          input,
          options: options || {},
          isTTY: isTTY(),
          fs: fsAsync,
          callback: (err, res) => err ? reject(err) : resolve(res)
        })),
        formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({
          callName: "formatMessages",
          refs,
          messages,
          options,
          callback: (err, res) => err ? reject(err) : resolve(res)
        })),
        analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({
          callName: "analyzeMetafile",
          refs,
          metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
          options,
          callback: (err, res) => err ? reject(err) : resolve(res)
        }))
      };
      return longLivedService;
    };
    var runServiceSync = (callback) => {
      let [command, args] = esbuildCommandAndArgs();
      let stdin = new Uint8Array();
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          if (stdin.length !== 0)
            throw new Error("Must run at most one command");
          stdin = bytes;
        },
        isSync: true,
        hasFS: true,
        esbuild: node_exports
      });
      callback(service);
      let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.25.9"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        // We don't know how large the output could be. If it's too large, the
        // command will fail with ENOBUFS. Reserve 16mb for now since that feels
        // like it should be enough. Also allow overriding this with an environment
        // variable.
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
      });
      readFromStdout(stdout);
      afterClose(null);
    };
    var randomFileName = () => {
      return path2.join(os22.tmpdir(), `esbuild-${crypto.randomBytes(32).toString("hex")}`);
    };
    var workerThreadService = null;
    var startWorkerThreadService = (worker_threads2) => {
      let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
      let worker = new worker_threads2.Worker(__filename, {
        workerData: { workerPort, defaultWD, esbuildVersion: "0.25.9" },
        transferList: [workerPort],
        // From node's documentation: https://nodejs.org/api/worker_threads.html
        //
        //   Take care when launching worker threads from preload scripts (scripts loaded
        //   and run using the `-r` command line flag). Unless the `execArgv` option is
        //   explicitly set, new Worker threads automatically inherit the command line flags
        //   from the running process and will preload the same preload scripts as the main
        //   thread. If the preload script unconditionally launches a worker thread, every
        //   thread spawned will spawn another until the application crashes.
        //
        execArgv: []
      });
      let nextID = 0;
      let fakeBuildError = (text) => {
        let error = new Error(`Build failed with 1 error:
error: ${text}`);
        let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
        error.errors = errors;
        error.warnings = [];
        return error;
      };
      let validateBuildSyncOptions = (options) => {
        if (!options)
          return;
        let plugins = options.plugins;
        if (plugins && plugins.length > 0)
          throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
      };
      let applyProperties = (object, properties) => {
        for (let key in properties) {
          object[key] = properties[key];
        }
      };
      let runCallSync = (command, args) => {
        let id = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = { sharedBuffer, id, command, args };
        worker.postMessage(msg);
        let status = Atomics.wait(sharedBufferView, 0, 0);
        if (status !== "ok" && status !== "not-equal")
          throw new Error("Internal error: Atomics.wait() failed: " + status);
        let { message: { id: id2, resolve, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id !== id2)
          throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        if (reject) {
          applyProperties(reject, properties);
          throw reject;
        }
        return resolve;
      };
      worker.unref();
      return {
        buildSync(options) {
          validateBuildSyncOptions(options);
          return runCallSync("build", [options]);
        },
        transformSync(input, options) {
          return runCallSync("transform", [input, options]);
        },
        formatMessagesSync(messages, options) {
          return runCallSync("formatMessages", [messages, options]);
        },
        analyzeMetafileSync(metafile, options) {
          return runCallSync("analyzeMetafile", [metafile, options]);
        },
        stop() {
          worker.terminate();
          workerThreadService = null;
        }
      };
    };
    var startSyncServiceWorker = () => {
      let workerPort = worker_threads.workerData.workerPort;
      let parentPort = worker_threads.parentPort;
      let extractProperties = (object) => {
        let properties = {};
        if (object && typeof object === "object") {
          for (let key in object) {
            properties[key] = object[key];
          }
        }
        return properties;
      };
      try {
        let service = ensureServiceIsRunning();
        defaultWD = worker_threads.workerData.defaultWD;
        parentPort.on("message", (msg) => {
          (async () => {
            let { sharedBuffer, id, command, args } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            try {
              switch (command) {
                case "build":
                  workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                  break;
                case "transform":
                  workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                  break;
                case "formatMessages":
                  workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                  break;
                case "analyzeMetafile":
                  workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                  break;
                default:
                  throw new Error(`Invalid command: ${command}`);
              }
            } catch (reject) {
              workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
            }
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          })();
        });
      } catch (reject) {
        parentPort.on("message", (msg) => {
          let { sharedBuffer, id } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        });
      }
    };
    if (isInternalWorkerThread) {
      startSyncServiceWorker();
    }
    var node_default = node_exports;
  }
});

// 
var lexer_DQCqS3nf_exports = {};
__export(lexer_DQCqS3nf_exports, {
  ImportType: () => L,
  init: () => G2,
  parse: () => F
});
function F(A3, E6 = "@") {
  if (!Q2)
    return G2.then(() => F(A3));
  const g2 = A3.length + 1, B3 = (Q2.__heap_base.value || Q2.__heap_base) + 4 * g2 - Q2.memory.buffer.byteLength;
  B3 > 0 && Q2.memory.grow(Math.ceil(B3 / 65536));
  const s5 = Q2.sa(g2 - 1);
  if ((R3 ? c : r2)(A3, new Uint16Array(Q2.memory.buffer, s5, g2)), !Q2.parse())
    throw Object.assign(new Error(`Parse error ${E6}:${A3.slice(0, Q2.e()).split(`
`).length}:${Q2.e() - A3.lastIndexOf(`
`, Q2.e() - 1)}`), { idx: Q2.e() });
  const U3 = [], t3 = [];
  for (; Q2.ri(); ) {
    const C4 = Q2.is(), I4 = Q2.ie(), D3 = Q2.it(), i6 = Q2.ai(), w4 = Q2.id(), J3 = Q2.ss(), K4 = Q2.se();
    let o8;
    Q2.ip() && (o8 = N2(A3.slice(w4 === -1 ? C4 - 1 : C4, w4 === -1 ? I4 + 1 : I4))), U3.push({ n: o8, t: D3, s: C4, e: I4, ss: J3, se: K4, d: w4, a: i6 });
  }
  for (; Q2.re(); ) {
    const C4 = Q2.es(), I4 = Q2.ee(), D3 = Q2.els(), i6 = Q2.ele(), w4 = A3.slice(C4, I4), J3 = w4[0], K4 = D3 < 0 ? void 0 : A3.slice(D3, i6), o8 = K4 ? K4[0] : "";
    t3.push({ s: C4, e: I4, ls: D3, le: i6, n: J3 === '"' || J3 === "'" ? N2(w4) : w4, ln: o8 === '"' || o8 === "'" ? N2(K4) : K4 });
  }
  function N2(C4) {
    try {
      return (0, eval)(C4);
    } catch {
    }
  }
  return k(N2, "k"), [U3, t3, !!Q2.f(), !!Q2.ms()];
}
function r2(A3, E6) {
  const g2 = A3.length;
  let B3 = 0;
  for (; B3 < g2; ) {
    const s5 = A3.charCodeAt(B3);
    E6[B3++] = (255 & s5) << 8 | s5 >>> 8;
  }
}
function c(A3, E6) {
  const g2 = A3.length;
  let B3 = 0;
  for (; B3 < g2; )
    E6[B3] = A3.charCodeAt(B3++);
}
var Y2, k, L, R3, Q2, G2, a3;
var init_lexer_DQCqS3nf = __esm({
  ""() {
    Y2 = Object.defineProperty;
    k = (A3, E6) => Y2(A3, "name", { value: E6, configurable: true });
    (function(A3) {
      A3[A3.Static = 1] = "Static", A3[A3.Dynamic = 2] = "Dynamic", A3[A3.ImportMeta = 3] = "ImportMeta", A3[A3.StaticSourcePhase = 4] = "StaticSourcePhase", A3[A3.DynamicSourcePhase = 5] = "DynamicSourcePhase";
    })(L || (L = {}));
    R3 = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
    k(F, "parse");
    k(r2, "Q");
    k(c, "B");
    G2 = WebAssembly.compile((a3 = "AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKm0EwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQvcCAEGf0EAIQBBAEEAKAKwCiIBQQxqIgI2ArAKQQEQKSEDQQAoArAKIQQCQAJAAkACQAJAAkACQAJAIANBLkcNAEEAIARBAmo2ArAKAkBBARApIgNB8wBGDQAgA0HtAEcNB0EAKAKwCiIDQQJqQZwIQQYQLw0HAkBBACgCnAoiBBAqDQAgBC8BAEEuRg0ICyABIAEgA0EIakEAKALUCRABDwtBACgCsAoiA0ECakGiCEEKEC8NBgJAQQAoApwKIgQQKg0AIAQvAQBBLkYNBwsgA0EMaiEDDAELIANB8wBHDQEgBCACTQ0BQQYhAEEAIQIgBEECakGiCEEKEC8NAiAEQQxqIQMCQCAELwEMIgVBd2oiBEEXSw0AQQEgBHRBn4CABHENAQsgBUGgAUcNAgtBACADNgKwCkEBIQBBARApIQMLAkACQAJAAkAgA0H7AEYNACADQShHDQFBACgCpApBAC8BmAoiA0EDdGoiBEEAKAKwCjYCBEEAIANBAWo7AZgKIARBBTYCAEEAKAKcCi8BAEEuRg0HQQBBACgCsAoiBEECajYCsApBARApIQMgAUEAKAKwCkEAIAQQAQJAAkAgAA0AQQAoAvAJIQQMAQtBACgC8AkiBEEFNgIcC0EAQQAvAZYKIgBBAWo7AZYKQQAoAqgKIABBAnRqIAQ2AgACQCADQSJGDQAgA0EnRg0AQQBBACgCsApBfmo2ArAKDwsgAxAaQQBBACgCsApBAmoiAzYCsAoCQAJAAkBBARApQVdqDgQBAgIAAgtBAEEAKAKwCkECajYCsApBARApGkEAKALwCSIEIAM2AgQgBEEBOgAYIARBACgCsAoiAzYCEEEAIANBfmo2ArAKDwtBACgC8AkiBCADNgIEIARBAToAGEEAQQAvAZgKQX9qOwGYCiAEQQAoArAKQQJqNgIMQQBBAC8BlgpBf2o7AZYKDwtBAEEAKAKwCkF+ajYCsAoPCyAADQJBACgCsAohA0EALwGYCg0BA0ACQAJAAkAgA0EAKAK0Ck8NAEEBECkiA0EiRg0BIANBJ0YNASADQf0ARw0CQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0JC0EAIANBCGo2ArAKAkBBARApIgNBIkYNACADQSdHDQkLIAEgA0EAECsPCyADEBoLQQBBACgCsApBAmoiAzYCsAoMAAsLIAANAUEGIQBBACECAkAgA0FZag4EBAMDBAALIANBIkYNAwwCC0EAIANBfmo2ArAKDwtBDCEAQQEhAgtBACgCsAoiAyABIABBAXRqRw0AQQAgA0F+ajYCsAoPC0EALwGYCg0CQQAoArAKIQNBACgCtAohAANAIAMgAE8NAQJAAkAgAy8BACIEQSdGDQAgBEEiRw0BCyABIAQgAhArDwtBACADQQJqIgM2ArAKDAALCxAlCw8LQQBBACgCsApBfmo2ArAKC0cBA39BACgCsApBAmohAEEAKAK0CiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2ArAKC5gBAQN/QQBBACgCsAoiAUECajYCsAogAUEGaiEBQQAoArQKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2ArAKDAELIAFBfmohAQtBACABNgKwCg8LIAFBAmohAQwACwuIAQEEf0EAKAKwCiEBQQAoArQKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKwChAlDwtBACABNgKwCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQaYJQQUQHQ0AIABBlghBAxAdDQAgAEGwCUECEB0hAQsgAQtGAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC3AkiBUkNACAAIAEgAhAvDQACQCAAIAVHDQBBAQ8LIAQQJiEDCyADC4MBAQJ/QQEhAQJAAkACQAJAAkACQCAALwEAIgJBRWoOBAUEBAEACwJAIAJBm39qDgQDBAQCAAsgAkEpRg0EIAJB+QBHDQMgAEF+akG8CUEGEB0PCyAAQX5qLwEAQT1GDwsgAEF+akG0CUEEEB0PCyAAQX5qQcgJQQMQHQ8LQQAhAQsgAQu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQcoIQQIQHQ8LIABBfGpBzghBAxAdDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAnDwsgAEF6akHjABAnDwsgAEF8akHUCEEEEB0PCyAAQXxqQdwIQQYQHQ8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB6AhBBhAdDwsgAEF4akH0CEECEB0PCyAAQX5qQfgIQQQQHQ8LQQEhASAAQX5qIgBB6QAQJw0EIABBgAlBBRAdDwsgAEF+akHkABAnDwsgAEF+akGKCUEHEB0PCyAAQX5qQZgJQQQQHQ8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAnDwsgAEF8akGgCUEDEB0hAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAocSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akH4CEEEEB0PCyAAQX5qLwEAQfUARw0AIABBfGpB3AhBBhAdIQELIAEL3gEBBH9BACgCsAohAEEAKAK0CiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2ArAKQQBBAC8BmAoiAkEBajsBmApBACgCpAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCsApBAEEALwGYCkF/aiIAOwGYCkEAKAKkCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2ArAKCxAlCwtwAQJ/AkACQANAQQBBACgCsAoiAEECaiIBNgKwCiAAQQAoArQKTw0BAkACQAJAIAEvAQAiAUGlf2oOAgECAAsCQCABQXZqDgQEAwMEAAsgAUEvRw0CDAQLEC4aDAELQQAgAEEEajYCsAoMAAsLECULCzUBAX9BAEEBOgD8CUEAKAKwCiEAQQBBACgCtApBAmo2ArAKQQAgAEEAKALcCWtBAXU2ApAKC0MBAn9BASEBAkAgAC8BACICQXdqQf//A3FBBUkNACACQYABckGgAUYNAEEAIQEgAhAoRQ0AIAJBLkcgABAqcg8LIAELPQECf0EAIQICQEEAKALcCSIDIABLDQAgAC8BACABRw0AAkAgAyAARw0AQQEPCyAAQX5qLwEAECAhAgsgAgtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQucAQEDf0EAKAKwCiEBAkADQAJAAkAgAS8BACICQS9HDQACQCABLwECIgFBKkYNACABQS9HDQQQGAwCCyAAEBkMAQsCQAJAIABFDQAgAkF3aiIBQRdLDQFBASABdEGfgIAEcUUNAQwCCyACECFFDQMMAQsgAkGgAUcNAgtBAEEAKAKwCiIDQQJqIgE2ArAKIANBACgCtApJDQALCyACCzEBAX9BACEBAkAgAC8BAEEuRw0AIABBfmovAQBBLkcNACAAQXxqLwEAQS5GIQELIAELnAQBAX8CQCABQSJGDQAgAUEnRg0AECUPC0EAKAKwCiEDIAEQGiAAIANBAmpBACgCsApBACgC0AkQAQJAIAJFDQBBACgC8AlBBDYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQAMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhACABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIABBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiAiEAA0BBACAAQQJqNgKwCgJAAkACQEEBECkiAEEiRg0AIABBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQAMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSEADAELIAAQLCEACwJAIABBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAEEiRg0AIABBJ0YNAEEAIAE2ArAKDwsgABAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAEEsRg0AIABB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiEADAELC0EAKALwCSIBIAI2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=", typeof Buffer < "u" ? Buffer.from(a3, "base64") : Uint8Array.from(atob(a3), (A3) => A3.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A3 }) => {
      Q2 = A3;
    });
  }
});

// 
var require_constants4 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// 
var require_debug = __commonJS({
  ""(exports, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// 
var require_re = __commonJS({
  ""(exports, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants4();
    var debug = require_debug();
    exports = module2.exports = {};
    var re3 = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t3 = exports.t = {};
    var R6 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R6++;
      debug(name, index, value);
      t3[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re3[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t3.NUMERICIDENTIFIER]})\\.(${src[t3.NUMERICIDENTIFIER]})\\.(${src[t3.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src[t3.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t3.NONNUMERICIDENTIFIER]}|${src[t3.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t3.NONNUMERICIDENTIFIER]}|${src[t3.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t3.PRERELEASEIDENTIFIER]}(?:\\.${src[t3.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t3.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t3.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t3.BUILDIDENTIFIER]}(?:\\.${src[t3.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t3.MAINVERSION]}${src[t3.PRERELEASE]}?${src[t3.BUILD]}?`);
    createToken("FULL", `^${src[t3.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t3.MAINVERSIONLOOSE]}${src[t3.PRERELEASELOOSE]}?${src[t3.BUILD]}?`);
    createToken("LOOSE", `^${src[t3.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t3.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t3.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t3.XRANGEIDENTIFIER]})(?:\\.(${src[t3.XRANGEIDENTIFIER]})(?:\\.(${src[t3.XRANGEIDENTIFIER]})(?:${src[t3.PRERELEASE]})?${src[t3.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:${src[t3.PRERELEASELOOSE]})?${src[t3.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t3.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t3.COERCEPLAIN] + `(?:${src[t3.PRERELEASE]})?(?:${src[t3.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t3.COERCE], true);
    createToken("COERCERTLFULL", src[t3.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t3.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t3.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t3.GTLT]}\\s*(${src[t3.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]}|${src[t3.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t3.XRANGEPLAIN]})\\s+-\\s+(${src[t3.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t3.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t3.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// 
var require_parse_options = __commonJS({
  ""(exports, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// 
var require_identifiers = __commonJS({
  ""(exports, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a7, b3) => {
      const anum = numeric.test(a7);
      const bnum = numeric.test(b3);
      if (anum && bnum) {
        a7 = +a7;
        b3 = +b3;
      }
      return a7 === b3 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a7 < b3 ? -1 : 1;
    };
    var rcompareIdentifiers = (a7, b3) => compareIdentifiers(b3, a7);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// 
var require_semver = __commonJS({
  ""(exports, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants4();
    var { safeRe: re3, t: t3 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m8 = version.trim().match(options.loose ? re3[t3.LOOSE] : re3[t3.FULL]);
        if (!m8) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m8[1];
        this.minor = +m8[2];
        this.patch = +m8[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m8[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m8[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m8[5] ? m8[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i6 = 0;
        do {
          const a7 = this.prerelease[i6];
          const b3 = other.prerelease[i6];
          debug("prerelease compare", i6, a7, b3);
          if (a7 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a7 === void 0) {
            return -1;
          } else if (a7 === b3) {
            continue;
          } else {
            return compareIdentifiers(a7, b3);
          }
        } while (++i6);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i6 = 0;
        do {
          const a7 = this.build[i6];
          const b3 = other.build[i6];
          debug("build compare", i6, a7, b3);
          if (a7 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a7 === void 0) {
            return -1;
          } else if (a7 === b3) {
            continue;
          } else {
            return compareIdentifiers(a7, b3);
          }
        } while (++i6);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re3[t3.PRERELEASELOOSE] : re3[t3.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i6 = this.prerelease.length;
              while (--i6 >= 0) {
                if (typeof this.prerelease[i6] === "number") {
                  this.prerelease[i6]++;
                  i6 = -2;
                }
              }
              if (i6 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// 
var require_parse3 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er2) {
        if (!throwErrors) {
          return null;
        }
        throw er2;
      }
    };
    module2.exports = parse2;
  }
});

// 
var require_valid = __commonJS({
  ""(exports, module2) {
    "use strict";
    var parse2 = require_parse3();
    var valid = (version, options) => {
      const v4 = parse2(version, options);
      return v4 ? v4.version : null;
    };
    module2.exports = valid;
  }
});

// 
var require_clean = __commonJS({
  ""(exports, module2) {
    "use strict";
    var parse2 = require_parse3();
    var clean = (version, options) => {
      const s5 = parse2(version.trim().replace(/^[=v]+/, ""), options);
      return s5 ? s5.version : null;
    };
    module2.exports = clean;
  }
});

// 
var require_inc = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er2) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// 
var require_diff = __commonJS({
  ""(exports, module2) {
    "use strict";
    var parse2 = require_parse3();
    var diff = (version1, version2) => {
      const v1 = parse2(version1, null, true);
      const v22 = parse2(version2, null, true);
      const comparison = v1.compare(v22);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v22;
      const lowVersion = v1Higher ? v22 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v22.major) {
        return prefix + "major";
      }
      if (v1.minor !== v22.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v22.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// 
var require_major = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a7, loose) => new SemVer(a7, loose).major;
    module2.exports = major;
  }
});

// 
var require_minor = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a7, loose) => new SemVer(a7, loose).minor;
    module2.exports = minor;
  }
});

// 
var require_patch = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a7, loose) => new SemVer(a7, loose).patch;
    module2.exports = patch;
  }
});

// 
var require_prerelease = __commonJS({
  ""(exports, module2) {
    "use strict";
    var parse2 = require_parse3();
    var prerelease = (version, options) => {
      const parsed = parse2(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// 
var require_compare = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a7, b3, loose) => new SemVer(a7, loose).compare(new SemVer(b3, loose));
    module2.exports = compare;
  }
});

// 
var require_rcompare = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a7, b3, loose) => compare(b3, a7, loose);
    module2.exports = rcompare;
  }
});

// 
var require_compare_loose = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a7, b3) => compare(a7, b3, true);
    module2.exports = compareLoose;
  }
});

// 
var require_compare_build = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a7, b3, loose) => {
      const versionA = new SemVer(a7, loose);
      const versionB = new SemVer(b3, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// 
var require_sort = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a7, b3) => compareBuild(a7, b3, loose));
    module2.exports = sort;
  }
});

// 
var require_rsort = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a7, b3) => compareBuild(b3, a7, loose));
    module2.exports = rsort;
  }
});

// 
var require_gt = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compare = require_compare();
    var gt2 = (a7, b3, loose) => compare(a7, b3, loose) > 0;
    module2.exports = gt2;
  }
});

// 
var require_lt = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compare = require_compare();
    var lt2 = (a7, b3, loose) => compare(a7, b3, loose) < 0;
    module2.exports = lt2;
  }
});

// 
var require_eq = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a7, b3, loose) => compare(a7, b3, loose) === 0;
    module2.exports = eq;
  }
});

// 
var require_neq = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a7, b3, loose) => compare(a7, b3, loose) !== 0;
    module2.exports = neq;
  }
});

// 
var require_gte = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a7, b3, loose) => compare(a7, b3, loose) >= 0;
    module2.exports = gte;
  }
});

// 
var require_lte = __commonJS({
  ""(exports, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a7, b3, loose) => compare(a7, b3, loose) <= 0;
    module2.exports = lte;
  }
});

// 
var require_cmp = __commonJS({
  ""(exports, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt2 = require_gt();
    var gte = require_gte();
    var lt2 = require_lt();
    var lte = require_lte();
    var cmp = (a7, op, b3, loose) => {
      switch (op) {
        case "===":
          if (typeof a7 === "object") {
            a7 = a7.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a7 === b3;
        case "!==":
          if (typeof a7 === "object") {
            a7 = a7.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a7 !== b3;
        case "":
        case "=":
        case "==":
          return eq(a7, b3, loose);
        case "!=":
          return neq(a7, b3, loose);
        case ">":
          return gt2(a7, b3, loose);
        case ">=":
          return gte(a7, b3, loose);
        case "<":
          return lt2(a7, b3, loose);
        case "<=":
          return lte(a7, b3, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// 
var require_coerce = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = require_parse3();
    var { safeRe: re3, t: t3 } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re3[t3.COERCEFULL] : re3[t3.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re3[t3.COERCERTLFULL] : re3[t3.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// 
var require_lrucache = __commonJS({
  ""(exports, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// 
var require_range = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r3) => this.parseRange(r3.trim())).filter((c3) => c3.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c3) => !isNullSet(c3[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c3 of this.set) {
              if (c3.length === 1 && isAny(c3[0])) {
                this.set = [c3];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i6 = 0; i6 < this.set.length; i6++) {
            if (i6 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i6];
            for (let k3 = 0; k3 < comps.length; k3++) {
              if (k3 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k3].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr2 = loose ? re3[t3.HYPHENRANGELOOSE] : re3[t3.HYPHENRANGE];
        range = range.replace(hr2, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re3[t3.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re3[t3.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re3[t3.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re3[t3.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er2) {
            return false;
          }
        }
        for (let i6 = 0; i6 < this.set.length; i6++) {
          if (testSet(this.set[i6], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re3,
      t: t3,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants4();
    var isNullSet = (c3) => c3.value === "<0.0.0-0";
    var isAny = (c3) => c3.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c3) => replaceTilde(c3, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r3 = options.loose ? re3[t3.TILDELOOSE] : re3[t3.TILDE];
      return comp.replace(r3, (_4, M3, m8, p5, pr) => {
        debug("tilde", comp, _4, M3, m8, p5, pr);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m8)) {
          ret = `>=${M3}.0.0 <${+M3 + 1}.0.0-0`;
        } else if (isX(p5)) {
          ret = `>=${M3}.${m8}.0 <${M3}.${+m8 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M3}.${m8}.${p5}-${pr} <${M3}.${+m8 + 1}.0-0`;
        } else {
          ret = `>=${M3}.${m8}.${p5} <${M3}.${+m8 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c3) => replaceCaret(c3, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r3 = options.loose ? re3[t3.CARETLOOSE] : re3[t3.CARET];
      const z3 = options.includePrerelease ? "-0" : "";
      return comp.replace(r3, (_4, M3, m8, p5, pr) => {
        debug("caret", comp, _4, M3, m8, p5, pr);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m8)) {
          ret = `>=${M3}.0.0${z3} <${+M3 + 1}.0.0-0`;
        } else if (isX(p5)) {
          if (M3 === "0") {
            ret = `>=${M3}.${m8}.0${z3} <${M3}.${+m8 + 1}.0-0`;
          } else {
            ret = `>=${M3}.${m8}.0${z3} <${+M3 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M3 === "0") {
            if (m8 === "0") {
              ret = `>=${M3}.${m8}.${p5}-${pr} <${M3}.${m8}.${+p5 + 1}-0`;
            } else {
              ret = `>=${M3}.${m8}.${p5}-${pr} <${M3}.${+m8 + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m8}.${p5}-${pr} <${+M3 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M3 === "0") {
            if (m8 === "0") {
              ret = `>=${M3}.${m8}.${p5}${z3} <${M3}.${m8}.${+p5 + 1}-0`;
            } else {
              ret = `>=${M3}.${m8}.${p5}${z3} <${M3}.${+m8 + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m8}.${p5} <${+M3 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c3) => replaceXRange(c3, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r3 = options.loose ? re3[t3.XRANGELOOSE] : re3[t3.XRANGE];
      return comp.replace(r3, (ret, gtlt, M3, m8, p5, pr) => {
        debug("xRange", comp, ret, gtlt, M3, m8, p5, pr);
        const xM = isX(M3);
        const xm = xM || isX(m8);
        const xp = xm || isX(p5);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m8 = 0;
          }
          p5 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M3 = +M3 + 1;
              m8 = 0;
              p5 = 0;
            } else {
              m8 = +m8 + 1;
              p5 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M3 = +M3 + 1;
            } else {
              m8 = +m8 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M3}.${m8}.${p5}${pr}`;
        } else if (xm) {
          ret = `>=${M3}.0.0${pr} <${+M3 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M3}.${m8}.0${pr} <${M3}.${+m8 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re3[t3.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re3[options.includePrerelease ? t3.GTE0PRE : t3.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i6 = 0; i6 < set.length; i6++) {
        if (!set[i6].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i6 = 0; i6 < set.length; i6++) {
          debug(set[i6].semver);
          if (set[i6].semver === Comparator.ANY) {
            continue;
          }
          if (set[i6].semver.prerelease.length > 0) {
            const allowed = set[i6].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// 
var require_comparator = __commonJS({
  ""(exports, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r3 = this.options.loose ? re3[t3.COMPARATORLOOSE] : re3[t3.COMPARATOR];
        const m8 = comp.match(r3);
        if (!m8) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m8[1] !== void 0 ? m8[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m8[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m8[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er2) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re3, t: t3 } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// 
var require_satisfies = __commonJS({
  ""(exports, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er2) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// 
var require_to_comparators = __commonJS({
  ""(exports, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c3) => c3.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// 
var require_max_satisfying = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er2) {
        return null;
      }
      versions.forEach((v4) => {
        if (rangeObj.test(v4)) {
          if (!max || maxSV.compare(v4) === -1) {
            max = v4;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// 
var require_min_satisfying = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er2) {
        return null;
      }
      versions.forEach((v4) => {
        if (rangeObj.test(v4)) {
          if (!min || minSV.compare(v4) === 1) {
            min = v4;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// 
var require_min_version = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt2 = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i6 = 0; i6 < range.set.length; ++i6) {
        const comparators = range.set[i6];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt2(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt2(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// 
var require_valid2 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er2) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// 
var require_outside = __commonJS({
  ""(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt2 = require_gt();
    var lt2 = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt2;
          ltefn = lte;
          ltfn = lt2;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt2;
          ltefn = gte;
          ltfn = gt2;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i6 = 0; i6 < range.set.length; ++i6) {
        const comparators = range.set[i6];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// 
var require_gtr = __commonJS({
  ""(exports, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// 
var require_ltr = __commonJS({
  ""(exports, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// 
var require_intersects = __commonJS({
  ""(exports, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module2.exports = intersects;
  }
});

// 
var require_simplify = __commonJS({
  ""(exports, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v4 = versions.sort((a7, b3) => compare(a7, b3, options));
      for (const version of v4) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v4[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v4[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// 
var require_subset = __commonJS({
  ""(exports, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt2, lt2;
      for (const c3 of sub) {
        if (c3.operator === ">" || c3.operator === ">=") {
          gt2 = higherGT(gt2, c3, options);
        } else if (c3.operator === "<" || c3.operator === "<=") {
          lt2 = lowerLT(lt2, c3, options);
        } else {
          eqSet.add(c3.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt2 && lt2) {
        gtltComp = compare(gt2.semver, lt2.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt2 && !satisfies(eq, String(gt2), options)) {
          return null;
        }
        if (lt2 && !satisfies(eq, String(lt2), options)) {
          return null;
        }
        for (const c3 of dom) {
          if (!satisfies(eq, String(c3), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
      let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c3 of dom) {
        hasDomGT = hasDomGT || c3.operator === ">" || c3.operator === ">=";
        hasDomLT = hasDomLT || c3.operator === "<" || c3.operator === "<=";
        if (gt2) {
          if (needDomGTPre) {
            if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomGTPre.major && c3.semver.minor === needDomGTPre.minor && c3.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c3.operator === ">" || c3.operator === ">=") {
            higher = higherGT(gt2, c3, options);
            if (higher === c3 && higher !== gt2) {
              return false;
            }
          } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c3), options)) {
            return false;
          }
        }
        if (lt2) {
          if (needDomLTPre) {
            if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomLTPre.major && c3.semver.minor === needDomLTPre.minor && c3.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c3.operator === "<" || c3.operator === "<=") {
            lower = lowerLT(lt2, c3, options);
            if (lower === c3 && lower !== lt2) {
              return false;
            }
          } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c3), options)) {
            return false;
          }
        }
        if (!c3.operator && (lt2 || gt2) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
        return false;
      }
      if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a7, b3, options) => {
      if (!a7) {
        return b3;
      }
      const comp = compare(a7.semver, b3.semver, options);
      return comp > 0 ? a7 : comp < 0 ? b3 : b3.operator === ">" && a7.operator === ">=" ? b3 : a7;
    };
    var lowerLT = (a7, b3, options) => {
      if (!a7) {
        return b3;
      }
      const comp = compare(a7.semver, b3.semver, options);
      return comp < 0 ? a7 : comp > 0 ? b3 : b3.operator === "<" && a7.operator === "<=" ? b3 : a7;
    };
    module2.exports = subset;
  }
});

// 
var require_semver2 = __commonJS({
  ""(exports, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants4();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse3();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt2 = require_gt();
    var lt2 = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt: gt2,
      lt: lt2,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// 
var require_dist = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphQLType = void 0;
    (function(GraphQLType) {
      GraphQLType[GraphQLType["SCALAR"] = 0] = "SCALAR";
      GraphQLType[GraphQLType["INLINE_FRAGMENT"] = 1] = "INLINE_FRAGMENT";
      GraphQLType[GraphQLType["FRAGMENT"] = 2] = "FRAGMENT";
    })(exports.GraphQLType || (exports.GraphQLType = {}));
    var typeSymbol = Symbol("GraphQL Type");
    var paramsSymbol = Symbol("GraphQL Params");
    function isInlineFragmentObject(value) {
      return typeof value === "object" && value !== null && value[typeSymbol] === exports.GraphQLType.INLINE_FRAGMENT;
    }
    function isFragmentObject(value) {
      return typeof value === "object" && value !== null && value[typeSymbol] === exports.GraphQLType.FRAGMENT;
    }
    function isScalarObject(value) {
      return typeof value === "object" && value !== null && value[typeSymbol] === exports.GraphQLType.SCALAR;
    }
    function renderName(name) {
      return name === void 0 ? "" : name;
    }
    function renderParams(params3, brackets, array) {
      if (brackets === void 0) {
        brackets = true;
      }
      if (array === void 0) {
        array = false;
      }
      if (!params3) {
        return "";
      }
      var builder = [];
      for (var _i = 0, _a = Object.entries(params3); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        var params_1 = void 0;
        if (value === null) {
          params_1 = "null";
        } else if (Array.isArray(value)) {
          params_1 = "[".concat(renderParams(value, false, true), "]");
        } else if (typeof value === "object") {
          params_1 = "{".concat(renderParams(value, false), "}");
        } else {
          params_1 = "".concat(value);
        }
        builder.push(array ? "".concat(params_1) : "".concat(key, ":").concat(params_1));
      }
      var built = builder.join(",");
      if (brackets) {
        built = "(".concat(built, ")");
      }
      return built;
    }
    function renderScalar(name, params3) {
      return renderName(name) + renderParams(params3);
    }
    function renderInlineFragment(fragment2, context2) {
      return "...on ".concat(fragment2.typeName).concat(renderObject(void 0, fragment2.internal, context2));
    }
    function renderFragment(fragment2, context2) {
      return "fragment ".concat(fragment2.name, " on ").concat(fragment2.typeName).concat(renderObject(void 0, fragment2.internal, context2));
    }
    function renderArray(name, arr, context2) {
      var first = arr[0];
      if (first === void 0 || first === null) {
        throw new Error("Cannot render array with no first value");
      }
      first[paramsSymbol] = arr[paramsSymbol];
      return renderType(name, first, context2);
    }
    function renderType(name, value, context2) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
          throw new Error("Rendering type ".concat(typeof value, " directly is disallowed"));
        case "object":
          if (value === null) {
            throw new Error("Cannot render null");
          }
          if (isScalarObject(value)) {
            return "".concat(renderScalar(name, value[paramsSymbol]), " ");
          } else if (Array.isArray(value)) {
            return renderArray(name, value, context2);
          } else {
            return renderObject(name, value, context2);
          }
        case "undefined":
          return "";
        default:
          throw new Error("Cannot render type ".concat(typeof value));
      }
    }
    function renderObject(name, obj, context2) {
      var fields = [];
      for (var _i = 0, _a = Object.entries(obj); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        fields.push(renderType(key, value, context2));
      }
      for (var _c = 0, _d = Object.getOwnPropertySymbols(obj); _c < _d.length; _c++) {
        var sym = _d[_c];
        var value = obj[sym];
        if (isInlineFragmentObject(value)) {
          fields.push(renderInlineFragment(value, context2));
        } else if (isFragmentObject(value)) {
          context2.fragments.set(sym, value);
          fields.push("...".concat(value.name));
        }
      }
      if (fields.length === 0) {
        throw new Error("Object cannot have no fields");
      }
      return "".concat(renderName(name)).concat(renderParams(obj[paramsSymbol]), "{").concat(fields.join("").trim(), "}");
    }
    function render(value) {
      var context2 = {
        fragments: /* @__PURE__ */ new Map()
      };
      var rend = renderObject(void 0, value, context2);
      var rendered = /* @__PURE__ */ new Map();
      var executingContext = context2;
      var currentContext = {
        // The current context for execution.
        fragments: /* @__PURE__ */ new Map()
      };
      while (executingContext.fragments.size > 0) {
        for (var _i = 0, _a = Array.from(executingContext.fragments.entries()); _i < _a.length; _i++) {
          var _b = _a[_i], sym = _b[0], fragment2 = _b[1];
          if (!rendered.has(sym)) {
            rendered.set(sym, renderFragment(fragment2, currentContext));
          }
        }
        executingContext = currentContext;
        currentContext = {
          // Reset current context.
          fragments: /* @__PURE__ */ new Map()
        };
      }
      return rend + Array.from(rendered.values()).join("");
    }
    function fragmentToString(value) {
      var context2 = {
        fragments: /* @__PURE__ */ new Map()
      };
      renderObject(void 0, value, context2);
      var currentContext = {
        // The current context for execution.
        fragments: /* @__PURE__ */ new Map()
      };
      var output = "";
      for (var _i = 0, _a = Array.from(context2.fragments.entries()); _i < _a.length; _i++) {
        var _b = _a[_i], fragment2 = _b[1];
        output = output + renderFragment(fragment2, currentContext);
      }
      return output;
    }
    function createOperate(operateType) {
      function operate(opNameOrQueryObject, queryObject) {
        if (typeof opNameOrQueryObject === "string") {
          if (!queryObject) {
            throw new Error("queryObject is not set");
          }
          return {
            toString: function() {
              return "".concat(operateType, " ").concat(opNameOrQueryObject).concat(render(queryObject));
            }
          };
        }
        return {
          toString: function() {
            return "".concat(operateType).concat(render(opNameOrQueryObject));
          }
        };
      }
      return operate;
    }
    var query2 = createOperate("query");
    var mutation = createOperate("mutation");
    var subscription = createOperate("subscription");
    function params2(params3, input) {
      if (typeof params3 !== "object") {
        throw new Error("Params have to be an object");
      }
      if (typeof input !== "object") {
        throw new Error("Cannot apply params to JS ".concat(typeof params3));
      }
      input[paramsSymbol] = params3;
      return input;
    }
    function alias(alias2, target) {
      return "".concat(alias2, ":").concat(target);
    }
    function fragment(name, typeName, input) {
      var _a, _b;
      var fragment2 = (_a = {}, _a[typeSymbol] = exports.GraphQLType.FRAGMENT, _a.name = name, _a.typeName = typeName, _a.internal = input, _a);
      return _b = {}, _b[Symbol("Fragment(".concat(name, " on ").concat(typeName, ")"))] = fragment2, _b;
    }
    function rawString(input) {
      return JSON.stringify(input);
    }
    var __assign = function() {
      __assign = Object.assign || function __assign2(t3) {
        for (var s5, i6 = 1, n3 = arguments.length; i6 < n3; i6++) {
          s5 = arguments[i6];
          for (var p5 in s5)
            if (Object.prototype.hasOwnProperty.call(s5, p5))
              t3[p5] = s5[p5];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    function optional(obj) {
      return obj;
    }
    function on2(typeName, internal) {
      var _a, _b;
      var fragment2 = (_a = {}, _a[typeSymbol] = exports.GraphQLType.INLINE_FRAGMENT, _a.typeName = typeName, _a.internal = internal, _a);
      return _b = {}, _b[Symbol("InlineFragment(".concat(typeName, ")"))] = fragment2, _b;
    }
    function onUnion(types3) {
      var fragments = {};
      for (var _i = 0, _a = Object.entries(types3); _i < _a.length; _i++) {
        var _b = _a[_i], typeName = _b[0], internal = _b[1];
        fragments = __assign(__assign({}, fragments), on2(typeName, internal));
      }
      return fragments;
    }
    function scalarType() {
      var _a;
      var scalar = (_a = {}, _a[typeSymbol] = exports.GraphQLType.SCALAR, _a);
      return scalar;
    }
    var types2 = (
      /** @class */
      function() {
        function types3() {
        }
        Object.defineProperty(types3, "number", {
          get: function() {
            return scalarType();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(types3, "string", {
          get: function() {
            return scalarType();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(types3, "boolean", {
          get: function() {
            return scalarType();
          },
          enumerable: false,
          configurable: true
        });
        types3.constant = function(_c) {
          return scalarType();
        };
        types3.oneOf = function(_e4) {
          return scalarType();
        };
        types3.custom = function() {
          return scalarType();
        };
        types3.optional = types3;
        return types3;
      }()
    );
    exports.alias = alias;
    exports.fragment = fragment;
    exports.fragmentToString = fragmentToString;
    exports.mutation = mutation;
    exports.on = on2;
    exports.onUnion = onUnion;
    exports.optional = optional;
    exports.params = params2;
    exports.paramsSymbol = paramsSymbol;
    exports.query = query2;
    exports.rawString = rawString;
    exports.render = render;
    exports.subscription = subscription;
    exports.typeSymbol = typeSymbol;
    exports.types = types2;
  }
});

// 
var require_fast_content_type_parse = __commonJS({
  ""(exports, module2) {
    "use strict";
    var NullObject = function NullObject2() {
    };
    NullObject.prototype = /* @__PURE__ */ Object.create(null);
    var paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
    var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
    var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
    var defaultContentType = { type: "", parameters: new NullObject() };
    Object.freeze(defaultContentType.parameters);
    Object.freeze(defaultContentType);
    function parse2(header) {
      if (typeof header !== "string") {
        throw new TypeError("argument header is required and must be a string");
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        throw new TypeError("invalid media type");
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while (match = paramRE.exec(header)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
      return result;
    }
    function safeParse2(header) {
      if (typeof header !== "string") {
        return defaultContentType;
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        return defaultContentType;
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while (match = paramRE.exec(header)) {
        if (match.index !== index) {
          return defaultContentType;
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        return defaultContentType;
      }
      return result;
    }
    module2.exports.default = { parse: parse2, safeParse: safeParse2 };
    module2.exports.parse = parse2;
    module2.exports.safeParse = safeParse2;
    module2.exports.defaultContentType = defaultContentType;
  }
});

// 
var require_posix = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sync = exports.isexe = void 0;
    var fs_1 = __require("fs");
    var promises_1 = __require("fs/promises");
    var isexe = async (path, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat(await (0, promises_1.stat)(path), options);
      } catch (e5) {
        const er2 = e5;
        if (ignoreErrors || er2.code === "EACCES")
          return false;
        throw er2;
      }
    };
    exports.isexe = isexe;
    var sync = (path, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat((0, fs_1.statSync)(path), options);
      } catch (e5) {
        const er2 = e5;
        if (ignoreErrors || er2.code === "EACCES")
          return false;
        throw er2;
      }
    };
    exports.sync = sync;
    var checkStat = (stat, options) => stat.isFile() && checkMode(stat, options);
    var checkMode = (stat, options) => {
      const myUid = options.uid ?? process.getuid?.();
      const myGroups = options.groups ?? process.getgroups?.() ?? [];
      const myGid = options.gid ?? process.getgid?.() ?? myGroups[0];
      if (myUid === void 0 || myGid === void 0) {
        throw new Error("cannot get uid or gid");
      }
      const groups = /* @__PURE__ */ new Set([myGid, ...myGroups]);
      const mod = stat.mode;
      const uid = stat.uid;
      const gid = stat.gid;
      const u5 = parseInt("100", 8);
      const g2 = parseInt("010", 8);
      const o8 = parseInt("001", 8);
      const ug = u5 | g2;
      return !!(mod & o8 || mod & g2 && groups.has(gid) || mod & u5 && uid === myUid || mod & ug && myUid === 0);
    };
  }
});

// 
var require_win32 = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sync = exports.isexe = void 0;
    var fs_1 = __require("fs");
    var promises_1 = __require("fs/promises");
    var isexe = async (path, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat(await (0, promises_1.stat)(path), path, options);
      } catch (e5) {
        const er2 = e5;
        if (ignoreErrors || er2.code === "EACCES")
          return false;
        throw er2;
      }
    };
    exports.isexe = isexe;
    var sync = (path, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat((0, fs_1.statSync)(path), path, options);
      } catch (e5) {
        const er2 = e5;
        if (ignoreErrors || er2.code === "EACCES")
          return false;
        throw er2;
      }
    };
    exports.sync = sync;
    var checkPathExt = (path, options) => {
      const { pathExt = process.env.PATHEXT || "" } = options;
      const peSplit = pathExt.split(";");
      if (peSplit.indexOf("") !== -1) {
        return true;
      }
      for (let i6 = 0; i6 < peSplit.length; i6++) {
        const p5 = peSplit[i6].toLowerCase();
        const ext = path.substring(path.length - p5.length).toLowerCase();
        if (p5 && ext === p5) {
          return true;
        }
      }
      return false;
    };
    var checkStat = (stat, path, options) => stat.isFile() && checkPathExt(path, options);
  }
});

// 
var require_options = __commonJS({
  ""(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// 
var require_cjs = __commonJS({
  ""(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m8, k3);
      if (!desc || ("get" in desc ? !m8.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m8[k3];
        } };
      }
      Object.defineProperty(o8, k22, desc);
    } : function(o8, m8, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o8[k22] = m8[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o8, v4) {
      Object.defineProperty(o8, "default", { enumerable: true, value: v4 });
    } : function(o8, v4) {
      o8["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m8, exports2) {
      for (var p5 in m8)
        if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
          __createBinding(exports2, m8, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sync = exports.isexe = exports.posix = exports.win32 = void 0;
    var posix = __importStar(require_posix());
    exports.posix = posix;
    var win32 = __importStar(require_win32());
    exports.win32 = win32;
    __exportStar(require_options(), exports);
    var platform = process.env._ISEXE_TEST_PLATFORM_ || process.platform;
    var impl = platform === "win32" ? win32 : posix;
    exports.isexe = impl.isexe;
    exports.sync = impl.sync;
  }
});

// 
var require_lib2 = __commonJS({
  ""(exports, module2) {
    var { isexe, sync: isexeSync } = require_cjs();
    var { join: join3, delimiter, sep: sep2, posix } = __require("path");
    var isWindows = process.platform === "win32";
    var rSlash = new RegExp(`[${posix.sep}${sep2 === posix.sep ? "" : sep2}]`.replace(/(\\)/g, "\\$1"));
    var rRel = new RegExp(`^\\.${rSlash.source}`);
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, {
      path: optPath = process.env.PATH,
      pathExt: optPathExt = process.env.PATHEXT,
      delimiter: optDelimiter = delimiter
    }) => {
      const pathEnv = cmd.match(rSlash) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(optPath || /* istanbul ignore next: very unusual */
        "").split(optDelimiter)
      ];
      if (isWindows) {
        const pathExtExe = optPathExt || [".EXE", ".CMD", ".BAT", ".COM"].join(optDelimiter);
        const pathExt = pathExtExe.split(optDelimiter).flatMap((item) => [item, item.toLowerCase()]);
        if (cmd.includes(".") && pathExt[0] !== "") {
          pathExt.unshift("");
        }
        return { pathEnv, pathExt, pathExtExe };
      }
      return { pathEnv, pathExt: [""] };
    };
    var getPathPart = (raw, cmd) => {
      const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
      const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "";
      return prefix + join3(pathPart, cmd);
    };
    var which2 = async (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const envPart of pathEnv) {
        const p5 = getPathPart(envPart, cmd);
        for (const ext of pathExt) {
          const withExt = p5 + ext;
          const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    var whichSync = (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const pathEnvPart of pathEnv) {
        const p5 = getPathPart(pathEnvPart, cmd);
        for (const ext of pathExt) {
          const withExt = p5 + ext;
          const is = isexeSync(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// 
var require_lockfile = __commonJS({
  ""(exports, module2) {
    module2.exports = /******/
    function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module3 = installedModules[moduleId] = {
          /******/
          i: moduleId,
          /******/
          l: false,
          /******/
          exports: {}
          /******/
        };
        modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
        module3.l = true;
        return module3.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.i = function(value) {
        return value;
      };
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, {
            /******/
            configurable: false,
            /******/
            enumerable: true,
            /******/
            get: getter
            /******/
          });
        }
      };
      __webpack_require__.n = function(module3) {
        var getter = module3 && module3.__esModule ? (
          /******/
          function getDefault() {
            return module3["default"];
          }
        ) : (
          /******/
          function getModuleExports() {
            return module3;
          }
        );
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = 14);
    }([
      /* 0 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("path");
      },
      /* 1 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        exports2.__esModule = true;
        var _promise = __webpack_require__(173);
        var _promise2 = _interopRequireDefault(_promise);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        exports2.default = function(fn2) {
          return function() {
            var gen = fn2.apply(this, arguments);
            return new _promise2.default(function(resolve, reject) {
              function step(key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  return _promise2.default.resolve(value).then(function(value2) {
                    step("next", value2);
                  }, function(err) {
                    step("throw", err);
                  });
                }
              }
              return step("next");
            });
          };
        };
      },
      /* 2 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("util");
      },
      /* 3 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("fs");
      },
      /* 4 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        class MessageError extends Error {
          constructor(msg, code) {
            super(msg);
            this.code = code;
          }
        }
        exports2.MessageError = MessageError;
        class ProcessSpawnError extends MessageError {
          constructor(msg, code, process4) {
            super(msg, code);
            this.process = process4;
          }
        }
        exports2.ProcessSpawnError = ProcessSpawnError;
        class SecurityError extends MessageError {
        }
        exports2.SecurityError = SecurityError;
        class ProcessTermError extends MessageError {
        }
        exports2.ProcessTermError = ProcessTermError;
        class ResponseError extends Error {
          constructor(msg, responseCode) {
            super(msg);
            this.responseCode = responseCode;
          }
        }
        exports2.ResponseError = ResponseError;
      },
      /* 5 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.getFirstSuitableFolder = exports2.readFirstAvailableStream = exports2.makeTempDir = exports2.hardlinksWork = exports2.writeFilePreservingEol = exports2.getFileSizeOnDisk = exports2.walk = exports2.symlink = exports2.find = exports2.readJsonAndFile = exports2.readJson = exports2.readFileAny = exports2.hardlinkBulk = exports2.copyBulk = exports2.unlink = exports2.glob = exports2.link = exports2.chmod = exports2.lstat = exports2.exists = exports2.mkdirp = exports2.stat = exports2.access = exports2.rename = exports2.readdir = exports2.realpath = exports2.readlink = exports2.writeFile = exports2.open = exports2.readFileBuffer = exports2.lockQueue = exports2.constants = void 0;
        var _asyncToGenerator2;
        function _load_asyncToGenerator() {
          return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));
        }
        let buildActionsForCopy = (() => {
          var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {
            let build = (() => {
              var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {
                const src = data.src, dest = data.dest, type = data.type;
                const onFresh = data.onFresh || noop2;
                const onDone = data.onDone || noop2;
                if (files.has(dest.toLowerCase())) {
                  reporter.verbose(`The case-insensitive file ${dest} shouldn't be copied twice in one bulk copy`);
                } else {
                  files.add(dest.toLowerCase());
                }
                if (type === "symlink") {
                  yield mkdirp((_path || _load_path()).default.dirname(dest));
                  onFresh();
                  actions.symlink.push({
                    dest,
                    linkname: src
                  });
                  onDone();
                  return;
                }
                if (events.ignoreBasenames.indexOf((_path || _load_path()).default.basename(src)) >= 0) {
                  return;
                }
                const srcStat = yield lstat(src);
                let srcFiles;
                if (srcStat.isDirectory()) {
                  srcFiles = yield readdir(src);
                }
                let destStat;
                try {
                  destStat = yield lstat(dest);
                } catch (e5) {
                  if (e5.code !== "ENOENT") {
                    throw e5;
                  }
                }
                if (destStat) {
                  const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();
                  const bothFolders = srcStat.isDirectory() && destStat.isDirectory();
                  const bothFiles = srcStat.isFile() && destStat.isFile();
                  if (bothFiles && artifactFiles.has(dest)) {
                    onDone();
                    reporter.verbose(reporter.lang("verboseFileSkipArtifact", src));
                    return;
                  }
                  if (bothFiles && srcStat.size === destStat.size && (0, (_fsNormalized || _load_fsNormalized()).fileDatesEqual)(srcStat.mtime, destStat.mtime)) {
                    onDone();
                    reporter.verbose(reporter.lang("verboseFileSkip", src, dest, srcStat.size, +srcStat.mtime));
                    return;
                  }
                  if (bothSymlinks) {
                    const srcReallink = yield readlink(src);
                    if (srcReallink === (yield readlink(dest))) {
                      onDone();
                      reporter.verbose(reporter.lang("verboseFileSkipSymlink", src, dest, srcReallink));
                      return;
                    }
                  }
                  if (bothFolders) {
                    const destFiles = yield readdir(dest);
                    invariant(srcFiles, "src files not initialised");
                    for (var _iterator4 = destFiles, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ; ) {
                      var _ref6;
                      if (_isArray4) {
                        if (_i4 >= _iterator4.length)
                          break;
                        _ref6 = _iterator4[_i4++];
                      } else {
                        _i4 = _iterator4.next();
                        if (_i4.done)
                          break;
                        _ref6 = _i4.value;
                      }
                      const file = _ref6;
                      if (srcFiles.indexOf(file) < 0) {
                        const loc = (_path || _load_path()).default.join(dest, file);
                        possibleExtraneous.add(loc);
                        if ((yield lstat(loc)).isDirectory()) {
                          for (var _iterator5 = yield readdir(loc), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ; ) {
                            var _ref7;
                            if (_isArray5) {
                              if (_i5 >= _iterator5.length)
                                break;
                              _ref7 = _iterator5[_i5++];
                            } else {
                              _i5 = _iterator5.next();
                              if (_i5.done)
                                break;
                              _ref7 = _i5.value;
                            }
                            const file2 = _ref7;
                            possibleExtraneous.add((_path || _load_path()).default.join(loc, file2));
                          }
                        }
                      }
                    }
                  }
                }
                if (destStat && destStat.isSymbolicLink()) {
                  yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dest);
                  destStat = null;
                }
                if (srcStat.isSymbolicLink()) {
                  onFresh();
                  const linkname = yield readlink(src);
                  actions.symlink.push({
                    dest,
                    linkname
                  });
                  onDone();
                } else if (srcStat.isDirectory()) {
                  if (!destStat) {
                    reporter.verbose(reporter.lang("verboseFileFolder", dest));
                    yield mkdirp(dest);
                  }
                  const destParts = dest.split((_path || _load_path()).default.sep);
                  while (destParts.length) {
                    files.add(destParts.join((_path || _load_path()).default.sep).toLowerCase());
                    destParts.pop();
                  }
                  invariant(srcFiles, "src files not initialised");
                  let remaining = srcFiles.length;
                  if (!remaining) {
                    onDone();
                  }
                  for (var _iterator6 = srcFiles, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ; ) {
                    var _ref8;
                    if (_isArray6) {
                      if (_i6 >= _iterator6.length)
                        break;
                      _ref8 = _iterator6[_i6++];
                    } else {
                      _i6 = _iterator6.next();
                      if (_i6.done)
                        break;
                      _ref8 = _i6.value;
                    }
                    const file = _ref8;
                    queue.push({
                      dest: (_path || _load_path()).default.join(dest, file),
                      onFresh,
                      onDone: function(_onDone) {
                        function onDone2() {
                          return _onDone.apply(this, arguments);
                        }
                        onDone2.toString = function() {
                          return _onDone.toString();
                        };
                        return onDone2;
                      }(function() {
                        if (--remaining === 0) {
                          onDone();
                        }
                      }),
                      src: (_path || _load_path()).default.join(src, file)
                    });
                  }
                } else if (srcStat.isFile()) {
                  onFresh();
                  actions.file.push({
                    src,
                    dest,
                    atime: srcStat.atime,
                    mtime: srcStat.mtime,
                    mode: srcStat.mode
                  });
                  onDone();
                } else {
                  throw new Error(`unsure how to copy this: ${src}`);
                }
              });
              return function build2(_x5) {
                return _ref5.apply(this, arguments);
              };
            })();
            const artifactFiles = new Set(events.artifactFiles || []);
            const files = /* @__PURE__ */ new Set();
            for (var _iterator = queue, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
              var _ref2;
              if (_isArray) {
                if (_i >= _iterator.length)
                  break;
                _ref2 = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done)
                  break;
                _ref2 = _i.value;
              }
              const item = _ref2;
              const onDone = item.onDone;
              item.onDone = function() {
                events.onProgress(item.dest);
                if (onDone) {
                  onDone();
                }
              };
            }
            events.onStart(queue.length);
            const actions = {
              file: [],
              symlink: [],
              link: []
            };
            while (queue.length) {
              const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);
              yield Promise.all(items.map(build));
            }
            for (var _iterator2 = artifactFiles, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
              var _ref3;
              if (_isArray2) {
                if (_i2 >= _iterator2.length)
                  break;
                _ref3 = _iterator2[_i2++];
              } else {
                _i2 = _iterator2.next();
                if (_i2.done)
                  break;
                _ref3 = _i2.value;
              }
              const file = _ref3;
              if (possibleExtraneous.has(file)) {
                reporter.verbose(reporter.lang("verboseFilePhantomExtraneous", file));
                possibleExtraneous.delete(file);
              }
            }
            for (var _iterator3 = possibleExtraneous, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ; ) {
              var _ref4;
              if (_isArray3) {
                if (_i3 >= _iterator3.length)
                  break;
                _ref4 = _iterator3[_i3++];
              } else {
                _i3 = _iterator3.next();
                if (_i3.done)
                  break;
                _ref4 = _i3.value;
              }
              const loc = _ref4;
              if (files.has(loc.toLowerCase())) {
                possibleExtraneous.delete(loc);
              }
            }
            return actions;
          });
          return function buildActionsForCopy2(_x, _x2, _x3, _x4) {
            return _ref.apply(this, arguments);
          };
        })();
        let buildActionsForHardlink = (() => {
          var _ref9 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {
            let build = (() => {
              var _ref13 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {
                const src = data.src, dest = data.dest;
                const onFresh = data.onFresh || noop2;
                const onDone = data.onDone || noop2;
                if (files.has(dest.toLowerCase())) {
                  onDone();
                  return;
                }
                files.add(dest.toLowerCase());
                if (events.ignoreBasenames.indexOf((_path || _load_path()).default.basename(src)) >= 0) {
                  return;
                }
                const srcStat = yield lstat(src);
                let srcFiles;
                if (srcStat.isDirectory()) {
                  srcFiles = yield readdir(src);
                }
                const destExists = yield exists(dest);
                if (destExists) {
                  const destStat = yield lstat(dest);
                  const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();
                  const bothFolders = srcStat.isDirectory() && destStat.isDirectory();
                  const bothFiles = srcStat.isFile() && destStat.isFile();
                  if (srcStat.mode !== destStat.mode) {
                    try {
                      yield access(dest, srcStat.mode);
                    } catch (err) {
                      reporter.verbose(err);
                    }
                  }
                  if (bothFiles && artifactFiles.has(dest)) {
                    onDone();
                    reporter.verbose(reporter.lang("verboseFileSkipArtifact", src));
                    return;
                  }
                  if (bothFiles && srcStat.ino !== null && srcStat.ino === destStat.ino) {
                    onDone();
                    reporter.verbose(reporter.lang("verboseFileSkip", src, dest, srcStat.ino));
                    return;
                  }
                  if (bothSymlinks) {
                    const srcReallink = yield readlink(src);
                    if (srcReallink === (yield readlink(dest))) {
                      onDone();
                      reporter.verbose(reporter.lang("verboseFileSkipSymlink", src, dest, srcReallink));
                      return;
                    }
                  }
                  if (bothFolders) {
                    const destFiles = yield readdir(dest);
                    invariant(srcFiles, "src files not initialised");
                    for (var _iterator10 = destFiles, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ; ) {
                      var _ref14;
                      if (_isArray10) {
                        if (_i10 >= _iterator10.length)
                          break;
                        _ref14 = _iterator10[_i10++];
                      } else {
                        _i10 = _iterator10.next();
                        if (_i10.done)
                          break;
                        _ref14 = _i10.value;
                      }
                      const file = _ref14;
                      if (srcFiles.indexOf(file) < 0) {
                        const loc = (_path || _load_path()).default.join(dest, file);
                        possibleExtraneous.add(loc);
                        if ((yield lstat(loc)).isDirectory()) {
                          for (var _iterator11 = yield readdir(loc), _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ; ) {
                            var _ref15;
                            if (_isArray11) {
                              if (_i11 >= _iterator11.length)
                                break;
                              _ref15 = _iterator11[_i11++];
                            } else {
                              _i11 = _iterator11.next();
                              if (_i11.done)
                                break;
                              _ref15 = _i11.value;
                            }
                            const file2 = _ref15;
                            possibleExtraneous.add((_path || _load_path()).default.join(loc, file2));
                          }
                        }
                      }
                    }
                  }
                }
                if (srcStat.isSymbolicLink()) {
                  onFresh();
                  const linkname = yield readlink(src);
                  actions.symlink.push({
                    dest,
                    linkname
                  });
                  onDone();
                } else if (srcStat.isDirectory()) {
                  reporter.verbose(reporter.lang("verboseFileFolder", dest));
                  yield mkdirp(dest);
                  const destParts = dest.split((_path || _load_path()).default.sep);
                  while (destParts.length) {
                    files.add(destParts.join((_path || _load_path()).default.sep).toLowerCase());
                    destParts.pop();
                  }
                  invariant(srcFiles, "src files not initialised");
                  let remaining = srcFiles.length;
                  if (!remaining) {
                    onDone();
                  }
                  for (var _iterator12 = srcFiles, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ; ) {
                    var _ref16;
                    if (_isArray12) {
                      if (_i12 >= _iterator12.length)
                        break;
                      _ref16 = _iterator12[_i12++];
                    } else {
                      _i12 = _iterator12.next();
                      if (_i12.done)
                        break;
                      _ref16 = _i12.value;
                    }
                    const file = _ref16;
                    queue.push({
                      onFresh,
                      src: (_path || _load_path()).default.join(src, file),
                      dest: (_path || _load_path()).default.join(dest, file),
                      onDone: function(_onDone2) {
                        function onDone2() {
                          return _onDone2.apply(this, arguments);
                        }
                        onDone2.toString = function() {
                          return _onDone2.toString();
                        };
                        return onDone2;
                      }(function() {
                        if (--remaining === 0) {
                          onDone();
                        }
                      })
                    });
                  }
                } else if (srcStat.isFile()) {
                  onFresh();
                  actions.link.push({
                    src,
                    dest,
                    removeDest: destExists
                  });
                  onDone();
                } else {
                  throw new Error(`unsure how to copy this: ${src}`);
                }
              });
              return function build2(_x10) {
                return _ref13.apply(this, arguments);
              };
            })();
            const artifactFiles = new Set(events.artifactFiles || []);
            const files = /* @__PURE__ */ new Set();
            for (var _iterator7 = queue, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ; ) {
              var _ref10;
              if (_isArray7) {
                if (_i7 >= _iterator7.length)
                  break;
                _ref10 = _iterator7[_i7++];
              } else {
                _i7 = _iterator7.next();
                if (_i7.done)
                  break;
                _ref10 = _i7.value;
              }
              const item = _ref10;
              const onDone = item.onDone || noop2;
              item.onDone = function() {
                events.onProgress(item.dest);
                onDone();
              };
            }
            events.onStart(queue.length);
            const actions = {
              file: [],
              symlink: [],
              link: []
            };
            while (queue.length) {
              const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);
              yield Promise.all(items.map(build));
            }
            for (var _iterator8 = artifactFiles, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ; ) {
              var _ref11;
              if (_isArray8) {
                if (_i8 >= _iterator8.length)
                  break;
                _ref11 = _iterator8[_i8++];
              } else {
                _i8 = _iterator8.next();
                if (_i8.done)
                  break;
                _ref11 = _i8.value;
              }
              const file = _ref11;
              if (possibleExtraneous.has(file)) {
                reporter.verbose(reporter.lang("verboseFilePhantomExtraneous", file));
                possibleExtraneous.delete(file);
              }
            }
            for (var _iterator9 = possibleExtraneous, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ; ) {
              var _ref12;
              if (_isArray9) {
                if (_i9 >= _iterator9.length)
                  break;
                _ref12 = _iterator9[_i9++];
              } else {
                _i9 = _iterator9.next();
                if (_i9.done)
                  break;
                _ref12 = _i9.value;
              }
              const loc = _ref12;
              if (files.has(loc.toLowerCase())) {
                possibleExtraneous.delete(loc);
              }
            }
            return actions;
          });
          return function buildActionsForHardlink2(_x6, _x7, _x8, _x9) {
            return _ref9.apply(this, arguments);
          };
        })();
        let copyBulk = exports2.copyBulk = (() => {
          var _ref17 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {
            const events = {
              onStart: _events && _events.onStart || noop2,
              onProgress: _events && _events.onProgress || noop2,
              possibleExtraneous: _events ? _events.possibleExtraneous : /* @__PURE__ */ new Set(),
              ignoreBasenames: _events && _events.ignoreBasenames || [],
              artifactFiles: _events && _events.artifactFiles || []
            };
            const actions = yield buildActionsForCopy(queue, events, events.possibleExtraneous, reporter);
            events.onStart(actions.file.length + actions.symlink.length + actions.link.length);
            const fileActions = actions.file;
            const currentlyWriting = /* @__PURE__ */ new Map();
            yield (_promise || _load_promise()).queue(fileActions, (() => {
              var _ref18 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {
                let writePromise;
                while (writePromise = currentlyWriting.get(data.dest)) {
                  yield writePromise;
                }
                reporter.verbose(reporter.lang("verboseFileCopy", data.src, data.dest));
                const copier = (0, (_fsNormalized || _load_fsNormalized()).copyFile)(data, function() {
                  return currentlyWriting.delete(data.dest);
                });
                currentlyWriting.set(data.dest, copier);
                events.onProgress(data.dest);
                return copier;
              });
              return function(_x14) {
                return _ref18.apply(this, arguments);
              };
            })(), CONCURRENT_QUEUE_ITEMS);
            const symlinkActions = actions.symlink;
            yield (_promise || _load_promise()).queue(symlinkActions, function(data) {
              const linkname = (_path || _load_path()).default.resolve((_path || _load_path()).default.dirname(data.dest), data.linkname);
              reporter.verbose(reporter.lang("verboseFileSymlink", data.dest, linkname));
              return symlink(linkname, data.dest);
            });
          });
          return function copyBulk2(_x11, _x12, _x13) {
            return _ref17.apply(this, arguments);
          };
        })();
        let hardlinkBulk = exports2.hardlinkBulk = (() => {
          var _ref19 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {
            const events = {
              onStart: _events && _events.onStart || noop2,
              onProgress: _events && _events.onProgress || noop2,
              possibleExtraneous: _events ? _events.possibleExtraneous : /* @__PURE__ */ new Set(),
              artifactFiles: _events && _events.artifactFiles || [],
              ignoreBasenames: []
            };
            const actions = yield buildActionsForHardlink(queue, events, events.possibleExtraneous, reporter);
            events.onStart(actions.file.length + actions.symlink.length + actions.link.length);
            const fileActions = actions.link;
            yield (_promise || _load_promise()).queue(fileActions, (() => {
              var _ref20 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {
                reporter.verbose(reporter.lang("verboseFileLink", data.src, data.dest));
                if (data.removeDest) {
                  yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(data.dest);
                }
                yield link(data.src, data.dest);
              });
              return function(_x18) {
                return _ref20.apply(this, arguments);
              };
            })(), CONCURRENT_QUEUE_ITEMS);
            const symlinkActions = actions.symlink;
            yield (_promise || _load_promise()).queue(symlinkActions, function(data) {
              const linkname = (_path || _load_path()).default.resolve((_path || _load_path()).default.dirname(data.dest), data.linkname);
              reporter.verbose(reporter.lang("verboseFileSymlink", data.dest, linkname));
              return symlink(linkname, data.dest);
            });
          });
          return function hardlinkBulk2(_x15, _x16, _x17) {
            return _ref19.apply(this, arguments);
          };
        })();
        let readFileAny = exports2.readFileAny = (() => {
          var _ref21 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (files) {
            for (var _iterator13 = files, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ; ) {
              var _ref22;
              if (_isArray13) {
                if (_i13 >= _iterator13.length)
                  break;
                _ref22 = _iterator13[_i13++];
              } else {
                _i13 = _iterator13.next();
                if (_i13.done)
                  break;
                _ref22 = _i13.value;
              }
              const file = _ref22;
              if (yield exists(file)) {
                return readFile2(file);
              }
            }
            return null;
          });
          return function readFileAny2(_x19) {
            return _ref21.apply(this, arguments);
          };
        })();
        let readJson = exports2.readJson = (() => {
          var _ref23 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {
            return (yield readJsonAndFile(loc)).object;
          });
          return function readJson2(_x20) {
            return _ref23.apply(this, arguments);
          };
        })();
        let readJsonAndFile = exports2.readJsonAndFile = (() => {
          var _ref24 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {
            const file = yield readFile2(loc);
            try {
              return {
                object: (0, (_map || _load_map()).default)(JSON.parse(stripBOM(file))),
                content: file
              };
            } catch (err) {
              err.message = `${loc}: ${err.message}`;
              throw err;
            }
          });
          return function readJsonAndFile2(_x21) {
            return _ref24.apply(this, arguments);
          };
        })();
        let find = exports2.find = (() => {
          var _ref25 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (filename, dir) {
            const parts = dir.split((_path || _load_path()).default.sep);
            while (parts.length) {
              const loc = parts.concat(filename).join((_path || _load_path()).default.sep);
              if (yield exists(loc)) {
                return loc;
              } else {
                parts.pop();
              }
            }
            return false;
          });
          return function find2(_x22, _x23) {
            return _ref25.apply(this, arguments);
          };
        })();
        let symlink = exports2.symlink = (() => {
          var _ref26 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest) {
            try {
              const stats = yield lstat(dest);
              if (stats.isSymbolicLink()) {
                const resolved = yield realpath(dest);
                if (resolved === src) {
                  return;
                }
              }
            } catch (err) {
              if (err.code !== "ENOENT") {
                throw err;
              }
            }
            yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dest);
            if (process.platform === "win32") {
              yield fsSymlink(src, dest, "junction");
            } else {
              let relative;
              try {
                relative = (_path || _load_path()).default.relative((_fs || _load_fs()).default.realpathSync((_path || _load_path()).default.dirname(dest)), (_fs || _load_fs()).default.realpathSync(src));
              } catch (err) {
                if (err.code !== "ENOENT") {
                  throw err;
                }
                relative = (_path || _load_path()).default.relative((_path || _load_path()).default.dirname(dest), src);
              }
              yield fsSymlink(relative || ".", dest);
            }
          });
          return function symlink2(_x24, _x25) {
            return _ref26.apply(this, arguments);
          };
        })();
        let walk = exports2.walk = (() => {
          var _ref27 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir, relativeDir, ignoreBasenames = /* @__PURE__ */ new Set()) {
            let files = [];
            let filenames = yield readdir(dir);
            if (ignoreBasenames.size) {
              filenames = filenames.filter(function(name) {
                return !ignoreBasenames.has(name);
              });
            }
            for (var _iterator14 = filenames, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator](); ; ) {
              var _ref28;
              if (_isArray14) {
                if (_i14 >= _iterator14.length)
                  break;
                _ref28 = _iterator14[_i14++];
              } else {
                _i14 = _iterator14.next();
                if (_i14.done)
                  break;
                _ref28 = _i14.value;
              }
              const name = _ref28;
              const relative = relativeDir ? (_path || _load_path()).default.join(relativeDir, name) : name;
              const loc = (_path || _load_path()).default.join(dir, name);
              const stat2 = yield lstat(loc);
              files.push({
                relative,
                basename: name,
                absolute: loc,
                mtime: +stat2.mtime
              });
              if (stat2.isDirectory()) {
                files = files.concat(yield walk(loc, relative, ignoreBasenames));
              }
            }
            return files;
          });
          return function walk2(_x26, _x27) {
            return _ref27.apply(this, arguments);
          };
        })();
        let getFileSizeOnDisk = exports2.getFileSizeOnDisk = (() => {
          var _ref29 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {
            const stat2 = yield lstat(loc);
            const size = stat2.size, blockSize = stat2.blksize;
            return Math.ceil(size / blockSize) * blockSize;
          });
          return function getFileSizeOnDisk2(_x28) {
            return _ref29.apply(this, arguments);
          };
        })();
        let getEolFromFile = (() => {
          var _ref30 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path) {
            if (!(yield exists(path))) {
              return void 0;
            }
            const buffer = yield readFileBuffer(path);
            for (let i6 = 0; i6 < buffer.length; ++i6) {
              if (buffer[i6] === cr2) {
                return "\r\n";
              }
              if (buffer[i6] === lf) {
                return "\n";
              }
            }
            return void 0;
          });
          return function getEolFromFile2(_x29) {
            return _ref30.apply(this, arguments);
          };
        })();
        let writeFilePreservingEol = exports2.writeFilePreservingEol = (() => {
          var _ref31 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path, data) {
            const eol = (yield getEolFromFile(path)) || (_os || _load_os()).default.EOL;
            if (eol !== "\n") {
              data = data.replace(/\n/g, eol);
            }
            yield writeFile2(path, data);
          });
          return function writeFilePreservingEol2(_x30, _x31) {
            return _ref31.apply(this, arguments);
          };
        })();
        let hardlinksWork = exports2.hardlinksWork = (() => {
          var _ref32 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir) {
            const filename = "test-file" + Math.random();
            const file = (_path || _load_path()).default.join(dir, filename);
            const fileLink = (_path || _load_path()).default.join(dir, filename + "-link");
            try {
              yield writeFile2(file, "test");
              yield link(file, fileLink);
            } catch (err) {
              return false;
            } finally {
              yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(file);
              yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(fileLink);
            }
            return true;
          });
          return function hardlinksWork2(_x32) {
            return _ref32.apply(this, arguments);
          };
        })();
        let makeTempDir = exports2.makeTempDir = (() => {
          var _ref33 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (prefix) {
            const dir = (_path || _load_path()).default.join((_os || _load_os()).default.tmpdir(), `yarn-${prefix || ""}-${Date.now()}-${Math.random()}`);
            yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dir);
            yield mkdirp(dir);
            return dir;
          });
          return function makeTempDir2(_x33) {
            return _ref33.apply(this, arguments);
          };
        })();
        let readFirstAvailableStream = exports2.readFirstAvailableStream = (() => {
          var _ref34 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (paths) {
            for (var _iterator15 = paths, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator](); ; ) {
              var _ref35;
              if (_isArray15) {
                if (_i15 >= _iterator15.length)
                  break;
                _ref35 = _iterator15[_i15++];
              } else {
                _i15 = _iterator15.next();
                if (_i15.done)
                  break;
                _ref35 = _i15.value;
              }
              const path = _ref35;
              try {
                const fd = yield open(path, "r");
                return (_fs || _load_fs()).default.createReadStream(path, { fd });
              } catch (err) {
              }
            }
            return null;
          });
          return function readFirstAvailableStream2(_x34) {
            return _ref34.apply(this, arguments);
          };
        })();
        let getFirstSuitableFolder = exports2.getFirstSuitableFolder = (() => {
          var _ref36 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (paths, mode = constants.W_OK | constants.X_OK) {
            const result = {
              skipped: [],
              folder: null
            };
            for (var _iterator16 = paths, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator](); ; ) {
              var _ref37;
              if (_isArray16) {
                if (_i16 >= _iterator16.length)
                  break;
                _ref37 = _iterator16[_i16++];
              } else {
                _i16 = _iterator16.next();
                if (_i16.done)
                  break;
                _ref37 = _i16.value;
              }
              const folder = _ref37;
              try {
                yield mkdirp(folder);
                yield access(folder, mode);
                result.folder = folder;
                return result;
              } catch (error) {
                result.skipped.push({
                  error,
                  folder
                });
              }
            }
            return result;
          });
          return function getFirstSuitableFolder2(_x35) {
            return _ref36.apply(this, arguments);
          };
        })();
        exports2.copy = copy;
        exports2.readFile = readFile2;
        exports2.readFileRaw = readFileRaw;
        exports2.normalizeOS = normalizeOS;
        var _fs;
        function _load_fs() {
          return _fs = _interopRequireDefault(__webpack_require__(3));
        }
        var _glob;
        function _load_glob() {
          return _glob = _interopRequireDefault(__webpack_require__(75));
        }
        var _os;
        function _load_os() {
          return _os = _interopRequireDefault(__webpack_require__(36));
        }
        var _path;
        function _load_path() {
          return _path = _interopRequireDefault(__webpack_require__(0));
        }
        var _blockingQueue;
        function _load_blockingQueue() {
          return _blockingQueue = _interopRequireDefault(__webpack_require__(84));
        }
        var _promise;
        function _load_promise() {
          return _promise = _interopRequireWildcard(__webpack_require__(40));
        }
        var _promise2;
        function _load_promise2() {
          return _promise2 = __webpack_require__(40);
        }
        var _map;
        function _load_map() {
          return _map = _interopRequireDefault(__webpack_require__(20));
        }
        var _fsNormalized;
        function _load_fsNormalized() {
          return _fsNormalized = __webpack_require__(164);
        }
        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};
            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key))
                  newObj[key] = obj[key];
              }
            }
            newObj.default = obj;
            return newObj;
          }
        }
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const constants = exports2.constants = typeof (_fs || _load_fs()).default.constants !== "undefined" ? (_fs || _load_fs()).default.constants : {
          R_OK: (_fs || _load_fs()).default.R_OK,
          W_OK: (_fs || _load_fs()).default.W_OK,
          X_OK: (_fs || _load_fs()).default.X_OK
        };
        const lockQueue = exports2.lockQueue = new (_blockingQueue || _load_blockingQueue()).default("fs lock");
        const readFileBuffer = exports2.readFileBuffer = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readFile);
        const open = exports2.open = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.open);
        const writeFile2 = exports2.writeFile = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.writeFile);
        const readlink = exports2.readlink = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readlink);
        const realpath = exports2.realpath = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.realpath);
        const readdir = exports2.readdir = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readdir);
        const rename = exports2.rename = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.rename);
        const access = exports2.access = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.access);
        const stat = exports2.stat = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.stat);
        const mkdirp = exports2.mkdirp = (0, (_promise2 || _load_promise2()).promisify)(__webpack_require__(116));
        const exists = exports2.exists = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.exists, true);
        const lstat = exports2.lstat = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.lstat);
        const chmod = exports2.chmod = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.chmod);
        const link = exports2.link = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.link);
        const glob2 = exports2.glob = (0, (_promise2 || _load_promise2()).promisify)((_glob || _load_glob()).default);
        exports2.unlink = (_fsNormalized || _load_fsNormalized()).unlink;
        const CONCURRENT_QUEUE_ITEMS = (_fs || _load_fs()).default.copyFile ? 128 : 4;
        const fsSymlink = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.symlink);
        const invariant = __webpack_require__(7);
        const stripBOM = __webpack_require__(122);
        const noop2 = () => {
        };
        function copy(src, dest, reporter) {
          return copyBulk([{ src, dest }], reporter);
        }
        function _readFile(loc, encoding) {
          return new Promise((resolve, reject) => {
            (_fs || _load_fs()).default.readFile(loc, encoding, function(err, content) {
              if (err) {
                reject(err);
              } else {
                resolve(content);
              }
            });
          });
        }
        function readFile2(loc) {
          return _readFile(loc, "utf8").then(normalizeOS);
        }
        function readFileRaw(loc) {
          return _readFile(loc, "binary");
        }
        function normalizeOS(body) {
          return body.replace(/\r\n/g, "\n");
        }
        const cr2 = "\r".charCodeAt(0);
        const lf = "\n".charCodeAt(0);
      },
      /* 6 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.getPathKey = getPathKey;
        const os3 = __webpack_require__(36);
        const path = __webpack_require__(0);
        const userHome = __webpack_require__(45).default;
        var _require = __webpack_require__(171);
        const getCacheDir = _require.getCacheDir, getConfigDir = _require.getConfigDir, getDataDir = _require.getDataDir;
        const isWebpackBundle = __webpack_require__(227);
        const DEPENDENCY_TYPES = exports2.DEPENDENCY_TYPES = ["devDependencies", "dependencies", "optionalDependencies", "peerDependencies"];
        const RESOLUTIONS = exports2.RESOLUTIONS = "resolutions";
        const MANIFEST_FIELDS = exports2.MANIFEST_FIELDS = [RESOLUTIONS, ...DEPENDENCY_TYPES];
        const SUPPORTED_NODE_VERSIONS = exports2.SUPPORTED_NODE_VERSIONS = "^4.8.0 || ^5.7.0 || ^6.2.2 || >=8.0.0";
        const YARN_REGISTRY = exports2.YARN_REGISTRY = "https://registry.yarnpkg.com";
        const YARN_DOCS = exports2.YARN_DOCS = "https://yarnpkg.com/en/docs/cli/";
        const YARN_INSTALLER_SH = exports2.YARN_INSTALLER_SH = "https://yarnpkg.com/install.sh";
        const YARN_INSTALLER_MSI = exports2.YARN_INSTALLER_MSI = "https://yarnpkg.com/latest.msi";
        const SELF_UPDATE_VERSION_URL = exports2.SELF_UPDATE_VERSION_URL = "https://yarnpkg.com/latest-version";
        const CACHE_VERSION = exports2.CACHE_VERSION = 2;
        const LOCKFILE_VERSION = exports2.LOCKFILE_VERSION = 1;
        const NETWORK_CONCURRENCY = exports2.NETWORK_CONCURRENCY = 8;
        const NETWORK_TIMEOUT = exports2.NETWORK_TIMEOUT = 30 * 1e3;
        const CHILD_CONCURRENCY = exports2.CHILD_CONCURRENCY = 5;
        const REQUIRED_PACKAGE_KEYS = exports2.REQUIRED_PACKAGE_KEYS = ["name", "version", "_uid"];
        function getPreferredCacheDirectories() {
          const preferredCacheDirectories = [getCacheDir()];
          if (process.getuid) {
            preferredCacheDirectories.push(path.join(os3.tmpdir(), `.yarn-cache-${process.getuid()}`));
          }
          preferredCacheDirectories.push(path.join(os3.tmpdir(), `.yarn-cache`));
          return preferredCacheDirectories;
        }
        const PREFERRED_MODULE_CACHE_DIRECTORIES = exports2.PREFERRED_MODULE_CACHE_DIRECTORIES = getPreferredCacheDirectories();
        const CONFIG_DIRECTORY = exports2.CONFIG_DIRECTORY = getConfigDir();
        const DATA_DIRECTORY = exports2.DATA_DIRECTORY = getDataDir();
        const LINK_REGISTRY_DIRECTORY = exports2.LINK_REGISTRY_DIRECTORY = path.join(DATA_DIRECTORY, "link");
        const GLOBAL_MODULE_DIRECTORY = exports2.GLOBAL_MODULE_DIRECTORY = path.join(DATA_DIRECTORY, "global");
        const NODE_BIN_PATH = exports2.NODE_BIN_PATH = process.execPath;
        const YARN_BIN_PATH = exports2.YARN_BIN_PATH = getYarnBinPath();
        function getYarnBinPath() {
          if (isWebpackBundle) {
            return __filename;
          } else {
            return path.join(__dirname, "..", "bin", "yarn.js");
          }
        }
        const NODE_MODULES_FOLDER = exports2.NODE_MODULES_FOLDER = "node_modules";
        const NODE_PACKAGE_JSON = exports2.NODE_PACKAGE_JSON = "package.json";
        const POSIX_GLOBAL_PREFIX = exports2.POSIX_GLOBAL_PREFIX = `${process.env.DESTDIR || ""}/usr/local`;
        const FALLBACK_GLOBAL_PREFIX = exports2.FALLBACK_GLOBAL_PREFIX = path.join(userHome, ".yarn");
        const META_FOLDER = exports2.META_FOLDER = ".yarn-meta";
        const INTEGRITY_FILENAME = exports2.INTEGRITY_FILENAME = ".yarn-integrity";
        const LOCKFILE_FILENAME = exports2.LOCKFILE_FILENAME = "yarn.lock";
        const METADATA_FILENAME = exports2.METADATA_FILENAME = ".yarn-metadata.json";
        const TARBALL_FILENAME = exports2.TARBALL_FILENAME = ".yarn-tarball.tgz";
        const CLEAN_FILENAME = exports2.CLEAN_FILENAME = ".yarnclean";
        const NPM_LOCK_FILENAME = exports2.NPM_LOCK_FILENAME = "package-lock.json";
        const NPM_SHRINKWRAP_FILENAME = exports2.NPM_SHRINKWRAP_FILENAME = "npm-shrinkwrap.json";
        const DEFAULT_INDENT = exports2.DEFAULT_INDENT = "  ";
        const SINGLE_INSTANCE_PORT = exports2.SINGLE_INSTANCE_PORT = 31997;
        const SINGLE_INSTANCE_FILENAME = exports2.SINGLE_INSTANCE_FILENAME = ".yarn-single-instance";
        const ENV_PATH_KEY = exports2.ENV_PATH_KEY = getPathKey(process.platform, process.env);
        function getPathKey(platform, env3) {
          let pathKey = "PATH";
          if (platform === "win32") {
            pathKey = "Path";
            for (const key in env3) {
              if (key.toLowerCase() === "path") {
                pathKey = key;
              }
            }
          }
          return pathKey;
        }
        const VERSION_COLOR_SCHEME = exports2.VERSION_COLOR_SCHEME = {
          major: "red",
          premajor: "red",
          minor: "yellow",
          preminor: "yellow",
          patch: "green",
          prepatch: "green",
          prerelease: "red",
          unchanged: "white",
          unknown: "red"
        };
      },
      /* 7 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var NODE_ENV = process.env.NODE_ENV;
        var invariant = function(condition, format, a7, b3, c3, d5, e5, f6) {
          if (NODE_ENV !== "production") {
            if (format === void 0) {
              throw new Error("invariant requires an error message argument");
            }
          }
          if (!condition) {
            var error;
            if (format === void 0) {
              error = new Error(
                "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
              );
            } else {
              var args = [a7, b3, c3, d5, e5, f6];
              var argIndex = 0;
              error = new Error(
                format.replace(/%s/g, function() {
                  return args[argIndex++];
                })
              );
              error.name = "Invariant Violation";
            }
            error.framesToPop = 1;
            throw error;
          }
        };
        module3.exports = invariant;
      },
      ,
      /* 9 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("crypto");
      },
      ,
      /* 11 */
      /***/
      function(module3, exports2) {
        var global2 = module3.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
        if (typeof __g == "number")
          __g = global2;
      },
      /* 12 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.sortAlpha = sortAlpha;
        exports2.entries = entries;
        exports2.removePrefix = removePrefix;
        exports2.removeSuffix = removeSuffix;
        exports2.addSuffix = addSuffix;
        exports2.hyphenate = hyphenate;
        exports2.camelCase = camelCase;
        exports2.compareSortedArrays = compareSortedArrays;
        exports2.sleep = sleep;
        const _camelCase = __webpack_require__(176);
        function sortAlpha(a7, b3) {
          const shortLen = Math.min(a7.length, b3.length);
          for (let i6 = 0; i6 < shortLen; i6++) {
            const aChar = a7.charCodeAt(i6);
            const bChar = b3.charCodeAt(i6);
            if (aChar !== bChar) {
              return aChar - bChar;
            }
          }
          return a7.length - b3.length;
        }
        function entries(obj) {
          const entries2 = [];
          if (obj) {
            for (const key in obj) {
              entries2.push([key, obj[key]]);
            }
          }
          return entries2;
        }
        function removePrefix(pattern, prefix) {
          if (pattern.startsWith(prefix)) {
            pattern = pattern.slice(prefix.length);
          }
          return pattern;
        }
        function removeSuffix(pattern, suffix) {
          if (pattern.endsWith(suffix)) {
            return pattern.slice(0, -suffix.length);
          }
          return pattern;
        }
        function addSuffix(pattern, suffix) {
          if (!pattern.endsWith(suffix)) {
            return pattern + suffix;
          }
          return pattern;
        }
        function hyphenate(str) {
          return str.replace(/[A-Z]/g, (match) => {
            return "-" + match.charAt(0).toLowerCase();
          });
        }
        function camelCase(str) {
          if (/[A-Z]/.test(str)) {
            return null;
          } else {
            return _camelCase(str);
          }
        }
        function compareSortedArrays(array1, array2) {
          if (array1.length !== array2.length) {
            return false;
          }
          for (let i6 = 0, len = array1.length; i6 < len; i6++) {
            if (array1[i6] !== array2[i6]) {
              return false;
            }
          }
          return true;
        }
        function sleep(ms) {
          return new Promise((resolve) => {
            setTimeout(resolve, ms);
          });
        }
      },
      /* 13 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var store = __webpack_require__(107)("wks");
        var uid = __webpack_require__(111);
        var Symbol2 = __webpack_require__(11).Symbol;
        var USE_SYMBOL = typeof Symbol2 == "function";
        var $exports = module3.exports = function(name) {
          return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
        };
        $exports.store = store;
      },
      /* 14 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.stringify = exports2.parse = void 0;
        var _asyncToGenerator2;
        function _load_asyncToGenerator() {
          return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));
        }
        var _parse;
        function _load_parse() {
          return _parse = __webpack_require__(81);
        }
        Object.defineProperty(exports2, "parse", {
          enumerable: true,
          get: function get() {
            return _interopRequireDefault(_parse || _load_parse()).default;
          }
        });
        var _stringify;
        function _load_stringify() {
          return _stringify = __webpack_require__(150);
        }
        Object.defineProperty(exports2, "stringify", {
          enumerable: true,
          get: function get() {
            return _interopRequireDefault(_stringify || _load_stringify()).default;
          }
        });
        exports2.implodeEntry = implodeEntry;
        exports2.explodeEntry = explodeEntry;
        var _misc;
        function _load_misc() {
          return _misc = __webpack_require__(12);
        }
        var _normalizePattern;
        function _load_normalizePattern() {
          return _normalizePattern = __webpack_require__(29);
        }
        var _parse2;
        function _load_parse2() {
          return _parse2 = _interopRequireDefault(__webpack_require__(81));
        }
        var _constants;
        function _load_constants() {
          return _constants = __webpack_require__(6);
        }
        var _fs;
        function _load_fs() {
          return _fs = _interopRequireWildcard(__webpack_require__(5));
        }
        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};
            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key))
                  newObj[key] = obj[key];
              }
            }
            newObj.default = obj;
            return newObj;
          }
        }
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const invariant = __webpack_require__(7);
        const path = __webpack_require__(0);
        const ssri = __webpack_require__(55);
        function getName(pattern) {
          return (0, (_normalizePattern || _load_normalizePattern()).normalizePattern)(pattern).name;
        }
        function blankObjectUndefined(obj) {
          return obj && Object.keys(obj).length ? obj : void 0;
        }
        function keyForRemote(remote) {
          return remote.resolved || (remote.reference && remote.hash ? `${remote.reference}#${remote.hash}` : null);
        }
        function serializeIntegrity(integrity) {
          return integrity.toString().split(" ").sort().join(" ");
        }
        function implodeEntry(pattern, obj) {
          const inferredName = getName(pattern);
          const integrity = obj.integrity ? serializeIntegrity(obj.integrity) : "";
          const imploded = {
            name: inferredName === obj.name ? void 0 : obj.name,
            version: obj.version,
            uid: obj.uid === obj.version ? void 0 : obj.uid,
            resolved: obj.resolved,
            registry: obj.registry === "npm" ? void 0 : obj.registry,
            dependencies: blankObjectUndefined(obj.dependencies),
            optionalDependencies: blankObjectUndefined(obj.optionalDependencies),
            permissions: blankObjectUndefined(obj.permissions),
            prebuiltVariants: blankObjectUndefined(obj.prebuiltVariants)
          };
          if (integrity) {
            imploded.integrity = integrity;
          }
          return imploded;
        }
        function explodeEntry(pattern, obj) {
          obj.optionalDependencies = obj.optionalDependencies || {};
          obj.dependencies = obj.dependencies || {};
          obj.uid = obj.uid || obj.version;
          obj.permissions = obj.permissions || {};
          obj.registry = obj.registry || "npm";
          obj.name = obj.name || getName(pattern);
          const integrity = obj.integrity;
          if (integrity && integrity.isIntegrity) {
            obj.integrity = ssri.parse(integrity);
          }
          return obj;
        }
        class Lockfile {
          constructor({ cache, source, parseResultType } = {}) {
            this.source = source || "";
            this.cache = cache;
            this.parseResultType = parseResultType;
          }
          // source string if the `cache` was parsed
          // if true, we're parsing an old yarn file and need to update integrity fields
          hasEntriesExistWithoutIntegrity() {
            if (!this.cache) {
              return false;
            }
            for (const key in this.cache) {
              if (!/^.*@(file:|http)/.test(key) && this.cache[key] && !this.cache[key].integrity) {
                return true;
              }
            }
            return false;
          }
          static fromDirectory(dir, reporter) {
            return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
              const lockfileLoc = path.join(dir, (_constants || _load_constants()).LOCKFILE_FILENAME);
              let lockfile2;
              let rawLockfile = "";
              let parseResult;
              if (yield (_fs || _load_fs()).exists(lockfileLoc)) {
                rawLockfile = yield (_fs || _load_fs()).readFile(lockfileLoc);
                parseResult = (0, (_parse2 || _load_parse2()).default)(rawLockfile, lockfileLoc);
                if (reporter) {
                  if (parseResult.type === "merge") {
                    reporter.info(reporter.lang("lockfileMerged"));
                  } else if (parseResult.type === "conflict") {
                    reporter.warn(reporter.lang("lockfileConflict"));
                  }
                }
                lockfile2 = parseResult.object;
              } else if (reporter) {
                reporter.info(reporter.lang("noLockfileFound"));
              }
              return new Lockfile({ cache: lockfile2, source: rawLockfile, parseResultType: parseResult && parseResult.type });
            })();
          }
          getLocked(pattern) {
            const cache = this.cache;
            if (!cache) {
              return void 0;
            }
            const shrunk = pattern in cache && cache[pattern];
            if (typeof shrunk === "string") {
              return this.getLocked(shrunk);
            } else if (shrunk) {
              explodeEntry(pattern, shrunk);
              return shrunk;
            }
            return void 0;
          }
          removePattern(pattern) {
            const cache = this.cache;
            if (!cache) {
              return;
            }
            delete cache[pattern];
          }
          getLockfile(patterns) {
            const lockfile2 = {};
            const seen = /* @__PURE__ */ new Map();
            const sortedPatternsKeys = Object.keys(patterns).sort((_misc || _load_misc()).sortAlpha);
            for (var _iterator = sortedPatternsKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
              var _ref;
              if (_isArray) {
                if (_i >= _iterator.length)
                  break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done)
                  break;
                _ref = _i.value;
              }
              const pattern = _ref;
              const pkg = patterns[pattern];
              const remote = pkg._remote, ref = pkg._reference;
              invariant(ref, "Package is missing a reference");
              invariant(remote, "Package is missing a remote");
              const remoteKey = keyForRemote(remote);
              const seenPattern = remoteKey && seen.get(remoteKey);
              if (seenPattern) {
                lockfile2[pattern] = seenPattern;
                if (!seenPattern.name && getName(pattern) !== pkg.name) {
                  seenPattern.name = pkg.name;
                }
                continue;
              }
              const obj = implodeEntry(pattern, {
                name: pkg.name,
                version: pkg.version,
                uid: pkg._uid,
                resolved: remote.resolved,
                integrity: remote.integrity,
                registry: remote.registry,
                dependencies: pkg.dependencies,
                peerDependencies: pkg.peerDependencies,
                optionalDependencies: pkg.optionalDependencies,
                permissions: ref.permissions,
                prebuiltVariants: pkg.prebuiltVariants
              });
              lockfile2[pattern] = obj;
              if (remoteKey) {
                seen.set(remoteKey, obj);
              }
            }
            return lockfile2;
          }
        }
        exports2.default = Lockfile;
      },
      ,
      ,
      /* 17 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("stream");
      },
      ,
      ,
      /* 20 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = nullify;
        function nullify(obj = {}) {
          if (Array.isArray(obj)) {
            for (var _iterator = obj, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
              var _ref;
              if (_isArray) {
                if (_i >= _iterator.length)
                  break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done)
                  break;
                _ref = _i.value;
              }
              const item = _ref;
              nullify(item);
            }
          } else if (obj !== null && typeof obj === "object" || typeof obj === "function") {
            Object.setPrototypeOf(obj, null);
            if (typeof obj === "object") {
              for (const key in obj) {
                nullify(obj[key]);
              }
            }
          }
          return obj;
        }
      },
      ,
      /* 22 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("assert");
      },
      /* 23 */
      /***/
      function(module3, exports2) {
        var core = module3.exports = { version: "2.5.7" };
        if (typeof __e == "number")
          __e = core;
      },
      ,
      ,
      ,
      /* 27 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var isObject = __webpack_require__(34);
        module3.exports = function(it2) {
          if (!isObject(it2))
            throw TypeError(it2 + " is not an object!");
          return it2;
        };
      },
      ,
      /* 29 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.normalizePattern = normalizePattern;
        function normalizePattern(pattern) {
          let hasVersion = false;
          let range = "latest";
          let name = pattern;
          let isScoped = false;
          if (name[0] === "@") {
            isScoped = true;
            name = name.slice(1);
          }
          const parts = name.split("@");
          if (parts.length > 1) {
            name = parts.shift();
            range = parts.join("@");
            if (range) {
              hasVersion = true;
            } else {
              range = "*";
            }
          }
          if (isScoped) {
            name = `@${name}`;
          }
          return { name, range, hasVersion };
        }
      },
      ,
      /* 31 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var dP = __webpack_require__(50);
        var createDesc = __webpack_require__(106);
        module3.exports = __webpack_require__(33) ? function(object, key, value) {
          return dP.f(object, key, createDesc(1, value));
        } : function(object, key, value) {
          object[key] = value;
          return object;
        };
      },
      /* 32 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var buffer = __webpack_require__(63);
        var Buffer2 = buffer.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
          module3.exports = buffer;
        } else {
          copyProps(buffer, exports2);
          exports2.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer2(arg, encodingOrOffset, length);
        }
        copyProps(Buffer2, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer2(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer2(size);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer2(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      },
      /* 33 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = !__webpack_require__(85)(function() {
          return Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      },
      /* 34 */
      /***/
      function(module3, exports2) {
        module3.exports = function(it2) {
          return typeof it2 === "object" ? it2 !== null : typeof it2 === "function";
        };
      },
      /* 35 */
      /***/
      function(module3, exports2) {
        module3.exports = {};
      },
      /* 36 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("os");
      },
      ,
      ,
      ,
      /* 40 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.wait = wait;
        exports2.promisify = promisify;
        exports2.queue = queue;
        function wait(delay) {
          return new Promise((resolve) => {
            setTimeout(resolve, delay);
          });
        }
        function promisify(fn2, firstData) {
          return function(...args) {
            return new Promise(function(resolve, reject) {
              args.push(function(err, ...result) {
                let res = result;
                if (result.length <= 1) {
                  res = result[0];
                }
                if (firstData) {
                  res = err;
                  err = null;
                }
                if (err) {
                  reject(err);
                } else {
                  resolve(res);
                }
              });
              fn2.apply(null, args);
            });
          };
        }
        function queue(arr, promiseProducer, concurrency = Infinity) {
          concurrency = Math.min(concurrency, arr.length);
          arr = arr.slice();
          const results = [];
          let total = arr.length;
          if (!total) {
            return Promise.resolve(results);
          }
          return new Promise((resolve, reject) => {
            for (let i6 = 0; i6 < concurrency; i6++) {
              next();
            }
            function next() {
              const item = arr.shift();
              const promise = promiseProducer(item);
              promise.then(function(result) {
                results.push(result);
                total--;
                if (total === 0) {
                  resolve(results);
                } else {
                  if (arr.length) {
                    next();
                  }
                }
              }, reject);
            }
          });
        }
      },
      /* 41 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var global2 = __webpack_require__(11);
        var core = __webpack_require__(23);
        var ctx = __webpack_require__(48);
        var hide = __webpack_require__(31);
        var has = __webpack_require__(49);
        var PROTOTYPE = "prototype";
        var $export = function(type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var IS_WRAP = type & $export.W;
          var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports3[PROTOTYPE];
          var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] : (global2[name] || {})[PROTOTYPE];
          var key, own, out;
          if (IS_GLOBAL)
            source = name;
          for (key in source) {
            own = !IS_FORCED && target && target[key] !== void 0;
            if (own && has(exports3, key))
              continue;
            out = own ? target[key] : source[key];
            exports3[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global2) : IS_WRAP && target[key] == out ? function(C4) {
              var F4 = function(a7, b3, c3) {
                if (this instanceof C4) {
                  switch (arguments.length) {
                    case 0:
                      return new C4();
                    case 1:
                      return new C4(a7);
                    case 2:
                      return new C4(a7, b3);
                  }
                  return new C4(a7, b3, c3);
                }
                return C4.apply(this, arguments);
              };
              F4[PROTOTYPE] = C4[PROTOTYPE];
              return F4;
            }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
            if (IS_PROTO) {
              (exports3.virtual || (exports3.virtual = {}))[key] = out;
              if (type & $export.R && expProto && !expProto[key])
                hide(expProto, key, out);
            }
          }
        };
        $export.F = 1;
        $export.G = 2;
        $export.S = 4;
        $export.P = 8;
        $export.B = 16;
        $export.W = 32;
        $export.U = 64;
        $export.R = 128;
        module3.exports = $export;
      },
      /* 42 */
      /***/
      function(module3, exports2, __webpack_require__) {
        try {
          var util = __webpack_require__(2);
          if (typeof util.inherits !== "function")
            throw "";
          module3.exports = util.inherits;
        } catch (e5) {
          module3.exports = __webpack_require__(224);
        }
      },
      ,
      ,
      /* 45 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.home = void 0;
        var _rootUser;
        function _load_rootUser() {
          return _rootUser = _interopRequireDefault(__webpack_require__(169));
        }
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const path = __webpack_require__(0);
        const home = exports2.home = __webpack_require__(36).homedir();
        const userHomeDir = (_rootUser || _load_rootUser()).default ? path.resolve("/usr/local/share") : home;
        exports2.default = userHomeDir;
      },
      /* 46 */
      /***/
      function(module3, exports2) {
        module3.exports = function(it2) {
          if (typeof it2 != "function")
            throw TypeError(it2 + " is not a function!");
          return it2;
        };
      },
      /* 47 */
      /***/
      function(module3, exports2) {
        var toString = {}.toString;
        module3.exports = function(it2) {
          return toString.call(it2).slice(8, -1);
        };
      },
      /* 48 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var aFunction = __webpack_require__(46);
        module3.exports = function(fn2, that, length) {
          aFunction(fn2);
          if (that === void 0)
            return fn2;
          switch (length) {
            case 1:
              return function(a7) {
                return fn2.call(that, a7);
              };
            case 2:
              return function(a7, b3) {
                return fn2.call(that, a7, b3);
              };
            case 3:
              return function(a7, b3, c3) {
                return fn2.call(that, a7, b3, c3);
              };
          }
          return function() {
            return fn2.apply(that, arguments);
          };
        };
      },
      /* 49 */
      /***/
      function(module3, exports2) {
        var hasOwnProperty = {}.hasOwnProperty;
        module3.exports = function(it2, key) {
          return hasOwnProperty.call(it2, key);
        };
      },
      /* 50 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var anObject = __webpack_require__(27);
        var IE8_DOM_DEFINE = __webpack_require__(184);
        var toPrimitive = __webpack_require__(201);
        var dP = Object.defineProperty;
        exports2.f = __webpack_require__(33) ? Object.defineProperty : function defineProperty(O5, P3, Attributes) {
          anObject(O5);
          P3 = toPrimitive(P3, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE)
            try {
              return dP(O5, P3, Attributes);
            } catch (e5) {
            }
          if ("get" in Attributes || "set" in Attributes)
            throw TypeError("Accessors not supported!");
          if ("value" in Attributes)
            O5[P3] = Attributes.value;
          return O5;
        };
      },
      ,
      ,
      ,
      /* 54 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("events");
      },
      /* 55 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        const Buffer2 = __webpack_require__(32).Buffer;
        const crypto = __webpack_require__(9);
        const Transform = __webpack_require__(17).Transform;
        const SPEC_ALGORITHMS = ["sha256", "sha384", "sha512"];
        const BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;
        const SRI_REGEX = /^([^-]+)-([^?]+)([?\S*]*)$/;
        const STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)*$/;
        const VCHAR_REGEX = /^[\x21-\x7E]+$/;
        class Hash {
          get isHash() {
            return true;
          }
          constructor(hash, opts) {
            const strict = !!(opts && opts.strict);
            this.source = hash.trim();
            const match = this.source.match(
              strict ? STRICT_SRI_REGEX : SRI_REGEX
            );
            if (!match) {
              return;
            }
            if (strict && !SPEC_ALGORITHMS.some((a7) => a7 === match[1])) {
              return;
            }
            this.algorithm = match[1];
            this.digest = match[2];
            const rawOpts = match[3];
            this.options = rawOpts ? rawOpts.slice(1).split("?") : [];
          }
          hexDigest() {
            return this.digest && Buffer2.from(this.digest, "base64").toString("hex");
          }
          toJSON() {
            return this.toString();
          }
          toString(opts) {
            if (opts && opts.strict) {
              if (!// The spec has very restricted productions for algorithms.
              // https://www.w3.org/TR/CSP2/#source-list-syntax
              (SPEC_ALGORITHMS.some((x2) => x2 === this.algorithm) && // Usually, if someone insists on using a "different" base64, we
              // leave it as-is, since there's multiple standards, and the
              // specified is not a URL-safe variant.
              // https://www.w3.org/TR/CSP2/#base64_value
              this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.
              // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression
              // https://tools.ietf.org/html/rfc5234#appendix-B.1
              (this.options || []).every((opt) => opt.match(VCHAR_REGEX)))) {
                return "";
              }
            }
            const options = this.options && this.options.length ? `?${this.options.join("?")}` : "";
            return `${this.algorithm}-${this.digest}${options}`;
          }
        }
        class Integrity {
          get isIntegrity() {
            return true;
          }
          toJSON() {
            return this.toString();
          }
          toString(opts) {
            opts = opts || {};
            let sep2 = opts.sep || " ";
            if (opts.strict) {
              sep2 = sep2.replace(/\S+/g, " ");
            }
            return Object.keys(this).map((k3) => {
              return this[k3].map((hash) => {
                return Hash.prototype.toString.call(hash, opts);
              }).filter((x2) => x2.length).join(sep2);
            }).filter((x2) => x2.length).join(sep2);
          }
          concat(integrity, opts) {
            const other = typeof integrity === "string" ? integrity : stringify(integrity, opts);
            return parse2(`${this.toString(opts)} ${other}`, opts);
          }
          hexDigest() {
            return parse2(this, { single: true }).hexDigest();
          }
          match(integrity, opts) {
            const other = parse2(integrity, opts);
            const algo = other.pickAlgorithm(opts);
            return this[algo] && other[algo] && this[algo].find(
              (hash) => other[algo].find(
                (otherhash) => hash.digest === otherhash.digest
              )
            ) || false;
          }
          pickAlgorithm(opts) {
            const pickAlgorithm = opts && opts.pickAlgorithm || getPrioritizedHash;
            const keys = Object.keys(this);
            if (!keys.length) {
              throw new Error(`No algorithms available for ${JSON.stringify(this.toString())}`);
            }
            return keys.reduce((acc, algo) => {
              return pickAlgorithm(acc, algo) || acc;
            });
          }
        }
        module3.exports.parse = parse2;
        function parse2(sri, opts) {
          opts = opts || {};
          if (typeof sri === "string") {
            return _parse(sri, opts);
          } else if (sri.algorithm && sri.digest) {
            const fullSri = new Integrity();
            fullSri[sri.algorithm] = [sri];
            return _parse(stringify(fullSri, opts), opts);
          } else {
            return _parse(stringify(sri, opts), opts);
          }
        }
        function _parse(integrity, opts) {
          if (opts.single) {
            return new Hash(integrity, opts);
          }
          return integrity.trim().split(/\s+/).reduce((acc, string) => {
            const hash = new Hash(string, opts);
            if (hash.algorithm && hash.digest) {
              const algo = hash.algorithm;
              if (!acc[algo]) {
                acc[algo] = [];
              }
              acc[algo].push(hash);
            }
            return acc;
          }, new Integrity());
        }
        module3.exports.stringify = stringify;
        function stringify(obj, opts) {
          if (obj.algorithm && obj.digest) {
            return Hash.prototype.toString.call(obj, opts);
          } else if (typeof obj === "string") {
            return stringify(parse2(obj, opts), opts);
          } else {
            return Integrity.prototype.toString.call(obj, opts);
          }
        }
        module3.exports.fromHex = fromHex;
        function fromHex(hexDigest, algorithm, opts) {
          const optString = opts && opts.options && opts.options.length ? `?${opts.options.join("?")}` : "";
          return parse2(
            `${algorithm}-${Buffer2.from(hexDigest, "hex").toString("base64")}${optString}`,
            opts
          );
        }
        module3.exports.fromData = fromData;
        function fromData(data, opts) {
          opts = opts || {};
          const algorithms = opts.algorithms || ["sha512"];
          const optString = opts.options && opts.options.length ? `?${opts.options.join("?")}` : "";
          return algorithms.reduce((acc, algo) => {
            const digest = crypto.createHash(algo).update(data).digest("base64");
            const hash = new Hash(
              `${algo}-${digest}${optString}`,
              opts
            );
            if (hash.algorithm && hash.digest) {
              const algo2 = hash.algorithm;
              if (!acc[algo2]) {
                acc[algo2] = [];
              }
              acc[algo2].push(hash);
            }
            return acc;
          }, new Integrity());
        }
        module3.exports.fromStream = fromStream;
        function fromStream(stream, opts) {
          opts = opts || {};
          const P3 = opts.Promise || Promise;
          const istream = integrityStream(opts);
          return new P3((resolve, reject) => {
            stream.pipe(istream);
            stream.on("error", reject);
            istream.on("error", reject);
            let sri;
            istream.on("integrity", (s5) => {
              sri = s5;
            });
            istream.on("end", () => resolve(sri));
            istream.on("data", () => {
            });
          });
        }
        module3.exports.checkData = checkData;
        function checkData(data, sri, opts) {
          opts = opts || {};
          sri = parse2(sri, opts);
          if (!Object.keys(sri).length) {
            if (opts.error) {
              throw Object.assign(
                new Error("No valid integrity hashes to check against"),
                {
                  code: "EINTEGRITY"
                }
              );
            } else {
              return false;
            }
          }
          const algorithm = sri.pickAlgorithm(opts);
          const digest = crypto.createHash(algorithm).update(data).digest("base64");
          const newSri = parse2({ algorithm, digest });
          const match = newSri.match(sri, opts);
          if (match || !opts.error) {
            return match;
          } else if (typeof opts.size === "number" && data.length !== opts.size) {
            const err = new Error(`data size mismatch when checking ${sri}.
  Wanted: ${opts.size}
  Found: ${data.length}`);
            err.code = "EBADSIZE";
            err.found = data.length;
            err.expected = opts.size;
            err.sri = sri;
            throw err;
          } else {
            const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);
            err.code = "EINTEGRITY";
            err.found = newSri;
            err.expected = sri;
            err.algorithm = algorithm;
            err.sri = sri;
            throw err;
          }
        }
        module3.exports.checkStream = checkStream;
        function checkStream(stream, sri, opts) {
          opts = opts || {};
          const P3 = opts.Promise || Promise;
          const checker = integrityStream(Object.assign({}, opts, {
            integrity: sri
          }));
          return new P3((resolve, reject) => {
            stream.pipe(checker);
            stream.on("error", reject);
            checker.on("error", reject);
            let sri2;
            checker.on("verified", (s5) => {
              sri2 = s5;
            });
            checker.on("end", () => resolve(sri2));
            checker.on("data", () => {
            });
          });
        }
        module3.exports.integrityStream = integrityStream;
        function integrityStream(opts) {
          opts = opts || {};
          const sri = opts.integrity && parse2(opts.integrity, opts);
          const goodSri = sri && Object.keys(sri).length;
          const algorithm = goodSri && sri.pickAlgorithm(opts);
          const digests = goodSri && sri[algorithm];
          const algorithms = Array.from(
            new Set(
              (opts.algorithms || ["sha512"]).concat(algorithm ? [algorithm] : [])
            )
          );
          const hashes = algorithms.map(crypto.createHash);
          let streamSize = 0;
          const stream = new Transform({
            transform(chunk, enc, cb) {
              streamSize += chunk.length;
              hashes.forEach((h4) => h4.update(chunk, enc));
              cb(null, chunk, enc);
            }
          }).on("end", () => {
            const optString = opts.options && opts.options.length ? `?${opts.options.join("?")}` : "";
            const newSri = parse2(hashes.map((h4, i6) => {
              return `${algorithms[i6]}-${h4.digest("base64")}${optString}`;
            }).join(" "), opts);
            const match = goodSri && newSri.match(sri, opts);
            if (typeof opts.size === "number" && streamSize !== opts.size) {
              const err = new Error(`stream size mismatch when checking ${sri}.
  Wanted: ${opts.size}
  Found: ${streamSize}`);
              err.code = "EBADSIZE";
              err.found = streamSize;
              err.expected = opts.size;
              err.sri = sri;
              stream.emit("error", err);
            } else if (opts.integrity && !match) {
              const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`);
              err.code = "EINTEGRITY";
              err.found = newSri;
              err.expected = digests;
              err.algorithm = algorithm;
              err.sri = sri;
              stream.emit("error", err);
            } else {
              stream.emit("size", streamSize);
              stream.emit("integrity", newSri);
              match && stream.emit("verified", match);
            }
          });
          return stream;
        }
        module3.exports.create = createIntegrity;
        function createIntegrity(opts) {
          opts = opts || {};
          const algorithms = opts.algorithms || ["sha512"];
          const optString = opts.options && opts.options.length ? `?${opts.options.join("?")}` : "";
          const hashes = algorithms.map(crypto.createHash);
          return {
            update: function(chunk, enc) {
              hashes.forEach((h4) => h4.update(chunk, enc));
              return this;
            },
            digest: function(enc) {
              const integrity = algorithms.reduce((acc, algo) => {
                const digest = hashes.shift().digest("base64");
                const hash = new Hash(
                  `${algo}-${digest}${optString}`,
                  opts
                );
                if (hash.algorithm && hash.digest) {
                  const algo2 = hash.algorithm;
                  if (!acc[algo2]) {
                    acc[algo2] = [];
                  }
                  acc[algo2].push(hash);
                }
                return acc;
              }, new Integrity());
              return integrity;
            }
          };
        }
        const NODE_HASHES = new Set(crypto.getHashes());
        const DEFAULT_PRIORITY = [
          "md5",
          "whirlpool",
          "sha1",
          "sha224",
          "sha256",
          "sha384",
          "sha512",
          // TODO - it's unclear _which_ of these Node will actually use as its name
          //        for the algorithm, so we guesswork it based on the OpenSSL names.
          "sha3",
          "sha3-256",
          "sha3-384",
          "sha3-512",
          "sha3_256",
          "sha3_384",
          "sha3_512"
        ].filter((algo) => NODE_HASHES.has(algo));
        function getPrioritizedHash(algo1, algo2) {
          return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;
        }
      },
      ,
      ,
      ,
      ,
      /* 60 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = minimatch;
        minimatch.Minimatch = Minimatch;
        var path = { sep: "/" };
        try {
          path = __webpack_require__(0);
        } catch (er2) {
        }
        var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
        var expand2 = __webpack_require__(175);
        var plTypes = {
          "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
          "?": { open: "(?:", close: ")?" },
          "+": { open: "(?:", close: ")+" },
          "*": { open: "(?:", close: ")*" },
          "@": { open: "(?:", close: ")" }
        };
        var qmark = "[^/]";
        var star = qmark + "*?";
        var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
        var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
        var reSpecials = charSet("().*{}+?[]^$\\!");
        function charSet(s5) {
          return s5.split("").reduce(function(set, c3) {
            set[c3] = true;
            return set;
          }, {});
        }
        var slashSplit = /\/+/;
        minimatch.filter = filter;
        function filter(pattern, options) {
          options = options || {};
          return function(p5, i6, list) {
            return minimatch(p5, pattern, options);
          };
        }
        function ext(a7, b3) {
          a7 = a7 || {};
          b3 = b3 || {};
          var t3 = {};
          Object.keys(b3).forEach(function(k3) {
            t3[k3] = b3[k3];
          });
          Object.keys(a7).forEach(function(k3) {
            t3[k3] = a7[k3];
          });
          return t3;
        }
        minimatch.defaults = function(def) {
          if (!def || !Object.keys(def).length)
            return minimatch;
          var orig = minimatch;
          var m8 = function minimatch2(p5, pattern, options) {
            return orig.minimatch(p5, pattern, ext(def, options));
          };
          m8.Minimatch = function Minimatch2(pattern, options) {
            return new orig.Minimatch(pattern, ext(def, options));
          };
          return m8;
        };
        Minimatch.defaults = function(def) {
          if (!def || !Object.keys(def).length)
            return Minimatch;
          return minimatch.defaults(def).Minimatch;
        };
        function minimatch(p5, pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("glob pattern string required");
          }
          if (!options)
            options = {};
          if (!options.nocomment && pattern.charAt(0) === "#") {
            return false;
          }
          if (pattern.trim() === "")
            return p5 === "";
          return new Minimatch(pattern, options).match(p5);
        }
        function Minimatch(pattern, options) {
          if (!(this instanceof Minimatch)) {
            return new Minimatch(pattern, options);
          }
          if (typeof pattern !== "string") {
            throw new TypeError("glob pattern string required");
          }
          if (!options)
            options = {};
          pattern = pattern.trim();
          if (path.sep !== "/") {
            pattern = pattern.split(path.sep).join("/");
          }
          this.options = options;
          this.set = [];
          this.pattern = pattern;
          this.regexp = null;
          this.negate = false;
          this.comment = false;
          this.empty = false;
          this.make();
        }
        Minimatch.prototype.debug = function() {
        };
        Minimatch.prototype.make = make;
        function make() {
          if (this._made)
            return;
          var pattern = this.pattern;
          var options = this.options;
          if (!options.nocomment && pattern.charAt(0) === "#") {
            this.comment = true;
            return;
          }
          if (!pattern) {
            this.empty = true;
            return;
          }
          this.parseNegate();
          var set = this.globSet = this.braceExpand();
          if (options.debug)
            this.debug = console.error;
          this.debug(this.pattern, set);
          set = this.globParts = set.map(function(s5) {
            return s5.split(slashSplit);
          });
          this.debug(this.pattern, set);
          set = set.map(function(s5, si, set2) {
            return s5.map(this.parse, this);
          }, this);
          this.debug(this.pattern, set);
          set = set.filter(function(s5) {
            return s5.indexOf(false) === -1;
          });
          this.debug(this.pattern, set);
          this.set = set;
        }
        Minimatch.prototype.parseNegate = parseNegate;
        function parseNegate() {
          var pattern = this.pattern;
          var negate = false;
          var options = this.options;
          var negateOffset = 0;
          if (options.nonegate)
            return;
          for (var i6 = 0, l3 = pattern.length; i6 < l3 && pattern.charAt(i6) === "!"; i6++) {
            negate = !negate;
            negateOffset++;
          }
          if (negateOffset)
            this.pattern = pattern.substr(negateOffset);
          this.negate = negate;
        }
        minimatch.braceExpand = function(pattern, options) {
          return braceExpand(pattern, options);
        };
        Minimatch.prototype.braceExpand = braceExpand;
        function braceExpand(pattern, options) {
          if (!options) {
            if (this instanceof Minimatch) {
              options = this.options;
            } else {
              options = {};
            }
          }
          pattern = typeof pattern === "undefined" ? this.pattern : pattern;
          if (typeof pattern === "undefined") {
            throw new TypeError("undefined pattern");
          }
          if (options.nobrace || !pattern.match(/\{.*\}/)) {
            return [pattern];
          }
          return expand2(pattern);
        }
        Minimatch.prototype.parse = parse2;
        var SUBPARSE = {};
        function parse2(pattern, isSub) {
          if (pattern.length > 1024 * 64) {
            throw new TypeError("pattern is too long");
          }
          var options = this.options;
          if (!options.noglobstar && pattern === "**")
            return GLOBSTAR;
          if (pattern === "")
            return "";
          var re3 = "";
          var hasMagic = !!options.nocase;
          var escaping = false;
          var patternListStack = [];
          var negativeLists = [];
          var stateChar;
          var inClass = false;
          var reClassStart = -1;
          var classStart = -1;
          var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
          var self2 = this;
          function clearStateChar() {
            if (stateChar) {
              switch (stateChar) {
                case "*":
                  re3 += star;
                  hasMagic = true;
                  break;
                case "?":
                  re3 += qmark;
                  hasMagic = true;
                  break;
                default:
                  re3 += "\\" + stateChar;
                  break;
              }
              self2.debug("clearStateChar %j %j", stateChar, re3);
              stateChar = false;
            }
          }
          for (var i6 = 0, len = pattern.length, c3; i6 < len && (c3 = pattern.charAt(i6)); i6++) {
            this.debug("%s	%s %s %j", pattern, i6, re3, c3);
            if (escaping && reSpecials[c3]) {
              re3 += "\\" + c3;
              escaping = false;
              continue;
            }
            switch (c3) {
              case "/":
                return false;
              case "\\":
                clearStateChar();
                escaping = true;
                continue;
              case "?":
              case "*":
              case "+":
              case "@":
              case "!":
                this.debug("%s	%s %s %j <-- stateChar", pattern, i6, re3, c3);
                if (inClass) {
                  this.debug("  in class");
                  if (c3 === "!" && i6 === classStart + 1)
                    c3 = "^";
                  re3 += c3;
                  continue;
                }
                self2.debug("call clearStateChar %j", stateChar);
                clearStateChar();
                stateChar = c3;
                if (options.noext)
                  clearStateChar();
                continue;
              case "(":
                if (inClass) {
                  re3 += "(";
                  continue;
                }
                if (!stateChar) {
                  re3 += "\\(";
                  continue;
                }
                patternListStack.push({
                  type: stateChar,
                  start: i6 - 1,
                  reStart: re3.length,
                  open: plTypes[stateChar].open,
                  close: plTypes[stateChar].close
                });
                re3 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
                this.debug("plType %j %j", stateChar, re3);
                stateChar = false;
                continue;
              case ")":
                if (inClass || !patternListStack.length) {
                  re3 += "\\)";
                  continue;
                }
                clearStateChar();
                hasMagic = true;
                var pl = patternListStack.pop();
                re3 += pl.close;
                if (pl.type === "!") {
                  negativeLists.push(pl);
                }
                pl.reEnd = re3.length;
                continue;
              case "|":
                if (inClass || !patternListStack.length || escaping) {
                  re3 += "\\|";
                  escaping = false;
                  continue;
                }
                clearStateChar();
                re3 += "|";
                continue;
              case "[":
                clearStateChar();
                if (inClass) {
                  re3 += "\\" + c3;
                  continue;
                }
                inClass = true;
                classStart = i6;
                reClassStart = re3.length;
                re3 += c3;
                continue;
              case "]":
                if (i6 === classStart + 1 || !inClass) {
                  re3 += "\\" + c3;
                  escaping = false;
                  continue;
                }
                if (inClass) {
                  var cs = pattern.substring(classStart + 1, i6);
                  try {
                    RegExp("[" + cs + "]");
                  } catch (er2) {
                    var sp = this.parse(cs, SUBPARSE);
                    re3 = re3.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                    hasMagic = hasMagic || sp[1];
                    inClass = false;
                    continue;
                  }
                }
                hasMagic = true;
                inClass = false;
                re3 += c3;
                continue;
              default:
                clearStateChar();
                if (escaping) {
                  escaping = false;
                } else if (reSpecials[c3] && !(c3 === "^" && inClass)) {
                  re3 += "\\";
                }
                re3 += c3;
            }
          }
          if (inClass) {
            cs = pattern.substr(classStart + 1);
            sp = this.parse(cs, SUBPARSE);
            re3 = re3.substr(0, reClassStart) + "\\[" + sp[0];
            hasMagic = hasMagic || sp[1];
          }
          for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
            var tail = re3.slice(pl.reStart + pl.open.length);
            this.debug("setting tail", re3, pl);
            tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_4, $1, $22) {
              if (!$22) {
                $22 = "\\";
              }
              return $1 + $1 + $22 + "|";
            });
            this.debug("tail=%j\n   %s", tail, tail, pl, re3);
            var t3 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
            hasMagic = true;
            re3 = re3.slice(0, pl.reStart) + t3 + "\\(" + tail;
          }
          clearStateChar();
          if (escaping) {
            re3 += "\\\\";
          }
          var addPatternStart = false;
          switch (re3.charAt(0)) {
            case ".":
            case "[":
            case "(":
              addPatternStart = true;
          }
          for (var n3 = negativeLists.length - 1; n3 > -1; n3--) {
            var nl = negativeLists[n3];
            var nlBefore = re3.slice(0, nl.reStart);
            var nlFirst = re3.slice(nl.reStart, nl.reEnd - 8);
            var nlLast = re3.slice(nl.reEnd - 8, nl.reEnd);
            var nlAfter = re3.slice(nl.reEnd);
            nlLast += nlAfter;
            var openParensBefore = nlBefore.split("(").length - 1;
            var cleanAfter = nlAfter;
            for (i6 = 0; i6 < openParensBefore; i6++) {
              cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
            }
            nlAfter = cleanAfter;
            var dollar = "";
            if (nlAfter === "" && isSub !== SUBPARSE) {
              dollar = "$";
            }
            var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
            re3 = newRe;
          }
          if (re3 !== "" && hasMagic) {
            re3 = "(?=.)" + re3;
          }
          if (addPatternStart) {
            re3 = patternStart + re3;
          }
          if (isSub === SUBPARSE) {
            return [re3, hasMagic];
          }
          if (!hasMagic) {
            return globUnescape(pattern);
          }
          var flags = options.nocase ? "i" : "";
          try {
            var regExp = new RegExp("^" + re3 + "$", flags);
          } catch (er2) {
            return new RegExp("$.");
          }
          regExp._glob = pattern;
          regExp._src = re3;
          return regExp;
        }
        minimatch.makeRe = function(pattern, options) {
          return new Minimatch(pattern, options || {}).makeRe();
        };
        Minimatch.prototype.makeRe = makeRe;
        function makeRe() {
          if (this.regexp || this.regexp === false)
            return this.regexp;
          var set = this.set;
          if (!set.length) {
            this.regexp = false;
            return this.regexp;
          }
          var options = this.options;
          var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
          var flags = options.nocase ? "i" : "";
          var re3 = set.map(function(pattern) {
            return pattern.map(function(p5) {
              return p5 === GLOBSTAR ? twoStar : typeof p5 === "string" ? regExpEscape(p5) : p5._src;
            }).join("\\/");
          }).join("|");
          re3 = "^(?:" + re3 + ")$";
          if (this.negate)
            re3 = "^(?!" + re3 + ").*$";
          try {
            this.regexp = new RegExp(re3, flags);
          } catch (ex) {
            this.regexp = false;
          }
          return this.regexp;
        }
        minimatch.match = function(list, pattern, options) {
          options = options || {};
          var mm = new Minimatch(pattern, options);
          list = list.filter(function(f6) {
            return mm.match(f6);
          });
          if (mm.options.nonull && !list.length) {
            list.push(pattern);
          }
          return list;
        };
        Minimatch.prototype.match = match;
        function match(f6, partial) {
          this.debug("match", f6, this.pattern);
          if (this.comment)
            return false;
          if (this.empty)
            return f6 === "";
          if (f6 === "/" && partial)
            return true;
          var options = this.options;
          if (path.sep !== "/") {
            f6 = f6.split(path.sep).join("/");
          }
          f6 = f6.split(slashSplit);
          this.debug(this.pattern, "split", f6);
          var set = this.set;
          this.debug(this.pattern, "set", set);
          var filename;
          var i6;
          for (i6 = f6.length - 1; i6 >= 0; i6--) {
            filename = f6[i6];
            if (filename)
              break;
          }
          for (i6 = 0; i6 < set.length; i6++) {
            var pattern = set[i6];
            var file = f6;
            if (options.matchBase && pattern.length === 1) {
              file = [filename];
            }
            var hit = this.matchOne(file, pattern, partial);
            if (hit) {
              if (options.flipNegate)
                return true;
              return !this.negate;
            }
          }
          if (options.flipNegate)
            return false;
          return this.negate;
        }
        Minimatch.prototype.matchOne = function(file, pattern, partial) {
          var options = this.options;
          this.debug(
            "matchOne",
            { "this": this, file, pattern }
          );
          this.debug("matchOne", file.length, pattern.length);
          for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug("matchOne loop");
            var p5 = pattern[pi];
            var f6 = file[fi];
            this.debug(pattern, p5, f6);
            if (p5 === false)
              return false;
            if (p5 === GLOBSTAR) {
              this.debug("GLOBSTAR", [pattern, p5, f6]);
              var fr2 = fi;
              var pr = pi + 1;
              if (pr === pl) {
                this.debug("** at the end");
                for (; fi < fl; fi++) {
                  if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                    return false;
                }
                return true;
              }
              while (fr2 < fl) {
                var swallowee = file[fr2];
                this.debug("\nglobstar while", file, fr2, pattern, pr, swallowee);
                if (this.matchOne(file.slice(fr2), pattern.slice(pr), partial)) {
                  this.debug("globstar found match!", fr2, fl, swallowee);
                  return true;
                } else {
                  if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                    this.debug("dot detected!", file, fr2, pattern, pr);
                    break;
                  }
                  this.debug("globstar swallow a segment, and continue");
                  fr2++;
                }
              }
              if (partial) {
                this.debug("\n>>> no match, partial?", file, fr2, pattern, pr);
                if (fr2 === fl)
                  return true;
              }
              return false;
            }
            var hit;
            if (typeof p5 === "string") {
              if (options.nocase) {
                hit = f6.toLowerCase() === p5.toLowerCase();
              } else {
                hit = f6 === p5;
              }
              this.debug("string match", p5, f6, hit);
            } else {
              hit = f6.match(p5);
              this.debug("pattern match", p5, f6, hit);
            }
            if (!hit)
              return false;
          }
          if (fi === fl && pi === pl) {
            return true;
          } else if (fi === fl) {
            return partial;
          } else if (pi === pl) {
            var emptyFileEnd = fi === fl - 1 && file[fi] === "";
            return emptyFileEnd;
          }
          throw new Error("wtf?");
        };
        function globUnescape(s5) {
          return s5.replace(/\\(.)/g, "$1");
        }
        function regExpEscape(s5) {
          return s5.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        }
      },
      /* 61 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var wrappy = __webpack_require__(123);
        module3.exports = wrappy(once);
        module3.exports.strict = wrappy(onceStrict);
        once.proto = once(function() {
          Object.defineProperty(Function.prototype, "once", {
            value: function() {
              return once(this);
            },
            configurable: true
          });
          Object.defineProperty(Function.prototype, "onceStrict", {
            value: function() {
              return onceStrict(this);
            },
            configurable: true
          });
        });
        function once(fn2) {
          var f6 = function() {
            if (f6.called)
              return f6.value;
            f6.called = true;
            return f6.value = fn2.apply(this, arguments);
          };
          f6.called = false;
          return f6;
        }
        function onceStrict(fn2) {
          var f6 = function() {
            if (f6.called)
              throw new Error(f6.onceError);
            f6.called = true;
            return f6.value = fn2.apply(this, arguments);
          };
          var name = fn2.name || "Function wrapped with `once`";
          f6.onceError = name + " shouldn't be called more than once";
          f6.called = false;
          return f6;
        }
      },
      ,
      /* 63 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("buffer");
      },
      ,
      ,
      ,
      /* 67 */
      /***/
      function(module3, exports2) {
        module3.exports = function(it2) {
          if (it2 == void 0)
            throw TypeError("Can't call method on  " + it2);
          return it2;
        };
      },
      /* 68 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var isObject = __webpack_require__(34);
        var document2 = __webpack_require__(11).document;
        var is = isObject(document2) && isObject(document2.createElement);
        module3.exports = function(it2) {
          return is ? document2.createElement(it2) : {};
        };
      },
      /* 69 */
      /***/
      function(module3, exports2) {
        module3.exports = true;
      },
      /* 70 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var aFunction = __webpack_require__(46);
        function PromiseCapability(C4) {
          var resolve, reject;
          this.promise = new C4(function($$resolve, $$reject) {
            if (resolve !== void 0 || reject !== void 0)
              throw TypeError("Bad Promise constructor");
            resolve = $$resolve;
            reject = $$reject;
          });
          this.resolve = aFunction(resolve);
          this.reject = aFunction(reject);
        }
        module3.exports.f = function(C4) {
          return new PromiseCapability(C4);
        };
      },
      /* 71 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var def = __webpack_require__(50).f;
        var has = __webpack_require__(49);
        var TAG = __webpack_require__(13)("toStringTag");
        module3.exports = function(it2, tag, stat) {
          if (it2 && !has(it2 = stat ? it2 : it2.prototype, TAG))
            def(it2, TAG, { configurable: true, value: tag });
        };
      },
      /* 72 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var shared = __webpack_require__(107)("keys");
        var uid = __webpack_require__(111);
        module3.exports = function(key) {
          return shared[key] || (shared[key] = uid(key));
        };
      },
      /* 73 */
      /***/
      function(module3, exports2) {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module3.exports = function(it2) {
          return isNaN(it2 = +it2) ? 0 : (it2 > 0 ? floor : ceil)(it2);
        };
      },
      /* 74 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var IObject = __webpack_require__(131);
        var defined = __webpack_require__(67);
        module3.exports = function(it2) {
          return IObject(defined(it2));
        };
      },
      /* 75 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = glob2;
        var fs = __webpack_require__(3);
        var rp = __webpack_require__(114);
        var minimatch = __webpack_require__(60);
        var Minimatch = minimatch.Minimatch;
        var inherits = __webpack_require__(42);
        var EE = __webpack_require__(54).EventEmitter;
        var path = __webpack_require__(0);
        var assert2 = __webpack_require__(22);
        var isAbsolute = __webpack_require__(76);
        var globSync = __webpack_require__(218);
        var common = __webpack_require__(115);
        var alphasort = common.alphasort;
        var alphasorti = common.alphasorti;
        var setopts = common.setopts;
        var ownProp = common.ownProp;
        var inflight = __webpack_require__(223);
        var util = __webpack_require__(2);
        var childrenIgnored = common.childrenIgnored;
        var isIgnored = common.isIgnored;
        var once = __webpack_require__(61);
        function glob2(pattern, options, cb) {
          if (typeof options === "function")
            cb = options, options = {};
          if (!options)
            options = {};
          if (options.sync) {
            if (cb)
              throw new TypeError("callback provided to sync glob");
            return globSync(pattern, options);
          }
          return new Glob(pattern, options, cb);
        }
        glob2.sync = globSync;
        var GlobSync = glob2.GlobSync = globSync.GlobSync;
        glob2.glob = glob2;
        function extend(origin, add) {
          if (add === null || typeof add !== "object") {
            return origin;
          }
          var keys = Object.keys(add);
          var i6 = keys.length;
          while (i6--) {
            origin[keys[i6]] = add[keys[i6]];
          }
          return origin;
        }
        glob2.hasMagic = function(pattern, options_) {
          var options = extend({}, options_);
          options.noprocess = true;
          var g2 = new Glob(pattern, options);
          var set = g2.minimatch.set;
          if (!pattern)
            return false;
          if (set.length > 1)
            return true;
          for (var j2 = 0; j2 < set[0].length; j2++) {
            if (typeof set[0][j2] !== "string")
              return true;
          }
          return false;
        };
        glob2.Glob = Glob;
        inherits(Glob, EE);
        function Glob(pattern, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          if (options && options.sync) {
            if (cb)
              throw new TypeError("callback provided to sync glob");
            return new GlobSync(pattern, options);
          }
          if (!(this instanceof Glob))
            return new Glob(pattern, options, cb);
          setopts(this, pattern, options);
          this._didRealPath = false;
          var n3 = this.minimatch.set.length;
          this.matches = new Array(n3);
          if (typeof cb === "function") {
            cb = once(cb);
            this.on("error", cb);
            this.on("end", function(matches) {
              cb(null, matches);
            });
          }
          var self2 = this;
          this._processing = 0;
          this._emitQueue = [];
          this._processQueue = [];
          this.paused = false;
          if (this.noprocess)
            return this;
          if (n3 === 0)
            return done();
          var sync = true;
          for (var i6 = 0; i6 < n3; i6++) {
            this._process(this.minimatch.set[i6], i6, false, done);
          }
          sync = false;
          function done() {
            --self2._processing;
            if (self2._processing <= 0) {
              if (sync) {
                process.nextTick(function() {
                  self2._finish();
                });
              } else {
                self2._finish();
              }
            }
          }
        }
        Glob.prototype._finish = function() {
          assert2(this instanceof Glob);
          if (this.aborted)
            return;
          if (this.realpath && !this._didRealpath)
            return this._realpath();
          common.finish(this);
          this.emit("end", this.found);
        };
        Glob.prototype._realpath = function() {
          if (this._didRealpath)
            return;
          this._didRealpath = true;
          var n3 = this.matches.length;
          if (n3 === 0)
            return this._finish();
          var self2 = this;
          for (var i6 = 0; i6 < this.matches.length; i6++)
            this._realpathSet(i6, next);
          function next() {
            if (--n3 === 0)
              self2._finish();
          }
        };
        Glob.prototype._realpathSet = function(index, cb) {
          var matchset = this.matches[index];
          if (!matchset)
            return cb();
          var found = Object.keys(matchset);
          var self2 = this;
          var n3 = found.length;
          if (n3 === 0)
            return cb();
          var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
          found.forEach(function(p5, i6) {
            p5 = self2._makeAbs(p5);
            rp.realpath(p5, self2.realpathCache, function(er2, real) {
              if (!er2)
                set[real] = true;
              else if (er2.syscall === "stat")
                set[p5] = true;
              else
                self2.emit("error", er2);
              if (--n3 === 0) {
                self2.matches[index] = set;
                cb();
              }
            });
          });
        };
        Glob.prototype._mark = function(p5) {
          return common.mark(this, p5);
        };
        Glob.prototype._makeAbs = function(f6) {
          return common.makeAbs(this, f6);
        };
        Glob.prototype.abort = function() {
          this.aborted = true;
          this.emit("abort");
        };
        Glob.prototype.pause = function() {
          if (!this.paused) {
            this.paused = true;
            this.emit("pause");
          }
        };
        Glob.prototype.resume = function() {
          if (this.paused) {
            this.emit("resume");
            this.paused = false;
            if (this._emitQueue.length) {
              var eq = this._emitQueue.slice(0);
              this._emitQueue.length = 0;
              for (var i6 = 0; i6 < eq.length; i6++) {
                var e5 = eq[i6];
                this._emitMatch(e5[0], e5[1]);
              }
            }
            if (this._processQueue.length) {
              var pq = this._processQueue.slice(0);
              this._processQueue.length = 0;
              for (var i6 = 0; i6 < pq.length; i6++) {
                var p5 = pq[i6];
                this._processing--;
                this._process(p5[0], p5[1], p5[2], p5[3]);
              }
            }
          }
        };
        Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
          assert2(this instanceof Glob);
          assert2(typeof cb === "function");
          if (this.aborted)
            return;
          this._processing++;
          if (this.paused) {
            this._processQueue.push([pattern, index, inGlobStar, cb]);
            return;
          }
          var n3 = 0;
          while (typeof pattern[n3] === "string") {
            n3++;
          }
          var prefix;
          switch (n3) {
            case pattern.length:
              this._processSimple(pattern.join("/"), index, cb);
              return;
            case 0:
              prefix = null;
              break;
            default:
              prefix = pattern.slice(0, n3).join("/");
              break;
          }
          var remain = pattern.slice(n3);
          var read;
          if (prefix === null)
            read = ".";
          else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
            if (!prefix || !isAbsolute(prefix))
              prefix = "/" + prefix;
            read = prefix;
          } else
            read = prefix;
          var abs = this._makeAbs(read);
          if (childrenIgnored(this, read))
            return cb();
          var isGlobStar = remain[0] === minimatch.GLOBSTAR;
          if (isGlobStar)
            this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
          else
            this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
        };
        Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
          var self2 = this;
          this._readdir(abs, inGlobStar, function(er2, entries) {
            return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
          });
        };
        Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
          if (!entries)
            return cb();
          var pn2 = remain[0];
          var negate = !!this.minimatch.negate;
          var rawGlob = pn2._glob;
          var dotOk = this.dot || rawGlob.charAt(0) === ".";
          var matchedEntries = [];
          for (var i6 = 0; i6 < entries.length; i6++) {
            var e5 = entries[i6];
            if (e5.charAt(0) !== "." || dotOk) {
              var m8;
              if (negate && !prefix) {
                m8 = !e5.match(pn2);
              } else {
                m8 = e5.match(pn2);
              }
              if (m8)
                matchedEntries.push(e5);
            }
          }
          var len = matchedEntries.length;
          if (len === 0)
            return cb();
          if (remain.length === 1 && !this.mark && !this.stat) {
            if (!this.matches[index])
              this.matches[index] = /* @__PURE__ */ Object.create(null);
            for (var i6 = 0; i6 < len; i6++) {
              var e5 = matchedEntries[i6];
              if (prefix) {
                if (prefix !== "/")
                  e5 = prefix + "/" + e5;
                else
                  e5 = prefix + e5;
              }
              if (e5.charAt(0) === "/" && !this.nomount) {
                e5 = path.join(this.root, e5);
              }
              this._emitMatch(index, e5);
            }
            return cb();
          }
          remain.shift();
          for (var i6 = 0; i6 < len; i6++) {
            var e5 = matchedEntries[i6];
            var newPattern;
            if (prefix) {
              if (prefix !== "/")
                e5 = prefix + "/" + e5;
              else
                e5 = prefix + e5;
            }
            this._process([e5].concat(remain), index, inGlobStar, cb);
          }
          cb();
        };
        Glob.prototype._emitMatch = function(index, e5) {
          if (this.aborted)
            return;
          if (isIgnored(this, e5))
            return;
          if (this.paused) {
            this._emitQueue.push([index, e5]);
            return;
          }
          var abs = isAbsolute(e5) ? e5 : this._makeAbs(e5);
          if (this.mark)
            e5 = this._mark(e5);
          if (this.absolute)
            e5 = abs;
          if (this.matches[index][e5])
            return;
          if (this.nodir) {
            var c3 = this.cache[abs];
            if (c3 === "DIR" || Array.isArray(c3))
              return;
          }
          this.matches[index][e5] = true;
          var st2 = this.statCache[abs];
          if (st2)
            this.emit("stat", e5, st2);
          this.emit("match", e5);
        };
        Glob.prototype._readdirInGlobStar = function(abs, cb) {
          if (this.aborted)
            return;
          if (this.follow)
            return this._readdir(abs, false, cb);
          var lstatkey = "lstat\0" + abs;
          var self2 = this;
          var lstatcb = inflight(lstatkey, lstatcb_);
          if (lstatcb)
            fs.lstat(abs, lstatcb);
          function lstatcb_(er2, lstat) {
            if (er2 && er2.code === "ENOENT")
              return cb();
            var isSym = lstat && lstat.isSymbolicLink();
            self2.symlinks[abs] = isSym;
            if (!isSym && lstat && !lstat.isDirectory()) {
              self2.cache[abs] = "FILE";
              cb();
            } else
              self2._readdir(abs, false, cb);
          }
        };
        Glob.prototype._readdir = function(abs, inGlobStar, cb) {
          if (this.aborted)
            return;
          cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
          if (!cb)
            return;
          if (inGlobStar && !ownProp(this.symlinks, abs))
            return this._readdirInGlobStar(abs, cb);
          if (ownProp(this.cache, abs)) {
            var c3 = this.cache[abs];
            if (!c3 || c3 === "FILE")
              return cb();
            if (Array.isArray(c3))
              return cb(null, c3);
          }
          var self2 = this;
          fs.readdir(abs, readdirCb(this, abs, cb));
        };
        function readdirCb(self2, abs, cb) {
          return function(er2, entries) {
            if (er2)
              self2._readdirError(abs, er2, cb);
            else
              self2._readdirEntries(abs, entries, cb);
          };
        }
        Glob.prototype._readdirEntries = function(abs, entries, cb) {
          if (this.aborted)
            return;
          if (!this.mark && !this.stat) {
            for (var i6 = 0; i6 < entries.length; i6++) {
              var e5 = entries[i6];
              if (abs === "/")
                e5 = abs + e5;
              else
                e5 = abs + "/" + e5;
              this.cache[e5] = true;
            }
          }
          this.cache[abs] = entries;
          return cb(null, entries);
        };
        Glob.prototype._readdirError = function(f6, er2, cb) {
          if (this.aborted)
            return;
          switch (er2.code) {
            case "ENOTSUP":
            case "ENOTDIR":
              var abs = this._makeAbs(f6);
              this.cache[abs] = "FILE";
              if (abs === this.cwdAbs) {
                var error = new Error(er2.code + " invalid cwd " + this.cwd);
                error.path = this.cwd;
                error.code = er2.code;
                this.emit("error", error);
                this.abort();
              }
              break;
            case "ENOENT":
            case "ELOOP":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              this.cache[this._makeAbs(f6)] = false;
              break;
            default:
              this.cache[this._makeAbs(f6)] = false;
              if (this.strict) {
                this.emit("error", er2);
                this.abort();
              }
              if (!this.silent)
                console.error("glob error", er2);
              break;
          }
          return cb();
        };
        Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
          var self2 = this;
          this._readdir(abs, inGlobStar, function(er2, entries) {
            self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
          });
        };
        Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
          if (!entries)
            return cb();
          var remainWithoutGlobStar = remain.slice(1);
          var gspref = prefix ? [prefix] : [];
          var noGlobStar = gspref.concat(remainWithoutGlobStar);
          this._process(noGlobStar, index, false, cb);
          var isSym = this.symlinks[abs];
          var len = entries.length;
          if (isSym && inGlobStar)
            return cb();
          for (var i6 = 0; i6 < len; i6++) {
            var e5 = entries[i6];
            if (e5.charAt(0) === "." && !this.dot)
              continue;
            var instead = gspref.concat(entries[i6], remainWithoutGlobStar);
            this._process(instead, index, true, cb);
            var below = gspref.concat(entries[i6], remain);
            this._process(below, index, true, cb);
          }
          cb();
        };
        Glob.prototype._processSimple = function(prefix, index, cb) {
          var self2 = this;
          this._stat(prefix, function(er2, exists) {
            self2._processSimple2(prefix, index, er2, exists, cb);
          });
        };
        Glob.prototype._processSimple2 = function(prefix, index, er2, exists, cb) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          if (!exists)
            return cb();
          if (prefix && isAbsolute(prefix) && !this.nomount) {
            var trail = /[\/\\]$/.test(prefix);
            if (prefix.charAt(0) === "/") {
              prefix = path.join(this.root, prefix);
            } else {
              prefix = path.resolve(this.root, prefix);
              if (trail)
                prefix += "/";
            }
          }
          if (process.platform === "win32")
            prefix = prefix.replace(/\\/g, "/");
          this._emitMatch(index, prefix);
          cb();
        };
        Glob.prototype._stat = function(f6, cb) {
          var abs = this._makeAbs(f6);
          var needDir = f6.slice(-1) === "/";
          if (f6.length > this.maxLength)
            return cb();
          if (!this.stat && ownProp(this.cache, abs)) {
            var c3 = this.cache[abs];
            if (Array.isArray(c3))
              c3 = "DIR";
            if (!needDir || c3 === "DIR")
              return cb(null, c3);
            if (needDir && c3 === "FILE")
              return cb();
          }
          var exists;
          var stat = this.statCache[abs];
          if (stat !== void 0) {
            if (stat === false)
              return cb(null, stat);
            else {
              var type = stat.isDirectory() ? "DIR" : "FILE";
              if (needDir && type === "FILE")
                return cb();
              else
                return cb(null, type, stat);
            }
          }
          var self2 = this;
          var statcb = inflight("stat\0" + abs, lstatcb_);
          if (statcb)
            fs.lstat(abs, statcb);
          function lstatcb_(er2, lstat) {
            if (lstat && lstat.isSymbolicLink()) {
              return fs.stat(abs, function(er3, stat2) {
                if (er3)
                  self2._stat2(f6, abs, null, lstat, cb);
                else
                  self2._stat2(f6, abs, er3, stat2, cb);
              });
            } else {
              self2._stat2(f6, abs, er2, lstat, cb);
            }
          }
        };
        Glob.prototype._stat2 = function(f6, abs, er2, stat, cb) {
          if (er2 && (er2.code === "ENOENT" || er2.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return cb();
          }
          var needDir = f6.slice(-1) === "/";
          this.statCache[abs] = stat;
          if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
            return cb(null, false, stat);
          var c3 = true;
          if (stat)
            c3 = stat.isDirectory() ? "DIR" : "FILE";
          this.cache[abs] = this.cache[abs] || c3;
          if (needDir && c3 === "FILE")
            return cb();
          return cb(null, c3, stat);
        };
      },
      /* 76 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        function posix(path) {
          return path.charAt(0) === "/";
        }
        function win32(path) {
          var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
          var result = splitDeviceRe.exec(path);
          var device = result[1] || "";
          var isUnc = Boolean(device && device.charAt(1) !== ":");
          return Boolean(result[2] || isUnc);
        }
        module3.exports = process.platform === "win32" ? win32 : posix;
        module3.exports.posix = posix;
        module3.exports.win32 = win32;
      },
      ,
      ,
      /* 79 */
      /***/
      function(module3, exports2) {
        module3.exports = __require("tty");
      },
      ,
      /* 81 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = function(str, fileLoc = "lockfile") {
          str = (0, (_stripBom || _load_stripBom()).default)(str);
          return hasMergeConflicts(str) ? parseWithConflict(str, fileLoc) : { type: "success", object: parse2(str, fileLoc) };
        };
        var _util;
        function _load_util() {
          return _util = _interopRequireDefault(__webpack_require__(2));
        }
        var _invariant;
        function _load_invariant() {
          return _invariant = _interopRequireDefault(__webpack_require__(7));
        }
        var _stripBom;
        function _load_stripBom() {
          return _stripBom = _interopRequireDefault(__webpack_require__(122));
        }
        var _constants;
        function _load_constants() {
          return _constants = __webpack_require__(6);
        }
        var _errors;
        function _load_errors() {
          return _errors = __webpack_require__(4);
        }
        var _map;
        function _load_map() {
          return _map = _interopRequireDefault(__webpack_require__(20));
        }
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const VERSION_REGEX = /^yarn lockfile v(\d+)$/;
        const TOKEN_TYPES = {
          boolean: "BOOLEAN",
          string: "STRING",
          identifier: "IDENTIFIER",
          eof: "EOF",
          colon: "COLON",
          newline: "NEWLINE",
          comment: "COMMENT",
          indent: "INDENT",
          invalid: "INVALID",
          number: "NUMBER",
          comma: "COMMA"
        };
        const VALID_PROP_VALUE_TOKENS = [TOKEN_TYPES.boolean, TOKEN_TYPES.string, TOKEN_TYPES.number];
        function isValidPropValueToken(token) {
          return VALID_PROP_VALUE_TOKENS.indexOf(token.type) >= 0;
        }
        function* tokenise(input) {
          let lastNewline = false;
          let line = 1;
          let col = 0;
          function buildToken(type, value) {
            return { line, col, type, value };
          }
          while (input.length) {
            let chop = 0;
            if (input[0] === "\n" || input[0] === "\r") {
              chop++;
              if (input[1] === "\n") {
                chop++;
              }
              line++;
              col = 0;
              yield buildToken(TOKEN_TYPES.newline);
            } else if (input[0] === "#") {
              chop++;
              let val = "";
              while (input[chop] !== "\n") {
                val += input[chop];
                chop++;
              }
              yield buildToken(TOKEN_TYPES.comment, val);
            } else if (input[0] === " ") {
              if (lastNewline) {
                let indent = "";
                for (let i6 = 0; input[i6] === " "; i6++) {
                  indent += input[i6];
                }
                if (indent.length % 2) {
                  throw new TypeError("Invalid number of spaces");
                } else {
                  chop = indent.length;
                  yield buildToken(TOKEN_TYPES.indent, indent.length / 2);
                }
              } else {
                chop++;
              }
            } else if (input[0] === '"') {
              let val = "";
              for (let i6 = 0; ; i6++) {
                const currentChar = input[i6];
                val += currentChar;
                if (i6 > 0 && currentChar === '"') {
                  const isEscaped = input[i6 - 1] === "\\" && input[i6 - 2] !== "\\";
                  if (!isEscaped) {
                    break;
                  }
                }
              }
              chop = val.length;
              try {
                yield buildToken(TOKEN_TYPES.string, JSON.parse(val));
              } catch (err) {
                if (err instanceof SyntaxError) {
                  yield buildToken(TOKEN_TYPES.invalid);
                } else {
                  throw err;
                }
              }
            } else if (/^[0-9]/.test(input)) {
              let val = "";
              for (let i6 = 0; /^[0-9]$/.test(input[i6]); i6++) {
                val += input[i6];
              }
              chop = val.length;
              yield buildToken(TOKEN_TYPES.number, +val);
            } else if (/^true/.test(input)) {
              yield buildToken(TOKEN_TYPES.boolean, true);
              chop = 4;
            } else if (/^false/.test(input)) {
              yield buildToken(TOKEN_TYPES.boolean, false);
              chop = 5;
            } else if (input[0] === ":") {
              yield buildToken(TOKEN_TYPES.colon);
              chop++;
            } else if (input[0] === ",") {
              yield buildToken(TOKEN_TYPES.comma);
              chop++;
            } else if (/^[a-zA-Z\/-]/g.test(input)) {
              let name = "";
              for (let i6 = 0; i6 < input.length; i6++) {
                const char = input[i6];
                if (char === ":" || char === " " || char === "\n" || char === "\r" || char === ",") {
                  break;
                } else {
                  name += char;
                }
              }
              chop = name.length;
              yield buildToken(TOKEN_TYPES.string, name);
            } else {
              yield buildToken(TOKEN_TYPES.invalid);
            }
            if (!chop) {
              yield buildToken(TOKEN_TYPES.invalid);
            }
            col += chop;
            lastNewline = input[0] === "\n" || input[0] === "\r" && input[1] === "\n";
            input = input.slice(chop);
          }
          yield buildToken(TOKEN_TYPES.eof);
        }
        class Parser {
          constructor(input, fileLoc = "lockfile") {
            this.comments = [];
            this.tokens = tokenise(input);
            this.fileLoc = fileLoc;
          }
          onComment(token) {
            const value = token.value;
            (0, (_invariant || _load_invariant()).default)(typeof value === "string", "expected token value to be a string");
            const comment = value.trim();
            const versionMatch = comment.match(VERSION_REGEX);
            if (versionMatch) {
              const version = +versionMatch[1];
              if (version > (_constants || _load_constants()).LOCKFILE_VERSION) {
                throw new (_errors || _load_errors()).MessageError(`Can't install from a lockfile of version ${version} as you're on an old yarn version that only supports versions up to ${(_constants || _load_constants()).LOCKFILE_VERSION}. Run \`$ yarn self-update\` to upgrade to the latest version.`);
              }
            }
            this.comments.push(comment);
          }
          next() {
            const item = this.tokens.next();
            (0, (_invariant || _load_invariant()).default)(item, "expected a token");
            const done = item.done, value = item.value;
            if (done || !value) {
              throw new Error("No more tokens");
            } else if (value.type === TOKEN_TYPES.comment) {
              this.onComment(value);
              return this.next();
            } else {
              return this.token = value;
            }
          }
          unexpected(msg = "Unexpected token") {
            throw new SyntaxError(`${msg} ${this.token.line}:${this.token.col} in ${this.fileLoc}`);
          }
          expect(tokType) {
            if (this.token.type === tokType) {
              this.next();
            } else {
              this.unexpected();
            }
          }
          eat(tokType) {
            if (this.token.type === tokType) {
              this.next();
              return true;
            } else {
              return false;
            }
          }
          parse(indent = 0) {
            const obj = (0, (_map || _load_map()).default)();
            while (true) {
              const propToken = this.token;
              if (propToken.type === TOKEN_TYPES.newline) {
                const nextToken = this.next();
                if (!indent) {
                  continue;
                }
                if (nextToken.type !== TOKEN_TYPES.indent) {
                  break;
                }
                if (nextToken.value === indent) {
                  this.next();
                } else {
                  break;
                }
              } else if (propToken.type === TOKEN_TYPES.indent) {
                if (propToken.value === indent) {
                  this.next();
                } else {
                  break;
                }
              } else if (propToken.type === TOKEN_TYPES.eof) {
                break;
              } else if (propToken.type === TOKEN_TYPES.string) {
                const key = propToken.value;
                (0, (_invariant || _load_invariant()).default)(key, "Expected a key");
                const keys = [key];
                this.next();
                while (this.token.type === TOKEN_TYPES.comma) {
                  this.next();
                  const keyToken = this.token;
                  if (keyToken.type !== TOKEN_TYPES.string) {
                    this.unexpected("Expected string");
                  }
                  const key2 = keyToken.value;
                  (0, (_invariant || _load_invariant()).default)(key2, "Expected a key");
                  keys.push(key2);
                  this.next();
                }
                const valToken = this.token;
                if (valToken.type === TOKEN_TYPES.colon) {
                  this.next();
                  const val = this.parse(indent + 1);
                  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
                    var _ref;
                    if (_isArray) {
                      if (_i >= _iterator.length)
                        break;
                      _ref = _iterator[_i++];
                    } else {
                      _i = _iterator.next();
                      if (_i.done)
                        break;
                      _ref = _i.value;
                    }
                    const key2 = _ref;
                    obj[key2] = val;
                  }
                  if (indent && this.token.type !== TOKEN_TYPES.indent) {
                    break;
                  }
                } else if (isValidPropValueToken(valToken)) {
                  for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
                    var _ref2;
                    if (_isArray2) {
                      if (_i2 >= _iterator2.length)
                        break;
                      _ref2 = _iterator2[_i2++];
                    } else {
                      _i2 = _iterator2.next();
                      if (_i2.done)
                        break;
                      _ref2 = _i2.value;
                    }
                    const key2 = _ref2;
                    obj[key2] = valToken.value;
                  }
                  this.next();
                } else {
                  this.unexpected("Invalid value type");
                }
              } else {
                this.unexpected(`Unknown token: ${(_util || _load_util()).default.inspect(propToken)}`);
              }
            }
            return obj;
          }
        }
        const MERGE_CONFLICT_ANCESTOR = "|||||||";
        const MERGE_CONFLICT_END = ">>>>>>>";
        const MERGE_CONFLICT_SEP = "=======";
        const MERGE_CONFLICT_START = "<<<<<<<";
        function extractConflictVariants(str) {
          const variants = [[], []];
          const lines = str.split(/\r?\n/g);
          let skip = false;
          while (lines.length) {
            const line = lines.shift();
            if (line.startsWith(MERGE_CONFLICT_START)) {
              while (lines.length) {
                const conflictLine = lines.shift();
                if (conflictLine === MERGE_CONFLICT_SEP) {
                  skip = false;
                  break;
                } else if (skip || conflictLine.startsWith(MERGE_CONFLICT_ANCESTOR)) {
                  skip = true;
                  continue;
                } else {
                  variants[0].push(conflictLine);
                }
              }
              while (lines.length) {
                const conflictLine = lines.shift();
                if (conflictLine.startsWith(MERGE_CONFLICT_END)) {
                  break;
                } else {
                  variants[1].push(conflictLine);
                }
              }
            } else {
              variants[0].push(line);
              variants[1].push(line);
            }
          }
          return [variants[0].join("\n"), variants[1].join("\n")];
        }
        function hasMergeConflicts(str) {
          return str.includes(MERGE_CONFLICT_START) && str.includes(MERGE_CONFLICT_SEP) && str.includes(MERGE_CONFLICT_END);
        }
        function parse2(str, fileLoc) {
          const parser = new Parser(str, fileLoc);
          parser.next();
          return parser.parse();
        }
        function parseWithConflict(str, fileLoc) {
          const variants = extractConflictVariants(str);
          try {
            return { type: "merge", object: Object.assign({}, parse2(variants[0], fileLoc), parse2(variants[1], fileLoc)) };
          } catch (err) {
            if (err instanceof SyntaxError) {
              return { type: "conflict", object: {} };
            } else {
              throw err;
            }
          }
        }
      },
      ,
      ,
      /* 84 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _map;
        function _load_map() {
          return _map = _interopRequireDefault(__webpack_require__(20));
        }
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const debug = __webpack_require__(212)("yarn");
        class BlockingQueue {
          constructor(alias, maxConcurrency = Infinity) {
            this.concurrencyQueue = [];
            this.maxConcurrency = maxConcurrency;
            this.runningCount = 0;
            this.warnedStuck = false;
            this.alias = alias;
            this.first = true;
            this.running = (0, (_map || _load_map()).default)();
            this.queue = (0, (_map || _load_map()).default)();
            this.stuckTick = this.stuckTick.bind(this);
          }
          stillActive() {
            if (this.stuckTimer) {
              clearTimeout(this.stuckTimer);
            }
            this.stuckTimer = setTimeout(this.stuckTick, 5e3);
            this.stuckTimer.unref && this.stuckTimer.unref();
          }
          stuckTick() {
            if (this.runningCount === 1) {
              this.warnedStuck = true;
              debug(`The ${JSON.stringify(this.alias)} blocking queue may be stuck. 5 seconds without any activity with 1 worker: ${Object.keys(this.running)[0]}`);
            }
          }
          push(key, factory) {
            if (this.first) {
              this.first = false;
            } else {
              this.stillActive();
            }
            return new Promise((resolve, reject) => {
              const queue = this.queue[key] = this.queue[key] || [];
              queue.push({ factory, resolve, reject });
              if (!this.running[key]) {
                this.shift(key);
              }
            });
          }
          shift(key) {
            if (this.running[key]) {
              delete this.running[key];
              this.runningCount--;
              if (this.stuckTimer) {
                clearTimeout(this.stuckTimer);
                this.stuckTimer = null;
              }
              if (this.warnedStuck) {
                this.warnedStuck = false;
                debug(`${JSON.stringify(this.alias)} blocking queue finally resolved. Nothing to worry about.`);
              }
            }
            const queue = this.queue[key];
            if (!queue) {
              return;
            }
            var _queue$shift = queue.shift();
            const resolve = _queue$shift.resolve, reject = _queue$shift.reject, factory = _queue$shift.factory;
            if (!queue.length) {
              delete this.queue[key];
            }
            const next = () => {
              this.shift(key);
              this.shiftConcurrencyQueue();
            };
            const run = () => {
              this.running[key] = true;
              this.runningCount++;
              factory().then(function(val) {
                resolve(val);
                next();
                return null;
              }).catch(function(err) {
                reject(err);
                next();
              });
            };
            this.maybePushConcurrencyQueue(run);
          }
          maybePushConcurrencyQueue(run) {
            if (this.runningCount < this.maxConcurrency) {
              run();
            } else {
              this.concurrencyQueue.push(run);
            }
          }
          shiftConcurrencyQueue() {
            if (this.runningCount < this.maxConcurrency) {
              const fn2 = this.concurrencyQueue.shift();
              if (fn2) {
                fn2();
              }
            }
          }
        }
        exports2.default = BlockingQueue;
      },
      /* 85 */
      /***/
      function(module3, exports2) {
        module3.exports = function(exec) {
          try {
            return !!exec();
          } catch (e5) {
            return true;
          }
        };
      },
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      /* 100 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var cof = __webpack_require__(47);
        var TAG = __webpack_require__(13)("toStringTag");
        var ARG = cof(/* @__PURE__ */ function() {
          return arguments;
        }()) == "Arguments";
        var tryGet = function(it2, key) {
          try {
            return it2[key];
          } catch (e5) {
          }
        };
        module3.exports = function(it2) {
          var O5, T3, B3;
          return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (T3 = tryGet(O5 = Object(it2), TAG)) == "string" ? T3 : ARG ? cof(O5) : (B3 = cof(O5)) == "Object" && typeof O5.callee == "function" ? "Arguments" : B3;
        };
      },
      /* 101 */
      /***/
      function(module3, exports2) {
        module3.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      },
      /* 102 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var document2 = __webpack_require__(11).document;
        module3.exports = document2 && document2.documentElement;
      },
      /* 103 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var LIBRARY = __webpack_require__(69);
        var $export = __webpack_require__(41);
        var redefine = __webpack_require__(197);
        var hide = __webpack_require__(31);
        var Iterators = __webpack_require__(35);
        var $iterCreate = __webpack_require__(188);
        var setToStringTag = __webpack_require__(71);
        var getPrototypeOf = __webpack_require__(194);
        var ITERATOR = __webpack_require__(13)("iterator");
        var BUGGY = !([].keys && "next" in [].keys());
        var FF_ITERATOR = "@@iterator";
        var KEYS = "keys";
        var VALUES = "values";
        var returnThis = function() {
          return this;
        };
        module3.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
          $iterCreate(Constructor, NAME, next);
          var getMethod = function(kind) {
            if (!BUGGY && kind in proto2)
              return proto2[kind];
            switch (kind) {
              case KEYS:
                return function keys() {
                  return new Constructor(this, kind);
                };
              case VALUES:
                return function values() {
                  return new Constructor(this, kind);
                };
            }
            return function entries() {
              return new Constructor(this, kind);
            };
          };
          var TAG = NAME + " Iterator";
          var DEF_VALUES = DEFAULT == VALUES;
          var VALUES_BUG = false;
          var proto2 = Base.prototype;
          var $native = proto2[ITERATOR] || proto2[FF_ITERATOR] || DEFAULT && proto2[DEFAULT];
          var $default = $native || getMethod(DEFAULT);
          var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
          var $anyNative = NAME == "Array" ? proto2.entries || $native : $native;
          var methods, key, IteratorPrototype;
          if ($anyNative) {
            IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
            if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
              setToStringTag(IteratorPrototype, TAG, true);
              if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function")
                hide(IteratorPrototype, ITERATOR, returnThis);
            }
          }
          if (DEF_VALUES && $native && $native.name !== VALUES) {
            VALUES_BUG = true;
            $default = function values() {
              return $native.call(this);
            };
          }
          if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto2[ITERATOR])) {
            hide(proto2, ITERATOR, $default);
          }
          Iterators[NAME] = $default;
          Iterators[TAG] = returnThis;
          if (DEFAULT) {
            methods = {
              values: DEF_VALUES ? $default : getMethod(VALUES),
              keys: IS_SET ? $default : getMethod(KEYS),
              entries: $entries
            };
            if (FORCED)
              for (key in methods) {
                if (!(key in proto2))
                  redefine(proto2, key, methods[key]);
              }
            else
              $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
          }
          return methods;
        };
      },
      /* 104 */
      /***/
      function(module3, exports2) {
        module3.exports = function(exec) {
          try {
            return { e: false, v: exec() };
          } catch (e5) {
            return { e: true, v: e5 };
          }
        };
      },
      /* 105 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var anObject = __webpack_require__(27);
        var isObject = __webpack_require__(34);
        var newPromiseCapability = __webpack_require__(70);
        module3.exports = function(C4, x2) {
          anObject(C4);
          if (isObject(x2) && x2.constructor === C4)
            return x2;
          var promiseCapability = newPromiseCapability.f(C4);
          var resolve = promiseCapability.resolve;
          resolve(x2);
          return promiseCapability.promise;
        };
      },
      /* 106 */
      /***/
      function(module3, exports2) {
        module3.exports = function(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value
          };
        };
      },
      /* 107 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var core = __webpack_require__(23);
        var global2 = __webpack_require__(11);
        var SHARED = "__core-js_shared__";
        var store = global2[SHARED] || (global2[SHARED] = {});
        (module3.exports = function(key, value) {
          return store[key] || (store[key] = value !== void 0 ? value : {});
        })("versions", []).push({
          version: core.version,
          mode: __webpack_require__(69) ? "pure" : "global",
          copyright: "\xA9 2018 Denis Pushkarev (zloirock.ru)"
        });
      },
      /* 108 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var anObject = __webpack_require__(27);
        var aFunction = __webpack_require__(46);
        var SPECIES = __webpack_require__(13)("species");
        module3.exports = function(O5, D3) {
          var C4 = anObject(O5).constructor;
          var S2;
          return C4 === void 0 || (S2 = anObject(C4)[SPECIES]) == void 0 ? D3 : aFunction(S2);
        };
      },
      /* 109 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var ctx = __webpack_require__(48);
        var invoke = __webpack_require__(185);
        var html = __webpack_require__(102);
        var cel = __webpack_require__(68);
        var global2 = __webpack_require__(11);
        var process4 = global2.process;
        var setTask = global2.setImmediate;
        var clearTask = global2.clearImmediate;
        var MessageChannel = global2.MessageChannel;
        var Dispatch = global2.Dispatch;
        var counter = 0;
        var queue = {};
        var ONREADYSTATECHANGE = "onreadystatechange";
        var defer, channel, port;
        var run = function() {
          var id = +this;
          if (queue.hasOwnProperty(id)) {
            var fn2 = queue[id];
            delete queue[id];
            fn2();
          }
        };
        var listener = function(event) {
          run.call(event.data);
        };
        if (!setTask || !clearTask) {
          setTask = function setImmediate2(fn2) {
            var args = [];
            var i6 = 1;
            while (arguments.length > i6)
              args.push(arguments[i6++]);
            queue[++counter] = function() {
              invoke(typeof fn2 == "function" ? fn2 : Function(fn2), args);
            };
            defer(counter);
            return counter;
          };
          clearTask = function clearImmediate(id) {
            delete queue[id];
          };
          if (__webpack_require__(47)(process4) == "process") {
            defer = function(id) {
              process4.nextTick(ctx(run, id, 1));
            };
          } else if (Dispatch && Dispatch.now) {
            defer = function(id) {
              Dispatch.now(ctx(run, id, 1));
            };
          } else if (MessageChannel) {
            channel = new MessageChannel();
            port = channel.port2;
            channel.port1.onmessage = listener;
            defer = ctx(port.postMessage, port, 1);
          } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts) {
            defer = function(id) {
              global2.postMessage(id + "", "*");
            };
            global2.addEventListener("message", listener, false);
          } else if (ONREADYSTATECHANGE in cel("script")) {
            defer = function(id) {
              html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
                html.removeChild(this);
                run.call(id);
              };
            };
          } else {
            defer = function(id) {
              setTimeout(ctx(run, id, 1), 0);
            };
          }
        }
        module3.exports = {
          set: setTask,
          clear: clearTask
        };
      },
      /* 110 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var toInteger = __webpack_require__(73);
        var min = Math.min;
        module3.exports = function(it2) {
          return it2 > 0 ? min(toInteger(it2), 9007199254740991) : 0;
        };
      },
      /* 111 */
      /***/
      function(module3, exports2) {
        var id = 0;
        var px = Math.random();
        module3.exports = function(key) {
          return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
        };
      },
      /* 112 */
      /***/
      function(module3, exports2, __webpack_require__) {
        exports2 = module3.exports = createDebug.debug = createDebug["default"] = createDebug;
        exports2.coerce = coerce;
        exports2.disable = disable;
        exports2.enable = enable;
        exports2.enabled = enabled;
        exports2.humanize = __webpack_require__(229);
        exports2.instances = [];
        exports2.names = [];
        exports2.skips = [];
        exports2.formatters = {};
        function selectColor(namespace) {
          var hash = 0, i6;
          for (i6 in namespace) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i6);
            hash |= 0;
          }
          return exports2.colors[Math.abs(hash) % exports2.colors.length];
        }
        function createDebug(namespace) {
          var prevTime;
          function debug() {
            if (!debug.enabled)
              return;
            var self2 = debug;
            var curr = +/* @__PURE__ */ new Date();
            var ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            var args = new Array(arguments.length);
            for (var i6 = 0; i6 < args.length; i6++) {
              args[i6] = arguments[i6];
            }
            args[0] = exports2.coerce(args[0]);
            if ("string" !== typeof args[0]) {
              args.unshift("%O");
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
              if (match === "%%")
                return match;
              index++;
              var formatter = exports2.formatters[format];
              if ("function" === typeof formatter) {
                var val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            exports2.formatArgs.call(self2, args);
            var logFn = debug.log || exports2.log || console.log.bind(console);
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.enabled = exports2.enabled(namespace);
          debug.useColors = exports2.useColors();
          debug.color = selectColor(namespace);
          debug.destroy = destroy;
          if ("function" === typeof exports2.init) {
            exports2.init(debug);
          }
          exports2.instances.push(debug);
          return debug;
        }
        function destroy() {
          var index = exports2.instances.indexOf(this);
          if (index !== -1) {
            exports2.instances.splice(index, 1);
            return true;
          } else {
            return false;
          }
        }
        function enable(namespaces) {
          exports2.save(namespaces);
          exports2.names = [];
          exports2.skips = [];
          var i6;
          var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          var len = split.length;
          for (i6 = 0; i6 < len; i6++) {
            if (!split[i6])
              continue;
            namespaces = split[i6].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              exports2.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
          for (i6 = 0; i6 < exports2.instances.length; i6++) {
            var instance = exports2.instances[i6];
            instance.enabled = exports2.enabled(instance.namespace);
          }
        }
        function disable() {
          exports2.enable("");
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          var i6, len;
          for (i6 = 0, len = exports2.skips.length; i6 < len; i6++) {
            if (exports2.skips[i6].test(name)) {
              return false;
            }
          }
          for (i6 = 0, len = exports2.names.length; i6 < len; i6++) {
            if (exports2.names[i6].test(name)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error)
            return val.stack || val.message;
          return val;
        }
      },
      ,
      /* 114 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = realpath;
        realpath.realpath = realpath;
        realpath.sync = realpathSync;
        realpath.realpathSync = realpathSync;
        realpath.monkeypatch = monkeypatch;
        realpath.unmonkeypatch = unmonkeypatch;
        var fs = __webpack_require__(3);
        var origRealpath = fs.realpath;
        var origRealpathSync = fs.realpathSync;
        var version = process.version;
        var ok = /^v[0-5]\./.test(version);
        var old = __webpack_require__(217);
        function newError(er2) {
          return er2 && er2.syscall === "realpath" && (er2.code === "ELOOP" || er2.code === "ENOMEM" || er2.code === "ENAMETOOLONG");
        }
        function realpath(p5, cache, cb) {
          if (ok) {
            return origRealpath(p5, cache, cb);
          }
          if (typeof cache === "function") {
            cb = cache;
            cache = null;
          }
          origRealpath(p5, cache, function(er2, result) {
            if (newError(er2)) {
              old.realpath(p5, cache, cb);
            } else {
              cb(er2, result);
            }
          });
        }
        function realpathSync(p5, cache) {
          if (ok) {
            return origRealpathSync(p5, cache);
          }
          try {
            return origRealpathSync(p5, cache);
          } catch (er2) {
            if (newError(er2)) {
              return old.realpathSync(p5, cache);
            } else {
              throw er2;
            }
          }
        }
        function monkeypatch() {
          fs.realpath = realpath;
          fs.realpathSync = realpathSync;
        }
        function unmonkeypatch() {
          fs.realpath = origRealpath;
          fs.realpathSync = origRealpathSync;
        }
      },
      /* 115 */
      /***/
      function(module3, exports2, __webpack_require__) {
        exports2.alphasort = alphasort;
        exports2.alphasorti = alphasorti;
        exports2.setopts = setopts;
        exports2.ownProp = ownProp;
        exports2.makeAbs = makeAbs;
        exports2.finish = finish;
        exports2.mark = mark;
        exports2.isIgnored = isIgnored;
        exports2.childrenIgnored = childrenIgnored;
        function ownProp(obj, field) {
          return Object.prototype.hasOwnProperty.call(obj, field);
        }
        var path = __webpack_require__(0);
        var minimatch = __webpack_require__(60);
        var isAbsolute = __webpack_require__(76);
        var Minimatch = minimatch.Minimatch;
        function alphasorti(a7, b3) {
          return a7.toLowerCase().localeCompare(b3.toLowerCase());
        }
        function alphasort(a7, b3) {
          return a7.localeCompare(b3);
        }
        function setupIgnores(self2, options) {
          self2.ignore = options.ignore || [];
          if (!Array.isArray(self2.ignore))
            self2.ignore = [self2.ignore];
          if (self2.ignore.length) {
            self2.ignore = self2.ignore.map(ignoreMap);
          }
        }
        function ignoreMap(pattern) {
          var gmatcher = null;
          if (pattern.slice(-3) === "/**") {
            var gpattern = pattern.replace(/(\/\*\*)+$/, "");
            gmatcher = new Minimatch(gpattern, { dot: true });
          }
          return {
            matcher: new Minimatch(pattern, { dot: true }),
            gmatcher
          };
        }
        function setopts(self2, pattern, options) {
          if (!options)
            options = {};
          if (options.matchBase && -1 === pattern.indexOf("/")) {
            if (options.noglobstar) {
              throw new Error("base matching requires globstar");
            }
            pattern = "**/" + pattern;
          }
          self2.silent = !!options.silent;
          self2.pattern = pattern;
          self2.strict = options.strict !== false;
          self2.realpath = !!options.realpath;
          self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
          self2.follow = !!options.follow;
          self2.dot = !!options.dot;
          self2.mark = !!options.mark;
          self2.nodir = !!options.nodir;
          if (self2.nodir)
            self2.mark = true;
          self2.sync = !!options.sync;
          self2.nounique = !!options.nounique;
          self2.nonull = !!options.nonull;
          self2.nosort = !!options.nosort;
          self2.nocase = !!options.nocase;
          self2.stat = !!options.stat;
          self2.noprocess = !!options.noprocess;
          self2.absolute = !!options.absolute;
          self2.maxLength = options.maxLength || Infinity;
          self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
          self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
          self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
          setupIgnores(self2, options);
          self2.changedCwd = false;
          var cwd = process.cwd();
          if (!ownProp(options, "cwd"))
            self2.cwd = cwd;
          else {
            self2.cwd = path.resolve(options.cwd);
            self2.changedCwd = self2.cwd !== cwd;
          }
          self2.root = options.root || path.resolve(self2.cwd, "/");
          self2.root = path.resolve(self2.root);
          if (process.platform === "win32")
            self2.root = self2.root.replace(/\\/g, "/");
          self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
          if (process.platform === "win32")
            self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
          self2.nomount = !!options.nomount;
          options.nonegate = true;
          options.nocomment = true;
          self2.minimatch = new Minimatch(pattern, options);
          self2.options = self2.minimatch.options;
        }
        function finish(self2) {
          var nou = self2.nounique;
          var all = nou ? [] : /* @__PURE__ */ Object.create(null);
          for (var i6 = 0, l3 = self2.matches.length; i6 < l3; i6++) {
            var matches = self2.matches[i6];
            if (!matches || Object.keys(matches).length === 0) {
              if (self2.nonull) {
                var literal = self2.minimatch.globSet[i6];
                if (nou)
                  all.push(literal);
                else
                  all[literal] = true;
              }
            } else {
              var m8 = Object.keys(matches);
              if (nou)
                all.push.apply(all, m8);
              else
                m8.forEach(function(m9) {
                  all[m9] = true;
                });
            }
          }
          if (!nou)
            all = Object.keys(all);
          if (!self2.nosort)
            all = all.sort(self2.nocase ? alphasorti : alphasort);
          if (self2.mark) {
            for (var i6 = 0; i6 < all.length; i6++) {
              all[i6] = self2._mark(all[i6]);
            }
            if (self2.nodir) {
              all = all.filter(function(e5) {
                var notDir = !/\/$/.test(e5);
                var c3 = self2.cache[e5] || self2.cache[makeAbs(self2, e5)];
                if (notDir && c3)
                  notDir = c3 !== "DIR" && !Array.isArray(c3);
                return notDir;
              });
            }
          }
          if (self2.ignore.length)
            all = all.filter(function(m9) {
              return !isIgnored(self2, m9);
            });
          self2.found = all;
        }
        function mark(self2, p5) {
          var abs = makeAbs(self2, p5);
          var c3 = self2.cache[abs];
          var m8 = p5;
          if (c3) {
            var isDir = c3 === "DIR" || Array.isArray(c3);
            var slash = p5.slice(-1) === "/";
            if (isDir && !slash)
              m8 += "/";
            else if (!isDir && slash)
              m8 = m8.slice(0, -1);
            if (m8 !== p5) {
              var mabs = makeAbs(self2, m8);
              self2.statCache[mabs] = self2.statCache[abs];
              self2.cache[mabs] = self2.cache[abs];
            }
          }
          return m8;
        }
        function makeAbs(self2, f6) {
          var abs = f6;
          if (f6.charAt(0) === "/") {
            abs = path.join(self2.root, f6);
          } else if (isAbsolute(f6) || f6 === "") {
            abs = f6;
          } else if (self2.changedCwd) {
            abs = path.resolve(self2.cwd, f6);
          } else {
            abs = path.resolve(f6);
          }
          if (process.platform === "win32")
            abs = abs.replace(/\\/g, "/");
          return abs;
        }
        function isIgnored(self2, path2) {
          if (!self2.ignore.length)
            return false;
          return self2.ignore.some(function(item) {
            return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
          });
        }
        function childrenIgnored(self2, path2) {
          if (!self2.ignore.length)
            return false;
          return self2.ignore.some(function(item) {
            return !!(item.gmatcher && item.gmatcher.match(path2));
          });
        }
      },
      /* 116 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var path = __webpack_require__(0);
        var fs = __webpack_require__(3);
        var _0777 = parseInt("0777", 8);
        module3.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
        function mkdirP(p5, opts, f6, made) {
          if (typeof opts === "function") {
            f6 = opts;
            opts = {};
          } else if (!opts || typeof opts !== "object") {
            opts = { mode: opts };
          }
          var mode = opts.mode;
          var xfs = opts.fs || fs;
          if (mode === void 0) {
            mode = _0777 & ~process.umask();
          }
          if (!made)
            made = null;
          var cb = f6 || function() {
          };
          p5 = path.resolve(p5);
          xfs.mkdir(p5, mode, function(er2) {
            if (!er2) {
              made = made || p5;
              return cb(null, made);
            }
            switch (er2.code) {
              case "ENOENT":
                mkdirP(path.dirname(p5), opts, function(er3, made2) {
                  if (er3)
                    cb(er3, made2);
                  else
                    mkdirP(p5, opts, cb, made2);
                });
                break;
              default:
                xfs.stat(p5, function(er22, stat) {
                  if (er22 || !stat.isDirectory())
                    cb(er2, made);
                  else
                    cb(null, made);
                });
                break;
            }
          });
        }
        mkdirP.sync = function sync(p5, opts, made) {
          if (!opts || typeof opts !== "object") {
            opts = { mode: opts };
          }
          var mode = opts.mode;
          var xfs = opts.fs || fs;
          if (mode === void 0) {
            mode = _0777 & ~process.umask();
          }
          if (!made)
            made = null;
          p5 = path.resolve(p5);
          try {
            xfs.mkdirSync(p5, mode);
            made = made || p5;
          } catch (err0) {
            switch (err0.code) {
              case "ENOENT":
                made = sync(path.dirname(p5), opts, made);
                sync(p5, opts, made);
                break;
              default:
                var stat;
                try {
                  stat = xfs.statSync(p5);
                } catch (err1) {
                  throw err0;
                }
                if (!stat.isDirectory())
                  throw err0;
                break;
            }
          }
          return made;
        };
      },
      ,
      ,
      ,
      ,
      ,
      /* 122 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        module3.exports = (x2) => {
          if (typeof x2 !== "string") {
            throw new TypeError("Expected a string, got " + typeof x2);
          }
          if (x2.charCodeAt(0) === 65279) {
            return x2.slice(1);
          }
          return x2;
        };
      },
      /* 123 */
      /***/
      function(module3, exports2) {
        module3.exports = wrappy;
        function wrappy(fn2, cb) {
          if (fn2 && cb)
            return wrappy(fn2)(cb);
          if (typeof fn2 !== "function")
            throw new TypeError("need wrapper function");
          Object.keys(fn2).forEach(function(k3) {
            wrapper[k3] = fn2[k3];
          });
          return wrapper;
          function wrapper() {
            var args = new Array(arguments.length);
            for (var i6 = 0; i6 < args.length; i6++) {
              args[i6] = arguments[i6];
            }
            var ret = fn2.apply(this, args);
            var cb2 = args[args.length - 1];
            if (typeof ret === "function" && ret !== cb2) {
              Object.keys(cb2).forEach(function(k3) {
                ret[k3] = cb2[k3];
              });
            }
            return ret;
          }
        }
      },
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      /* 131 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var cof = __webpack_require__(47);
        module3.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it2) {
          return cof(it2) == "String" ? it2.split("") : Object(it2);
        };
      },
      /* 132 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var $keys = __webpack_require__(195);
        var enumBugKeys = __webpack_require__(101);
        module3.exports = Object.keys || function keys(O5) {
          return $keys(O5, enumBugKeys);
        };
      },
      /* 133 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var defined = __webpack_require__(67);
        module3.exports = function(it2) {
          return Object(defined(it2));
        };
      },
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      /* 145 */
      /***/
      function(module3, exports2) {
        module3.exports = { "name": "yarn", "installationMethod": "unknown", "version": "1.10.0-0", "license": "BSD-2-Clause", "preferGlobal": true, "description": "\u{1F4E6}\u{1F408} Fast, reliable, and secure dependency management.", "dependencies": { "@zkochan/cmd-shim": "^2.2.4", "babel-runtime": "^6.26.0", "bytes": "^3.0.0", "camelcase": "^4.0.0", "chalk": "^2.1.0", "commander": "^2.9.0", "death": "^1.0.0", "debug": "^3.0.0", "deep-equal": "^1.0.1", "detect-indent": "^5.0.0", "dnscache": "^1.0.1", "glob": "^7.1.1", "gunzip-maybe": "^1.4.0", "hash-for-dep": "^1.2.3", "imports-loader": "^0.8.0", "ini": "^1.3.4", "inquirer": "^3.0.1", "invariant": "^2.2.0", "is-builtin-module": "^2.0.0", "is-ci": "^1.0.10", "is-webpack-bundle": "^1.0.0", "leven": "^2.0.0", "loud-rejection": "^1.2.0", "micromatch": "^2.3.11", "mkdirp": "^0.5.1", "node-emoji": "^1.6.1", "normalize-url": "^2.0.0", "npm-logical-tree": "^1.2.1", "object-path": "^0.11.2", "proper-lockfile": "^2.0.0", "puka": "^1.0.0", "read": "^1.0.7", "request": "^2.87.0", "request-capture-har": "^1.2.2", "rimraf": "^2.5.0", "semver": "^5.1.0", "ssri": "^5.3.0", "strip-ansi": "^4.0.0", "strip-bom": "^3.0.0", "tar-fs": "^1.16.0", "tar-stream": "^1.6.1", "uuid": "^3.0.1", "v8-compile-cache": "^2.0.0", "validate-npm-package-license": "^3.0.3", "yn": "^2.0.0" }, "devDependencies": { "babel-core": "^6.26.0", "babel-eslint": "^7.2.3", "babel-loader": "^6.2.5", "babel-plugin-array-includes": "^2.0.3", "babel-plugin-transform-builtin-extend": "^1.1.2", "babel-plugin-transform-inline-imports-commonjs": "^1.0.0", "babel-plugin-transform-runtime": "^6.4.3", "babel-preset-env": "^1.6.0", "babel-preset-flow": "^6.23.0", "babel-preset-stage-0": "^6.0.0", "babylon": "^6.5.0", "commitizen": "^2.9.6", "cz-conventional-changelog": "^2.0.0", "eslint": "^4.3.0", "eslint-config-fb-strict": "^22.0.0", "eslint-plugin-babel": "^5.0.0", "eslint-plugin-flowtype": "^2.35.0", "eslint-plugin-jasmine": "^2.6.2", "eslint-plugin-jest": "^21.0.0", "eslint-plugin-jsx-a11y": "^6.0.2", "eslint-plugin-prefer-object-spread": "^1.2.1", "eslint-plugin-prettier": "^2.1.2", "eslint-plugin-react": "^7.1.0", "eslint-plugin-relay": "^0.0.24", "eslint-plugin-yarn-internal": "file:scripts/eslint-rules", "execa": "^0.10.0", "flow-bin": "^0.66.0", "git-release-notes": "^3.0.0", "gulp": "^3.9.0", "gulp-babel": "^7.0.0", "gulp-if": "^2.0.1", "gulp-newer": "^1.0.0", "gulp-plumber": "^1.0.1", "gulp-sourcemaps": "^2.2.0", "gulp-util": "^3.0.7", "gulp-watch": "^5.0.0", "jest": "^22.4.4", "jsinspect": "^0.12.6", "minimatch": "^3.0.4", "mock-stdin": "^0.3.0", "prettier": "^1.5.2", "temp": "^0.8.3", "webpack": "^2.1.0-beta.25", "yargs": "^6.3.0" }, "resolutions": { "sshpk": "^1.14.2" }, "engines": { "node": ">=4.0.0" }, "repository": "yarnpkg/yarn", "bin": { "yarn": "./bin/yarn.js", "yarnpkg": "./bin/yarn.js" }, "scripts": { "build": "gulp build", "build-bundle": "node ./scripts/build-webpack.js", "build-chocolatey": "powershell ./scripts/build-chocolatey.ps1", "build-deb": "./scripts/build-deb.sh", "build-dist": "bash ./scripts/build-dist.sh", "build-win-installer": "scripts\\build-windows-installer.bat", "changelog": "git-release-notes $(git describe --tags --abbrev=0 $(git describe --tags --abbrev=0)^)..$(git describe --tags --abbrev=0) scripts/changelog.md", "dupe-check": "yarn jsinspect ./src", "lint": "eslint . && flow check", "pkg-tests": "yarn --cwd packages/pkg-tests jest yarn.test.js", "prettier": "eslint src __tests__ --fix", "release-branch": "./scripts/release-branch.sh", "test": "yarn lint && yarn test-only", "test-only": "node --max_old_space_size=4096 ", "test-only-debug": "node --inspect-brk --max_old_space_size=4096 ", "test-coverage": "node --max_old_space_size=4096 ", "watch": "gulp watch", "commit": "git-cz" }, "jest": { "collectCoverageFrom": ["src/**/*.js"], "testEnvironment": "node", "modulePathIgnorePatterns": ["__tests__/fixtures/", "packages/pkg-tests/pkg-tests-fixtures", "dist/"], "testPathIgnorePatterns": ["__tests__/(fixtures|__mocks__)/", "updates/", "_(temp|mock|install|init|helpers).js$", "packages/pkg-tests"] }, "config": { "commitizen": { "path": "./" } } };
      },
      ,
      ,
      ,
      ,
      /* 150 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = stringify;
        var _misc;
        function _load_misc() {
          return _misc = __webpack_require__(12);
        }
        var _constants;
        function _load_constants() {
          return _constants = __webpack_require__(6);
        }
        var _package;
        function _load_package() {
          return _package = __webpack_require__(145);
        }
        const NODE_VERSION = process.version;
        function shouldWrapKey(str) {
          return str.indexOf("true") === 0 || str.indexOf("false") === 0 || /[:\s\n\\",\[\]]/g.test(str) || /^[0-9]/g.test(str) || !/^[a-zA-Z]/g.test(str);
        }
        function maybeWrap(str) {
          if (typeof str === "boolean" || typeof str === "number" || shouldWrapKey(str)) {
            return JSON.stringify(str);
          } else {
            return str;
          }
        }
        const priorities = {
          name: 1,
          version: 2,
          uid: 3,
          resolved: 4,
          integrity: 5,
          registry: 6,
          dependencies: 7
        };
        function priorityThenAlphaSort(a7, b3) {
          if (priorities[a7] || priorities[b3]) {
            return (priorities[a7] || 100) > (priorities[b3] || 100) ? 1 : -1;
          } else {
            return (0, (_misc || _load_misc()).sortAlpha)(a7, b3);
          }
        }
        function _stringify(obj, options) {
          if (typeof obj !== "object") {
            throw new TypeError();
          }
          const indent = options.indent;
          const lines = [];
          const keys = Object.keys(obj).sort(priorityThenAlphaSort);
          let addedKeys = [];
          for (let i6 = 0; i6 < keys.length; i6++) {
            const key = keys[i6];
            const val = obj[key];
            if (val == null || addedKeys.indexOf(key) >= 0) {
              continue;
            }
            const valKeys = [key];
            if (typeof val === "object") {
              for (let j2 = i6 + 1; j2 < keys.length; j2++) {
                const key2 = keys[j2];
                if (val === obj[key2]) {
                  valKeys.push(key2);
                }
              }
            }
            const keyLine = valKeys.sort((_misc || _load_misc()).sortAlpha).map(maybeWrap).join(", ");
            if (typeof val === "string" || typeof val === "boolean" || typeof val === "number") {
              lines.push(`${keyLine} ${maybeWrap(val)}`);
            } else if (typeof val === "object") {
              lines.push(`${keyLine}:
${_stringify(val, { indent: indent + "  " })}` + (options.topLevel ? "\n" : ""));
            } else {
              throw new TypeError();
            }
            addedKeys = addedKeys.concat(valKeys);
          }
          return indent + lines.join(`
${indent}`);
        }
        function stringify(obj, noHeader, enableVersions) {
          const val = _stringify(obj, {
            indent: "",
            topLevel: true
          });
          if (noHeader) {
            return val;
          }
          const lines = [];
          lines.push("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.");
          lines.push(`# yarn lockfile v${(_constants || _load_constants()).LOCKFILE_VERSION}`);
          if (enableVersions) {
            lines.push(`# yarn v${(_package || _load_package()).version}`);
            lines.push(`# node ${NODE_VERSION}`);
          }
          lines.push("\n");
          lines.push(val);
          return lines.join("\n");
        }
      },
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      /* 164 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.fileDatesEqual = exports2.copyFile = exports2.unlink = void 0;
        var _asyncToGenerator2;
        function _load_asyncToGenerator() {
          return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));
        }
        let fixTimes = (() => {
          var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (fd, dest, data) {
            const doOpen = fd === void 0;
            let openfd = fd ? fd : -1;
            if (disableTimestampCorrection === void 0) {
              const destStat = yield lstat(dest);
              disableTimestampCorrection = fileDatesEqual(destStat.mtime, data.mtime);
            }
            if (disableTimestampCorrection) {
              return;
            }
            if (doOpen) {
              try {
                openfd = yield open(dest, "a", data.mode);
              } catch (er2) {
                try {
                  openfd = yield open(dest, "r", data.mode);
                } catch (err) {
                  return;
                }
              }
            }
            try {
              if (openfd) {
                yield futimes(openfd, data.atime, data.mtime);
              }
            } catch (er2) {
            } finally {
              if (doOpen && openfd) {
                yield close(openfd);
              }
            }
          });
          return function fixTimes2(_x7, _x8, _x9) {
            return _ref3.apply(this, arguments);
          };
        })();
        var _fs;
        function _load_fs() {
          return _fs = _interopRequireDefault(__webpack_require__(3));
        }
        var _promise;
        function _load_promise() {
          return _promise = __webpack_require__(40);
        }
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        let disableTimestampCorrection = void 0;
        const readFileBuffer = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.readFile);
        const close = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.close);
        const lstat = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.lstat);
        const open = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.open);
        const futimes = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.futimes);
        const write = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.write);
        const unlink = exports2.unlink = (0, (_promise || _load_promise()).promisify)(__webpack_require__(233));
        const copyFile = exports2.copyFile = (() => {
          var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data, cleanup) {
            try {
              yield unlink(data.dest);
              yield copyFilePoly(data.src, data.dest, 0, data);
            } finally {
              if (cleanup) {
                cleanup();
              }
            }
          });
          return function copyFile2(_x, _x2) {
            return _ref.apply(this, arguments);
          };
        })();
        const copyFilePoly = (src, dest, flags, data) => {
          if ((_fs || _load_fs()).default.copyFile) {
            return new Promise((resolve, reject) => (_fs || _load_fs()).default.copyFile(src, dest, flags, (err) => {
              if (err) {
                reject(err);
              } else {
                fixTimes(void 0, dest, data).then(() => resolve()).catch((ex) => reject(ex));
              }
            }));
          } else {
            return copyWithBuffer(src, dest, flags, data);
          }
        };
        const copyWithBuffer = (() => {
          var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest, flags, data) {
            const fd = yield open(dest, "w", data.mode);
            try {
              const buffer = yield readFileBuffer(src);
              yield write(fd, buffer, 0, buffer.length);
              yield fixTimes(fd, dest, data);
            } finally {
              yield close(fd);
            }
          });
          return function copyWithBuffer2(_x3, _x4, _x5, _x6) {
            return _ref2.apply(this, arguments);
          };
        })();
        const fileDatesEqual = exports2.fileDatesEqual = (a7, b3) => {
          const aTime = a7.getTime();
          const bTime = b3.getTime();
          if (process.platform !== "win32") {
            return aTime === bTime;
          }
          if (Math.abs(aTime - bTime) <= 1) {
            return true;
          }
          const aTimeSec = Math.floor(aTime / 1e3);
          const bTimeSec = Math.floor(bTime / 1e3);
          if (aTime - aTimeSec * 1e3 === 0 || bTime - bTimeSec * 1e3 === 0) {
            return aTimeSec === bTimeSec;
          }
          return aTime === bTime;
        };
      },
      ,
      ,
      ,
      ,
      /* 169 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.isFakeRoot = isFakeRoot;
        exports2.isRootUser = isRootUser;
        function getUid() {
          if (process.platform !== "win32" && process.getuid) {
            return process.getuid();
          }
          return null;
        }
        exports2.default = isRootUser(getUid()) && !isFakeRoot();
        function isFakeRoot() {
          return Boolean(process.env.FAKEROOTKEY);
        }
        function isRootUser(uid) {
          return uid === 0;
        }
      },
      ,
      /* 171 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.getDataDir = getDataDir;
        exports2.getCacheDir = getCacheDir;
        exports2.getConfigDir = getConfigDir;
        const path = __webpack_require__(0);
        const userHome = __webpack_require__(45).default;
        const FALLBACK_CONFIG_DIR = path.join(userHome, ".config", "yarn");
        const FALLBACK_CACHE_DIR = path.join(userHome, ".cache", "yarn");
        function getDataDir() {
          if (process.platform === "win32") {
            const WIN32_APPDATA_DIR = getLocalAppDataDir();
            return WIN32_APPDATA_DIR == null ? FALLBACK_CONFIG_DIR : path.join(WIN32_APPDATA_DIR, "Data");
          } else if (process.env.XDG_DATA_HOME) {
            return path.join(process.env.XDG_DATA_HOME, "yarn");
          } else {
            return FALLBACK_CONFIG_DIR;
          }
        }
        function getCacheDir() {
          if (process.platform === "win32") {
            return path.join(getLocalAppDataDir() || path.join(userHome, "AppData", "Local", "Yarn"), "Cache");
          } else if (process.env.XDG_CACHE_HOME) {
            return path.join(process.env.XDG_CACHE_HOME, "yarn");
          } else if (process.platform === "darwin") {
            return path.join(userHome, "Library", "Caches", "Yarn");
          } else {
            return FALLBACK_CACHE_DIR;
          }
        }
        function getConfigDir() {
          if (process.platform === "win32") {
            const WIN32_APPDATA_DIR = getLocalAppDataDir();
            return WIN32_APPDATA_DIR == null ? FALLBACK_CONFIG_DIR : path.join(WIN32_APPDATA_DIR, "Config");
          } else if (process.env.XDG_CONFIG_HOME) {
            return path.join(process.env.XDG_CONFIG_HOME, "yarn");
          } else {
            return FALLBACK_CONFIG_DIR;
          }
        }
        function getLocalAppDataDir() {
          return process.env.LOCALAPPDATA ? path.join(process.env.LOCALAPPDATA, "Yarn") : null;
        }
      },
      ,
      /* 173 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = { "default": __webpack_require__(179), __esModule: true };
      },
      /* 174 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        module3.exports = balanced;
        function balanced(a7, b3, str) {
          if (a7 instanceof RegExp)
            a7 = maybeMatch(a7, str);
          if (b3 instanceof RegExp)
            b3 = maybeMatch(b3, str);
          var r3 = range(a7, b3, str);
          return r3 && {
            start: r3[0],
            end: r3[1],
            pre: str.slice(0, r3[0]),
            body: str.slice(r3[0] + a7.length, r3[1]),
            post: str.slice(r3[1] + b3.length)
          };
        }
        function maybeMatch(reg, str) {
          var m8 = str.match(reg);
          return m8 ? m8[0] : null;
        }
        balanced.range = range;
        function range(a7, b3, str) {
          var begs, beg, left, right, result;
          var ai = str.indexOf(a7);
          var bi = str.indexOf(b3, ai + 1);
          var i6 = ai;
          if (ai >= 0 && bi > 0) {
            begs = [];
            left = str.length;
            while (i6 >= 0 && !result) {
              if (i6 == ai) {
                begs.push(i6);
                ai = str.indexOf(a7, i6 + 1);
              } else if (begs.length == 1) {
                result = [begs.pop(), bi];
              } else {
                beg = begs.pop();
                if (beg < left) {
                  left = beg;
                  right = bi;
                }
                bi = str.indexOf(b3, i6 + 1);
              }
              i6 = ai < bi && ai >= 0 ? ai : bi;
            }
            if (begs.length) {
              result = [left, right];
            }
          }
          return result;
        }
      },
      /* 175 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var concatMap = __webpack_require__(178);
        var balanced = __webpack_require__(174);
        module3.exports = expandTop;
        var escSlash = "\0SLASH" + Math.random() + "\0";
        var escOpen = "\0OPEN" + Math.random() + "\0";
        var escClose = "\0CLOSE" + Math.random() + "\0";
        var escComma = "\0COMMA" + Math.random() + "\0";
        var escPeriod = "\0PERIOD" + Math.random() + "\0";
        function numeric(str) {
          return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
        }
        function escapeBraces(str) {
          return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
        }
        function unescapeBraces(str) {
          return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
        }
        function parseCommaParts(str) {
          if (!str)
            return [""];
          var parts = [];
          var m8 = balanced("{", "}", str);
          if (!m8)
            return str.split(",");
          var pre = m8.pre;
          var body = m8.body;
          var post = m8.post;
          var p5 = pre.split(",");
          p5[p5.length - 1] += "{" + body + "}";
          var postParts = parseCommaParts(post);
          if (post.length) {
            p5[p5.length - 1] += postParts.shift();
            p5.push.apply(p5, postParts);
          }
          parts.push.apply(parts, p5);
          return parts;
        }
        function expandTop(str) {
          if (!str)
            return [];
          if (str.substr(0, 2) === "{}") {
            str = "\\{\\}" + str.substr(2);
          }
          return expand2(escapeBraces(str), true).map(unescapeBraces);
        }
        function identity(e5) {
          return e5;
        }
        function embrace(str) {
          return "{" + str + "}";
        }
        function isPadded(el) {
          return /^-?0\d/.test(el);
        }
        function lte(i6, y3) {
          return i6 <= y3;
        }
        function gte(i6, y3) {
          return i6 >= y3;
        }
        function expand2(str, isTop) {
          var expansions = [];
          var m8 = balanced("{", "}", str);
          if (!m8 || /\$$/.test(m8.pre))
            return [str];
          var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m8.body);
          var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m8.body);
          var isSequence = isNumericSequence || isAlphaSequence;
          var isOptions = m8.body.indexOf(",") >= 0;
          if (!isSequence && !isOptions) {
            if (m8.post.match(/,.*\}/)) {
              str = m8.pre + "{" + m8.body + escClose + m8.post;
              return expand2(str);
            }
            return [str];
          }
          var n3;
          if (isSequence) {
            n3 = m8.body.split(/\.\./);
          } else {
            n3 = parseCommaParts(m8.body);
            if (n3.length === 1) {
              n3 = expand2(n3[0], false).map(embrace);
              if (n3.length === 1) {
                var post = m8.post.length ? expand2(m8.post, false) : [""];
                return post.map(function(p5) {
                  return m8.pre + n3[0] + p5;
                });
              }
            }
          }
          var pre = m8.pre;
          var post = m8.post.length ? expand2(m8.post, false) : [""];
          var N2;
          if (isSequence) {
            var x2 = numeric(n3[0]);
            var y3 = numeric(n3[1]);
            var width = Math.max(n3[0].length, n3[1].length);
            var incr = n3.length == 3 ? Math.abs(numeric(n3[2])) : 1;
            var test = lte;
            var reverse = y3 < x2;
            if (reverse) {
              incr *= -1;
              test = gte;
            }
            var pad = n3.some(isPadded);
            N2 = [];
            for (var i6 = x2; test(i6, y3); i6 += incr) {
              var c3;
              if (isAlphaSequence) {
                c3 = String.fromCharCode(i6);
                if (c3 === "\\")
                  c3 = "";
              } else {
                c3 = String(i6);
                if (pad) {
                  var need = width - c3.length;
                  if (need > 0) {
                    var z3 = new Array(need + 1).join("0");
                    if (i6 < 0)
                      c3 = "-" + z3 + c3.slice(1);
                    else
                      c3 = z3 + c3;
                  }
                }
              }
              N2.push(c3);
            }
          } else {
            N2 = concatMap(n3, function(el) {
              return expand2(el, false);
            });
          }
          for (var j2 = 0; j2 < N2.length; j2++) {
            for (var k3 = 0; k3 < post.length; k3++) {
              var expansion = pre + N2[j2] + post[k3];
              if (!isTop || isSequence || expansion)
                expansions.push(expansion);
            }
          }
          return expansions;
        }
      },
      /* 176 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        function preserveCamelCase(str) {
          let isLastCharLower = false;
          let isLastCharUpper = false;
          let isLastLastCharUpper = false;
          for (let i6 = 0; i6 < str.length; i6++) {
            const c3 = str[i6];
            if (isLastCharLower && /[a-zA-Z]/.test(c3) && c3.toUpperCase() === c3) {
              str = str.substr(0, i6) + "-" + str.substr(i6);
              isLastCharLower = false;
              isLastLastCharUpper = isLastCharUpper;
              isLastCharUpper = true;
              i6++;
            } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(c3) && c3.toLowerCase() === c3) {
              str = str.substr(0, i6 - 1) + "-" + str.substr(i6 - 1);
              isLastLastCharUpper = isLastCharUpper;
              isLastCharUpper = false;
              isLastCharLower = true;
            } else {
              isLastCharLower = c3.toLowerCase() === c3;
              isLastLastCharUpper = isLastCharUpper;
              isLastCharUpper = c3.toUpperCase() === c3;
            }
          }
          return str;
        }
        module3.exports = function(str) {
          if (arguments.length > 1) {
            str = Array.from(arguments).map((x2) => x2.trim()).filter((x2) => x2.length).join("-");
          } else {
            str = str.trim();
          }
          if (str.length === 0) {
            return "";
          }
          if (str.length === 1) {
            return str.toLowerCase();
          }
          if (/^[a-z0-9]+$/.test(str)) {
            return str;
          }
          const hasUpperCase = str !== str.toLowerCase();
          if (hasUpperCase) {
            str = preserveCamelCase(str);
          }
          return str.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (m8, p1) => p1.toUpperCase());
        };
      },
      ,
      /* 178 */
      /***/
      function(module3, exports2) {
        module3.exports = function(xs, fn2) {
          var res = [];
          for (var i6 = 0; i6 < xs.length; i6++) {
            var x2 = fn2(xs[i6], i6);
            if (isArray(x2))
              res.push.apply(res, x2);
            else
              res.push(x2);
          }
          return res;
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
      },
      /* 179 */
      /***/
      function(module3, exports2, __webpack_require__) {
        __webpack_require__(205);
        __webpack_require__(207);
        __webpack_require__(210);
        __webpack_require__(206);
        __webpack_require__(208);
        __webpack_require__(209);
        module3.exports = __webpack_require__(23).Promise;
      },
      /* 180 */
      /***/
      function(module3, exports2) {
        module3.exports = function() {
        };
      },
      /* 181 */
      /***/
      function(module3, exports2) {
        module3.exports = function(it2, Constructor, name, forbiddenField) {
          if (!(it2 instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it2) {
            throw TypeError(name + ": incorrect invocation!");
          }
          return it2;
        };
      },
      /* 182 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var toIObject = __webpack_require__(74);
        var toLength = __webpack_require__(110);
        var toAbsoluteIndex = __webpack_require__(200);
        module3.exports = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O5 = toIObject($this);
            var length = toLength(O5.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            if (IS_INCLUDES && el != el)
              while (length > index) {
                value = O5[index++];
                if (value != value)
                  return true;
              }
            else
              for (; length > index; index++)
                if (IS_INCLUDES || index in O5) {
                  if (O5[index] === el)
                    return IS_INCLUDES || index || 0;
                }
            return !IS_INCLUDES && -1;
          };
        };
      },
      /* 183 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var ctx = __webpack_require__(48);
        var call = __webpack_require__(187);
        var isArrayIter = __webpack_require__(186);
        var anObject = __webpack_require__(27);
        var toLength = __webpack_require__(110);
        var getIterFn = __webpack_require__(203);
        var BREAK = {};
        var RETURN = {};
        var exports2 = module3.exports = function(iterable, entries, fn2, that, ITERATOR) {
          var iterFn = ITERATOR ? function() {
            return iterable;
          } : getIterFn(iterable);
          var f6 = ctx(fn2, that, entries ? 2 : 1);
          var index = 0;
          var length, step, iterator2, result;
          if (typeof iterFn != "function")
            throw TypeError(iterable + " is not iterable!");
          if (isArrayIter(iterFn))
            for (length = toLength(iterable.length); length > index; index++) {
              result = entries ? f6(anObject(step = iterable[index])[0], step[1]) : f6(iterable[index]);
              if (result === BREAK || result === RETURN)
                return result;
            }
          else
            for (iterator2 = iterFn.call(iterable); !(step = iterator2.next()).done; ) {
              result = call(iterator2, f6, step.value, entries);
              if (result === BREAK || result === RETURN)
                return result;
            }
        };
        exports2.BREAK = BREAK;
        exports2.RETURN = RETURN;
      },
      /* 184 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = !__webpack_require__(33) && !__webpack_require__(85)(function() {
          return Object.defineProperty(__webpack_require__(68)("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      },
      /* 185 */
      /***/
      function(module3, exports2) {
        module3.exports = function(fn2, args, that) {
          var un2 = that === void 0;
          switch (args.length) {
            case 0:
              return un2 ? fn2() : fn2.call(that);
            case 1:
              return un2 ? fn2(args[0]) : fn2.call(that, args[0]);
            case 2:
              return un2 ? fn2(args[0], args[1]) : fn2.call(that, args[0], args[1]);
            case 3:
              return un2 ? fn2(args[0], args[1], args[2]) : fn2.call(that, args[0], args[1], args[2]);
            case 4:
              return un2 ? fn2(args[0], args[1], args[2], args[3]) : fn2.call(that, args[0], args[1], args[2], args[3]);
          }
          return fn2.apply(that, args);
        };
      },
      /* 186 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var Iterators = __webpack_require__(35);
        var ITERATOR = __webpack_require__(13)("iterator");
        var ArrayProto = Array.prototype;
        module3.exports = function(it2) {
          return it2 !== void 0 && (Iterators.Array === it2 || ArrayProto[ITERATOR] === it2);
        };
      },
      /* 187 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var anObject = __webpack_require__(27);
        module3.exports = function(iterator2, fn2, value, entries) {
          try {
            return entries ? fn2(anObject(value)[0], value[1]) : fn2(value);
          } catch (e5) {
            var ret = iterator2["return"];
            if (ret !== void 0)
              anObject(ret.call(iterator2));
            throw e5;
          }
        };
      },
      /* 188 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var create = __webpack_require__(192);
        var descriptor = __webpack_require__(106);
        var setToStringTag = __webpack_require__(71);
        var IteratorPrototype = {};
        __webpack_require__(31)(IteratorPrototype, __webpack_require__(13)("iterator"), function() {
          return this;
        });
        module3.exports = function(Constructor, NAME, next) {
          Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
          setToStringTag(Constructor, NAME + " Iterator");
        };
      },
      /* 189 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var ITERATOR = __webpack_require__(13)("iterator");
        var SAFE_CLOSING = false;
        try {
          var riter = [7][ITERATOR]();
          riter["return"] = function() {
            SAFE_CLOSING = true;
          };
          Array.from(riter, function() {
            throw 2;
          });
        } catch (e5) {
        }
        module3.exports = function(exec, skipClosing) {
          if (!skipClosing && !SAFE_CLOSING)
            return false;
          var safe = false;
          try {
            var arr = [7];
            var iter = arr[ITERATOR]();
            iter.next = function() {
              return { done: safe = true };
            };
            arr[ITERATOR] = function() {
              return iter;
            };
            exec(arr);
          } catch (e5) {
          }
          return safe;
        };
      },
      /* 190 */
      /***/
      function(module3, exports2) {
        module3.exports = function(done, value) {
          return { value, done: !!done };
        };
      },
      /* 191 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var global2 = __webpack_require__(11);
        var macrotask = __webpack_require__(109).set;
        var Observer = global2.MutationObserver || global2.WebKitMutationObserver;
        var process4 = global2.process;
        var Promise2 = global2.Promise;
        var isNode = __webpack_require__(47)(process4) == "process";
        module3.exports = function() {
          var head, last, notify;
          var flush = function() {
            var parent, fn2;
            if (isNode && (parent = process4.domain))
              parent.exit();
            while (head) {
              fn2 = head.fn;
              head = head.next;
              try {
                fn2();
              } catch (e5) {
                if (head)
                  notify();
                else
                  last = void 0;
                throw e5;
              }
            }
            last = void 0;
            if (parent)
              parent.enter();
          };
          if (isNode) {
            notify = function() {
              process4.nextTick(flush);
            };
          } else if (Observer && !(global2.navigator && global2.navigator.standalone)) {
            var toggle = true;
            var node = document.createTextNode("");
            new Observer(flush).observe(node, { characterData: true });
            notify = function() {
              node.data = toggle = !toggle;
            };
          } else if (Promise2 && Promise2.resolve) {
            var promise = Promise2.resolve(void 0);
            notify = function() {
              promise.then(flush);
            };
          } else {
            notify = function() {
              macrotask.call(global2, flush);
            };
          }
          return function(fn2) {
            var task = { fn: fn2, next: void 0 };
            if (last)
              last.next = task;
            if (!head) {
              head = task;
              notify();
            }
            last = task;
          };
        };
      },
      /* 192 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var anObject = __webpack_require__(27);
        var dPs = __webpack_require__(193);
        var enumBugKeys = __webpack_require__(101);
        var IE_PROTO = __webpack_require__(72)("IE_PROTO");
        var Empty = function() {
        };
        var PROTOTYPE = "prototype";
        var createDict = function() {
          var iframe = __webpack_require__(68)("iframe");
          var i6 = enumBugKeys.length;
          var lt2 = "<";
          var gt2 = ">";
          var iframeDocument;
          iframe.style.display = "none";
          __webpack_require__(102).appendChild(iframe);
          iframe.src = "javascript:";
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(lt2 + "script" + gt2 + "document.F=Object" + lt2 + "/script" + gt2);
          iframeDocument.close();
          createDict = iframeDocument.F;
          while (i6--)
            delete createDict[PROTOTYPE][enumBugKeys[i6]];
          return createDict();
        };
        module3.exports = Object.create || function create(O5, Properties) {
          var result;
          if (O5 !== null) {
            Empty[PROTOTYPE] = anObject(O5);
            result = new Empty();
            Empty[PROTOTYPE] = null;
            result[IE_PROTO] = O5;
          } else
            result = createDict();
          return Properties === void 0 ? result : dPs(result, Properties);
        };
      },
      /* 193 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var dP = __webpack_require__(50);
        var anObject = __webpack_require__(27);
        var getKeys = __webpack_require__(132);
        module3.exports = __webpack_require__(33) ? Object.defineProperties : function defineProperties(O5, Properties) {
          anObject(O5);
          var keys = getKeys(Properties);
          var length = keys.length;
          var i6 = 0;
          var P3;
          while (length > i6)
            dP.f(O5, P3 = keys[i6++], Properties[P3]);
          return O5;
        };
      },
      /* 194 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var has = __webpack_require__(49);
        var toObject = __webpack_require__(133);
        var IE_PROTO = __webpack_require__(72)("IE_PROTO");
        var ObjectProto = Object.prototype;
        module3.exports = Object.getPrototypeOf || function(O5) {
          O5 = toObject(O5);
          if (has(O5, IE_PROTO))
            return O5[IE_PROTO];
          if (typeof O5.constructor == "function" && O5 instanceof O5.constructor) {
            return O5.constructor.prototype;
          }
          return O5 instanceof Object ? ObjectProto : null;
        };
      },
      /* 195 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var has = __webpack_require__(49);
        var toIObject = __webpack_require__(74);
        var arrayIndexOf = __webpack_require__(182)(false);
        var IE_PROTO = __webpack_require__(72)("IE_PROTO");
        module3.exports = function(object, names) {
          var O5 = toIObject(object);
          var i6 = 0;
          var result = [];
          var key;
          for (key in O5)
            if (key != IE_PROTO)
              has(O5, key) && result.push(key);
          while (names.length > i6)
            if (has(O5, key = names[i6++])) {
              ~arrayIndexOf(result, key) || result.push(key);
            }
          return result;
        };
      },
      /* 196 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var hide = __webpack_require__(31);
        module3.exports = function(target, src, safe) {
          for (var key in src) {
            if (safe && target[key])
              target[key] = src[key];
            else
              hide(target, key, src[key]);
          }
          return target;
        };
      },
      /* 197 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = __webpack_require__(31);
      },
      /* 198 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var global2 = __webpack_require__(11);
        var core = __webpack_require__(23);
        var dP = __webpack_require__(50);
        var DESCRIPTORS = __webpack_require__(33);
        var SPECIES = __webpack_require__(13)("species");
        module3.exports = function(KEY) {
          var C4 = typeof core[KEY] == "function" ? core[KEY] : global2[KEY];
          if (DESCRIPTORS && C4 && !C4[SPECIES])
            dP.f(C4, SPECIES, {
              configurable: true,
              get: function() {
                return this;
              }
            });
        };
      },
      /* 199 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var toInteger = __webpack_require__(73);
        var defined = __webpack_require__(67);
        module3.exports = function(TO_STRING) {
          return function(that, pos) {
            var s5 = String(defined(that));
            var i6 = toInteger(pos);
            var l3 = s5.length;
            var a7, b3;
            if (i6 < 0 || i6 >= l3)
              return TO_STRING ? "" : void 0;
            a7 = s5.charCodeAt(i6);
            return a7 < 55296 || a7 > 56319 || i6 + 1 === l3 || (b3 = s5.charCodeAt(i6 + 1)) < 56320 || b3 > 57343 ? TO_STRING ? s5.charAt(i6) : a7 : TO_STRING ? s5.slice(i6, i6 + 2) : (a7 - 55296 << 10) + (b3 - 56320) + 65536;
          };
        };
      },
      /* 200 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var toInteger = __webpack_require__(73);
        var max = Math.max;
        var min = Math.min;
        module3.exports = function(index, length) {
          index = toInteger(index);
          return index < 0 ? max(index + length, 0) : min(index, length);
        };
      },
      /* 201 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var isObject = __webpack_require__(34);
        module3.exports = function(it2, S2) {
          if (!isObject(it2))
            return it2;
          var fn2, val;
          if (S2 && typeof (fn2 = it2.toString) == "function" && !isObject(val = fn2.call(it2)))
            return val;
          if (typeof (fn2 = it2.valueOf) == "function" && !isObject(val = fn2.call(it2)))
            return val;
          if (!S2 && typeof (fn2 = it2.toString) == "function" && !isObject(val = fn2.call(it2)))
            return val;
          throw TypeError("Can't convert object to primitive value");
        };
      },
      /* 202 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var global2 = __webpack_require__(11);
        var navigator2 = global2.navigator;
        module3.exports = navigator2 && navigator2.userAgent || "";
      },
      /* 203 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var classof = __webpack_require__(100);
        var ITERATOR = __webpack_require__(13)("iterator");
        var Iterators = __webpack_require__(35);
        module3.exports = __webpack_require__(23).getIteratorMethod = function(it2) {
          if (it2 != void 0)
            return it2[ITERATOR] || it2["@@iterator"] || Iterators[classof(it2)];
        };
      },
      /* 204 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var addToUnscopables = __webpack_require__(180);
        var step = __webpack_require__(190);
        var Iterators = __webpack_require__(35);
        var toIObject = __webpack_require__(74);
        module3.exports = __webpack_require__(103)(Array, "Array", function(iterated, kind) {
          this._t = toIObject(iterated);
          this._i = 0;
          this._k = kind;
        }, function() {
          var O5 = this._t;
          var kind = this._k;
          var index = this._i++;
          if (!O5 || index >= O5.length) {
            this._t = void 0;
            return step(1);
          }
          if (kind == "keys")
            return step(0, index);
          if (kind == "values")
            return step(0, O5[index]);
          return step(0, [index, O5[index]]);
        }, "values");
        Iterators.Arguments = Iterators.Array;
        addToUnscopables("keys");
        addToUnscopables("values");
        addToUnscopables("entries");
      },
      /* 205 */
      /***/
      function(module3, exports2) {
      },
      /* 206 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var LIBRARY = __webpack_require__(69);
        var global2 = __webpack_require__(11);
        var ctx = __webpack_require__(48);
        var classof = __webpack_require__(100);
        var $export = __webpack_require__(41);
        var isObject = __webpack_require__(34);
        var aFunction = __webpack_require__(46);
        var anInstance = __webpack_require__(181);
        var forOf = __webpack_require__(183);
        var speciesConstructor = __webpack_require__(108);
        var task = __webpack_require__(109).set;
        var microtask = __webpack_require__(191)();
        var newPromiseCapabilityModule = __webpack_require__(70);
        var perform = __webpack_require__(104);
        var userAgent2 = __webpack_require__(202);
        var promiseResolve = __webpack_require__(105);
        var PROMISE = "Promise";
        var TypeError2 = global2.TypeError;
        var process4 = global2.process;
        var versions = process4 && process4.versions;
        var v8 = versions && versions.v8 || "";
        var $Promise = global2[PROMISE];
        var isNode = classof(process4) == "process";
        var empty = function() {
        };
        var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
        var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
        var USE_NATIVE = !!function() {
          try {
            var promise = $Promise.resolve(1);
            var FakePromise = (promise.constructor = {})[__webpack_require__(13)("species")] = function(exec) {
              exec(empty, empty);
            };
            return (isNode || typeof PromiseRejectionEvent == "function") && promise.then(empty) instanceof FakePromise && v8.indexOf("6.6") !== 0 && userAgent2.indexOf("Chrome/66") === -1;
          } catch (e5) {
          }
        }();
        var isThenable = function(it2) {
          var then;
          return isObject(it2) && typeof (then = it2.then) == "function" ? then : false;
        };
        var notify = function(promise, isReject) {
          if (promise._n)
            return;
          promise._n = true;
          var chain = promise._c;
          microtask(function() {
            var value = promise._v;
            var ok = promise._s == 1;
            var i6 = 0;
            var run = function(reaction) {
              var handler2 = ok ? reaction.ok : reaction.fail;
              var resolve = reaction.resolve;
              var reject = reaction.reject;
              var domain = reaction.domain;
              var result, then, exited;
              try {
                if (handler2) {
                  if (!ok) {
                    if (promise._h == 2)
                      onHandleUnhandled(promise);
                    promise._h = 1;
                  }
                  if (handler2 === true)
                    result = value;
                  else {
                    if (domain)
                      domain.enter();
                    result = handler2(value);
                    if (domain) {
                      domain.exit();
                      exited = true;
                    }
                  }
                  if (result === reaction.promise) {
                    reject(TypeError2("Promise-chain cycle"));
                  } else if (then = isThenable(result)) {
                    then.call(result, resolve, reject);
                  } else
                    resolve(result);
                } else
                  reject(value);
              } catch (e5) {
                if (domain && !exited)
                  domain.exit();
                reject(e5);
              }
            };
            while (chain.length > i6)
              run(chain[i6++]);
            promise._c = [];
            promise._n = false;
            if (isReject && !promise._h)
              onUnhandled(promise);
          });
        };
        var onUnhandled = function(promise) {
          task.call(global2, function() {
            var value = promise._v;
            var unhandled = isUnhandled(promise);
            var result, handler2, console2;
            if (unhandled) {
              result = perform(function() {
                if (isNode) {
                  process4.emit("unhandledRejection", value, promise);
                } else if (handler2 = global2.onunhandledrejection) {
                  handler2({ promise, reason: value });
                } else if ((console2 = global2.console) && console2.error) {
                  console2.error("Unhandled promise rejection", value);
                }
              });
              promise._h = isNode || isUnhandled(promise) ? 2 : 1;
            }
            promise._a = void 0;
            if (unhandled && result.e)
              throw result.v;
          });
        };
        var isUnhandled = function(promise) {
          return promise._h !== 1 && (promise._a || promise._c).length === 0;
        };
        var onHandleUnhandled = function(promise) {
          task.call(global2, function() {
            var handler2;
            if (isNode) {
              process4.emit("rejectionHandled", promise);
            } else if (handler2 = global2.onrejectionhandled) {
              handler2({ promise, reason: promise._v });
            }
          });
        };
        var $reject = function(value) {
          var promise = this;
          if (promise._d)
            return;
          promise._d = true;
          promise = promise._w || promise;
          promise._v = value;
          promise._s = 2;
          if (!promise._a)
            promise._a = promise._c.slice();
          notify(promise, true);
        };
        var $resolve = function(value) {
          var promise = this;
          var then;
          if (promise._d)
            return;
          promise._d = true;
          promise = promise._w || promise;
          try {
            if (promise === value)
              throw TypeError2("Promise can't be resolved itself");
            if (then = isThenable(value)) {
              microtask(function() {
                var wrapper = { _w: promise, _d: false };
                try {
                  then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
                } catch (e5) {
                  $reject.call(wrapper, e5);
                }
              });
            } else {
              promise._v = value;
              promise._s = 1;
              notify(promise, false);
            }
          } catch (e5) {
            $reject.call({ _w: promise, _d: false }, e5);
          }
        };
        if (!USE_NATIVE) {
          $Promise = function Promise2(executor) {
            anInstance(this, $Promise, PROMISE, "_h");
            aFunction(executor);
            Internal.call(this);
            try {
              executor(ctx($resolve, this, 1), ctx($reject, this, 1));
            } catch (err) {
              $reject.call(this, err);
            }
          };
          Internal = function Promise2(executor) {
            this._c = [];
            this._a = void 0;
            this._s = 0;
            this._d = false;
            this._v = void 0;
            this._h = 0;
            this._n = false;
          };
          Internal.prototype = __webpack_require__(196)($Promise.prototype, {
            // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
            then: function then(onFulfilled, onRejected) {
              var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
              reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
              reaction.fail = typeof onRejected == "function" && onRejected;
              reaction.domain = isNode ? process4.domain : void 0;
              this._c.push(reaction);
              if (this._a)
                this._a.push(reaction);
              if (this._s)
                notify(this, false);
              return reaction.promise;
            },
            // 25.4.5.1 Promise.prototype.catch(onRejected)
            "catch": function(onRejected) {
              return this.then(void 0, onRejected);
            }
          });
          OwnPromiseCapability = function() {
            var promise = new Internal();
            this.promise = promise;
            this.resolve = ctx($resolve, promise, 1);
            this.reject = ctx($reject, promise, 1);
          };
          newPromiseCapabilityModule.f = newPromiseCapability = function(C4) {
            return C4 === $Promise || C4 === Wrapper ? new OwnPromiseCapability(C4) : newGenericPromiseCapability(C4);
          };
        }
        $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
        __webpack_require__(71)($Promise, PROMISE);
        __webpack_require__(198)(PROMISE);
        Wrapper = __webpack_require__(23)[PROMISE];
        $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
          // 25.4.4.5 Promise.reject(r)
          reject: function reject(r3) {
            var capability = newPromiseCapability(this);
            var $$reject = capability.reject;
            $$reject(r3);
            return capability.promise;
          }
        });
        $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
          // 25.4.4.6 Promise.resolve(x)
          resolve: function resolve(x2) {
            return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x2);
          }
        });
        $export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(189)(function(iter) {
          $Promise.all(iter)["catch"](empty);
        })), PROMISE, {
          // 25.4.4.1 Promise.all(iterable)
          all: function all(iterable) {
            var C4 = this;
            var capability = newPromiseCapability(C4);
            var resolve = capability.resolve;
            var reject = capability.reject;
            var result = perform(function() {
              var values = [];
              var index = 0;
              var remaining = 1;
              forOf(iterable, false, function(promise) {
                var $index = index++;
                var alreadyCalled = false;
                values.push(void 0);
                remaining++;
                C4.resolve(promise).then(function(value) {
                  if (alreadyCalled)
                    return;
                  alreadyCalled = true;
                  values[$index] = value;
                  --remaining || resolve(values);
                }, reject);
              });
              --remaining || resolve(values);
            });
            if (result.e)
              reject(result.v);
            return capability.promise;
          },
          // 25.4.4.4 Promise.race(iterable)
          race: function race(iterable) {
            var C4 = this;
            var capability = newPromiseCapability(C4);
            var reject = capability.reject;
            var result = perform(function() {
              forOf(iterable, false, function(promise) {
                C4.resolve(promise).then(capability.resolve, reject);
              });
            });
            if (result.e)
              reject(result.v);
            return capability.promise;
          }
        });
      },
      /* 207 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var $at = __webpack_require__(199)(true);
        __webpack_require__(103)(String, "String", function(iterated) {
          this._t = String(iterated);
          this._i = 0;
        }, function() {
          var O5 = this._t;
          var index = this._i;
          var point;
          if (index >= O5.length)
            return { value: void 0, done: true };
          point = $at(O5, index);
          this._i += point.length;
          return { value: point, done: false };
        });
      },
      /* 208 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var $export = __webpack_require__(41);
        var core = __webpack_require__(23);
        var global2 = __webpack_require__(11);
        var speciesConstructor = __webpack_require__(108);
        var promiseResolve = __webpack_require__(105);
        $export($export.P + $export.R, "Promise", { "finally": function(onFinally) {
          var C4 = speciesConstructor(this, core.Promise || global2.Promise);
          var isFunction = typeof onFinally == "function";
          return this.then(
            isFunction ? function(x2) {
              return promiseResolve(C4, onFinally()).then(function() {
                return x2;
              });
            } : onFinally,
            isFunction ? function(e5) {
              return promiseResolve(C4, onFinally()).then(function() {
                throw e5;
              });
            } : onFinally
          );
        } });
      },
      /* 209 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var $export = __webpack_require__(41);
        var newPromiseCapability = __webpack_require__(70);
        var perform = __webpack_require__(104);
        $export($export.S, "Promise", { "try": function(callbackfn) {
          var promiseCapability = newPromiseCapability.f(this);
          var result = perform(callbackfn);
          (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
          return promiseCapability.promise;
        } });
      },
      /* 210 */
      /***/
      function(module3, exports2, __webpack_require__) {
        __webpack_require__(204);
        var global2 = __webpack_require__(11);
        var hide = __webpack_require__(31);
        var Iterators = __webpack_require__(35);
        var TO_STRING_TAG = __webpack_require__(13)("toStringTag");
        var DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
        for (var i6 = 0; i6 < DOMIterables.length; i6++) {
          var NAME = DOMIterables[i6];
          var Collection2 = global2[NAME];
          var proto2 = Collection2 && Collection2.prototype;
          if (proto2 && !proto2[TO_STRING_TAG])
            hide(proto2, TO_STRING_TAG, NAME);
          Iterators[NAME] = Iterators.Array;
        }
      },
      /* 211 */
      /***/
      function(module3, exports2, __webpack_require__) {
        exports2 = module3.exports = __webpack_require__(112);
        exports2.log = log;
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
        exports2.colors = [
          "#0000CC",
          "#0000FF",
          "#0033CC",
          "#0033FF",
          "#0066CC",
          "#0066FF",
          "#0099CC",
          "#0099FF",
          "#00CC00",
          "#00CC33",
          "#00CC66",
          "#00CC99",
          "#00CCCC",
          "#00CCFF",
          "#3300CC",
          "#3300FF",
          "#3333CC",
          "#3333FF",
          "#3366CC",
          "#3366FF",
          "#3399CC",
          "#3399FF",
          "#33CC00",
          "#33CC33",
          "#33CC66",
          "#33CC99",
          "#33CCCC",
          "#33CCFF",
          "#6600CC",
          "#6600FF",
          "#6633CC",
          "#6633FF",
          "#66CC00",
          "#66CC33",
          "#9900CC",
          "#9900FF",
          "#9933CC",
          "#9933FF",
          "#99CC00",
          "#99CC33",
          "#CC0000",
          "#CC0033",
          "#CC0066",
          "#CC0099",
          "#CC00CC",
          "#CC00FF",
          "#CC3300",
          "#CC3333",
          "#CC3366",
          "#CC3399",
          "#CC33CC",
          "#CC33FF",
          "#CC6600",
          "#CC6633",
          "#CC9900",
          "#CC9933",
          "#CCCC00",
          "#CCCC33",
          "#FF0000",
          "#FF0033",
          "#FF0066",
          "#FF0099",
          "#FF00CC",
          "#FF00FF",
          "#FF3300",
          "#FF3333",
          "#FF3366",
          "#FF3399",
          "#FF33CC",
          "#FF33FF",
          "#FF6600",
          "#FF6633",
          "#FF9900",
          "#FF9933",
          "#FFCC00",
          "#FFCC33"
        ];
        function useColors() {
          if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
            return true;
          }
          if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
          }
          return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
          typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
          typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
          typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        exports2.formatters.j = function(v4) {
          try {
            return JSON.stringify(v4);
          } catch (err) {
            return "[UnexpectedJSONParseError]: " + err.message;
          }
        };
        function formatArgs(args) {
          var useColors2 = this.useColors;
          args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
          if (!useColors2)
            return;
          var c3 = "color: " + this.color;
          args.splice(1, 0, c3, "color: inherit");
          var index = 0;
          var lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, function(match) {
            if ("%%" === match)
              return;
            index++;
            if ("%c" === match) {
              lastC = index;
            }
          });
          args.splice(lastC, 0, c3);
        }
        function log() {
          return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }
        function save(namespaces) {
          try {
            if (null == namespaces) {
              exports2.storage.removeItem("debug");
            } else {
              exports2.storage.debug = namespaces;
            }
          } catch (e5) {
          }
        }
        function load() {
          var r3;
          try {
            r3 = exports2.storage.debug;
          } catch (e5) {
          }
          if (!r3 && typeof process !== "undefined" && "env" in process) {
            r3 = process.env.DEBUG;
          }
          return r3;
        }
        exports2.enable(load());
        function localstorage() {
          try {
            return window.localStorage;
          } catch (e5) {
          }
        }
      },
      /* 212 */
      /***/
      function(module3, exports2, __webpack_require__) {
        if (typeof process === "undefined" || process.type === "renderer") {
          module3.exports = __webpack_require__(211);
        } else {
          module3.exports = __webpack_require__(213);
        }
      },
      /* 213 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var tty3 = __webpack_require__(79);
        var util = __webpack_require__(2);
        exports2 = module3.exports = __webpack_require__(112);
        exports2.init = init;
        exports2.log = log;
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.colors = [6, 2, 3, 4, 5, 1];
        try {
          var supportsColor3 = __webpack_require__(239);
          if (supportsColor3 && supportsColor3.level >= 2) {
            exports2.colors = [
              20,
              21,
              26,
              27,
              32,
              33,
              38,
              39,
              40,
              41,
              42,
              43,
              44,
              45,
              56,
              57,
              62,
              63,
              68,
              69,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              92,
              93,
              98,
              99,
              112,
              113,
              128,
              129,
              134,
              135,
              148,
              149,
              160,
              161,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              171,
              172,
              173,
              178,
              179,
              184,
              185,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              203,
              204,
              205,
              206,
              207,
              208,
              209,
              214,
              215,
              220,
              221
            ];
          }
        } catch (err) {
        }
        exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
          return /^debug_/i.test(key);
        }).reduce(function(obj, key) {
          var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_4, k3) {
            return k3.toUpperCase();
          });
          var val = process.env[key];
          if (/^(yes|on|true|enabled)$/i.test(val))
            val = true;
          else if (/^(no|off|false|disabled)$/i.test(val))
            val = false;
          else if (val === "null")
            val = null;
          else
            val = Number(val);
          obj[prop] = val;
          return obj;
        }, {});
        function useColors() {
          return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty3.isatty(process.stderr.fd);
        }
        exports2.formatters.o = function(v4) {
          this.inspectOpts.colors = this.useColors;
          return util.inspect(v4, this.inspectOpts).split("\n").map(function(str) {
            return str.trim();
          }).join(" ");
        };
        exports2.formatters.O = function(v4) {
          this.inspectOpts.colors = this.useColors;
          return util.inspect(v4, this.inspectOpts);
        };
        function formatArgs(args) {
          var name = this.namespace;
          var useColors2 = this.useColors;
          if (useColors2) {
            var c3 = this.color;
            var colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
            var prefix = "  " + colorCode + ";1m" + name + " \x1B[0m";
            args[0] = prefix + args[0].split("\n").join("\n" + prefix);
            args.push(colorCode + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
          } else {
            args[0] = getDate() + name + " " + args[0];
          }
        }
        function getDate() {
          if (exports2.inspectOpts.hideDate) {
            return "";
          } else {
            return (/* @__PURE__ */ new Date()).toISOString() + " ";
          }
        }
        function log() {
          return process.stderr.write(util.format.apply(util, arguments) + "\n");
        }
        function save(namespaces) {
          if (null == namespaces) {
            delete process.env.DEBUG;
          } else {
            process.env.DEBUG = namespaces;
          }
        }
        function load() {
          return process.env.DEBUG;
        }
        function init(debug) {
          debug.inspectOpts = {};
          var keys = Object.keys(exports2.inspectOpts);
          for (var i6 = 0; i6 < keys.length; i6++) {
            debug.inspectOpts[keys[i6]] = exports2.inspectOpts[keys[i6]];
          }
        }
        exports2.enable(load());
      },
      ,
      ,
      ,
      /* 217 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var pathModule = __webpack_require__(0);
        var isWindows = process.platform === "win32";
        var fs = __webpack_require__(3);
        var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
        function rethrow() {
          var callback;
          if (DEBUG) {
            var backtrace = new Error();
            callback = debugCallback;
          } else
            callback = missingCallback;
          return callback;
          function debugCallback(err) {
            if (err) {
              backtrace.message = err.message;
              err = backtrace;
              missingCallback(err);
            }
          }
          function missingCallback(err) {
            if (err) {
              if (process.throwDeprecation)
                throw err;
              else if (!process.noDeprecation) {
                var msg = "fs: missing callback " + (err.stack || err.message);
                if (process.traceDeprecation)
                  console.trace(msg);
                else
                  console.error(msg);
              }
            }
          }
        }
        function maybeCallback(cb) {
          return typeof cb === "function" ? cb : rethrow();
        }
        var normalize = pathModule.normalize;
        if (isWindows) {
          var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
        } else {
          var nextPartRe = /(.*?)(?:[\/]+|$)/g;
        }
        if (isWindows) {
          var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
        } else {
          var splitRootRe = /^[\/]*/;
        }
        exports2.realpathSync = function realpathSync(p5, cache) {
          p5 = pathModule.resolve(p5);
          if (cache && Object.prototype.hasOwnProperty.call(cache, p5)) {
            return cache[p5];
          }
          var original = p5, seenLinks = {}, knownHard = {};
          var pos;
          var current;
          var base;
          var previous;
          start();
          function start() {
            var m8 = splitRootRe.exec(p5);
            pos = m8[0].length;
            current = m8[0];
            base = m8[0];
            previous = "";
            if (isWindows && !knownHard[base]) {
              fs.lstatSync(base);
              knownHard[base] = true;
            }
          }
          while (pos < p5.length) {
            nextPartRe.lastIndex = pos;
            var result = nextPartRe.exec(p5);
            previous = current;
            current += result[0];
            base = previous + result[1];
            pos = nextPartRe.lastIndex;
            if (knownHard[base] || cache && cache[base] === base) {
              continue;
            }
            var resolvedLink;
            if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
              resolvedLink = cache[base];
            } else {
              var stat = fs.lstatSync(base);
              if (!stat.isSymbolicLink()) {
                knownHard[base] = true;
                if (cache)
                  cache[base] = base;
                continue;
              }
              var linkTarget = null;
              if (!isWindows) {
                var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
                if (seenLinks.hasOwnProperty(id)) {
                  linkTarget = seenLinks[id];
                }
              }
              if (linkTarget === null) {
                fs.statSync(base);
                linkTarget = fs.readlinkSync(base);
              }
              resolvedLink = pathModule.resolve(previous, linkTarget);
              if (cache)
                cache[base] = resolvedLink;
              if (!isWindows)
                seenLinks[id] = linkTarget;
            }
            p5 = pathModule.resolve(resolvedLink, p5.slice(pos));
            start();
          }
          if (cache)
            cache[original] = p5;
          return p5;
        };
        exports2.realpath = function realpath(p5, cache, cb) {
          if (typeof cb !== "function") {
            cb = maybeCallback(cache);
            cache = null;
          }
          p5 = pathModule.resolve(p5);
          if (cache && Object.prototype.hasOwnProperty.call(cache, p5)) {
            return process.nextTick(cb.bind(null, null, cache[p5]));
          }
          var original = p5, seenLinks = {}, knownHard = {};
          var pos;
          var current;
          var base;
          var previous;
          start();
          function start() {
            var m8 = splitRootRe.exec(p5);
            pos = m8[0].length;
            current = m8[0];
            base = m8[0];
            previous = "";
            if (isWindows && !knownHard[base]) {
              fs.lstat(base, function(err) {
                if (err)
                  return cb(err);
                knownHard[base] = true;
                LOOP();
              });
            } else {
              process.nextTick(LOOP);
            }
          }
          function LOOP() {
            if (pos >= p5.length) {
              if (cache)
                cache[original] = p5;
              return cb(null, p5);
            }
            nextPartRe.lastIndex = pos;
            var result = nextPartRe.exec(p5);
            previous = current;
            current += result[0];
            base = previous + result[1];
            pos = nextPartRe.lastIndex;
            if (knownHard[base] || cache && cache[base] === base) {
              return process.nextTick(LOOP);
            }
            if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
              return gotResolvedLink(cache[base]);
            }
            return fs.lstat(base, gotStat);
          }
          function gotStat(err, stat) {
            if (err)
              return cb(err);
            if (!stat.isSymbolicLink()) {
              knownHard[base] = true;
              if (cache)
                cache[base] = base;
              return process.nextTick(LOOP);
            }
            if (!isWindows) {
              var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
              if (seenLinks.hasOwnProperty(id)) {
                return gotTarget(null, seenLinks[id], base);
              }
            }
            fs.stat(base, function(err2) {
              if (err2)
                return cb(err2);
              fs.readlink(base, function(err3, target) {
                if (!isWindows)
                  seenLinks[id] = target;
                gotTarget(err3, target);
              });
            });
          }
          function gotTarget(err, target, base2) {
            if (err)
              return cb(err);
            var resolvedLink = pathModule.resolve(previous, target);
            if (cache)
              cache[base2] = resolvedLink;
            gotResolvedLink(resolvedLink);
          }
          function gotResolvedLink(resolvedLink) {
            p5 = pathModule.resolve(resolvedLink, p5.slice(pos));
            start();
          }
        };
      },
      /* 218 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = globSync;
        globSync.GlobSync = GlobSync;
        var fs = __webpack_require__(3);
        var rp = __webpack_require__(114);
        var minimatch = __webpack_require__(60);
        var Minimatch = minimatch.Minimatch;
        var Glob = __webpack_require__(75).Glob;
        var util = __webpack_require__(2);
        var path = __webpack_require__(0);
        var assert2 = __webpack_require__(22);
        var isAbsolute = __webpack_require__(76);
        var common = __webpack_require__(115);
        var alphasort = common.alphasort;
        var alphasorti = common.alphasorti;
        var setopts = common.setopts;
        var ownProp = common.ownProp;
        var childrenIgnored = common.childrenIgnored;
        var isIgnored = common.isIgnored;
        function globSync(pattern, options) {
          if (typeof options === "function" || arguments.length === 3)
            throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
          return new GlobSync(pattern, options).found;
        }
        function GlobSync(pattern, options) {
          if (!pattern)
            throw new Error("must provide pattern");
          if (typeof options === "function" || arguments.length === 3)
            throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
          if (!(this instanceof GlobSync))
            return new GlobSync(pattern, options);
          setopts(this, pattern, options);
          if (this.noprocess)
            return this;
          var n3 = this.minimatch.set.length;
          this.matches = new Array(n3);
          for (var i6 = 0; i6 < n3; i6++) {
            this._process(this.minimatch.set[i6], i6, false);
          }
          this._finish();
        }
        GlobSync.prototype._finish = function() {
          assert2(this instanceof GlobSync);
          if (this.realpath) {
            var self2 = this;
            this.matches.forEach(function(matchset, index) {
              var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
              for (var p5 in matchset) {
                try {
                  p5 = self2._makeAbs(p5);
                  var real = rp.realpathSync(p5, self2.realpathCache);
                  set[real] = true;
                } catch (er2) {
                  if (er2.syscall === "stat")
                    set[self2._makeAbs(p5)] = true;
                  else
                    throw er2;
                }
              }
            });
          }
          common.finish(this);
        };
        GlobSync.prototype._process = function(pattern, index, inGlobStar) {
          assert2(this instanceof GlobSync);
          var n3 = 0;
          while (typeof pattern[n3] === "string") {
            n3++;
          }
          var prefix;
          switch (n3) {
            case pattern.length:
              this._processSimple(pattern.join("/"), index);
              return;
            case 0:
              prefix = null;
              break;
            default:
              prefix = pattern.slice(0, n3).join("/");
              break;
          }
          var remain = pattern.slice(n3);
          var read;
          if (prefix === null)
            read = ".";
          else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
            if (!prefix || !isAbsolute(prefix))
              prefix = "/" + prefix;
            read = prefix;
          } else
            read = prefix;
          var abs = this._makeAbs(read);
          if (childrenIgnored(this, read))
            return;
          var isGlobStar = remain[0] === minimatch.GLOBSTAR;
          if (isGlobStar)
            this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
          else
            this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
        };
        GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
          var entries = this._readdir(abs, inGlobStar);
          if (!entries)
            return;
          var pn2 = remain[0];
          var negate = !!this.minimatch.negate;
          var rawGlob = pn2._glob;
          var dotOk = this.dot || rawGlob.charAt(0) === ".";
          var matchedEntries = [];
          for (var i6 = 0; i6 < entries.length; i6++) {
            var e5 = entries[i6];
            if (e5.charAt(0) !== "." || dotOk) {
              var m8;
              if (negate && !prefix) {
                m8 = !e5.match(pn2);
              } else {
                m8 = e5.match(pn2);
              }
              if (m8)
                matchedEntries.push(e5);
            }
          }
          var len = matchedEntries.length;
          if (len === 0)
            return;
          if (remain.length === 1 && !this.mark && !this.stat) {
            if (!this.matches[index])
              this.matches[index] = /* @__PURE__ */ Object.create(null);
            for (var i6 = 0; i6 < len; i6++) {
              var e5 = matchedEntries[i6];
              if (prefix) {
                if (prefix.slice(-1) !== "/")
                  e5 = prefix + "/" + e5;
                else
                  e5 = prefix + e5;
              }
              if (e5.charAt(0) === "/" && !this.nomount) {
                e5 = path.join(this.root, e5);
              }
              this._emitMatch(index, e5);
            }
            return;
          }
          remain.shift();
          for (var i6 = 0; i6 < len; i6++) {
            var e5 = matchedEntries[i6];
            var newPattern;
            if (prefix)
              newPattern = [prefix, e5];
            else
              newPattern = [e5];
            this._process(newPattern.concat(remain), index, inGlobStar);
          }
        };
        GlobSync.prototype._emitMatch = function(index, e5) {
          if (isIgnored(this, e5))
            return;
          var abs = this._makeAbs(e5);
          if (this.mark)
            e5 = this._mark(e5);
          if (this.absolute) {
            e5 = abs;
          }
          if (this.matches[index][e5])
            return;
          if (this.nodir) {
            var c3 = this.cache[abs];
            if (c3 === "DIR" || Array.isArray(c3))
              return;
          }
          this.matches[index][e5] = true;
          if (this.stat)
            this._stat(e5);
        };
        GlobSync.prototype._readdirInGlobStar = function(abs) {
          if (this.follow)
            return this._readdir(abs, false);
          var entries;
          var lstat;
          var stat;
          try {
            lstat = fs.lstatSync(abs);
          } catch (er2) {
            if (er2.code === "ENOENT") {
              return null;
            }
          }
          var isSym = lstat && lstat.isSymbolicLink();
          this.symlinks[abs] = isSym;
          if (!isSym && lstat && !lstat.isDirectory())
            this.cache[abs] = "FILE";
          else
            entries = this._readdir(abs, false);
          return entries;
        };
        GlobSync.prototype._readdir = function(abs, inGlobStar) {
          var entries;
          if (inGlobStar && !ownProp(this.symlinks, abs))
            return this._readdirInGlobStar(abs);
          if (ownProp(this.cache, abs)) {
            var c3 = this.cache[abs];
            if (!c3 || c3 === "FILE")
              return null;
            if (Array.isArray(c3))
              return c3;
          }
          try {
            return this._readdirEntries(abs, fs.readdirSync(abs));
          } catch (er2) {
            this._readdirError(abs, er2);
            return null;
          }
        };
        GlobSync.prototype._readdirEntries = function(abs, entries) {
          if (!this.mark && !this.stat) {
            for (var i6 = 0; i6 < entries.length; i6++) {
              var e5 = entries[i6];
              if (abs === "/")
                e5 = abs + e5;
              else
                e5 = abs + "/" + e5;
              this.cache[e5] = true;
            }
          }
          this.cache[abs] = entries;
          return entries;
        };
        GlobSync.prototype._readdirError = function(f6, er2) {
          switch (er2.code) {
            case "ENOTSUP":
            case "ENOTDIR":
              var abs = this._makeAbs(f6);
              this.cache[abs] = "FILE";
              if (abs === this.cwdAbs) {
                var error = new Error(er2.code + " invalid cwd " + this.cwd);
                error.path = this.cwd;
                error.code = er2.code;
                throw error;
              }
              break;
            case "ENOENT":
            case "ELOOP":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              this.cache[this._makeAbs(f6)] = false;
              break;
            default:
              this.cache[this._makeAbs(f6)] = false;
              if (this.strict)
                throw er2;
              if (!this.silent)
                console.error("glob error", er2);
              break;
          }
        };
        GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
          var entries = this._readdir(abs, inGlobStar);
          if (!entries)
            return;
          var remainWithoutGlobStar = remain.slice(1);
          var gspref = prefix ? [prefix] : [];
          var noGlobStar = gspref.concat(remainWithoutGlobStar);
          this._process(noGlobStar, index, false);
          var len = entries.length;
          var isSym = this.symlinks[abs];
          if (isSym && inGlobStar)
            return;
          for (var i6 = 0; i6 < len; i6++) {
            var e5 = entries[i6];
            if (e5.charAt(0) === "." && !this.dot)
              continue;
            var instead = gspref.concat(entries[i6], remainWithoutGlobStar);
            this._process(instead, index, true);
            var below = gspref.concat(entries[i6], remain);
            this._process(below, index, true);
          }
        };
        GlobSync.prototype._processSimple = function(prefix, index) {
          var exists = this._stat(prefix);
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          if (!exists)
            return;
          if (prefix && isAbsolute(prefix) && !this.nomount) {
            var trail = /[\/\\]$/.test(prefix);
            if (prefix.charAt(0) === "/") {
              prefix = path.join(this.root, prefix);
            } else {
              prefix = path.resolve(this.root, prefix);
              if (trail)
                prefix += "/";
            }
          }
          if (process.platform === "win32")
            prefix = prefix.replace(/\\/g, "/");
          this._emitMatch(index, prefix);
        };
        GlobSync.prototype._stat = function(f6) {
          var abs = this._makeAbs(f6);
          var needDir = f6.slice(-1) === "/";
          if (f6.length > this.maxLength)
            return false;
          if (!this.stat && ownProp(this.cache, abs)) {
            var c3 = this.cache[abs];
            if (Array.isArray(c3))
              c3 = "DIR";
            if (!needDir || c3 === "DIR")
              return c3;
            if (needDir && c3 === "FILE")
              return false;
          }
          var exists;
          var stat = this.statCache[abs];
          if (!stat) {
            var lstat;
            try {
              lstat = fs.lstatSync(abs);
            } catch (er2) {
              if (er2 && (er2.code === "ENOENT" || er2.code === "ENOTDIR")) {
                this.statCache[abs] = false;
                return false;
              }
            }
            if (lstat && lstat.isSymbolicLink()) {
              try {
                stat = fs.statSync(abs);
              } catch (er2) {
                stat = lstat;
              }
            } else {
              stat = lstat;
            }
          }
          this.statCache[abs] = stat;
          var c3 = true;
          if (stat)
            c3 = stat.isDirectory() ? "DIR" : "FILE";
          this.cache[abs] = this.cache[abs] || c3;
          if (needDir && c3 === "FILE")
            return false;
          return c3;
        };
        GlobSync.prototype._mark = function(p5) {
          return common.mark(this, p5);
        };
        GlobSync.prototype._makeAbs = function(f6) {
          return common.makeAbs(this, f6);
        };
      },
      ,
      ,
      /* 221 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        module3.exports = function(flag, argv) {
          argv = argv || process.argv;
          var terminatorPos = argv.indexOf("--");
          var prefix = /^--/.test(flag) ? "" : "--";
          var pos = argv.indexOf(prefix + flag);
          return pos !== -1 && (terminatorPos !== -1 ? pos < terminatorPos : true);
        };
      },
      ,
      /* 223 */
      /***/
      function(module3, exports2, __webpack_require__) {
        var wrappy = __webpack_require__(123);
        var reqs = /* @__PURE__ */ Object.create(null);
        var once = __webpack_require__(61);
        module3.exports = wrappy(inflight);
        function inflight(key, cb) {
          if (reqs[key]) {
            reqs[key].push(cb);
            return null;
          } else {
            reqs[key] = [cb];
            return makeres(key);
          }
        }
        function makeres(key) {
          return once(function RES() {
            var cbs = reqs[key];
            var len = cbs.length;
            var args = slice(arguments);
            try {
              for (var i6 = 0; i6 < len; i6++) {
                cbs[i6].apply(null, args);
              }
            } finally {
              if (cbs.length > len) {
                cbs.splice(0, len);
                process.nextTick(function() {
                  RES.apply(null, args);
                });
              } else {
                delete reqs[key];
              }
            }
          });
        }
        function slice(args) {
          var length = args.length;
          var array = [];
          for (var i6 = 0; i6 < length; i6++)
            array[i6] = args[i6];
          return array;
        }
      },
      /* 224 */
      /***/
      function(module3, exports2) {
        if (typeof Object.create === "function") {
          module3.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };
        } else {
          module3.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      },
      ,
      ,
      /* 227 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = typeof __webpack_require__ !== "undefined";
      },
      ,
      /* 229 */
      /***/
      function(module3, exports2) {
        var s5 = 1e3;
        var m8 = s5 * 60;
        var h4 = m8 * 60;
        var d5 = h4 * 24;
        var y3 = d5 * 365.25;
        module3.exports = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse2(val);
          } else if (type === "number" && isNaN(val) === false) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse2(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n3 = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n3 * y3;
            case "days":
            case "day":
            case "d":
              return n3 * d5;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n3 * h4;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n3 * m8;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n3 * s5;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n3;
            default:
              return void 0;
          }
        }
        function fmtShort(ms) {
          if (ms >= d5) {
            return Math.round(ms / d5) + "d";
          }
          if (ms >= h4) {
            return Math.round(ms / h4) + "h";
          }
          if (ms >= m8) {
            return Math.round(ms / m8) + "m";
          }
          if (ms >= s5) {
            return Math.round(ms / s5) + "s";
          }
          return ms + "ms";
        }
        function fmtLong(ms) {
          return plural(ms, d5, "day") || plural(ms, h4, "hour") || plural(ms, m8, "minute") || plural(ms, s5, "second") || ms + " ms";
        }
        function plural(ms, n3, name) {
          if (ms < n3) {
            return;
          }
          if (ms < n3 * 1.5) {
            return Math.floor(ms / n3) + " " + name;
          }
          return Math.ceil(ms / n3) + " " + name + "s";
        }
      },
      ,
      ,
      ,
      /* 233 */
      /***/
      function(module3, exports2, __webpack_require__) {
        module3.exports = rimraf;
        rimraf.sync = rimrafSync;
        var assert2 = __webpack_require__(22);
        var path = __webpack_require__(0);
        var fs = __webpack_require__(3);
        var glob2 = __webpack_require__(75);
        var _0666 = parseInt("666", 8);
        var defaultGlobOpts = {
          nosort: true,
          silent: true
        };
        var timeout = 0;
        var isWindows = process.platform === "win32";
        function defaults(options) {
          var methods = [
            "unlink",
            "chmod",
            "stat",
            "lstat",
            "rmdir",
            "readdir"
          ];
          methods.forEach(function(m8) {
            options[m8] = options[m8] || fs[m8];
            m8 = m8 + "Sync";
            options[m8] = options[m8] || fs[m8];
          });
          options.maxBusyTries = options.maxBusyTries || 3;
          options.emfileWait = options.emfileWait || 1e3;
          if (options.glob === false) {
            options.disableGlob = true;
          }
          options.disableGlob = options.disableGlob || false;
          options.glob = options.glob || defaultGlobOpts;
        }
        function rimraf(p5, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = {};
          }
          assert2(p5, "rimraf: missing path");
          assert2.equal(typeof p5, "string", "rimraf: path should be a string");
          assert2.equal(typeof cb, "function", "rimraf: callback function required");
          assert2(options, "rimraf: invalid options argument provided");
          assert2.equal(typeof options, "object", "rimraf: options should be object");
          defaults(options);
          var busyTries = 0;
          var errState = null;
          var n3 = 0;
          if (options.disableGlob || !glob2.hasMagic(p5))
            return afterGlob(null, [p5]);
          options.lstat(p5, function(er2, stat) {
            if (!er2)
              return afterGlob(null, [p5]);
            glob2(p5, options.glob, afterGlob);
          });
          function next(er2) {
            errState = errState || er2;
            if (--n3 === 0)
              cb(errState);
          }
          function afterGlob(er2, results) {
            if (er2)
              return cb(er2);
            n3 = results.length;
            if (n3 === 0)
              return cb();
            results.forEach(function(p6) {
              rimraf_(p6, options, function CB(er3) {
                if (er3) {
                  if ((er3.code === "EBUSY" || er3.code === "ENOTEMPTY" || er3.code === "EPERM") && busyTries < options.maxBusyTries) {
                    busyTries++;
                    var time = busyTries * 100;
                    return setTimeout(function() {
                      rimraf_(p6, options, CB);
                    }, time);
                  }
                  if (er3.code === "EMFILE" && timeout < options.emfileWait) {
                    return setTimeout(function() {
                      rimraf_(p6, options, CB);
                    }, timeout++);
                  }
                  if (er3.code === "ENOENT")
                    er3 = null;
                }
                timeout = 0;
                next(er3);
              });
            });
          }
        }
        function rimraf_(p5, options, cb) {
          assert2(p5);
          assert2(options);
          assert2(typeof cb === "function");
          options.lstat(p5, function(er2, st2) {
            if (er2 && er2.code === "ENOENT")
              return cb(null);
            if (er2 && er2.code === "EPERM" && isWindows)
              fixWinEPERM(p5, options, er2, cb);
            if (st2 && st2.isDirectory())
              return rmdir(p5, options, er2, cb);
            options.unlink(p5, function(er3) {
              if (er3) {
                if (er3.code === "ENOENT")
                  return cb(null);
                if (er3.code === "EPERM")
                  return isWindows ? fixWinEPERM(p5, options, er3, cb) : rmdir(p5, options, er3, cb);
                if (er3.code === "EISDIR")
                  return rmdir(p5, options, er3, cb);
              }
              return cb(er3);
            });
          });
        }
        function fixWinEPERM(p5, options, er2, cb) {
          assert2(p5);
          assert2(options);
          assert2(typeof cb === "function");
          if (er2)
            assert2(er2 instanceof Error);
          options.chmod(p5, _0666, function(er22) {
            if (er22)
              cb(er22.code === "ENOENT" ? null : er2);
            else
              options.stat(p5, function(er3, stats) {
                if (er3)
                  cb(er3.code === "ENOENT" ? null : er2);
                else if (stats.isDirectory())
                  rmdir(p5, options, er2, cb);
                else
                  options.unlink(p5, cb);
              });
          });
        }
        function fixWinEPERMSync(p5, options, er2) {
          assert2(p5);
          assert2(options);
          if (er2)
            assert2(er2 instanceof Error);
          try {
            options.chmodSync(p5, _0666);
          } catch (er22) {
            if (er22.code === "ENOENT")
              return;
            else
              throw er2;
          }
          try {
            var stats = options.statSync(p5);
          } catch (er3) {
            if (er3.code === "ENOENT")
              return;
            else
              throw er2;
          }
          if (stats.isDirectory())
            rmdirSync(p5, options, er2);
          else
            options.unlinkSync(p5);
        }
        function rmdir(p5, options, originalEr, cb) {
          assert2(p5);
          assert2(options);
          if (originalEr)
            assert2(originalEr instanceof Error);
          assert2(typeof cb === "function");
          options.rmdir(p5, function(er2) {
            if (er2 && (er2.code === "ENOTEMPTY" || er2.code === "EEXIST" || er2.code === "EPERM"))
              rmkids(p5, options, cb);
            else if (er2 && er2.code === "ENOTDIR")
              cb(originalEr);
            else
              cb(er2);
          });
        }
        function rmkids(p5, options, cb) {
          assert2(p5);
          assert2(options);
          assert2(typeof cb === "function");
          options.readdir(p5, function(er2, files) {
            if (er2)
              return cb(er2);
            var n3 = files.length;
            if (n3 === 0)
              return options.rmdir(p5, cb);
            var errState;
            files.forEach(function(f6) {
              rimraf(path.join(p5, f6), options, function(er3) {
                if (errState)
                  return;
                if (er3)
                  return cb(errState = er3);
                if (--n3 === 0)
                  options.rmdir(p5, cb);
              });
            });
          });
        }
        function rimrafSync(p5, options) {
          options = options || {};
          defaults(options);
          assert2(p5, "rimraf: missing path");
          assert2.equal(typeof p5, "string", "rimraf: path should be a string");
          assert2(options, "rimraf: missing options");
          assert2.equal(typeof options, "object", "rimraf: options should be object");
          var results;
          if (options.disableGlob || !glob2.hasMagic(p5)) {
            results = [p5];
          } else {
            try {
              options.lstatSync(p5);
              results = [p5];
            } catch (er2) {
              results = glob2.sync(p5, options.glob);
            }
          }
          if (!results.length)
            return;
          for (var i6 = 0; i6 < results.length; i6++) {
            var p5 = results[i6];
            try {
              var st2 = options.lstatSync(p5);
            } catch (er2) {
              if (er2.code === "ENOENT")
                return;
              if (er2.code === "EPERM" && isWindows)
                fixWinEPERMSync(p5, options, er2);
            }
            try {
              if (st2 && st2.isDirectory())
                rmdirSync(p5, options, null);
              else
                options.unlinkSync(p5);
            } catch (er2) {
              if (er2.code === "ENOENT")
                return;
              if (er2.code === "EPERM")
                return isWindows ? fixWinEPERMSync(p5, options, er2) : rmdirSync(p5, options, er2);
              if (er2.code !== "EISDIR")
                throw er2;
              rmdirSync(p5, options, er2);
            }
          }
        }
        function rmdirSync(p5, options, originalEr) {
          assert2(p5);
          assert2(options);
          if (originalEr)
            assert2(originalEr instanceof Error);
          try {
            options.rmdirSync(p5);
          } catch (er2) {
            if (er2.code === "ENOENT")
              return;
            if (er2.code === "ENOTDIR")
              throw originalEr;
            if (er2.code === "ENOTEMPTY" || er2.code === "EEXIST" || er2.code === "EPERM")
              rmkidsSync(p5, options);
          }
        }
        function rmkidsSync(p5, options) {
          assert2(p5);
          assert2(options);
          options.readdirSync(p5).forEach(function(f6) {
            rimrafSync(path.join(p5, f6), options);
          });
          var retries = isWindows ? 100 : 1;
          var i6 = 0;
          do {
            var threw = true;
            try {
              var ret = options.rmdirSync(p5, options);
              threw = false;
              return ret;
            } finally {
              if (++i6 < retries && threw)
                continue;
            }
          } while (true);
        }
      },
      ,
      ,
      ,
      ,
      ,
      /* 239 */
      /***/
      function(module3, exports2, __webpack_require__) {
        "use strict";
        var hasFlag3 = __webpack_require__(221);
        var support = function(level) {
          if (level === 0) {
            return false;
          }
          return {
            level,
            hasBasic: true,
            has256: level >= 2,
            has16m: level >= 3
          };
        };
        var supportLevel = function() {
          if (hasFlag3("no-color") || hasFlag3("no-colors") || hasFlag3("color=false")) {
            return 0;
          }
          if (hasFlag3("color=16m") || hasFlag3("color=full") || hasFlag3("color=truecolor")) {
            return 3;
          }
          if (hasFlag3("color=256")) {
            return 2;
          }
          if (hasFlag3("color") || hasFlag3("colors") || hasFlag3("color=true") || hasFlag3("color=always")) {
            return 1;
          }
          if (process.stdout && !process.stdout.isTTY) {
            return 0;
          }
          if (process.platform === "win32") {
            return 1;
          }
          if ("CI" in process.env) {
            if ("TRAVIS" in process.env || process.env.CI === "Travis") {
              return 1;
            }
            return 0;
          }
          if ("TEAMCITY_VERSION" in process.env) {
            return process.env.TEAMCITY_VERSION.match(/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/) === null ? 0 : 1;
          }
          if (/^(screen|xterm)-256(?:color)?/.test(process.env.TERM)) {
            return 2;
          }
          if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
            return 1;
          }
          if ("COLORTERM" in process.env) {
            return 1;
          }
          if (process.env.TERM === "dumb") {
            return 0;
          }
          return 0;
        }();
        if (supportLevel === 0 && "FORCE_COLOR" in process.env) {
          supportLevel = 1;
        }
        module3.exports = process && support(supportLevel);
      }
      /******/
    ]);
  }
});

// 
var require_identity = __commonJS({
  ""(exports) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP;
    exports.NODE_TYPE = NODE_TYPE;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;
  }
});

// 
var require_visit = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path) {
      const ctrl = callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i6 = 0; i6 < node.items.length; ++i6) {
            const ci = visit_(i6, node.items[i6], visitor, path);
            if (typeof ci === "number")
              i6 = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i6, 1);
              i6 -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = visit_("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path) {
      const ctrl = await callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i6 = 0; i6 < node.items.length; ++i6) {
            const ci = await visitAsync_(i6, node.items[i6], visitor, path);
            if (typeof ci === "number")
              i6 = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i6, 1);
              i6 -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path) {
      if (typeof visitor === "function")
        return visitor(key, node, path);
      if (identity.isMap(node))
        return visitor.Map?.(key, node, path);
      if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path);
      if (identity.isPair(node))
        return visitor.Pair?.(key, node, path);
      if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path);
      if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path);
      return void 0;
    }
    function replaceNode(key, path, node) {
      const parent = path[path.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports.visit = visit;
    exports.visitAsync = visitAsync;
  }
});

// 
var require_directives = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn2) => tn2.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version);
              onError(6, `Unsupported YAML version ${version}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn2) => tn2.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports.Directives = Directives;
  }
});

// 
var require_anchors = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i6 = 1; true; ++i6) {
        const name = `${prefix}${i6}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          prevAnchors ?? (prevAnchors = anchorNames(doc));
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;
  }
});

// 
var require_applyReviver = __commonJS({
  ""(exports) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i6 = 0, len = val.length; i6 < len; ++i6) {
            const v0 = val[i6];
            const v1 = applyReviver(reviver, val, String(i6), v0);
            if (v1 === void 0)
              delete val[i6];
            else if (v1 !== v0)
              val[i6] = v1;
          }
        } else if (val instanceof Map) {
          for (const k3 of Array.from(val.keys())) {
            const v0 = val.get(k3);
            const v1 = applyReviver(reviver, val, k3, v0);
            if (v1 === void 0)
              val.delete(k3);
            else if (v1 !== v0)
              val.set(k3, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k3, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k3, v0);
            if (v1 === void 0)
              delete val[k3];
            else if (v1 !== v0)
              val[k3] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports.applyReviver = applyReviver;
  }
});

// 
var require_toJS = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v4, i6) => toJS(v4, String(i6), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !ctx?.keep)
        return Number(value);
      return value;
    }
    exports.toJS = toJS;
  }
});

// 
var require_Node = __commonJS({
  ""(exports) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports.NodeBase = NodeBase;
  }
});

// 
var require_Alias = __commonJS({
  ""(exports) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
          nodes = ctx.aliasResolveCache;
        } else {
          nodes = [];
          visit.visit(doc, {
            Node: (_key, node) => {
              if (identity.isAlias(node) || identity.hasAnchor(node))
                nodes.push(node);
            }
          });
          if (ctx)
            ctx.aliasResolveCache = nodes;
        }
        let found = void 0;
        for (const node of nodes) {
          if (node === this)
            break;
          if (node.anchor === this.source)
            found = node;
        }
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c3 = getAliasCount(doc, item, anchors2);
          if (c3 > count)
            count = c3;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports.Alias = Alias;
  }
});

// 
var require_Scalar = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;
  }
});

// 
var require_createNode = __commonJS({
  ""(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t3) => t3.tag === tagName);
        const tagObj = match.find((t3) => !t3.format) ?? match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t3) => t3.identify?.(value) && !t3.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value))
        value = value.contents;
      if (identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          ref.anchor ?? (ref.anchor = onAnchor(value));
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node2 = new Scalar.Scalar(value);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports.createNode = createNode;
  }
});

// 
var require_Collection = __commonJS({
  ""(exports) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path, value) {
      let v4 = value;
      for (let i6 = path.length - 1; i6 >= 0; --i6) {
        const k3 = path[i6];
        if (typeof k3 === "number" && Number.isInteger(k3) && k3 >= 0) {
          const a7 = [];
          a7[k3] = v4;
          v4 = a7;
        } else {
          v4 = /* @__PURE__ */ new Map([[k3, v4]]);
        }
      }
      return createNode.createNode(v4, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    var Collection2 = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it2) => identity.isNode(it2) || identity.isPair(it2) ? it2.clone(schema) : it2);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return false;
          const n3 = node.value;
          return n3 == null || allowScalar && identity.isScalar(n3) && n3.value == null && !n3.commentBefore && !n3.comment && !n3.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports.Collection = Collection2;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;
  }
});

// 
var require_stringifyComment = __commonJS({
  ""(exports) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports.indentComment = indentComment;
    exports.lineComment = lineComment;
    exports.stringifyComment = stringifyComment;
  }
});

// 
var require_foldFlowLines = __commonJS({
  ""(exports) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i6 = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i6 = consumeMoreIndentedLines(text, i6, indent.length);
        if (i6 !== -1)
          end = i6 + endStep;
      }
      for (let ch; ch = text[i6 += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i6;
          switch (text[i6 + 1]) {
            case "x":
              i6 += 3;
              break;
            case "u":
              i6 += 5;
              break;
            case "U":
              i6 += 9;
              break;
            default:
              i6 += 1;
          }
          escEnd = i6;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i6 = consumeMoreIndentedLines(text, i6, indent.length);
          end = i6 + indent.length + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i6 + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i6;
          }
          if (i6 >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i6 += 1];
                overflow = true;
              }
              const j2 = i6 > escEnd + 1 ? i6 - 2 : escStart - 1;
              if (escapedFolds[j2])
                return text;
              folds.push(j2);
              escapedFolds[j2] = true;
              end = j2 + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i7 = 0; i7 < folds.length; ++i7) {
        const fold = folds[i7];
        const end2 = folds[i7 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i6, indent) {
      let end = i6;
      let start = i6 + 1;
      let ch = text[start];
      while (ch === " " || ch === "	") {
        if (i6 < start + indent) {
          ch = text[++i6];
        } else {
          do {
            ch = text[++i6];
          } while (ch && ch !== "\n");
          end = i6;
          start = i6 + 1;
          ch = text[start];
        }
      }
      return end;
    }
    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;
  }
});

// 
var require_stringifyString = __commonJS({
  ""(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i6 = 0, start = 0; i6 < strLen; ++i6) {
        if (str[i6] === "\n") {
          if (i6 - start > limit)
            return true;
          start = i6 + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i6 = 0, ch = json[i6]; ch; ch = json[++i6]) {
        if (ch === " " && json[i6 + 1] === "\\" && json[i6 + 2] === "n") {
          str += json.slice(start, i6) + "\\ ";
          i6 += 1;
          start = i6;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i6 + 1]) {
            case "u":
              {
                str += json.slice(start, i6);
                const code = json.substr(i6 + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i6, 6);
                }
                i6 += 5;
                start = i6 + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i6 + 2] === '"' || json.length < minMultiLineLength) {
                i6 += 1;
              } else {
                str += json.slice(start, i6) + "\n\n";
                while (json[i6 + 2] === "\\" && json[i6 + 3] === "n" && json[i6 + 4] !== '"') {
                  str += "\n";
                  i6 += 2;
                }
                str += indent;
                if (json[i6 + 2] === " ")
                  str += "\\";
                i6 += 1;
                start = i6 + 1;
              }
              break;
            default:
              i6 += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal) {
        const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent}${body}`;
      }
      value = value.replace(/\n+/g, `$&${indent}`);
      return `|${header}
${indent}${start}${value}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t3 = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t3);
        if (res === null)
          throw new Error(`Unsupported default string type ${t3}`);
      }
      return res;
    }
    exports.stringifyString = stringifyString;
  }
});

// 
var require_stringify2 = __commonJS({
  ""(exports) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t3) => t3.tag === item.tag);
        if (match.length > 0)
          return match.find((t3) => t3.format === item.format) ?? match[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter((t3) => t3.identify?.(obj));
        if (match.length > 1) {
          const testMatch = match.filter((t3) => t3.test);
          if (testMatch.length > 0)
            match = testMatch;
        }
        tagObj = match.find((t3) => t3.format === item.format) ?? match.find((t3) => !t3.format);
      } else {
        obj = item;
        tagObj = tags.find((t3) => t3.nodeClass && obj instanceof t3.nodeClass);
      }
      if (!tagObj) {
        const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o8) => tagObj = o8 });
      tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify;
  }
});

// 
var require_stringifyPair = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var stringify = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object")
          value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports.stringifyPair = stringifyPair;
  }
});

// 
var require_log = __commonJS({
  ""(exports) {
    "use strict";
    var node_process = __require("process");
    function debug(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof node_process.emitWarning === "function")
          node_process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports.debug = debug;
    exports.warn = warn;
  }
});

// 
var require_merge = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge2 = {
      identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge2.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge2.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge2.tag && tag.default);
    function addMergeToJSMap(ctx, map, value) {
      value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (identity.isSeq(value))
        for (const it2 of value.items)
          mergeValue(ctx, map, it2);
      else if (Array.isArray(value))
        for (const it2 of value)
          mergeValue(ctx, map, it2);
      else
        mergeValue(ctx, map, value);
    }
    function mergeValue(ctx, map, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key))
            map.set(key, value2);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map;
    }
    exports.addMergeToJSMap = addMergeToJSMap;
    exports.isMergeKey = isMergeKey;
    exports.merge = merge2;
  }
});

// 
var require_addPairToJSMap = __commonJS({
  ""(exports) {
    "use strict";
    var log = require_log();
    var merge2 = require_merge();
    var stringify = require_stringify2();
    var identity = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map, { key, value }) {
      if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map, value);
      else if (merge2.isMergeKey(ctx, key))
        merge2.addMergeToJSMap(ctx, map, value);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map[stringKey] = jsValue;
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports.addPairToJSMap = addPairToJSMap;
  }
});

// 
var require_Pair = __commonJS({
  ""(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value, ctx) {
      const k3 = createNode.createNode(key, void 0, ctx);
      const v4 = createNode.createNode(value, void 0, ctx);
      return new Pair(k3, v4);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
          key = key.clone(schema);
        if (identity.isNode(value))
          value = value.clone(schema);
        return new _Pair(key, value);
      }
      toJSON(_4, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports.Pair = Pair;
    exports.createPair = createPair;
  }
});

// 
var require_stringifyCollection = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i6 = 0; i6 < items.length; ++i6) {
        const item = items[i6];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i6 = 1; i6 < lines.length; ++i6) {
          const line = lines[i6];
          str += line ? `
${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i6 = 0; i6 < items.length; ++i6) {
        const item = items[i6];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => comment = null);
        if (i6 < items.length - 1)
          str += ",";
        if (comment)
          str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent}${line}` : "\n";
          return `${str}
${indent}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports.stringifyCollection = stringifyCollection;
  }
});

// 
var require_YAMLMap = __commonJS({
  ""(exports) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection2 = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k3 = identity.isScalar(key) ? key.value : key;
      for (const it2 of items) {
        if (identity.isPair(it2)) {
          if (it2.key === key || it2.key === k3)
            return it2;
          if (identity.isScalar(it2.key) && it2.key.value === k3)
            return it2;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection2.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map.items.sort(schema.sortMapEntries);
        }
        return map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i6 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i6 === -1)
            this.items.push(_pair);
          else
            this.items.splice(i6, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it2 = findPair(this.items, key);
        if (!it2)
          return false;
        const del = this.items.splice(this.items.indexOf(it2), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it2 = findPair(this.items, key);
        const node = it2?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_4, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;
  }
});

// 
var require_map = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var YAMLMap = require_YAMLMap();
    var map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!identity.isMap(map2))
          onError("Expected a mapping for this tag");
        return map2;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports.map = map;
  }
});

// 
var require_YAMLSeq = __commonJS({
  ""(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection2 = require_Collection();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection2.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it2 = this.items[idx];
        return !keepScalar && identity.isScalar(it2) ? it2.value : it2;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_4, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i6 = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i6++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i6 = 0;
          for (let it2 of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it2 : String(i6++);
              it2 = replacer.call(obj, key, it2);
            }
            seq.items.push(createNode.createNode(it2, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports.YAMLSeq = YAMLSeq;
  }
});

// 
var require_seq = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports.seq = seq;
  }
});

// 
var require_string2 = __commonJS({
  ""(exports) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports.string = string;
  }
});

// 
var require_null = __commonJS({
  ""(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports.nullTag = nullTag;
  }
});

// 
var require_bool = __commonJS({
  ""(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports.boolTag = boolTag;
  }
});

// 
var require_stringifyNumber = __commonJS({
  ""(exports) {
    "use strict";
    function stringifyNumber({ format, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n3 = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n3)) {
        let i6 = n3.indexOf(".");
        if (i6 < 0) {
          i6 = n3.length;
          n3 += ".";
        }
        let d5 = minFractionDigits - (n3.length - i6 - 1);
        while (d5-- > 0)
          n3 += "0";
      }
      return n3;
    }
    exports.stringifyNumber = stringifyNumber;
  }
});

// 
var require_float = __commonJS({
  ""(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// 
var require_int = __commonJS({
  ""(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// 
var require_schema = __commonJS({
  ""(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string2();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports.schema = schema;
  }
});

// 
var require_schema2 = __commonJS({
  ""(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var map = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
    exports.schema = schema;
  }
});

// 
var require_binary = __commonJS({
  ""(exports) {
    "use strict";
    var node_buffer = __require("buffer");
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof node_buffer.Buffer === "function") {
          return node_buffer.Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i6 = 0; i6 < str.length; ++i6)
            buffer[i6] = str.charCodeAt(i6);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
          return "";
        const buf = value;
        let str;
        if (typeof node_buffer.Buffer === "function") {
          str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s5 = "";
          for (let i6 = 0; i6 < buf.length; ++i6)
            s5 += String.fromCharCode(buf[i6]);
          str = btoa(s5);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n3 = Math.ceil(str.length / lineWidth);
          const lines = new Array(n3);
          for (let i6 = 0, o8 = 0; i6 < n3; ++i6, o8 += lineWidth) {
            lines[i6] = str.substr(o8, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports.binary = binary;
  }
});

// 
var require_pairs = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i6 = 0; i6 < seq.items.length; ++i6) {
          let item = seq.items[i6];
          if (identity.isPair(item))
            continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn2 = pair.value ?? pair.key;
              cn2.comment = cn2.comment ? `${item.comment}
${cn2.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i6] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i6 = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it2 of iterable) {
          if (typeof replacer === "function")
            it2 = replacer.call(iterable, String(i6++), it2);
          let key, value;
          if (Array.isArray(it2)) {
            if (it2.length === 2) {
              key = it2[0];
              value = it2[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it2}`);
          } else if (it2 && it2 instanceof Object) {
            const keys = Object.keys(it2);
            if (keys.length === 1) {
              key = keys[0];
              value = it2[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
            }
          } else {
            key = it2;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;
  }
});

// 
var require_omap = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_4, ctx) {
        if (!ctx)
          return super.toJSON(_4);
        const map = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;
  }
});

// 
var require_bool2 = __commonJS({
  ""(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports.falseTag = falseTag;
    exports.trueTag = trueTag;
  }
});

// 
var require_float2 = __commonJS({
  ""(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f6 = str.substring(dot + 1).replace(/_/g, "");
          if (f6[f6.length - 1] === "0")
            node.minFractionDigits = f6.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// 
var require_int2 = __commonJS({
  ""(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n4 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n4 : n4;
      }
      const n3 = parseInt(str, radix);
      return sign === "-" ? -1 * n3 : n3;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// 
var require_set = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_4, ctx) {
        return super.toJSON(_4, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map, onError) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map;
      }
    };
    exports.YAMLSet = YAMLSet;
    exports.set = set;
  }
});

// 
var require_timestamp = __commonJS({
  ""(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n3) => asBigInt ? BigInt(n3) : Number(n3);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p5) => res2 * num(60) + num(p5), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n3) => n3;
      if (typeof value === "bigint")
        num = (n3) => BigInt(n3);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n3) => String(n3).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d5 = parseSexagesimal(tz, false);
          if (Math.abs(d5) < 30)
            d5 *= 60;
          date -= 6e4 * d5;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
    };
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;
  }
});

// 
var require_schema3 = __commonJS({
  ""(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string2();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge2 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge2.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports.schema = schema;
  }
});

// 
var require_tags = __commonJS({
  ""(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string2();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge2 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      merge: merge2.merge,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge2.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge2.merge) ? schemaTags.concat(merge2.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge2.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;
  }
});

// 
var require_Schema = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var map = require_map();
    var seq = require_seq();
    var string = require_string2();
    var tags = require_tags();
    var sortMapEntriesByKey = (a7, b3) => a7.key < b3.key ? -1 : a7.key > b3.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge2);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports.Schema = Schema;
  }
});

// 
var require_stringifyDocument = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports.stringifyDocument = stringifyDocument;
  }
});

// 
var require_Document = __commonJS({
  ""(exports) {
    "use strict";
    var Alias = require_Alias();
    var Collection2 = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v4) => typeof v4 === "number" || v4 instanceof String || v4 instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k3 = this.createNode(key, null, options);
        const v4 = this.createNode(value, null, options);
        return new Pair.Pair(k3, v4);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (Collection2.isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (Collection2.isEmptyPath(path))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (Collection2.isEmptyPath(path))
          return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection2.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (Collection2.isEmptyPath(path)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = Collection2.collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === "number")
          version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version;
            else
              this.directives = new directives.Directives({ version });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s5 = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s5}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports.Document = Document;
  }
});

// 
var require_errors = __commonJS({
  ""(exports) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;
  }
});

// 
var require_resolve_props = __commonJS({
  ""(exports) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else if (!found || indicator !== "seq-item-ind")
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports.resolveProps = resolveProps;
  }
});

// 
var require_util_contains_newline = __commonJS({
  ""(exports) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st2 of key.end)
              if (st2.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it2 of key.items) {
            for (const st2 of it2.start)
              if (st2.type === "newline")
                return true;
            if (it2.sep) {
              for (const st2 of it2.sep)
                if (st2.type === "newline")
                  return true;
            }
            if (containsNewline(it2.key) || containsNewline(it2.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports.containsNewline = containsNewline;
  }
});

// 
var require_util_flow_indent_check = __commonJS({
  ""(exports) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports.flowIndentCheck = flowIndentCheck;
  }
});

// 
var require_util_map_includes = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a7, b3) => a7 === b3 || identity.isScalar(a7) && identity.isScalar(b3) && a7.value === b3.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports.mapIncludes = mapIncludes;
  }
});

// 
var require_resolve_block_map = __commonJS({
  ""(exports) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep: sep2, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep2?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep2) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map.comment)
                map.comment += "\n" + keyProps.comment;
              else
                map.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep2 ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep2, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map.range = [bm.offset, offset, commentEnd ?? offset];
      return map;
    }
    exports.resolveBlockMap = resolveBlockMap;
  }
});

// 
var require_resolve_block_seq = __commonJS({
  ""(exports) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports.resolveBlockSeq = resolveBlockSeq;
  }
});

// 
var require_resolve_end = __commonJS({
  ""(exports) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep2 = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep2 + cb;
              sep2 = "";
              break;
            }
            case "newline":
              if (comment)
                sep2 += source;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports.resolveEnd = resolveEnd;
  }
});

// 
var require_resolve_flow_collection = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i6 = 0; i6 < fc.items.length; ++i6) {
        const collItem = fc.items[i6];
        const { start, key, sep: sep2, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep2?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep2 && !value) {
            if (i6 === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i6 < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i6 === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop:
              for (const st2 of start) {
                switch (st2.type) {
                  case "comma":
                  case "space":
                    break;
                  case "comment":
                    prevItemComment = st2.source.substring(1);
                    break loop;
                  default:
                    break loop;
                }
              }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep2 && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep2, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep2 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep2)
                for (const st2 of sep2) {
                  if (st2 === valueProps.found)
                    break;
                  if (st2.type === "newline") {
                    onError(st2, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":")
              onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce2, ...ee3] = fc.end;
      let cePos = offset;
      if (ce2 && ce2.source === expectedEnd)
        cePos = ce2.offset + ce2.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce2 && ce2.source.length !== 1)
          ee3.unshift(ce2);
      }
      if (ee3.length > 0) {
        const end = resolveEnd.resolveEnd(ee3, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports.resolveFlowCollection = resolveFlowCollection;
  }
});

// 
var require_compose_collection = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t3) => t3.tag === tagName && t3.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports.composeCollection = composeCollection;
  }
});

// 
var require_resolve_block_scalar = __commonJS({
  ""(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i6 = lines.length - 1; i6 >= 0; --i6) {
        const content = lines[i6][1];
        if (content === "" || content === "\r")
          chompStart = i6;
        else
          break;
      }
      if (chompStart === 0) {
        const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i6 = 0; i6 < chompStart; ++i6) {
        const [indent, content] = lines[i6];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent.length;
          contentStart = i6;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent.length + content.length + 1;
      }
      for (let i6 = lines.length - 1; i6 >= chompStart; --i6) {
        if (lines[i6][0].length > trimIndent)
          chompStart = i6 + 1;
      }
      let value = "";
      let sep2 = "";
      let prevMoreIndented = false;
      for (let i6 = 0; i6 < contentStart; ++i6)
        value += lines[i6][0].slice(trimIndent) + "\n";
      for (let i6 = contentStart; i6 < chompStart; ++i6) {
        let [indent, content] = lines[i6];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep2 + indent.slice(trimIndent) + content;
          sep2 = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep2 === " ")
            sep2 = "\n";
          else if (!prevMoreIndented && sep2 === "\n")
            sep2 = "\n\n";
          value += sep2 + indent.slice(trimIndent) + content;
          sep2 = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep2 === "\n")
            value += "\n";
          else
            sep2 = "\n";
        } else {
          value += sep2 + content;
          sep2 = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i6 = chompStart; i6 < lines.length; ++i6)
            value += "\n" + lines[i6][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error = -1;
      for (let i6 = 1; i6 < source.length; ++i6) {
        const ch = source[i6];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n3 = Number(ch);
          if (!indent && n3)
            indent = n3;
          else if (error === -1)
            error = offset + i6;
        }
      }
      if (error !== -1)
        onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i6 = 1; i6 < props.length; ++i6) {
        const token = props[i6];
        switch (token.type) {
          case "space":
            hasSpace = true;
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m8 = first.match(/^( *)/);
      const line0 = m8?.[1] ? [m8[1], first.slice(m8[1].length)] : ["", first];
      const lines = [line0];
      for (let i6 = 1; i6 < split.length; i6 += 2)
        lines.push([split[i6], split[i6 + 1]]);
      return lines;
    }
    exports.resolveBlockScalar = resolveBlockScalar;
  }
});

// 
var require_resolve_flow_scalar = __commonJS({
  ""(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re3 = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re3.comment,
        range: [offset, valueEnd, re3.offset]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match)
        return source;
      let res = match[1];
      let sep2 = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while (match = line.exec(source)) {
        if (match[1] === "") {
          if (sep2 === "\n")
            res += sep2;
          else
            sep2 = "\n";
        } else {
          res += sep2 + match[1];
          sep2 = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep2 + (match?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i6 = 1; i6 < source.length - 1; ++i6) {
        const ch = source[i6];
        if (ch === "\r" && source[i6 + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i6);
          res += fold;
          i6 = offset;
        } else if (ch === "\\") {
          let next = source[++i6];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i6 + 1];
            while (next === " " || next === "	")
              next = source[++i6 + 1];
          } else if (next === "\r" && source[i6 + 1] === "\n") {
            next = source[++i6 + 1];
            while (next === " " || next === "	")
              next = source[++i6 + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i6 + 1, length, onError);
            i6 += length;
          } else {
            const raw = source.substr(i6 - 1, 2);
            onError(i6 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i6;
          let next = source[i6 + 1];
          while (next === " " || next === "	")
            next = source[++i6 + 1];
          if (next !== "\n" && !(next === "\r" && source[i6 + 2] === "\n"))
            res += i6 > wsStart ? source.slice(wsStart, i6 + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports.resolveFlowScalar = resolveFlowScalar;
  }
});

// 
var require_compose_scalar = __commonJS({
  ""(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
      else if (token.type === "scalar")
        tag = findScalarTagByTest(ctx, value, token, onError);
      else
        tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      if (tagName === "!")
        return schema[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports.composeScalar = composeScalar;
  }
});

// 
var require_util_empty_scalar_position = __commonJS({
  ""(exports) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos ?? (pos = before.length);
        for (let i6 = pos - 1; i6 >= 0; --i6) {
          let st2 = before[i6];
          switch (st2.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st2.source.length;
              continue;
          }
          st2 = before[++i6];
          while (st2?.type === "space") {
            offset += st2.source.length;
            st2 = before[++i6];
          }
          break;
        }
      }
      return offset;
    }
    exports.emptyScalarPosition = emptyScalarPosition;
  }
});

// 
var require_compose_node = __commonJS({
  ""(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re3 = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re3.offset];
      if (re3.comment)
        alias.comment = re3.comment;
      return alias;
    }
    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;
  }
});

// 
var require_compose_doc = __commonJS({
  ""(exports) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re3 = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re3.comment)
        doc.comment = re3.comment;
      doc.range = [offset, contentEnd, re3.offset];
      return doc;
    }
    exports.composeDoc = composeDoc;
  }
});

// 
var require_composer = __commonJS({
  ""(exports) {
    "use strict";
    var node_process = __require("process");
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i6 = 0; i6 < prelude.length; ++i6) {
        const source = prelude[i6];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i6 + 1]?.[0] !== "#")
              i6 += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it2 = dc.items[0];
            if (identity.isPair(it2))
              it2 = it2.key;
            const cb = it2.commentBefore;
            it2.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (node_process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports.Composer = Composer;
  }
});

// 
var require_cst_scalar = __commonJS({
  ""(exports) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context2) {
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context2;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context2.end ?? [
        { type: "newline", offset: -1, indent, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he2 = source.indexOf("\n");
          const head = source.substring(0, he2);
          const body = source.substring(he2 + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token, value, context2 = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context2;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number")
        indent += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he2 = source.indexOf("\n");
      const head = source.substring(0, he2);
      const body = source.substring(he2 + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st2 of end)
          switch (st2.type) {
            case "space":
            case "comment":
              props.push(st2);
              break;
            case "newline":
              props.push(st2);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st2) => st2.type === "space" || st2.type === "comment" || st2.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }
    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;
  }
});

// 
var require_cst_stringify = __commonJS({
  ""(exports) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st2 of token.end)
            res += st2.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st2 of token.end)
              res += st2.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st2 of token.end)
              res += st2.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep: sep2, value }) {
      let res = "";
      for (const st2 of start)
        res += st2.source;
      if (key)
        res += stringifyToken(key);
      if (sep2)
        for (const st2 of sep2)
          res += st2.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports.stringify = stringify;
  }
});

// 
var require_cst_visit = __commonJS({
  ""(exports) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path) => {
      const parent = visit.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path, item, visitor) {
      let ctrl = visitor(item, path);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i6 = 0; i6 < token.items.length; ++i6) {
            const ci = _visit(Object.freeze(path.concat([[field, i6]])), token.items[i6], visitor);
            if (typeof ci === "number")
              i6 = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i6, 1);
              i6 -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
    }
    exports.visit = visit;
  }
});

// 
var require_cst = __commonJS({
  ""(exports) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;
  }
});

// 
var require_lexer = __commonJS({
  ""(exports) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i6 = this.pos;
        let ch = this.buffer[i6];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i6];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i6 + 1] === "\n";
        return false;
      }
      charAt(n3) {
        return this.buffer[this.pos + n3];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt2 = this.buffer.substr(offset, 3);
          if ((dt2 === "---" || dt2 === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n3) {
        return this.pos + n3 <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n3) {
        return this.buffer.substr(this.pos, n3);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n3 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n3);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s5 = this.peek(3);
          if ((s5 === "---" || s5 === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s5 === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n3 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n3;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n3 = yield* this.pushIndicators();
        switch (line[n3]) {
          case "#":
            yield* this.pushCount(line.length - n3);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n3 += yield* this.parseBlockScalarHeader();
            n3 += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n3);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n3 = 0;
        while (line[n3] === ",") {
          n3 += yield* this.pushCount(1);
          n3 += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n3 += yield* this.pushIndicators();
        switch (line[n3]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n3);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n3 = 0;
            while (this.buffer[end - 1 - n3] === "\\")
              n3 += 1;
            if (n3 % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i6 = this.pos;
        while (true) {
          const ch = this.buffer[++i6];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop:
          for (let i7 = this.pos; ch = this.buffer[i7]; ++i7) {
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case "\n":
                nl = i7;
                indent = 0;
                break;
              case "\r": {
                const next = this.buffer[i7 + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i6 = nl + 1;
        ch = this.buffer[i6];
        while (ch === " ")
          ch = this.buffer[++i6];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i6];
          nl = i6 - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i7 = nl - 1;
            let ch2 = this.buffer[i7];
            if (ch2 === "\r")
              ch2 = this.buffer[--i7];
            const lastChar = i7;
            while (ch2 === " ")
              ch2 = this.buffer[--i7];
            if (ch2 === "\n" && i7 >= this.pos && i7 + 1 + indent > lastChar)
              nl = i7;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i6 = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i6]) {
          if (ch === ":") {
            const next = this.buffer[i6 + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i6;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i6 + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i6 += 1;
                ch = "\n";
                next = this.buffer[i6 + 1];
              } else
                end = i6;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i6 + 1);
              if (cs === -1)
                break;
              i6 = Math.max(i6, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i6;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n3) {
        if (n3 > 0) {
          yield this.buffer.substr(this.pos, n3);
          this.pos += n3;
          return n3;
        }
        return 0;
      }
      *pushToIndex(i6, allowEmpty) {
        const s5 = this.buffer.slice(this.pos, i6);
        if (s5) {
          yield s5;
          this.pos += s5.length;
          return s5.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i6 = this.pos + 2;
          let ch = this.buffer[i6];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i6];
          return yield* this.pushToIndex(ch === ">" ? i6 + 1 : i6, false);
        } else {
          let i6 = this.pos + 1;
          let ch = this.buffer[i6];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i6];
            else if (ch === "%" && hexDigits.has(this.buffer[i6 + 1]) && hexDigits.has(this.buffer[i6 + 2])) {
              ch = this.buffer[i6 += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i6, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i6 = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i6];
        } while (ch === " " || allowTabs && ch === "	");
        const n3 = i6 - this.pos;
        if (n3 > 0) {
          yield this.buffer.substr(this.pos, n3);
          this.pos = i6;
        }
        return n3;
      }
      *pushUntil(test) {
        let i6 = this.pos;
        let ch = this.buffer[i6];
        while (!test(ch))
          ch = this.buffer[++i6];
        return yield* this.pushToIndex(i6, false);
      }
    };
    exports.Lexer = Lexer;
  }
});

// 
var require_line_counter = __commonJS({
  ""(exports) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports.LineCounter = LineCounter;
  }
});

// 
var require_parser = __commonJS({
  ""(exports) {
    "use strict";
    var node_process = __require("process");
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i6 = 0; i6 < list.length; ++i6)
        if (list[i6].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i6 = 0; i6 < list.length; ++i6) {
        switch (list[i6].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i6;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it2 = parent.items[parent.items.length - 1];
          return it2.sep ?? it2.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i6 = prev.length;
      loop:
        while (--i6 >= 0) {
          switch (prev[i6].type) {
            case "doc-start":
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
            case "newline":
              break loop;
          }
        }
      while (prev[++i6]?.type === "space") {
      }
      return prev.splice(i6, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it2 of fc.items) {
          if (it2.sep && !it2.value && !includesToken(it2.start, "explicit-key-ind") && !includesToken(it2.sep, "map-value-ind")) {
            if (it2.key)
              it2.value = it2.key;
            delete it2.key;
            if (isFlowToken(it2.value)) {
              if (it2.value.end)
                Array.prototype.push.apply(it2.value.end, it2.sep);
              else
                it2.value.end = it2.sep;
            } else
              Array.prototype.push.apply(it2.start, it2.sep);
            delete it2.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st2 = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st2;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n3) {
        return this.stack[this.stack.length - n3];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it2 = top.items[top.items.length - 1];
              if (it2.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it2.sep) {
                it2.value = token;
              } else {
                Object.assign(it2, { key: token, sep: [] });
                this.onKeyLine = !it2.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it2 = top.items[top.items.length - 1];
              if (it2.value)
                top.items.push({ start: [], value: token });
              else
                it2.value = token;
              break;
            }
            case "flow-collection": {
              const it2 = top.items[top.items.length - 1];
              if (!it2 || it2.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it2.sep)
                it2.value = token;
              else
                Object.assign(it2, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st2) => st2.type !== "comment" || st2.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep2;
          if (scalar.end) {
            sep2 = scalar.end;
            sep2.push(this.sourceToken);
            delete scalar.end;
          } else
            sep2 = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep2 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it2 = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it2.value) {
              const end = "end" in it2.value ? it2.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map.items.push({ start: [this.sourceToken] });
            } else if (it2.sep) {
              it2.sep.push(this.sourceToken);
            } else {
              it2.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it2.value) {
              map.items.push({ start: [this.sourceToken] });
            } else if (it2.sep) {
              it2.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it2.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it2.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it2.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map.indent;
          const atNextItem = atMapIndent && (it2.sep || it2.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it2.sep && !it2.value) {
            const nl = [];
            for (let i6 = 0; i6 < it2.sep.length; ++i6) {
              const st2 = it2.sep[i6];
              switch (st2.type) {
                case "newline":
                  nl.push(i6);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st2.indent > map.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it2.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it2.value) {
                start.push(this.sourceToken);
                map.items.push({ start });
                this.onKeyLine = true;
              } else if (it2.sep) {
                it2.sep.push(this.sourceToken);
              } else {
                it2.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it2.sep && !it2.explicitKey) {
                it2.start.push(this.sourceToken);
                it2.explicitKey = true;
              } else if (atNextItem || it2.value) {
                start.push(this.sourceToken);
                map.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it2.explicitKey) {
                if (!it2.sep) {
                  if (includesToken(it2.start, "newline")) {
                    Object.assign(it2, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it2.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it2.value) {
                  map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it2.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it2.key) && !includesToken(it2.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it2.start);
                  const key = it2.key;
                  const sep2 = it2.sep;
                  sep2.push(this.sourceToken);
                  delete it2.key;
                  delete it2.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep2 }]
                  });
                } else if (start.length > 0) {
                  it2.sep = it2.sep.concat(start, this.sourceToken);
                } else {
                  it2.sep.push(this.sourceToken);
                }
              } else {
                if (!it2.sep) {
                  Object.assign(it2, { key: null, sep: [this.sourceToken] });
                } else if (it2.value || atNextItem) {
                  map.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it2.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it2.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it2.value) {
                map.items.push({ start, key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it2.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it2, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (bv.type === "block-seq") {
                  if (!it2.explicitKey && it2.sep && !includesToken(it2.sep, "newline")) {
                    yield* this.pop({
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected block-seq-ind on same line with key",
                      source: this.source
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it2 = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it2.value) {
              const end = "end" in it2.value ? it2.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it2.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it2.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it2.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it2.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it2.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it2.value || this.indent <= seq.indent)
              break;
            it2.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it2.value || includesToken(it2.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it2.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it2 = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it2 || it2.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it2.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it2 || it2.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it2.sep)
                it2.sep.push(this.sourceToken);
              else
                Object.assign(it2, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it2 || it2.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it2.sep)
                it2.sep.push(this.sourceToken);
              else
                it2.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it2 || it2.value)
                fc.items.push({ start: [], key: fs, sep: [] });
              else if (it2.sep)
                this.stack.push(fs);
              else
                Object.assign(it2, { key: fs, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep2 = fc.end.splice(1, fc.end.length);
            sep2.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep2 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st2) => st2.type === "newline" || st2.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports.Parser = Parser;
  }
});

// 
var require_public_api = __commonJS({
  ""(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log = require_log();
    var identity = require_identity();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse2(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity.isDocument(value) && !_replacer)
        return value.toString(options);
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports.parse = parse2;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify;
  }
});

// 
var require_dist2 = __commonJS({
  ""(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports.Composer = composer.Composer;
    exports.Document = Document.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = identity.isAlias;
    exports.isCollection = identity.isCollection;
    exports.isDocument = identity.isDocument;
    exports.isMap = identity.isMap;
    exports.isNode = identity.isNode;
    exports.isPair = identity.isPair;
    exports.isScalar = identity.isScalar;
    exports.isSeq = identity.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit.visit;
    exports.visitAsync = visit.visitAsync;
  }
});

// .github/actions/deploy-docs-site/lib/main.mts
var import_core3 = __toESM(require_core(), 1);
var import_github3 = __toESM(require_github(), 1);

// .github/actions/deploy-docs-site/lib/deploy.mjs
import { cp, mkdtemp, readFile, rm, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { spawnSync } from "node:child_process";

// .github/actions/deploy-docs-site/lib/credential.mjs
var import_tmp = __toESM(require_tmp(), 1);
var import_core = __toESM(require_core(), 1);
import { writeSync } from "node:fs";
var credentialFilePath;
function getCredentialFilePath() {
  if (credentialFilePath === void 0) {
    const tmpFile = (0, import_tmp.fileSync)({ postfix: ".json" });
    writeSync(tmpFile.fd, (0, import_core.getInput)("serviceKey", { required: true }));
    (0, import_core.setSecret)(tmpFile.name);
    credentialFilePath = tmpFile.name;
  }
  return credentialFilePath;
}
var githubReleaseTrainReadToken = (0, import_core.getInput)("githubReleaseTrainReadToken", {
  required: true
});

// .github/actions/deploy-docs-site/lib/deploy.mjs
async function deployToFirebase(deployment, configPath, distDirPath) {
  if (deployment.destination == void 0) {
    console.log(`No deployment necessary for docs created from: ${deployment.branch}`);
    return;
  }
  console.log("Preparing for deployment to firebase...");
  const tmpDeployDir = await mkdtemp(join(tmpdir(), "deploy-directory"));
  const deployConfigPath = join(tmpDeployDir, "firebase.json");
  const config = JSON.parse(await readFile(configPath, { encoding: "utf-8" }));
  config["hosting"]["public"] = "./dist";
  await writeFile(deployConfigPath, JSON.stringify(config, null, 2));
  await cp(distDirPath, join(tmpDeployDir, "dist"), { recursive: true });
  spawnSync(`chmod 777 -R ${tmpDeployDir}`, { encoding: "utf-8", shell: true });
  firebase(`target:clear --config ${deployConfigPath} --project angular-dev-site hosting angular-docs`, tmpDeployDir);
  firebase(`target:apply --config ${deployConfigPath} --project angular-dev-site hosting angular-docs ${deployment.destination}`, tmpDeployDir);
  firebase(`deploy --config ${deployConfigPath} --project angular-dev-site --only hosting --non-interactive`, tmpDeployDir);
  firebase(`target:clear --config ${deployConfigPath} --project angular-dev-site hosting angular-docs`, tmpDeployDir);
  await rm(tmpDeployDir, { recursive: true });
}
async function setupRedirect(deployment) {
  if (deployment.redirect === void 0) {
    console.log(`No redirect necessary for docs created from: ${deployment.branch}`);
    return;
  }
  console.log("Preparing to set up redirect on firebase...");
  const redirectConfig = JSON.stringify({
    hosting: {
      target: "angular-docs",
      redirects: [
        {
          type: 302,
          regex: "^(.*)$",
          destination: `${deployment.redirect.to}:1`
        }
      ]
    }
  }, null, 2);
  const tmpRedirectDir = await mkdtemp(join(tmpdir(), "redirect-directory"));
  const redirectConfigPath = join(tmpRedirectDir, "firebase.json");
  await writeFile(redirectConfigPath, redirectConfig);
  spawnSync(`chmod 777 -R ${tmpRedirectDir}`, { encoding: "utf-8", shell: true });
  firebase(`target:clear --config ${redirectConfigPath} --project angular-dev-site hosting angular-docs`, tmpRedirectDir);
  firebase(`target:apply --config ${redirectConfigPath} --project angular-dev-site hosting angular-docs ${deployment.redirect.from}`, tmpRedirectDir);
  firebase(`deploy --config ${redirectConfigPath} --project angular-dev-site --only hosting --non-interactive`, tmpRedirectDir);
  firebase(`target:clear --config ${redirectConfigPath} --project angular-dev-site hosting angular-docs`, tmpRedirectDir);
  await rm(tmpRedirectDir, { recursive: true });
}
function firebase(cmd, cwd) {
  spawnSync("npx", `-y firebase-tools@13.15.1 ${cmd}`.split(" "), {
    cwd,
    encoding: "utf-8",
    shell: true,
    stdio: "inherit",
    env: {
      ...process.env,
      GOOGLE_APPLICATION_CREDENTIALS: getCredentialFilePath()
    }
  });
}

// 
var import_fast_glob = __toESM(require_out4());
import { join as join2 } from "path";

// 
import m5 from "node:module";
import { MessageChannel as u3 } from "node:worker_threads";

// 
import { createRequire as o2 } from "module";
import a from "node:path";

// 
import r from "node:path";
import o from "node:os";
var { geteuid: t } = process;
var s = t ? t() : o.userInfo().username;
var e = r.join(o.tmpdir(), `tsx-${s}`);

// 
var p = Object.defineProperty;
var e2 = (t3, r3) => p(t3, "name", { value: r3, configurable: true });
var m = o2(import.meta.url);
var i = process.platform === "win32";
var n = e2((t3) => {
  const r3 = a.join(e, `${t3}.pipe`);
  return i ? `\\\\?\\pipe\\${r3}` : r3;
}, "getPipePath");

// 
import d3 from "node:module";
import p4 from "node:path";
import { fileURLToPath as O4 } from "node:url";

// 
import m3 from "node:path";
import te from "node:fs";
import ve from "node:module";

// 
var A = (r3) => r3 !== null && typeof r3 == "object";
var a2 = (r3, t3) => Object.assign(new Error(`[${r3}]: ${t3}`), { code: r3 });
var _ = "ERR_INVALID_PACKAGE_CONFIG";
var E = "ERR_INVALID_PACKAGE_TARGET";
var I = "ERR_PACKAGE_PATH_NOT_EXPORTED";
var R = /^\d+$/;
var O = /^(\.{1,2}|node_modules)$/i;
var w = /\/|\\/;
var h = ((r3) => (r3.Export = "exports", r3.Import = "imports", r3))(h || {});
var f = (r3, t3, e5, o8, c3) => {
  if (t3 == null)
    return [];
  if (typeof t3 == "string") {
    const [n3, ...i6] = t3.split(w);
    if (n3 === ".." || i6.some((l3) => O.test(l3)))
      throw a2(E, `Invalid "${r3}" target "${t3}" defined in the package config`);
    return [c3 ? t3.replace(/\*/g, c3) : t3];
  }
  if (Array.isArray(t3))
    return t3.flatMap((n3) => f(r3, n3, e5, o8, c3));
  if (A(t3)) {
    for (const n3 of Object.keys(t3)) {
      if (R.test(n3))
        throw a2(_, "Cannot contain numeric property keys");
      if (n3 === "default" || o8.includes(n3))
        return f(r3, t3[n3], e5, o8, c3);
    }
    return [];
  }
  throw a2(E, `Invalid "${r3}" target "${t3}"`);
};
var s2 = "*";
var m2 = (r3, t3) => {
  const e5 = r3.indexOf(s2), o8 = t3.indexOf(s2);
  return e5 === o8 ? t3.length > r3.length : o8 > e5;
};
function d(r3, t3) {
  if (!t3.includes(s2) && r3.hasOwnProperty(t3))
    return [t3];
  let e5, o8;
  for (const c3 of Object.keys(r3))
    if (c3.includes(s2)) {
      const [n3, i6, l3] = c3.split(s2);
      if (l3 === void 0 && t3.startsWith(n3) && t3.endsWith(i6)) {
        const g2 = t3.slice(n3.length, -i6.length || void 0);
        g2 && (!e5 || m2(e5, c3)) && (e5 = c3, o8 = g2);
      }
    }
  return [e5, o8];
}
var p2 = (r3) => Object.keys(r3).reduce((t3, e5) => {
  const o8 = e5 === "" || e5[0] !== ".";
  if (t3 === void 0 || t3 === o8)
    return o8;
  throw a2(_, '"exports" cannot contain some keys starting with "." and some not');
}, void 0);
var u = /^\w+:/;
var v = (r3, t3, e5) => {
  if (!r3)
    throw new Error('"exports" is required');
  t3 = t3 === "" ? "." : `./${t3}`, (typeof r3 == "string" || Array.isArray(r3) || A(r3) && p2(r3)) && (r3 = { ".": r3 });
  const [o8, c3] = d(r3, t3), n3 = f(h.Export, r3[o8], t3, e5, c3);
  if (n3.length === 0)
    throw a2(I, t3 === "." ? 'No "exports" main defined' : `Package subpath '${t3}' is not defined by "exports"`);
  for (const i6 of n3)
    if (!i6.startsWith("./") && !u.test(i6))
      throw a2(E, `Invalid "exports" target "${i6}" defined in the package config`);
  return n3;
};

// 
import Ae from "fs";
var de = Object.defineProperty;
var o3 = (e5, t3) => de(e5, "name", { value: t3, configurable: true });
function E2(e5) {
  return e5.startsWith("\\\\?\\") ? e5 : e5.replace(/\\/g, "/");
}
o3(E2, "slash");
var O2 = o3((e5) => {
  const t3 = te[e5];
  return (s5, ...n3) => {
    const l3 = `${e5}:${n3.join(":")}`;
    let i6 = s5 == null ? void 0 : s5.get(l3);
    return i6 === void 0 && (i6 = Reflect.apply(t3, te, n3), s5 == null || s5.set(l3, i6)), i6;
  };
}, "cacheFs");
var B = O2("existsSync");
var _e = O2("readFileSync");
var P = O2("statSync");
var se = o3((e5, t3, s5) => {
  for (; ; ) {
    const n3 = m3.posix.join(e5, t3);
    if (B(s5, n3))
      return n3;
    const l3 = m3.dirname(e5);
    if (l3 === e5)
      return;
    e5 = l3;
  }
}, "findUp");
var z = /^\.{1,2}(\/.*)?$/;
var G = o3((e5) => {
  const t3 = E2(e5);
  return z.test(t3) ? t3 : `./${t3}`;
}, "normalizeRelativePath");
function je(e5, t3 = false) {
  const s5 = e5.length;
  let n3 = 0, l3 = "", i6 = 0, u5 = 16, f6 = 0, r3 = 0, g2 = 0, T3 = 0, b3 = 0;
  function _4(c3, k3) {
    let p5 = 0, F4 = 0;
    for (; p5 < c3; ) {
      let j2 = e5.charCodeAt(n3);
      if (j2 >= 48 && j2 <= 57)
        F4 = F4 * 16 + j2 - 48;
      else if (j2 >= 65 && j2 <= 70)
        F4 = F4 * 16 + j2 - 65 + 10;
      else if (j2 >= 97 && j2 <= 102)
        F4 = F4 * 16 + j2 - 97 + 10;
      else
        break;
      n3++, p5++;
    }
    return p5 < c3 && (F4 = -1), F4;
  }
  o3(_4, "scanHexDigits");
  function d5(c3) {
    n3 = c3, l3 = "", i6 = 0, u5 = 16, b3 = 0;
  }
  o3(d5, "setPosition");
  function A3() {
    let c3 = n3;
    if (e5.charCodeAt(n3) === 48)
      n3++;
    else
      for (n3++; n3 < e5.length && U(e5.charCodeAt(n3)); )
        n3++;
    if (n3 < e5.length && e5.charCodeAt(n3) === 46)
      if (n3++, n3 < e5.length && U(e5.charCodeAt(n3)))
        for (n3++; n3 < e5.length && U(e5.charCodeAt(n3)); )
          n3++;
      else
        return b3 = 3, e5.substring(c3, n3);
    let k3 = n3;
    if (n3 < e5.length && (e5.charCodeAt(n3) === 69 || e5.charCodeAt(n3) === 101))
      if (n3++, (n3 < e5.length && e5.charCodeAt(n3) === 43 || e5.charCodeAt(n3) === 45) && n3++, n3 < e5.length && U(e5.charCodeAt(n3))) {
        for (n3++; n3 < e5.length && U(e5.charCodeAt(n3)); )
          n3++;
        k3 = n3;
      } else
        b3 = 3;
    return e5.substring(c3, k3);
  }
  o3(A3, "scanNumber");
  function w4() {
    let c3 = "", k3 = n3;
    for (; ; ) {
      if (n3 >= s5) {
        c3 += e5.substring(k3, n3), b3 = 2;
        break;
      }
      const p5 = e5.charCodeAt(n3);
      if (p5 === 34) {
        c3 += e5.substring(k3, n3), n3++;
        break;
      }
      if (p5 === 92) {
        if (c3 += e5.substring(k3, n3), n3++, n3 >= s5) {
          b3 = 2;
          break;
        }
        switch (e5.charCodeAt(n3++)) {
          case 34:
            c3 += '"';
            break;
          case 92:
            c3 += "\\";
            break;
          case 47:
            c3 += "/";
            break;
          case 98:
            c3 += "\b";
            break;
          case 102:
            c3 += "\f";
            break;
          case 110:
            c3 += `
`;
            break;
          case 114:
            c3 += "\r";
            break;
          case 116:
            c3 += "	";
            break;
          case 117:
            const j2 = _4(4);
            j2 >= 0 ? c3 += String.fromCharCode(j2) : b3 = 4;
            break;
          default:
            b3 = 5;
        }
        k3 = n3;
        continue;
      }
      if (p5 >= 0 && p5 <= 31)
        if (x(p5)) {
          c3 += e5.substring(k3, n3), b3 = 2;
          break;
        } else
          b3 = 6;
      n3++;
    }
    return c3;
  }
  o3(w4, "scanString");
  function y3() {
    if (l3 = "", b3 = 0, i6 = n3, r3 = f6, T3 = g2, n3 >= s5)
      return i6 = s5, u5 = 17;
    let c3 = e5.charCodeAt(n3);
    if (Q(c3)) {
      do
        n3++, l3 += String.fromCharCode(c3), c3 = e5.charCodeAt(n3);
      while (Q(c3));
      return u5 = 15;
    }
    if (x(c3))
      return n3++, l3 += String.fromCharCode(c3), c3 === 13 && e5.charCodeAt(n3) === 10 && (n3++, l3 += `
`), f6++, g2 = n3, u5 = 14;
    switch (c3) {
      case 123:
        return n3++, u5 = 1;
      case 125:
        return n3++, u5 = 2;
      case 91:
        return n3++, u5 = 3;
      case 93:
        return n3++, u5 = 4;
      case 58:
        return n3++, u5 = 6;
      case 44:
        return n3++, u5 = 5;
      case 34:
        return n3++, l3 = w4(), u5 = 10;
      case 47:
        const k3 = n3 - 1;
        if (e5.charCodeAt(n3 + 1) === 47) {
          for (n3 += 2; n3 < s5 && !x(e5.charCodeAt(n3)); )
            n3++;
          return l3 = e5.substring(k3, n3), u5 = 12;
        }
        if (e5.charCodeAt(n3 + 1) === 42) {
          n3 += 2;
          const p5 = s5 - 1;
          let F4 = false;
          for (; n3 < p5; ) {
            const j2 = e5.charCodeAt(n3);
            if (j2 === 42 && e5.charCodeAt(n3 + 1) === 47) {
              n3 += 2, F4 = true;
              break;
            }
            n3++, x(j2) && (j2 === 13 && e5.charCodeAt(n3) === 10 && n3++, f6++, g2 = n3);
          }
          return F4 || (n3++, b3 = 1), l3 = e5.substring(k3, n3), u5 = 13;
        }
        return l3 += String.fromCharCode(c3), n3++, u5 = 16;
      case 45:
        if (l3 += String.fromCharCode(c3), n3++, n3 === s5 || !U(e5.charCodeAt(n3)))
          return u5 = 16;
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return l3 += A3(), u5 = 11;
      default:
        for (; n3 < s5 && I4(c3); )
          n3++, c3 = e5.charCodeAt(n3);
        if (i6 !== n3) {
          switch (l3 = e5.substring(i6, n3), l3) {
            case "true":
              return u5 = 8;
            case "false":
              return u5 = 9;
            case "null":
              return u5 = 7;
          }
          return u5 = 16;
        }
        return l3 += String.fromCharCode(c3), n3++, u5 = 16;
    }
  }
  o3(y3, "scanNext");
  function I4(c3) {
    if (Q(c3) || x(c3))
      return false;
    switch (c3) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  o3(I4, "isUnknownContentCharacter");
  function L3() {
    let c3;
    do
      c3 = y3();
    while (c3 >= 12 && c3 <= 15);
    return c3;
  }
  return o3(L3, "scanNextNonTrivia"), { setPosition: d5, getPosition: o3(() => n3, "getPosition"), scan: t3 ? L3 : y3, getToken: o3(() => u5, "getToken"), getTokenValue: o3(() => l3, "getTokenValue"), getTokenOffset: o3(() => i6, "getTokenOffset"), getTokenLength: o3(() => n3 - i6, "getTokenLength"), getTokenStartLine: o3(() => r3, "getTokenStartLine"), getTokenStartCharacter: o3(() => i6 - T3, "getTokenStartCharacter"), getTokenError: o3(() => b3, "getTokenError") };
}
o3(je, "createScanner");
function Q(e5) {
  return e5 === 32 || e5 === 9;
}
o3(Q, "isWhiteSpace");
function x(e5) {
  return e5 === 10 || e5 === 13;
}
o3(x, "isLineBreak");
function U(e5) {
  return e5 >= 48 && e5 <= 57;
}
o3(U, "isDigit");
var le;
(function(e5) {
  e5[e5.lineFeed = 10] = "lineFeed", e5[e5.carriageReturn = 13] = "carriageReturn", e5[e5.space = 32] = "space", e5[e5._0 = 48] = "_0", e5[e5._1 = 49] = "_1", e5[e5._2 = 50] = "_2", e5[e5._3 = 51] = "_3", e5[e5._4 = 52] = "_4", e5[e5._5 = 53] = "_5", e5[e5._6 = 54] = "_6", e5[e5._7 = 55] = "_7", e5[e5._8 = 56] = "_8", e5[e5._9 = 57] = "_9", e5[e5.a = 97] = "a", e5[e5.b = 98] = "b", e5[e5.c = 99] = "c", e5[e5.d = 100] = "d", e5[e5.e = 101] = "e", e5[e5.f = 102] = "f", e5[e5.g = 103] = "g", e5[e5.h = 104] = "h", e5[e5.i = 105] = "i", e5[e5.j = 106] = "j", e5[e5.k = 107] = "k", e5[e5.l = 108] = "l", e5[e5.m = 109] = "m", e5[e5.n = 110] = "n", e5[e5.o = 111] = "o", e5[e5.p = 112] = "p", e5[e5.q = 113] = "q", e5[e5.r = 114] = "r", e5[e5.s = 115] = "s", e5[e5.t = 116] = "t", e5[e5.u = 117] = "u", e5[e5.v = 118] = "v", e5[e5.w = 119] = "w", e5[e5.x = 120] = "x", e5[e5.y = 121] = "y", e5[e5.z = 122] = "z", e5[e5.A = 65] = "A", e5[e5.B = 66] = "B", e5[e5.C = 67] = "C", e5[e5.D = 68] = "D", e5[e5.E = 69] = "E", e5[e5.F = 70] = "F", e5[e5.G = 71] = "G", e5[e5.H = 72] = "H", e5[e5.I = 73] = "I", e5[e5.J = 74] = "J", e5[e5.K = 75] = "K", e5[e5.L = 76] = "L", e5[e5.M = 77] = "M", e5[e5.N = 78] = "N", e5[e5.O = 79] = "O", e5[e5.P = 80] = "P", e5[e5.Q = 81] = "Q", e5[e5.R = 82] = "R", e5[e5.S = 83] = "S", e5[e5.T = 84] = "T", e5[e5.U = 85] = "U", e5[e5.V = 86] = "V", e5[e5.W = 87] = "W", e5[e5.X = 88] = "X", e5[e5.Y = 89] = "Y", e5[e5.Z = 90] = "Z", e5[e5.asterisk = 42] = "asterisk", e5[e5.backslash = 92] = "backslash", e5[e5.closeBrace = 125] = "closeBrace", e5[e5.closeBracket = 93] = "closeBracket", e5[e5.colon = 58] = "colon", e5[e5.comma = 44] = "comma", e5[e5.dot = 46] = "dot", e5[e5.doubleQuote = 34] = "doubleQuote", e5[e5.minus = 45] = "minus", e5[e5.openBrace = 123] = "openBrace", e5[e5.openBracket = 91] = "openBracket", e5[e5.plus = 43] = "plus", e5[e5.slash = 47] = "slash", e5[e5.formFeed = 12] = "formFeed", e5[e5.tab = 9] = "tab";
})(le || (le = {})), new Array(20).fill(0).map((e5, t3) => " ".repeat(t3));
var h2 = 200;
new Array(h2).fill(0).map((e5, t3) => `
` + " ".repeat(t3)), new Array(h2).fill(0).map((e5, t3) => "\r" + " ".repeat(t3)), new Array(h2).fill(0).map((e5, t3) => `\r
` + " ".repeat(t3)), new Array(h2).fill(0).map((e5, t3) => `
` + "	".repeat(t3)), new Array(h2).fill(0).map((e5, t3) => "\r" + "	".repeat(t3)), new Array(h2).fill(0).map((e5, t3) => `\r
` + "	".repeat(t3));
var R2;
(function(e5) {
  e5.DEFAULT = { allowTrailingComma: false };
})(R2 || (R2 = {}));
function ye(e5, t3 = [], s5 = R2.DEFAULT) {
  let n3 = null, l3 = [];
  const i6 = [];
  function u5(r3) {
    Array.isArray(l3) ? l3.push(r3) : n3 !== null && (l3[n3] = r3);
  }
  return o3(u5, "onValue"), Fe(e5, { onObjectBegin: o3(() => {
    const r3 = {};
    u5(r3), i6.push(l3), l3 = r3, n3 = null;
  }, "onObjectBegin"), onObjectProperty: o3((r3) => {
    n3 = r3;
  }, "onObjectProperty"), onObjectEnd: o3(() => {
    l3 = i6.pop();
  }, "onObjectEnd"), onArrayBegin: o3(() => {
    const r3 = [];
    u5(r3), i6.push(l3), l3 = r3, n3 = null;
  }, "onArrayBegin"), onArrayEnd: o3(() => {
    l3 = i6.pop();
  }, "onArrayEnd"), onLiteralValue: u5, onError: o3((r3, g2, T3) => {
    t3.push({ error: r3, offset: g2, length: T3 });
  }, "onError") }, s5), l3[0];
}
o3(ye, "parse$1");
function Fe(e5, t3, s5 = R2.DEFAULT) {
  const n3 = je(e5, false), l3 = [];
  function i6(v4) {
    return v4 ? () => v4(n3.getTokenOffset(), n3.getTokenLength(), n3.getTokenStartLine(), n3.getTokenStartCharacter()) : () => true;
  }
  o3(i6, "toNoArgVisit");
  function u5(v4) {
    return v4 ? () => v4(n3.getTokenOffset(), n3.getTokenLength(), n3.getTokenStartLine(), n3.getTokenStartCharacter(), () => l3.slice()) : () => true;
  }
  o3(u5, "toNoArgVisitWithPath");
  function f6(v4) {
    return v4 ? (D3) => v4(D3, n3.getTokenOffset(), n3.getTokenLength(), n3.getTokenStartLine(), n3.getTokenStartCharacter()) : () => true;
  }
  o3(f6, "toOneArgVisit");
  function r3(v4) {
    return v4 ? (D3) => v4(D3, n3.getTokenOffset(), n3.getTokenLength(), n3.getTokenStartLine(), n3.getTokenStartCharacter(), () => l3.slice()) : () => true;
  }
  o3(r3, "toOneArgVisitWithPath");
  const g2 = u5(t3.onObjectBegin), T3 = r3(t3.onObjectProperty), b3 = i6(t3.onObjectEnd), _4 = u5(t3.onArrayBegin), d5 = i6(t3.onArrayEnd), A3 = r3(t3.onLiteralValue), w4 = f6(t3.onSeparator), y3 = i6(t3.onComment), I4 = f6(t3.onError), L3 = s5 && s5.disallowComments, c3 = s5 && s5.allowTrailingComma;
  function k3() {
    for (; ; ) {
      const v4 = n3.scan();
      switch (n3.getTokenError()) {
        case 4:
          p5(14);
          break;
        case 5:
          p5(15);
          break;
        case 3:
          p5(13);
          break;
        case 1:
          L3 || p5(11);
          break;
        case 2:
          p5(12);
          break;
        case 6:
          p5(16);
          break;
      }
      switch (v4) {
        case 12:
        case 13:
          L3 ? p5(10) : y3();
          break;
        case 16:
          p5(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return v4;
      }
    }
  }
  o3(k3, "scanNext");
  function p5(v4, D3 = [], ne = []) {
    if (I4(v4), D3.length + ne.length > 0) {
      let S2 = n3.getToken();
      for (; S2 !== 17; ) {
        if (D3.indexOf(S2) !== -1) {
          k3();
          break;
        } else if (ne.indexOf(S2) !== -1)
          break;
        S2 = k3();
      }
    }
  }
  o3(p5, "handleError");
  function F4(v4) {
    const D3 = n3.getTokenValue();
    return v4 ? A3(D3) : (T3(D3), l3.push(D3)), k3(), true;
  }
  o3(F4, "parseString");
  function j2() {
    switch (n3.getToken()) {
      case 11:
        const v4 = n3.getTokenValue();
        let D3 = Number(v4);
        isNaN(D3) && (p5(2), D3 = 0), A3(D3);
        break;
      case 7:
        A3(null);
        break;
      case 8:
        A3(true);
        break;
      case 9:
        A3(false);
        break;
      default:
        return false;
    }
    return k3(), true;
  }
  o3(j2, "parseLiteral");
  function a7() {
    return n3.getToken() !== 10 ? (p5(3, [], [2, 5]), false) : (F4(false), n3.getToken() === 6 ? (w4(":"), k3(), J3() || p5(4, [], [2, 5])) : p5(5, [], [2, 5]), l3.pop(), true);
  }
  o3(a7, "parseProperty");
  function N2() {
    g2(), k3();
    let v4 = false;
    for (; n3.getToken() !== 2 && n3.getToken() !== 17; ) {
      if (n3.getToken() === 5) {
        if (v4 || p5(4, [], []), w4(","), k3(), n3.getToken() === 2 && c3)
          break;
      } else
        v4 && p5(6, [], []);
      a7() || p5(4, [], [2, 5]), v4 = true;
    }
    return b3(), n3.getToken() !== 2 ? p5(7, [2], []) : k3(), true;
  }
  o3(N2, "parseObject");
  function be2() {
    _4(), k3();
    let v4 = true, D3 = false;
    for (; n3.getToken() !== 4 && n3.getToken() !== 17; ) {
      if (n3.getToken() === 5) {
        if (D3 || p5(4, [], []), w4(","), k3(), n3.getToken() === 4 && c3)
          break;
      } else
        D3 && p5(6, [], []);
      v4 ? (l3.push(0), v4 = false) : l3[l3.length - 1]++, J3() || p5(4, [], [4, 5]), D3 = true;
    }
    return d5(), v4 || l3.pop(), n3.getToken() !== 4 ? p5(8, [4], []) : k3(), true;
  }
  o3(be2, "parseArray");
  function J3() {
    switch (n3.getToken()) {
      case 3:
        return be2();
      case 1:
        return N2();
      case 10:
        return F4(true);
      default:
        return j2();
    }
  }
  return o3(J3, "parseValue"), k3(), n3.getToken() === 17 ? s5.allowEmptyContent ? true : (p5(4, [], []), false) : J3() ? (n3.getToken() !== 17 && p5(9, [], []), true) : (p5(4, [], []), false);
}
o3(Fe, "visit");
var ie;
(function(e5) {
  e5[e5.None = 0] = "None", e5[e5.UnexpectedEndOfComment = 1] = "UnexpectedEndOfComment", e5[e5.UnexpectedEndOfString = 2] = "UnexpectedEndOfString", e5[e5.UnexpectedEndOfNumber = 3] = "UnexpectedEndOfNumber", e5[e5.InvalidUnicode = 4] = "InvalidUnicode", e5[e5.InvalidEscapeCharacter = 5] = "InvalidEscapeCharacter", e5[e5.InvalidCharacter = 6] = "InvalidCharacter";
})(ie || (ie = {}));
var oe;
(function(e5) {
  e5[e5.OpenBraceToken = 1] = "OpenBraceToken", e5[e5.CloseBraceToken = 2] = "CloseBraceToken", e5[e5.OpenBracketToken = 3] = "OpenBracketToken", e5[e5.CloseBracketToken = 4] = "CloseBracketToken", e5[e5.CommaToken = 5] = "CommaToken", e5[e5.ColonToken = 6] = "ColonToken", e5[e5.NullKeyword = 7] = "NullKeyword", e5[e5.TrueKeyword = 8] = "TrueKeyword", e5[e5.FalseKeyword = 9] = "FalseKeyword", e5[e5.StringLiteral = 10] = "StringLiteral", e5[e5.NumericLiteral = 11] = "NumericLiteral", e5[e5.LineCommentTrivia = 12] = "LineCommentTrivia", e5[e5.BlockCommentTrivia = 13] = "BlockCommentTrivia", e5[e5.LineBreakTrivia = 14] = "LineBreakTrivia", e5[e5.Trivia = 15] = "Trivia", e5[e5.Unknown = 16] = "Unknown", e5[e5.EOF = 17] = "EOF";
})(oe || (oe = {}));
var De = ye;
var ue;
(function(e5) {
  e5[e5.InvalidSymbol = 1] = "InvalidSymbol", e5[e5.InvalidNumberFormat = 2] = "InvalidNumberFormat", e5[e5.PropertyNameExpected = 3] = "PropertyNameExpected", e5[e5.ValueExpected = 4] = "ValueExpected", e5[e5.ColonExpected = 5] = "ColonExpected", e5[e5.CommaExpected = 6] = "CommaExpected", e5[e5.CloseBraceExpected = 7] = "CloseBraceExpected", e5[e5.CloseBracketExpected = 8] = "CloseBracketExpected", e5[e5.EndOfFileExpected = 9] = "EndOfFileExpected", e5[e5.InvalidCommentToken = 10] = "InvalidCommentToken", e5[e5.UnexpectedEndOfComment = 11] = "UnexpectedEndOfComment", e5[e5.UnexpectedEndOfString = 12] = "UnexpectedEndOfString", e5[e5.UnexpectedEndOfNumber = 13] = "UnexpectedEndOfNumber", e5[e5.InvalidUnicode = 14] = "InvalidUnicode", e5[e5.InvalidEscapeCharacter = 15] = "InvalidEscapeCharacter", e5[e5.InvalidCharacter = 16] = "InvalidCharacter";
})(ue || (ue = {}));
var re = o3((e5, t3) => De(_e(t3, e5, "utf8")), "readJsonc");
var H = Symbol("implicitBaseUrl");
var $ = "${configDir}";
var Ee = o3(() => {
  const { findPnpApi: e5 } = ve;
  return e5 && e5(process.cwd());
}, "getPnpApi");
var X = o3((e5, t3, s5, n3) => {
  const l3 = `resolveFromPackageJsonPath:${e5}:${t3}:${s5}`;
  if (n3 != null && n3.has(l3))
    return n3.get(l3);
  const i6 = re(e5, n3);
  if (!i6)
    return;
  let u5 = t3 || "tsconfig.json";
  if (!s5 && i6.exports)
    try {
      const [f6] = v(i6.exports, t3, ["require", "types"]);
      u5 = f6;
    } catch {
      return false;
    }
  else
    !t3 && i6.tsconfig && (u5 = i6.tsconfig);
  return u5 = m3.join(e5, "..", u5), n3 == null || n3.set(l3, u5), u5;
}, "resolveFromPackageJsonPath");
var Y = "package.json";
var Z = "tsconfig.json";
var Be = o3((e5, t3, s5) => {
  let n3 = e5;
  if (e5 === ".." && (n3 = m3.join(n3, Z)), e5[0] === "." && (n3 = m3.resolve(t3, n3)), m3.isAbsolute(n3)) {
    if (B(s5, n3)) {
      if (P(s5, n3).isFile())
        return n3;
    } else if (!n3.endsWith(".json")) {
      const d5 = `${n3}.json`;
      if (B(s5, d5))
        return d5;
    }
    return;
  }
  const [l3, ...i6] = e5.split("/"), u5 = l3[0] === "@" ? `${l3}/${i6.shift()}` : l3, f6 = i6.join("/"), r3 = Ee();
  if (r3) {
    const { resolveRequest: d5 } = r3;
    try {
      if (u5 === e5) {
        const A3 = d5(m3.join(u5, Y), t3);
        if (A3) {
          const w4 = X(A3, f6, false, s5);
          if (w4 && B(s5, w4))
            return w4;
        }
      } else {
        let A3;
        try {
          A3 = d5(e5, t3, { extensions: [".json"] });
        } catch {
          A3 = d5(m3.join(e5, Z), t3);
        }
        if (A3)
          return A3;
      }
    } catch {
    }
  }
  const g2 = se(m3.resolve(t3), m3.join("node_modules", u5), s5);
  if (!g2 || !P(s5, g2).isDirectory())
    return;
  const T3 = m3.join(g2, Y);
  if (B(s5, T3)) {
    const d5 = X(T3, f6, false, s5);
    if (d5 === false)
      return;
    if (d5 && B(s5, d5) && P(s5, d5).isFile())
      return d5;
  }
  const b3 = m3.join(g2, f6), _4 = b3.endsWith(".json");
  if (!_4) {
    const d5 = `${b3}.json`;
    if (B(s5, d5))
      return d5;
  }
  if (B(s5, b3)) {
    if (P(s5, b3).isDirectory()) {
      const d5 = m3.join(b3, Y);
      if (B(s5, d5)) {
        const w4 = X(d5, "", true, s5);
        if (w4 && B(s5, w4))
          return w4;
      }
      const A3 = m3.join(b3, Z);
      if (B(s5, A3))
        return A3;
    } else if (_4)
      return b3;
  }
}, "resolveExtendsPath");
var q = o3((e5, t3) => G(m3.relative(e5, t3)), "pathRelative");
var fe = ["files", "include", "exclude"];
var Ie = o3((e5, t3, s5, n3) => {
  const l3 = Be(e5, t3, n3);
  if (!l3)
    throw new Error(`File '${e5}' not found.`);
  if (s5.has(l3))
    throw new Error(`Circularity detected while resolving configuration: ${l3}`);
  s5.add(l3);
  const i6 = m3.dirname(l3), u5 = ce(l3, n3, s5);
  delete u5.references;
  const { compilerOptions: f6 } = u5;
  if (f6) {
    const { baseUrl: r3 } = f6;
    r3 && !r3.startsWith($) && (f6.baseUrl = E2(m3.relative(t3, m3.join(i6, r3))) || "./");
    let { outDir: g2 } = f6;
    g2 && (g2.startsWith($) || (g2 = m3.relative(t3, m3.join(i6, g2))), f6.outDir = E2(g2) || "./");
  }
  for (const r3 of fe) {
    const g2 = u5[r3];
    g2 && (u5[r3] = g2.map((T3) => T3.startsWith($) ? T3 : E2(m3.relative(t3, m3.join(i6, T3)))));
  }
  return u5;
}, "resolveExtends");
var Le = ["outDir", "declarationDir"];
var ce = o3((e5, t3, s5 = /* @__PURE__ */ new Set()) => {
  let n3;
  try {
    n3 = re(e5, t3) || {};
  } catch {
    throw new Error(`Cannot resolve tsconfig at path: ${e5}`);
  }
  if (typeof n3 != "object")
    throw new SyntaxError(`Failed to parse tsconfig at: ${e5}`);
  const l3 = m3.dirname(e5);
  if (n3.compilerOptions) {
    const { compilerOptions: i6 } = n3;
    i6.paths && !i6.baseUrl && (i6[H] = l3);
  }
  if (n3.extends) {
    const i6 = Array.isArray(n3.extends) ? n3.extends : [n3.extends];
    delete n3.extends;
    for (const u5 of i6.reverse()) {
      const f6 = Ie(u5, l3, new Set(s5), t3), r3 = { ...f6, ...n3, compilerOptions: { ...f6.compilerOptions, ...n3.compilerOptions } };
      f6.watchOptions && (r3.watchOptions = { ...f6.watchOptions, ...n3.watchOptions }), n3 = r3;
    }
  }
  if (n3.compilerOptions) {
    const { compilerOptions: i6 } = n3, u5 = ["baseUrl", "rootDir"];
    for (const f6 of u5) {
      const r3 = i6[f6];
      if (r3 && !r3.startsWith($)) {
        const g2 = m3.resolve(l3, r3), T3 = q(l3, g2);
        i6[f6] = T3;
      }
    }
    for (const f6 of Le) {
      let r3 = i6[f6];
      r3 && (Array.isArray(n3.exclude) || (n3.exclude = []), n3.exclude.includes(r3) || n3.exclude.push(r3), r3.startsWith($) || (r3 = G(r3)), i6[f6] = r3);
    }
  } else
    n3.compilerOptions = {};
  if (n3.include ? (n3.include = n3.include.map(E2), n3.files && delete n3.files) : n3.files && (n3.files = n3.files.map((i6) => i6.startsWith($) ? i6 : G(i6))), n3.watchOptions) {
    const { watchOptions: i6 } = n3;
    i6.excludeDirectories && (i6.excludeDirectories = i6.excludeDirectories.map((u5) => E2(m3.resolve(l3, u5))));
  }
  return n3;
}, "_parseTsconfig");
var W = o3((e5, t3) => {
  if (e5.startsWith($))
    return E2(m3.join(t3, e5.slice($.length)));
}, "interpolateConfigDir");
var $e = ["outDir", "declarationDir", "outFile", "rootDir", "baseUrl", "tsBuildInfoFile"];
var Ue = o3((e5) => {
  var t3, s5, n3, l3, i6, u5, f6, r3, g2, T3, b3, _4, d5, A3, w4, y3, I4, L3, c3, k3, p5, F4, j2;
  if (e5.strict) {
    const a7 = ["noImplicitAny", "noImplicitThis", "strictNullChecks", "strictFunctionTypes", "strictBindCallApply", "strictPropertyInitialization", "strictBuiltinIteratorReturn", "alwaysStrict", "useUnknownInCatchVariables"];
    for (const N2 of a7)
      e5[N2] === void 0 && (e5[N2] = true);
  }
  if (e5.target) {
    let a7 = e5.target.toLowerCase();
    a7 === "es2015" && (a7 = "es6"), e5.target = a7, a7 === "esnext" && ((t3 = e5.module) != null || (e5.module = "es6"), (s5 = e5.useDefineForClassFields) != null || (e5.useDefineForClassFields = true)), (a7 === "es6" || a7 === "es2016" || a7 === "es2017" || a7 === "es2018" || a7 === "es2019" || a7 === "es2020" || a7 === "es2021" || a7 === "es2022" || a7 === "es2023" || a7 === "es2024") && ((n3 = e5.module) != null || (e5.module = "es6")), (a7 === "es2022" || a7 === "es2023" || a7 === "es2024") && ((l3 = e5.useDefineForClassFields) != null || (e5.useDefineForClassFields = true));
  }
  if (e5.module) {
    let a7 = e5.module.toLowerCase();
    a7 === "es2015" && (a7 = "es6"), e5.module = a7, (a7 === "es6" || a7 === "es2020" || a7 === "es2022" || a7 === "esnext" || a7 === "none" || a7 === "system" || a7 === "umd" || a7 === "amd") && ((i6 = e5.moduleResolution) != null || (e5.moduleResolution = "classic")), a7 === "system" && ((u5 = e5.allowSyntheticDefaultImports) != null || (e5.allowSyntheticDefaultImports = true)), (a7 === "node16" || a7 === "nodenext" || a7 === "preserve") && ((f6 = e5.esModuleInterop) != null || (e5.esModuleInterop = true), (r3 = e5.allowSyntheticDefaultImports) != null || (e5.allowSyntheticDefaultImports = true)), (a7 === "node16" || a7 === "nodenext") && ((g2 = e5.moduleDetection) != null || (e5.moduleDetection = "force"), (T3 = e5.useDefineForClassFields) != null || (e5.useDefineForClassFields = true)), a7 === "node16" && ((b3 = e5.target) != null || (e5.target = "es2022"), (_4 = e5.moduleResolution) != null || (e5.moduleResolution = "node16")), a7 === "nodenext" && ((d5 = e5.target) != null || (e5.target = "esnext"), (A3 = e5.moduleResolution) != null || (e5.moduleResolution = "nodenext")), a7 === "preserve" && ((w4 = e5.moduleResolution) != null || (e5.moduleResolution = "bundler"));
  }
  if (e5.moduleResolution) {
    let a7 = e5.moduleResolution.toLowerCase();
    a7 === "node" && (a7 = "node10"), e5.moduleResolution = a7, (a7 === "node16" || a7 === "nodenext" || a7 === "bundler") && ((y3 = e5.resolvePackageJsonExports) != null || (e5.resolvePackageJsonExports = true), (I4 = e5.resolvePackageJsonImports) != null || (e5.resolvePackageJsonImports = true)), a7 === "bundler" && ((L3 = e5.allowSyntheticDefaultImports) != null || (e5.allowSyntheticDefaultImports = true), (c3 = e5.resolveJsonModule) != null || (e5.resolveJsonModule = true));
  }
  e5.esModuleInterop && ((k3 = e5.allowSyntheticDefaultImports) != null || (e5.allowSyntheticDefaultImports = true)), e5.verbatimModuleSyntax && ((p5 = e5.isolatedModules) != null || (e5.isolatedModules = true), (F4 = e5.preserveConstEnums) != null || (e5.preserveConstEnums = true)), e5.isolatedModules && ((j2 = e5.preserveConstEnums) != null || (e5.preserveConstEnums = true));
}, "normalizeCompilerOptions");
var ae = o3((e5, t3 = /* @__PURE__ */ new Map()) => {
  const s5 = m3.resolve(e5), n3 = ce(s5, t3), l3 = m3.dirname(s5), { compilerOptions: i6 } = n3;
  if (i6) {
    for (const f6 of $e) {
      const r3 = i6[f6];
      if (r3) {
        const g2 = W(r3, l3);
        i6[f6] = g2 ? q(l3, g2) : r3;
      }
    }
    for (const f6 of ["rootDirs", "typeRoots"]) {
      const r3 = i6[f6];
      r3 && (i6[f6] = r3.map((g2) => {
        const T3 = W(g2, l3);
        return T3 ? q(l3, T3) : g2;
      }));
    }
    const { paths: u5 } = i6;
    if (u5)
      for (const f6 of Object.keys(u5))
        u5[f6] = u5[f6].map((r3) => {
          var g2;
          return (g2 = W(r3, l3)) != null ? g2 : r3;
        });
    Ue(i6);
  }
  for (const u5 of fe) {
    const f6 = n3[u5];
    f6 && (n3[u5] = f6.map((r3) => {
      var g2;
      return (g2 = W(r3, l3)) != null ? g2 : r3;
    }));
  }
  return n3;
}, "parseTsconfig");
var he = o3((e5 = process.cwd(), t3 = "tsconfig.json", s5 = /* @__PURE__ */ new Map()) => {
  const n3 = se(E2(e5), t3, s5);
  if (!n3)
    return null;
  const l3 = ae(n3, s5);
  return { path: n3, config: l3 };
}, "getTsconfig");
var xe = /\*/g;
var ge = o3((e5, t3) => {
  const s5 = e5.match(xe);
  if (s5 && s5.length > 1)
    throw new Error(t3);
}, "assertStarCount");
var Ne = o3((e5) => {
  if (e5.includes("*")) {
    const [t3, s5] = e5.split("*");
    return { prefix: t3, suffix: s5 };
  }
  return e5;
}, "parsePattern");
var Se = o3(({ prefix: e5, suffix: t3 }, s5) => s5.startsWith(e5) && s5.endsWith(t3), "isPatternMatch");
var Pe = o3((e5, t3, s5) => Object.entries(e5).map(([n3, l3]) => (ge(n3, `Pattern '${n3}' can have at most one '*' character.`), { pattern: Ne(n3), substitutions: l3.map((i6) => {
  if (ge(i6, `Substitution '${i6}' in pattern '${n3}' can have at most one '*' character.`), !t3 && !z.test(i6))
    throw new Error("Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?");
  return m3.resolve(s5, i6);
}) })), "parsePaths");
var Re = o3((e5) => {
  const { compilerOptions: t3 } = e5.config;
  if (!t3)
    return null;
  const { baseUrl: s5, paths: n3 } = t3;
  if (!s5 && !n3)
    return null;
  const l3 = H in t3 && t3[H], i6 = m3.resolve(m3.dirname(e5.path), s5 || l3 || "."), u5 = n3 ? Pe(n3, s5, i6) : [];
  return (f6) => {
    if (z.test(f6))
      return [];
    const r3 = [];
    for (const _4 of u5) {
      if (_4.pattern === f6)
        return _4.substitutions.map(E2);
      typeof _4.pattern != "string" && r3.push(_4);
    }
    let g2, T3 = -1;
    for (const _4 of r3)
      Se(_4.pattern, f6) && _4.pattern.prefix.length > T3 && (T3 = _4.pattern.prefix.length, g2 = _4);
    if (!g2)
      return s5 ? [E2(m3.join(i6, f6))] : [];
    const b3 = f6.slice(g2.pattern.prefix.length, f6.length - g2.pattern.suffix.length);
    return g2.substitutions.map((_4) => E2(_4.replace("*", b3)));
  };
}, "createPathsMatcher");
var pe = o3((e5) => {
  let t3 = "";
  for (let s5 = 0; s5 < e5.length; s5 += 1) {
    const n3 = e5[s5], l3 = n3.toUpperCase();
    t3 += n3 === l3 ? n3.toLowerCase() : l3;
  }
  return t3;
}, "s");
var We = 65;
var Me = 97;
var Ve = o3(() => Math.floor(Math.random() * 26), "m");
var Je = o3((e5) => Array.from({ length: e5 }, () => String.fromCodePoint(Ve() + (Math.random() > 0.5 ? We : Me))).join(""), "S");
var Oe = o3((e5 = Ae) => {
  const t3 = process.execPath;
  if (e5.existsSync(t3))
    return !e5.existsSync(pe(t3));
  const s5 = `/${Je(10)}`;
  e5.writeFileSync(s5, "");
  const n3 = !e5.existsSync(pe(s5));
  return e5.unlinkSync(s5), n3;
}, "l");
var { join: M } = m3.posix;
var K = { ts: [".ts", ".tsx", ".d.ts"], cts: [".cts", ".d.cts"], mts: [".mts", ".d.mts"] };
var ze = o3((e5) => {
  const t3 = [...K.ts], s5 = [...K.cts], n3 = [...K.mts];
  return e5 != null && e5.allowJs && (t3.push(".js", ".jsx"), s5.push(".cjs"), n3.push(".mjs")), [...t3, ...s5, ...n3];
}, "getSupportedExtensions");
var Ge = o3((e5) => {
  const t3 = [];
  if (!e5)
    return t3;
  const { outDir: s5, declarationDir: n3 } = e5;
  return s5 && t3.push(s5), n3 && t3.push(n3), t3;
}, "getDefaultExcludeSpec");
var me = o3((e5) => e5.replaceAll(/[.*+?^${}()|[\]\\]/g, String.raw`\$&`), "escapeForRegexp");
var Qe = ["node_modules", "bower_components", "jspm_packages"];
var C = `(?!(${Qe.join("|")})(/|$))`;
var He = /(?:^|\/)[^.*?]+$/;
var ke = "**/*";
var V = "[^/]";
var ee = "[^./]";
var we = process.platform === "win32";
var Xe = o3(({ config: e5, path: t3 }, s5 = Oe()) => {
  if ("extends" in e5)
    throw new Error("tsconfig#extends must be resolved. Use getTsconfig or parseTsconfig to resolve it.");
  if (!m3.isAbsolute(t3))
    throw new Error("The tsconfig path must be absolute");
  we && (t3 = E2(t3));
  const n3 = m3.dirname(t3), { files: l3, include: i6, exclude: u5, compilerOptions: f6 } = e5, r3 = l3 == null ? void 0 : l3.map((w4) => M(n3, w4)), g2 = ze(f6), T3 = s5 ? "" : "i", _4 = (u5 || Ge(f6)).map((w4) => {
    const y3 = M(n3, w4), I4 = me(y3).replaceAll(String.raw`\*\*/`, "(.+/)?").replaceAll(String.raw`\*`, `${V}*`).replaceAll(String.raw`\?`, V);
    return new RegExp(`^${I4}($|/)`, T3);
  }), d5 = l3 || i6 ? i6 : [ke], A3 = d5 ? d5.map((w4) => {
    let y3 = M(n3, w4);
    He.test(y3) && (y3 = M(y3, ke));
    const I4 = me(y3).replaceAll(String.raw`/\*\*`, `(/${C}${ee}${V}*)*?`).replaceAll(/(\/)?\\\*/g, (L3, c3) => {
      const k3 = `(${ee}|(\\.(?!min\\.js$))?)*`;
      return c3 ? `/${C}${ee}${k3}` : k3;
    }).replaceAll(/(\/)?\\\?/g, (L3, c3) => {
      const k3 = V;
      return c3 ? `/${C}${k3}` : k3;
    });
    return new RegExp(`^${I4}$`, T3);
  }) : void 0;
  return (w4) => {
    if (!m3.isAbsolute(w4))
      throw new Error("filePath must be absolute");
    if (we && (w4 = E2(w4)), r3 != null && r3.includes(w4))
      return e5;
    if (!(!g2.some((y3) => w4.endsWith(y3)) || _4.some((y3) => y3.test(w4))) && A3 && A3.some((y3) => y3.test(w4)))
      return e5;
  };
}, "createFilesMatcher");

// 
import se3, { writeSync as te2 } from "node:fs";

// 
var import_esbuild = __toESM(require_main(), 1);
import { fileURLToPath as Jt, pathToFileURL as Gt } from "node:url";
import Ht from "node:crypto";
import U2 from "node:fs";
import X2 from "node:path";
import Xt from "node:os";
var Pt = Object.defineProperty;
var f2 = (s5, e5) => Pt(s5, "name", { value: e5, configurable: true });
var Ne2 = f2((s5) => Ht.createHash("sha1").update(s5).digest("hex"), "sha1");
var Ie2 = 44;
var Yt = 59;
var Me2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var $e2 = new Uint8Array(64);
var Ue2 = new Uint8Array(128);
for (let s5 = 0; s5 < Me2.length; s5++) {
  const e5 = Me2.charCodeAt(s5);
  $e2[s5] = e5, Ue2[e5] = s5;
}
var me2 = typeof TextDecoder < "u" ? new TextDecoder() : typeof Buffer < "u" ? { decode(s5) {
  return Buffer.from(s5.buffer, s5.byteOffset, s5.byteLength).toString();
} } : { decode(s5) {
  let e5 = "";
  for (let n3 = 0; n3 < s5.length; n3++)
    e5 += String.fromCharCode(s5[n3]);
  return e5;
} };
function Qt(s5) {
  const e5 = new Int32Array(5), n3 = [];
  let i6 = 0;
  do {
    const o8 = Zt(s5, i6), c3 = [];
    let u5 = true, p5 = 0;
    e5[0] = 0;
    for (let g2 = i6; g2 < o8; g2++) {
      let b3;
      g2 = K2(s5, g2, e5, 0);
      const d5 = e5[0];
      d5 < p5 && (u5 = false), p5 = d5, je2(s5, g2, o8) ? (g2 = K2(s5, g2, e5, 1), g2 = K2(s5, g2, e5, 2), g2 = K2(s5, g2, e5, 3), je2(s5, g2, o8) ? (g2 = K2(s5, g2, e5, 4), b3 = [d5, e5[1], e5[2], e5[3], e5[4]]) : b3 = [d5, e5[1], e5[2], e5[3]]) : b3 = [d5], c3.push(b3);
    }
    u5 || Vt(c3), n3.push(c3), i6 = o8 + 1;
  } while (i6 <= s5.length);
  return n3;
}
f2(Qt, "decode");
function Zt(s5, e5) {
  const n3 = s5.indexOf(";", e5);
  return n3 === -1 ? s5.length : n3;
}
f2(Zt, "indexOf");
function K2(s5, e5, n3, i6) {
  let o8 = 0, c3 = 0, u5 = 0;
  do {
    const g2 = s5.charCodeAt(e5++);
    u5 = Ue2[g2], o8 |= (u5 & 31) << c3, c3 += 5;
  } while (u5 & 32);
  const p5 = o8 & 1;
  return o8 >>>= 1, p5 && (o8 = -2147483648 | -o8), n3[i6] += o8, e5;
}
f2(K2, "decodeInteger");
function je2(s5, e5, n3) {
  return e5 >= n3 ? false : s5.charCodeAt(e5) !== Ie2;
}
f2(je2, "hasMoreVlq");
function Vt(s5) {
  s5.sort(en);
}
f2(Vt, "sort");
function en(s5, e5) {
  return s5[0] - e5[0];
}
f2(en, "sortComparator$1");
function De2(s5) {
  const e5 = new Int32Array(5), n3 = 1024 * 16, i6 = n3 - 36, o8 = new Uint8Array(n3), c3 = o8.subarray(0, i6);
  let u5 = 0, p5 = "";
  for (let g2 = 0; g2 < s5.length; g2++) {
    const b3 = s5[g2];
    if (g2 > 0 && (u5 === n3 && (p5 += me2.decode(o8), u5 = 0), o8[u5++] = Yt), b3.length !== 0) {
      e5[0] = 0;
      for (let d5 = 0; d5 < b3.length; d5++) {
        const r3 = b3[d5];
        u5 > i6 && (p5 += me2.decode(c3), o8.copyWithin(0, i6, u5), u5 -= i6), d5 > 0 && (o8[u5++] = Ie2), u5 = Y3(o8, u5, e5, r3, 0), r3.length !== 1 && (u5 = Y3(o8, u5, e5, r3, 1), u5 = Y3(o8, u5, e5, r3, 2), u5 = Y3(o8, u5, e5, r3, 3), r3.length !== 4 && (u5 = Y3(o8, u5, e5, r3, 4)));
      }
    }
  }
  return p5 + me2.decode(o8.subarray(0, u5));
}
f2(De2, "encode");
function Y3(s5, e5, n3, i6, o8) {
  const c3 = i6[o8];
  let u5 = c3 - n3[o8];
  n3[o8] = c3, u5 = u5 < 0 ? -u5 << 1 | 1 : u5 << 1;
  do {
    let p5 = u5 & 31;
    u5 >>>= 5, u5 > 0 && (p5 |= 32), s5[e5++] = $e2[p5];
  } while (u5 > 0);
  return e5;
}
f2(Y3, "encodeInteger");
var ae2 = class _ae {
  static {
    f2(this, "BitSet");
  }
  constructor(e5) {
    this.bits = e5 instanceof _ae ? e5.bits.slice() : [];
  }
  add(e5) {
    this.bits[e5 >> 5] |= 1 << (e5 & 31);
  }
  has(e5) {
    return !!(this.bits[e5 >> 5] & 1 << (e5 & 31));
  }
};
var ee2 = class _ee {
  static {
    f2(this, "Chunk");
  }
  constructor(e5, n3, i6) {
    this.start = e5, this.end = n3, this.original = i6, this.intro = "", this.outro = "", this.content = i6, this.storeName = false, this.edited = false, this.previous = null, this.next = null;
  }
  appendLeft(e5) {
    this.outro += e5;
  }
  appendRight(e5) {
    this.intro = this.intro + e5;
  }
  clone() {
    const e5 = new _ee(this.start, this.end, this.original);
    return e5.intro = this.intro, e5.outro = this.outro, e5.content = this.content, e5.storeName = this.storeName, e5.edited = this.edited, e5;
  }
  contains(e5) {
    return this.start < e5 && e5 < this.end;
  }
  eachNext(e5) {
    let n3 = this;
    for (; n3; )
      e5(n3), n3 = n3.next;
  }
  eachPrevious(e5) {
    let n3 = this;
    for (; n3; )
      e5(n3), n3 = n3.previous;
  }
  edit(e5, n3, i6) {
    return this.content = e5, i6 || (this.intro = "", this.outro = ""), this.storeName = n3, this.edited = true, this;
  }
  prependLeft(e5) {
    this.outro = e5 + this.outro;
  }
  prependRight(e5) {
    this.intro = e5 + this.intro;
  }
  reset() {
    this.intro = "", this.outro = "", this.edited && (this.content = this.original, this.storeName = false, this.edited = false);
  }
  split(e5) {
    const n3 = e5 - this.start, i6 = this.original.slice(0, n3), o8 = this.original.slice(n3);
    this.original = i6;
    const c3 = new _ee(e5, this.end, o8);
    return c3.outro = this.outro, this.outro = "", this.end = e5, this.edited ? (c3.edit("", false), this.content = "") : this.content = i6, c3.next = this.next, c3.next && (c3.next.previous = c3), c3.previous = this, this.next = c3, c3;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(e5) {
    if (this.outro = this.outro.replace(e5, ""), this.outro.length)
      return true;
    const n3 = this.content.replace(e5, "");
    if (n3.length)
      return n3 !== this.content && (this.split(this.start + n3.length).edit("", void 0, true), this.edited && this.edit(n3, this.storeName, true)), true;
    if (this.edit("", void 0, true), this.intro = this.intro.replace(e5, ""), this.intro.length)
      return true;
  }
  trimStart(e5) {
    if (this.intro = this.intro.replace(e5, ""), this.intro.length)
      return true;
    const n3 = this.content.replace(e5, "");
    if (n3.length) {
      if (n3 !== this.content) {
        const i6 = this.split(this.end - n3.length);
        this.edited && i6.edit(n3, this.storeName, true), this.edit("", void 0, true);
      }
      return true;
    } else if (this.edit("", void 0, true), this.outro = this.outro.replace(e5, ""), this.outro.length)
      return true;
  }
};
function tn() {
  return typeof globalThis < "u" && typeof globalThis.btoa == "function" ? (s5) => globalThis.btoa(unescape(encodeURIComponent(s5))) : typeof Buffer == "function" ? (s5) => Buffer.from(s5, "utf-8").toString("base64") : () => {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
}
f2(tn, "getBtoa");
var nn = tn();
var rn = class {
  static {
    f2(this, "SourceMap");
  }
  constructor(e5) {
    this.version = 3, this.file = e5.file, this.sources = e5.sources, this.sourcesContent = e5.sourcesContent, this.names = e5.names, this.mappings = De2(e5.mappings), typeof e5.x_google_ignoreList < "u" && (this.x_google_ignoreList = e5.x_google_ignoreList);
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + nn(this.toString());
  }
};
function sn(s5) {
  const e5 = s5.split(`
`), n3 = e5.filter((c3) => /^\t+/.test(c3)), i6 = e5.filter((c3) => /^ {2,}/.test(c3));
  if (n3.length === 0 && i6.length === 0)
    return null;
  if (n3.length >= i6.length)
    return "	";
  const o8 = i6.reduce((c3, u5) => {
    const p5 = /^ +/.exec(u5)[0].length;
    return Math.min(p5, c3);
  }, 1 / 0);
  return new Array(o8 + 1).join(" ");
}
f2(sn, "guessIndent");
function on(s5, e5) {
  const n3 = s5.split(/[/\\]/), i6 = e5.split(/[/\\]/);
  for (n3.pop(); n3[0] === i6[0]; )
    n3.shift(), i6.shift();
  if (n3.length) {
    let o8 = n3.length;
    for (; o8--; )
      n3[o8] = "..";
  }
  return n3.concat(i6).join("/");
}
f2(on, "getRelativePath");
var an = Object.prototype.toString;
function cn(s5) {
  return an.call(s5) === "[object Object]";
}
f2(cn, "isObject");
function Te(s5) {
  const e5 = s5.split(`
`), n3 = [];
  for (let i6 = 0, o8 = 0; i6 < e5.length; i6++)
    n3.push(o8), o8 += e5[i6].length + 1;
  return f2(function(o8) {
    let c3 = 0, u5 = n3.length;
    for (; c3 < u5; ) {
      const b3 = c3 + u5 >> 1;
      o8 < n3[b3] ? u5 = b3 : c3 = b3 + 1;
    }
    const p5 = c3 - 1, g2 = o8 - n3[p5];
    return { line: p5, column: g2 };
  }, "locate");
}
f2(Te, "getLocator");
var un = /\w/;
var ln = class {
  static {
    f2(this, "Mappings");
  }
  constructor(e5) {
    this.hires = e5, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
  }
  addEdit(e5, n3, i6, o8) {
    if (n3.length) {
      const c3 = n3.length - 1;
      let u5 = n3.indexOf(`
`, 0), p5 = -1;
      for (; u5 >= 0 && c3 > u5; ) {
        const b3 = [this.generatedCodeColumn, e5, i6.line, i6.column];
        o8 >= 0 && b3.push(o8), this.rawSegments.push(b3), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, p5 = u5, u5 = n3.indexOf(`
`, u5 + 1);
      }
      const g2 = [this.generatedCodeColumn, e5, i6.line, i6.column];
      o8 >= 0 && g2.push(o8), this.rawSegments.push(g2), this.advance(n3.slice(p5 + 1));
    } else
      this.pending && (this.rawSegments.push(this.pending), this.advance(n3));
    this.pending = null;
  }
  addUneditedChunk(e5, n3, i6, o8, c3) {
    let u5 = n3.start, p5 = true, g2 = false;
    for (; u5 < n3.end; ) {
      if (this.hires || p5 || c3.has(u5)) {
        const b3 = [this.generatedCodeColumn, e5, o8.line, o8.column];
        this.hires === "boundary" ? un.test(i6[u5]) ? g2 || (this.rawSegments.push(b3), g2 = true) : (this.rawSegments.push(b3), g2 = false) : this.rawSegments.push(b3);
      }
      i6[u5] === `
` ? (o8.line += 1, o8.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, p5 = true) : (o8.column += 1, this.generatedCodeColumn += 1, p5 = false), u5 += 1;
    }
    this.pending = null;
  }
  advance(e5) {
    if (!e5)
      return;
    const n3 = e5.split(`
`);
    if (n3.length > 1) {
      for (let i6 = 0; i6 < n3.length - 1; i6++)
        this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += n3[n3.length - 1].length;
  }
};
var Q3 = `
`;
var J = { insertLeft: false, insertRight: false, storeName: false };
var _e2 = class __e2 {
  static {
    f2(this, "MagicString");
  }
  constructor(e5, n3 = {}) {
    const i6 = new ee2(0, e5.length, e5);
    Object.defineProperties(this, { original: { writable: true, value: e5 }, outro: { writable: true, value: "" }, intro: { writable: true, value: "" }, firstChunk: { writable: true, value: i6 }, lastChunk: { writable: true, value: i6 }, lastSearchedChunk: { writable: true, value: i6 }, byStart: { writable: true, value: {} }, byEnd: { writable: true, value: {} }, filename: { writable: true, value: n3.filename }, indentExclusionRanges: { writable: true, value: n3.indentExclusionRanges }, sourcemapLocations: { writable: true, value: new ae2() }, storedNames: { writable: true, value: {} }, indentStr: { writable: true, value: void 0 }, ignoreList: { writable: true, value: n3.ignoreList } }), this.byStart[0] = i6, this.byEnd[e5.length] = i6;
  }
  addSourcemapLocation(e5) {
    this.sourcemapLocations.add(e5);
  }
  append(e5) {
    if (typeof e5 != "string")
      throw new TypeError("outro content must be a string");
    return this.outro += e5, this;
  }
  appendLeft(e5, n3) {
    if (typeof n3 != "string")
      throw new TypeError("inserted content must be a string");
    this._split(e5);
    const i6 = this.byEnd[e5];
    return i6 ? i6.appendLeft(n3) : this.intro += n3, this;
  }
  appendRight(e5, n3) {
    if (typeof n3 != "string")
      throw new TypeError("inserted content must be a string");
    this._split(e5);
    const i6 = this.byStart[e5];
    return i6 ? i6.appendRight(n3) : this.outro += n3, this;
  }
  clone() {
    const e5 = new __e2(this.original, { filename: this.filename });
    let n3 = this.firstChunk, i6 = e5.firstChunk = e5.lastSearchedChunk = n3.clone();
    for (; n3; ) {
      e5.byStart[i6.start] = i6, e5.byEnd[i6.end] = i6;
      const o8 = n3.next, c3 = o8 && o8.clone();
      c3 && (i6.next = c3, c3.previous = i6, i6 = c3), n3 = o8;
    }
    return e5.lastChunk = i6, this.indentExclusionRanges && (e5.indentExclusionRanges = this.indentExclusionRanges.slice()), e5.sourcemapLocations = new ae2(this.sourcemapLocations), e5.intro = this.intro, e5.outro = this.outro, e5;
  }
  generateDecodedMap(e5) {
    e5 = e5 || {};
    const n3 = 0, i6 = Object.keys(this.storedNames), o8 = new ln(e5.hires), c3 = Te(this.original);
    return this.intro && o8.advance(this.intro), this.firstChunk.eachNext((u5) => {
      const p5 = c3(u5.start);
      u5.intro.length && o8.advance(u5.intro), u5.edited ? o8.addEdit(n3, u5.content, p5, u5.storeName ? i6.indexOf(u5.original) : -1) : o8.addUneditedChunk(n3, u5, this.original, p5, this.sourcemapLocations), u5.outro.length && o8.advance(u5.outro);
    }), { file: e5.file ? e5.file.split(/[/\\]/).pop() : void 0, sources: [e5.source ? on(e5.file || "", e5.source) : e5.file || ""], sourcesContent: e5.includeContent ? [this.original] : void 0, names: i6, mappings: o8.raw, x_google_ignoreList: this.ignoreList ? [n3] : void 0 };
  }
  generateMap(e5) {
    return new rn(this.generateDecodedMap(e5));
  }
  _ensureindentStr() {
    this.indentStr === void 0 && (this.indentStr = sn(this.original));
  }
  _getRawIndentString() {
    return this._ensureindentStr(), this.indentStr;
  }
  getIndentString() {
    return this._ensureindentStr(), this.indentStr === null ? "	" : this.indentStr;
  }
  indent(e5, n3) {
    const i6 = /^[^\r\n]/gm;
    if (cn(e5) && (n3 = e5, e5 = void 0), e5 === void 0 && (this._ensureindentStr(), e5 = this.indentStr || "	"), e5 === "")
      return this;
    n3 = n3 || {};
    const o8 = {};
    n3.exclude && (typeof n3.exclude[0] == "number" ? [n3.exclude] : n3.exclude).forEach((d5) => {
      for (let r3 = d5[0]; r3 < d5[1]; r3 += 1)
        o8[r3] = true;
    });
    let c3 = n3.indentStart !== false;
    const u5 = f2((b3) => c3 ? `${e5}${b3}` : (c3 = true, b3), "replacer");
    this.intro = this.intro.replace(i6, u5);
    let p5 = 0, g2 = this.firstChunk;
    for (; g2; ) {
      const b3 = g2.end;
      if (g2.edited)
        o8[p5] || (g2.content = g2.content.replace(i6, u5), g2.content.length && (c3 = g2.content[g2.content.length - 1] === `
`));
      else
        for (p5 = g2.start; p5 < b3; ) {
          if (!o8[p5]) {
            const d5 = this.original[p5];
            d5 === `
` ? c3 = true : d5 !== "\r" && c3 && (c3 = false, p5 === g2.start || (this._splitChunk(g2, p5), g2 = g2.next), g2.prependRight(e5));
          }
          p5 += 1;
        }
      p5 = g2.end, g2 = g2.next;
    }
    return this.outro = this.outro.replace(i6, u5), this;
  }
  insert() {
    throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
  }
  insertLeft(e5, n3) {
    return J.insertLeft || (console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"), J.insertLeft = true), this.appendLeft(e5, n3);
  }
  insertRight(e5, n3) {
    return J.insertRight || (console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"), J.insertRight = true), this.prependRight(e5, n3);
  }
  move(e5, n3, i6) {
    if (i6 >= e5 && i6 <= n3)
      throw new Error("Cannot move a selection inside itself");
    this._split(e5), this._split(n3), this._split(i6);
    const o8 = this.byStart[e5], c3 = this.byEnd[n3], u5 = o8.previous, p5 = c3.next, g2 = this.byStart[i6];
    if (!g2 && c3 === this.lastChunk)
      return this;
    const b3 = g2 ? g2.previous : this.lastChunk;
    return u5 && (u5.next = p5), p5 && (p5.previous = u5), b3 && (b3.next = o8), g2 && (g2.previous = c3), o8.previous || (this.firstChunk = c3.next), c3.next || (this.lastChunk = o8.previous, this.lastChunk.next = null), o8.previous = b3, c3.next = g2 || null, b3 || (this.firstChunk = o8), g2 || (this.lastChunk = c3), this;
  }
  overwrite(e5, n3, i6, o8) {
    return o8 = o8 || {}, this.update(e5, n3, i6, { ...o8, overwrite: !o8.contentOnly });
  }
  update(e5, n3, i6, o8) {
    if (typeof i6 != "string")
      throw new TypeError("replacement content must be a string");
    for (; e5 < 0; )
      e5 += this.original.length;
    for (; n3 < 0; )
      n3 += this.original.length;
    if (n3 > this.original.length)
      throw new Error("end is out of bounds");
    if (e5 === n3)
      throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
    this._split(e5), this._split(n3), o8 === true && (J.storeName || (console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"), J.storeName = true), o8 = { storeName: true });
    const c3 = o8 !== void 0 ? o8.storeName : false, u5 = o8 !== void 0 ? o8.overwrite : false;
    if (c3) {
      const b3 = this.original.slice(e5, n3);
      Object.defineProperty(this.storedNames, b3, { writable: true, value: true, enumerable: true });
    }
    const p5 = this.byStart[e5], g2 = this.byEnd[n3];
    if (p5) {
      let b3 = p5;
      for (; b3 !== g2; ) {
        if (b3.next !== this.byStart[b3.end])
          throw new Error("Cannot overwrite across a split point");
        b3 = b3.next, b3.edit("", false);
      }
      p5.edit(i6, c3, !u5);
    } else {
      const b3 = new ee2(e5, n3, "").edit(i6, c3);
      g2.next = b3, b3.previous = g2;
    }
    return this;
  }
  prepend(e5) {
    if (typeof e5 != "string")
      throw new TypeError("outro content must be a string");
    return this.intro = e5 + this.intro, this;
  }
  prependLeft(e5, n3) {
    if (typeof n3 != "string")
      throw new TypeError("inserted content must be a string");
    this._split(e5);
    const i6 = this.byEnd[e5];
    return i6 ? i6.prependLeft(n3) : this.intro = n3 + this.intro, this;
  }
  prependRight(e5, n3) {
    if (typeof n3 != "string")
      throw new TypeError("inserted content must be a string");
    this._split(e5);
    const i6 = this.byStart[e5];
    return i6 ? i6.prependRight(n3) : this.outro = n3 + this.outro, this;
  }
  remove(e5, n3) {
    for (; e5 < 0; )
      e5 += this.original.length;
    for (; n3 < 0; )
      n3 += this.original.length;
    if (e5 === n3)
      return this;
    if (e5 < 0 || n3 > this.original.length)
      throw new Error("Character is out of bounds");
    if (e5 > n3)
      throw new Error("end must be greater than start");
    this._split(e5), this._split(n3);
    let i6 = this.byStart[e5];
    for (; i6; )
      i6.intro = "", i6.outro = "", i6.edit(""), i6 = n3 > i6.end ? this.byStart[i6.end] : null;
    return this;
  }
  reset(e5, n3) {
    for (; e5 < 0; )
      e5 += this.original.length;
    for (; n3 < 0; )
      n3 += this.original.length;
    if (e5 === n3)
      return this;
    if (e5 < 0 || n3 > this.original.length)
      throw new Error("Character is out of bounds");
    if (e5 > n3)
      throw new Error("end must be greater than start");
    this._split(e5), this._split(n3);
    let i6 = this.byStart[e5];
    for (; i6; )
      i6.reset(), i6 = n3 > i6.end ? this.byStart[i6.end] : null;
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let e5 = this.lastChunk;
    do {
      if (e5.outro.length)
        return e5.outro[e5.outro.length - 1];
      if (e5.content.length)
        return e5.content[e5.content.length - 1];
      if (e5.intro.length)
        return e5.intro[e5.intro.length - 1];
    } while (e5 = e5.previous);
    return this.intro.length ? this.intro[this.intro.length - 1] : "";
  }
  lastLine() {
    let e5 = this.outro.lastIndexOf(Q3);
    if (e5 !== -1)
      return this.outro.substr(e5 + 1);
    let n3 = this.outro, i6 = this.lastChunk;
    do {
      if (i6.outro.length > 0) {
        if (e5 = i6.outro.lastIndexOf(Q3), e5 !== -1)
          return i6.outro.substr(e5 + 1) + n3;
        n3 = i6.outro + n3;
      }
      if (i6.content.length > 0) {
        if (e5 = i6.content.lastIndexOf(Q3), e5 !== -1)
          return i6.content.substr(e5 + 1) + n3;
        n3 = i6.content + n3;
      }
      if (i6.intro.length > 0) {
        if (e5 = i6.intro.lastIndexOf(Q3), e5 !== -1)
          return i6.intro.substr(e5 + 1) + n3;
        n3 = i6.intro + n3;
      }
    } while (i6 = i6.previous);
    return e5 = this.intro.lastIndexOf(Q3), e5 !== -1 ? this.intro.substr(e5 + 1) + n3 : this.intro + n3;
  }
  slice(e5 = 0, n3 = this.original.length) {
    for (; e5 < 0; )
      e5 += this.original.length;
    for (; n3 < 0; )
      n3 += this.original.length;
    let i6 = "", o8 = this.firstChunk;
    for (; o8 && (o8.start > e5 || o8.end <= e5); ) {
      if (o8.start < n3 && o8.end >= n3)
        return i6;
      o8 = o8.next;
    }
    if (o8 && o8.edited && o8.start !== e5)
      throw new Error(`Cannot use replaced character ${e5} as slice start anchor.`);
    const c3 = o8;
    for (; o8; ) {
      o8.intro && (c3 !== o8 || o8.start === e5) && (i6 += o8.intro);
      const u5 = o8.start < n3 && o8.end >= n3;
      if (u5 && o8.edited && o8.end !== n3)
        throw new Error(`Cannot use replaced character ${n3} as slice end anchor.`);
      const p5 = c3 === o8 ? e5 - o8.start : 0, g2 = u5 ? o8.content.length + n3 - o8.end : o8.content.length;
      if (i6 += o8.content.slice(p5, g2), o8.outro && (!u5 || o8.end === n3) && (i6 += o8.outro), u5)
        break;
      o8 = o8.next;
    }
    return i6;
  }
  snip(e5, n3) {
    const i6 = this.clone();
    return i6.remove(0, e5), i6.remove(n3, i6.original.length), i6;
  }
  _split(e5) {
    if (this.byStart[e5] || this.byEnd[e5])
      return;
    let n3 = this.lastSearchedChunk;
    const i6 = e5 > n3.end;
    for (; n3; ) {
      if (n3.contains(e5))
        return this._splitChunk(n3, e5);
      n3 = i6 ? this.byStart[n3.end] : this.byEnd[n3.start];
    }
  }
  _splitChunk(e5, n3) {
    if (e5.edited && e5.content.length) {
      const o8 = Te(this.original)(n3);
      throw new Error(`Cannot split a chunk that has already been edited (${o8.line}:${o8.column} \u2013 "${e5.original}")`);
    }
    const i6 = e5.split(n3);
    return this.byEnd[n3] = e5, this.byStart[n3] = i6, this.byEnd[i6.end] = i6, e5 === this.lastChunk && (this.lastChunk = i6), this.lastSearchedChunk = e5, true;
  }
  toString() {
    let e5 = this.intro, n3 = this.firstChunk;
    for (; n3; )
      e5 += n3.toString(), n3 = n3.next;
    return e5 + this.outro;
  }
  isEmpty() {
    let e5 = this.firstChunk;
    do
      if (e5.intro.length && e5.intro.trim() || e5.content.length && e5.content.trim() || e5.outro.length && e5.outro.trim())
        return false;
    while (e5 = e5.next);
    return true;
  }
  length() {
    let e5 = this.firstChunk, n3 = 0;
    do
      n3 += e5.intro.length + e5.content.length + e5.outro.length;
    while (e5 = e5.next);
    return n3;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(e5) {
    return this.trimStart(e5).trimEnd(e5);
  }
  trimEndAborted(e5) {
    const n3 = new RegExp((e5 || "\\s") + "+$");
    if (this.outro = this.outro.replace(n3, ""), this.outro.length)
      return true;
    let i6 = this.lastChunk;
    do {
      const o8 = i6.end, c3 = i6.trimEnd(n3);
      if (i6.end !== o8 && (this.lastChunk === i6 && (this.lastChunk = i6.next), this.byEnd[i6.end] = i6, this.byStart[i6.next.start] = i6.next, this.byEnd[i6.next.end] = i6.next), c3)
        return true;
      i6 = i6.previous;
    } while (i6);
    return false;
  }
  trimEnd(e5) {
    return this.trimEndAborted(e5), this;
  }
  trimStartAborted(e5) {
    const n3 = new RegExp("^" + (e5 || "\\s") + "+");
    if (this.intro = this.intro.replace(n3, ""), this.intro.length)
      return true;
    let i6 = this.firstChunk;
    do {
      const o8 = i6.end, c3 = i6.trimStart(n3);
      if (i6.end !== o8 && (i6 === this.lastChunk && (this.lastChunk = i6.next), this.byEnd[i6.end] = i6, this.byStart[i6.next.start] = i6.next, this.byEnd[i6.next.end] = i6.next), c3)
        return true;
      i6 = i6.next;
    } while (i6);
    return false;
  }
  trimStart(e5) {
    return this.trimStartAborted(e5), this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(e5, n3) {
    function i6(c3, u5) {
      return typeof n3 == "string" ? n3.replace(/\$(\$|&|\d+)/g, (p5, g2) => g2 === "$" ? "$" : g2 === "&" ? c3[0] : +g2 < c3.length ? c3[+g2] : `$${g2}`) : n3(...c3, c3.index, u5, c3.groups);
    }
    f2(i6, "getReplacement");
    function o8(c3, u5) {
      let p5;
      const g2 = [];
      for (; p5 = c3.exec(u5); )
        g2.push(p5);
      return g2;
    }
    if (f2(o8, "matchAll"), e5.global)
      o8(e5, this.original).forEach((u5) => {
        if (u5.index != null) {
          const p5 = i6(u5, this.original);
          p5 !== u5[0] && this.overwrite(u5.index, u5.index + u5[0].length, p5);
        }
      });
    else {
      const c3 = this.original.match(e5);
      if (c3 && c3.index != null) {
        const u5 = i6(c3, this.original);
        u5 !== c3[0] && this.overwrite(c3.index, c3.index + c3[0].length, u5);
      }
    }
    return this;
  }
  _replaceString(e5, n3) {
    const { original: i6 } = this, o8 = i6.indexOf(e5);
    return o8 !== -1 && this.overwrite(o8, o8 + e5.length, n3), this;
  }
  replace(e5, n3) {
    return typeof e5 == "string" ? this._replaceString(e5, n3) : this._replaceRegexp(e5, n3);
  }
  _replaceAllString(e5, n3) {
    const { original: i6 } = this, o8 = e5.length;
    for (let c3 = i6.indexOf(e5); c3 !== -1; c3 = i6.indexOf(e5, c3 + o8))
      i6.slice(c3, c3 + o8) !== n3 && this.overwrite(c3, c3 + o8, n3);
    return this;
  }
  replaceAll(e5, n3) {
    if (typeof e5 == "string")
      return this._replaceAllString(e5, n3);
    if (!e5.global)
      throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
    return this._replaceRegexp(e5, n3);
  }
};
var v2;
var re2;
var ke2;
var Z2 = 2 << 19;
var Fe2 = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1 ? function(s5, e5) {
  const n3 = s5.length;
  let i6 = 0;
  for (; i6 < n3; )
    e5[i6] = s5.charCodeAt(i6++);
} : function(s5, e5) {
  const n3 = s5.length;
  let i6 = 0;
  for (; i6 < n3; ) {
    const o8 = s5.charCodeAt(i6);
    e5[i6++] = (255 & o8) << 8 | o8 >>> 8;
  }
};
var hn = "xportmportlassforetaourceromsyncunctionssertvoyiedelecontininstantybreareturdebuggeawaithrwhileifcatcfinallels";
var _2;
var We2;
var y;
function fn(s5, e5 = "@") {
  _2 = s5, We2 = e5;
  const n3 = 2 * _2.length + (2 << 18);
  if (n3 > Z2 || !v2) {
    for (; n3 > Z2; )
      Z2 *= 2;
    re2 = new ArrayBuffer(Z2), Fe2(hn, new Uint16Array(re2, 16, 110)), v2 = function(u5, p5, g2) {
      var b3 = new u5.Int8Array(g2), d5 = new u5.Int16Array(g2), r3 = new u5.Int32Array(g2), R6 = new u5.Uint8Array(g2), L3 = new u5.Uint16Array(g2), E6 = 1040;
      function N2() {
        var t3 = 0, a7 = 0, h4 = 0, l3 = 0, w4 = 0, m8 = 0, C4 = 0;
        C4 = E6, E6 = E6 + 10240 | 0, b3[804] = 1, b3[803] = 0, d5[399] = 0, d5[400] = 0, r3[69] = r3[2], b3[805] = 0, r3[68] = 0, b3[802] = 0, r3[70] = C4 + 2048, r3[71] = C4, b3[806] = 0, t3 = (r3[3] | 0) + -2 | 0, r3[72] = t3, a7 = t3 + (r3[66] << 1) | 0, r3[73] = a7;
        e:
          for (; ; ) {
            if (h4 = t3 + 2 | 0, r3[72] = h4, t3 >>> 0 >= a7 >>> 0) {
              l3 = 18;
              break;
            }
            t:
              do
                switch (d5[h4 >> 1] | 0) {
                  case 9:
                  case 10:
                  case 11:
                  case 12:
                  case 13:
                  case 32:
                    break;
                  case 101: {
                    if (!(d5[400] | 0) && z3(h4) | 0 && !(A3(t3 + 4 | 0, 16, 10) | 0) && ($3(), (b3[804] | 0) == 0)) {
                      l3 = 9;
                      break e;
                    } else
                      l3 = 17;
                    break;
                  }
                  case 105: {
                    z3(h4) | 0 && !(A3(t3 + 4 | 0, 26, 10) | 0) && W2(), l3 = 17;
                    break;
                  }
                  case 59: {
                    l3 = 17;
                    break;
                  }
                  case 47:
                    switch (d5[t3 + 4 >> 1] | 0) {
                      case 47: {
                        fe2();
                        break t;
                      }
                      case 42: {
                        le2(1);
                        break t;
                      }
                      default: {
                        l3 = 16;
                        break e;
                      }
                    }
                  default: {
                    l3 = 16;
                    break e;
                  }
                }
              while (false);
            (l3 | 0) == 17 && (l3 = 0, r3[69] = r3[72]), t3 = r3[72] | 0, a7 = r3[73] | 0;
          }
        (l3 | 0) == 9 ? (t3 = r3[72] | 0, r3[69] = t3, l3 = 19) : (l3 | 0) == 16 ? (b3[804] = 0, r3[72] = t3, l3 = 19) : (l3 | 0) == 18 && (b3[802] | 0 ? t3 = 0 : (t3 = h4, l3 = 19));
        do
          if ((l3 | 0) == 19) {
            e:
              for (; ; ) {
                if (a7 = t3 + 2 | 0, r3[72] = a7, t3 >>> 0 >= (r3[73] | 0) >>> 0) {
                  l3 = 92;
                  break;
                }
                t:
                  do
                    switch (d5[a7 >> 1] | 0) {
                      case 9:
                      case 10:
                      case 11:
                      case 12:
                      case 13:
                      case 32:
                        break;
                      case 101: {
                        !(d5[400] | 0) && z3(a7) | 0 && !(A3(t3 + 4 | 0, 16, 10) | 0) && $3(), l3 = 91;
                        break;
                      }
                      case 105: {
                        z3(a7) | 0 && !(A3(t3 + 4 | 0, 26, 10) | 0) && W2(), l3 = 91;
                        break;
                      }
                      case 99: {
                        z3(a7) | 0 && !(A3(t3 + 4 | 0, 36, 8) | 0) && P3(d5[t3 + 12 >> 1] | 0) | 0 && (b3[806] = 1), l3 = 91;
                        break;
                      }
                      case 40: {
                        h4 = r3[70] | 0, t3 = d5[400] | 0, l3 = t3 & 65535, r3[h4 + (l3 << 3) >> 2] = 1, a7 = r3[69] | 0, d5[400] = t3 + 1 << 16 >> 16, r3[h4 + (l3 << 3) + 4 >> 2] = a7, l3 = 91;
                        break;
                      }
                      case 41: {
                        if (a7 = d5[400] | 0, !(a7 << 16 >> 16)) {
                          l3 = 36;
                          break e;
                        }
                        h4 = a7 + -1 << 16 >> 16, d5[400] = h4, l3 = d5[399] | 0, a7 = l3 & 65535, l3 << 16 >> 16 && (r3[(r3[70] | 0) + ((h4 & 65535) << 3) >> 2] | 0) == 5 && (a7 = r3[(r3[71] | 0) + (a7 + -1 << 2) >> 2] | 0, h4 = a7 + 4 | 0, r3[h4 >> 2] | 0 || (r3[h4 >> 2] = (r3[69] | 0) + 2), r3[a7 + 12 >> 2] = t3 + 4, d5[399] = l3 + -1 << 16 >> 16), l3 = 91;
                        break;
                      }
                      case 123: {
                        l3 = r3[69] | 0, h4 = r3[63] | 0, t3 = l3;
                        do
                          if ((d5[l3 >> 1] | 0) == 41 & (h4 | 0) != 0 && (r3[h4 + 4 >> 2] | 0) == (l3 | 0))
                            if (a7 = r3[64] | 0, r3[63] = a7, a7) {
                              r3[a7 + 32 >> 2] = 0;
                              break;
                            } else {
                              r3[59] = 0;
                              break;
                            }
                        while (false);
                        h4 = r3[70] | 0, a7 = d5[400] | 0, l3 = a7 & 65535, r3[h4 + (l3 << 3) >> 2] = b3[806] | 0 ? 6 : 2, d5[400] = a7 + 1 << 16 >> 16, r3[h4 + (l3 << 3) + 4 >> 2] = t3, b3[806] = 0, l3 = 91;
                        break;
                      }
                      case 125: {
                        if (t3 = d5[400] | 0, !(t3 << 16 >> 16)) {
                          l3 = 49;
                          break e;
                        }
                        h4 = r3[70] | 0, l3 = t3 + -1 << 16 >> 16, d5[400] = l3, (r3[h4 + ((l3 & 65535) << 3) >> 2] | 0) == 4 && Ee3(), l3 = 91;
                        break;
                      }
                      case 39: {
                        I4(39), l3 = 91;
                        break;
                      }
                      case 34: {
                        I4(34), l3 = 91;
                        break;
                      }
                      case 47:
                        switch (d5[t3 + 4 >> 1] | 0) {
                          case 47: {
                            fe2();
                            break t;
                          }
                          case 42: {
                            le2(1);
                            break t;
                          }
                          default: {
                            t3 = r3[69] | 0, a7 = d5[t3 >> 1] | 0;
                            n:
                              do
                                if (!(kt(a7) | 0))
                                  a7 << 16 >> 16 == 41 ? (h4 = d5[400] | 0, xt(r3[(r3[70] | 0) + ((h4 & 65535) << 3) + 4 >> 2] | 0) | 0 || (l3 = 65)) : l3 = 64;
                                else
                                  switch (a7 << 16 >> 16) {
                                    case 46:
                                      if (((d5[t3 + -2 >> 1] | 0) + -48 & 65535) < 10) {
                                        l3 = 64;
                                        break n;
                                      } else
                                        break n;
                                    case 43:
                                      if ((d5[t3 + -2 >> 1] | 0) == 43) {
                                        l3 = 64;
                                        break n;
                                      } else
                                        break n;
                                    case 45:
                                      if ((d5[t3 + -2 >> 1] | 0) == 45) {
                                        l3 = 64;
                                        break n;
                                      } else
                                        break n;
                                    default:
                                      break n;
                                  }
                              while (false);
                            (l3 | 0) == 64 && (h4 = d5[400] | 0, l3 = 65);
                            n:
                              do
                                if ((l3 | 0) == 65) {
                                  if (l3 = 0, h4 << 16 >> 16 && (w4 = r3[70] | 0, m8 = (h4 & 65535) + -1 | 0, a7 << 16 >> 16 == 102 ? (r3[w4 + (m8 << 3) >> 2] | 0) == 1 : 0)) {
                                    if ((d5[t3 + -2 >> 1] | 0) == 111 && O5(r3[w4 + (m8 << 3) + 4 >> 2] | 0, 44, 3) | 0)
                                      break;
                                  } else
                                    l3 = 69;
                                  if ((l3 | 0) == 69 && a7 << 16 >> 16 == 125 && (l3 = r3[70] | 0, h4 = h4 & 65535, mt(r3[l3 + (h4 << 3) + 4 >> 2] | 0) | 0 || (r3[l3 + (h4 << 3) >> 2] | 0) == 6))
                                    break;
                                  if (!(pt(t3) | 0)) {
                                    switch (a7 << 16 >> 16) {
                                      case 0:
                                        break n;
                                      case 47: {
                                        if (b3[805] | 0)
                                          break n;
                                        break;
                                      }
                                      default:
                                    }
                                    if (l3 = r3[65] | 0, l3 | 0 && t3 >>> 0 >= (r3[l3 >> 2] | 0) >>> 0 && t3 >>> 0 <= (r3[l3 + 4 >> 2] | 0) >>> 0) {
                                      ue2(), b3[805] = 0, l3 = 91;
                                      break t;
                                    }
                                    h4 = r3[3] | 0;
                                    do {
                                      if (t3 >>> 0 <= h4 >>> 0)
                                        break;
                                      t3 = t3 + -2 | 0, r3[69] = t3, a7 = d5[t3 >> 1] | 0;
                                    } while (!(he2(a7) | 0));
                                    if (ne(a7) | 0) {
                                      do {
                                        if (t3 >>> 0 <= h4 >>> 0)
                                          break;
                                        t3 = t3 + -2 | 0, r3[69] = t3;
                                      } while (ne(d5[t3 >> 1] | 0) | 0);
                                      if (Ct(t3) | 0) {
                                        ue2(), b3[805] = 0, l3 = 91;
                                        break t;
                                      }
                                    }
                                    b3[805] = 1, l3 = 91;
                                    break t;
                                  }
                                }
                              while (false);
                            ue2(), b3[805] = 0, l3 = 91;
                            break t;
                          }
                        }
                      case 96: {
                        h4 = r3[70] | 0, a7 = d5[400] | 0, l3 = a7 & 65535, r3[h4 + (l3 << 3) + 4 >> 2] = r3[69], d5[400] = a7 + 1 << 16 >> 16, r3[h4 + (l3 << 3) >> 2] = 3, Ee3(), l3 = 91;
                        break;
                      }
                      default:
                        l3 = 91;
                    }
                  while (false);
                (l3 | 0) == 91 && (l3 = 0, r3[69] = r3[72]), t3 = r3[72] | 0;
              }
            if ((l3 | 0) == 36) {
              M3(), t3 = 0;
              break;
            } else if ((l3 | 0) == 49) {
              M3(), t3 = 0;
              break;
            } else if ((l3 | 0) == 92) {
              t3 = b3[802] | 0 ? 0 : (d5[399] | d5[400]) << 16 >> 16 == 0;
              break;
            }
          }
        while (false);
        return E6 = C4, t3 | 0;
      }
      f2(N2, "b");
      function $3() {
        var t3 = 0, a7 = 0, h4 = 0, l3 = 0, w4 = 0, m8 = 0, C4 = 0, T3 = 0, ge3 = 0, be2 = 0, pe3 = 0, we3 = 0, S2 = 0, x2 = 0;
        T3 = r3[72] | 0, ge3 = r3[65] | 0, x2 = T3 + 12 | 0, r3[72] = x2, h4 = k3(1) | 0, t3 = r3[72] | 0, (t3 | 0) == (x2 | 0) && !(te3(h4) | 0) || (S2 = 3);
        e:
          do
            if ((S2 | 0) == 3) {
              t:
                do
                  switch (h4 << 16 >> 16) {
                    case 123: {
                      for (r3[72] = t3 + 2, t3 = k3(1) | 0, a7 = r3[72] | 0; ; ) {
                        if (H3(t3) | 0 ? (I4(t3), t3 = (r3[72] | 0) + 2 | 0, r3[72] = t3) : (j2(t3) | 0, t3 = r3[72] | 0), k3(1) | 0, t3 = Le2(a7, t3) | 0, t3 << 16 >> 16 == 44 && (r3[72] = (r3[72] | 0) + 2, t3 = k3(1) | 0), t3 << 16 >> 16 == 125) {
                          S2 = 15;
                          break;
                        }
                        if (x2 = a7, a7 = r3[72] | 0, (a7 | 0) == (x2 | 0)) {
                          S2 = 12;
                          break;
                        }
                        if (a7 >>> 0 > (r3[73] | 0) >>> 0) {
                          S2 = 14;
                          break;
                        }
                      }
                      if ((S2 | 0) == 12) {
                        M3();
                        break e;
                      } else if ((S2 | 0) == 14) {
                        M3();
                        break e;
                      } else if ((S2 | 0) == 15) {
                        b3[803] = 1, r3[72] = (r3[72] | 0) + 2;
                        break t;
                      }
                      break;
                    }
                    case 42: {
                      r3[72] = t3 + 2, k3(1) | 0, x2 = r3[72] | 0, Le2(x2, x2) | 0;
                      break;
                    }
                    default: {
                      switch (b3[804] = 0, h4 << 16 >> 16) {
                        case 100: {
                          switch (T3 = t3 + 14 | 0, r3[72] = T3, (k3(1) | 0) << 16 >> 16) {
                            case 97: {
                              a7 = r3[72] | 0, !(A3(a7 + 2 | 0, 72, 8) | 0) && (w4 = a7 + 10 | 0, ne(d5[w4 >> 1] | 0) | 0) && (r3[72] = w4, k3(0) | 0, S2 = 22);
                              break;
                            }
                            case 102: {
                              S2 = 22;
                              break;
                            }
                            case 99: {
                              a7 = r3[72] | 0, !(A3(a7 + 2 | 0, 36, 8) | 0) && (l3 = a7 + 10 | 0, x2 = d5[l3 >> 1] | 0, P3(x2) | 0 | x2 << 16 >> 16 == 123) && (r3[72] = l3, m8 = k3(1) | 0, m8 << 16 >> 16 != 123) && (we3 = m8, S2 = 31);
                              break;
                            }
                            default:
                          }
                          n:
                            do
                              if ((S2 | 0) == 22 && (C4 = r3[72] | 0, (A3(C4 + 2 | 0, 80, 14) | 0) == 0)) {
                                if (h4 = C4 + 16 | 0, a7 = d5[h4 >> 1] | 0, !(P3(a7) | 0))
                                  switch (a7 << 16 >> 16) {
                                    case 40:
                                    case 42:
                                      break;
                                    default:
                                      break n;
                                  }
                                r3[72] = h4, a7 = k3(1) | 0, a7 << 16 >> 16 == 42 && (r3[72] = (r3[72] | 0) + 2, a7 = k3(1) | 0), a7 << 16 >> 16 != 40 && (we3 = a7, S2 = 31);
                              }
                            while (false);
                          if ((S2 | 0) == 31 && (be2 = r3[72] | 0, j2(we3) | 0, pe3 = r3[72] | 0, pe3 >>> 0 > be2 >>> 0)) {
                            B3(t3, T3, be2, pe3), r3[72] = (r3[72] | 0) + -2;
                            break e;
                          }
                          B3(t3, T3, 0, 0), r3[72] = t3 + 12;
                          break e;
                        }
                        case 97: {
                          r3[72] = t3 + 10, k3(0) | 0, t3 = r3[72] | 0, S2 = 35;
                          break;
                        }
                        case 102: {
                          S2 = 35;
                          break;
                        }
                        case 99: {
                          if (!(A3(t3 + 2 | 0, 36, 8) | 0) && (a7 = t3 + 10 | 0, he2(d5[a7 >> 1] | 0) | 0)) {
                            r3[72] = a7, x2 = k3(1) | 0, S2 = r3[72] | 0, j2(x2) | 0, x2 = r3[72] | 0, B3(S2, x2, S2, x2), r3[72] = (r3[72] | 0) + -2;
                            break e;
                          }
                          t3 = t3 + 4 | 0, r3[72] = t3;
                          break;
                        }
                        case 108:
                        case 118:
                          break;
                        default:
                          break e;
                      }
                      if ((S2 | 0) == 35) {
                        r3[72] = t3 + 16, t3 = k3(1) | 0, t3 << 16 >> 16 == 42 && (r3[72] = (r3[72] | 0) + 2, t3 = k3(1) | 0), S2 = r3[72] | 0, j2(t3) | 0, x2 = r3[72] | 0, B3(S2, x2, S2, x2), r3[72] = (r3[72] | 0) + -2;
                        break e;
                      }
                      r3[72] = t3 + 6, b3[804] = 0, h4 = k3(1) | 0, t3 = r3[72] | 0, h4 = (j2(h4) | 0 | 32) << 16 >> 16 == 123, l3 = r3[72] | 0, h4 && (r3[72] = l3 + 2, x2 = k3(1) | 0, t3 = r3[72] | 0, j2(x2) | 0);
                      n:
                        for (; a7 = r3[72] | 0, (a7 | 0) != (t3 | 0); ) {
                          if (B3(t3, a7, t3, a7), a7 = k3(1) | 0, h4)
                            switch (a7 << 16 >> 16) {
                              case 93:
                              case 125:
                                break e;
                              default:
                            }
                          if (t3 = r3[72] | 0, a7 << 16 >> 16 != 44) {
                            S2 = 51;
                            break;
                          }
                          switch (r3[72] = t3 + 2, a7 = k3(1) | 0, t3 = r3[72] | 0, a7 << 16 >> 16) {
                            case 91:
                            case 123: {
                              S2 = 51;
                              break n;
                            }
                            default:
                          }
                          j2(a7) | 0;
                        }
                      if ((S2 | 0) == 51 && (r3[72] = t3 + -2), !h4)
                        break e;
                      r3[72] = l3 + -2;
                      break e;
                    }
                  }
                while (false);
              if (x2 = (k3(1) | 0) << 16 >> 16 == 102, t3 = r3[72] | 0, x2 && !(A3(t3 + 2 | 0, 66, 6) | 0))
                for (r3[72] = t3 + 8, G4(T3, k3(1) | 0, 0), t3 = ge3 | 0 ? ge3 + 16 | 0 : 240; ; ) {
                  if (t3 = r3[t3 >> 2] | 0, !t3)
                    break e;
                  r3[t3 + 12 >> 2] = 0, r3[t3 + 8 >> 2] = 0, t3 = t3 + 16 | 0;
                }
              r3[72] = t3 + -2;
            }
          while (false);
      }
      f2($3, "k");
      function W2() {
        var t3 = 0, a7 = 0, h4 = 0, l3 = 0, w4 = 0, m8 = 0, C4 = 0;
        w4 = r3[72] | 0, h4 = w4 + 12 | 0, r3[72] = h4, l3 = k3(1) | 0, a7 = r3[72] | 0;
        e:
          do
            if (l3 << 16 >> 16 != 46)
              l3 << 16 >> 16 == 115 & a7 >>> 0 > h4 >>> 0 ? !(A3(a7 + 2 | 0, 56, 10) | 0) && (t3 = a7 + 12 | 0, P3(d5[t3 >> 1] | 0) | 0) ? m8 = 14 : (a7 = 6, h4 = 0, m8 = 46) : (t3 = l3, h4 = 0, m8 = 15);
            else
              switch (r3[72] = a7 + 2, (k3(1) | 0) << 16 >> 16) {
                case 109: {
                  if (t3 = r3[72] | 0, A3(t3 + 2 | 0, 50, 6) | 0 || (a7 = r3[69] | 0, !(de3(a7) | 0) && (d5[a7 >> 1] | 0) == 46))
                    break e;
                  ce2(w4, w4, t3 + 8 | 0, 2);
                  break e;
                }
                case 115: {
                  if (t3 = r3[72] | 0, A3(t3 + 2 | 0, 56, 10) | 0 || (a7 = r3[69] | 0, !(de3(a7) | 0) && (d5[a7 >> 1] | 0) == 46))
                    break e;
                  t3 = t3 + 12 | 0, m8 = 14;
                  break e;
                }
                default:
                  break e;
              }
          while (false);
        (m8 | 0) == 14 && (r3[72] = t3, t3 = k3(1) | 0, h4 = 1, m8 = 15);
        e:
          do
            if ((m8 | 0) == 15)
              switch (t3 << 16 >> 16) {
                case 40: {
                  if (a7 = r3[70] | 0, C4 = d5[400] | 0, l3 = C4 & 65535, r3[a7 + (l3 << 3) >> 2] = 5, t3 = r3[72] | 0, d5[400] = C4 + 1 << 16 >> 16, r3[a7 + (l3 << 3) + 4 >> 2] = t3, (d5[r3[69] >> 1] | 0) == 46)
                    break e;
                  switch (r3[72] = t3 + 2, a7 = k3(1) | 0, ce2(w4, r3[72] | 0, 0, t3), h4 ? (t3 = r3[63] | 0, r3[t3 + 28 >> 2] = 5) : t3 = r3[63] | 0, w4 = r3[71] | 0, C4 = d5[399] | 0, d5[399] = C4 + 1 << 16 >> 16, r3[w4 + ((C4 & 65535) << 2) >> 2] = t3, a7 << 16 >> 16) {
                    case 39: {
                      I4(39);
                      break;
                    }
                    case 34: {
                      I4(34);
                      break;
                    }
                    default: {
                      r3[72] = (r3[72] | 0) + -2;
                      break e;
                    }
                  }
                  switch (t3 = (r3[72] | 0) + 2 | 0, r3[72] = t3, (k3(1) | 0) << 16 >> 16) {
                    case 44: {
                      r3[72] = (r3[72] | 0) + 2, k3(1) | 0, w4 = r3[63] | 0, r3[w4 + 4 >> 2] = t3, C4 = r3[72] | 0, r3[w4 + 16 >> 2] = C4, b3[w4 + 24 >> 0] = 1, r3[72] = C4 + -2;
                      break e;
                    }
                    case 41: {
                      d5[400] = (d5[400] | 0) + -1 << 16 >> 16, C4 = r3[63] | 0, r3[C4 + 4 >> 2] = t3, r3[C4 + 12 >> 2] = (r3[72] | 0) + 2, b3[C4 + 24 >> 0] = 1, d5[399] = (d5[399] | 0) + -1 << 16 >> 16;
                      break e;
                    }
                    default: {
                      r3[72] = (r3[72] | 0) + -2;
                      break e;
                    }
                  }
                }
                case 123: {
                  if (h4) {
                    a7 = 12, h4 = 1, m8 = 46;
                    break e;
                  }
                  if (t3 = r3[72] | 0, d5[400] | 0) {
                    r3[72] = t3 + -2;
                    break e;
                  }
                  for (; !(t3 >>> 0 >= (r3[73] | 0) >>> 0); ) {
                    if (t3 = k3(1) | 0, H3(t3) | 0)
                      I4(t3);
                    else if (t3 << 16 >> 16 == 125) {
                      m8 = 36;
                      break;
                    }
                    t3 = (r3[72] | 0) + 2 | 0, r3[72] = t3;
                  }
                  if ((m8 | 0) == 36 && (r3[72] = (r3[72] | 0) + 2), C4 = (k3(1) | 0) << 16 >> 16 == 102, t3 = r3[72] | 0, C4 && A3(t3 + 2 | 0, 66, 6) | 0) {
                    M3();
                    break e;
                  }
                  if (r3[72] = t3 + 8, t3 = k3(1) | 0, H3(t3) | 0) {
                    G4(w4, t3, 0);
                    break e;
                  } else {
                    M3();
                    break e;
                  }
                }
                default: {
                  if (h4) {
                    a7 = 12, h4 = 1, m8 = 46;
                    break e;
                  }
                  switch (t3 << 16 >> 16) {
                    case 42:
                    case 39:
                    case 34: {
                      h4 = 0, m8 = 48;
                      break e;
                    }
                    default: {
                      a7 = 6, h4 = 0, m8 = 46;
                      break e;
                    }
                  }
                }
              }
          while (false);
        (m8 | 0) == 46 && (t3 = r3[72] | 0, (t3 | 0) == (w4 + (a7 << 1) | 0) ? r3[72] = t3 + -2 : m8 = 48);
        do
          if ((m8 | 0) == 48) {
            if (d5[400] | 0) {
              r3[72] = (r3[72] | 0) + -2;
              break;
            }
            for (t3 = r3[73] | 0, a7 = r3[72] | 0; ; ) {
              if (a7 >>> 0 >= t3 >>> 0) {
                m8 = 55;
                break;
              }
              if (l3 = d5[a7 >> 1] | 0, H3(l3) | 0) {
                m8 = 53;
                break;
              }
              C4 = a7 + 2 | 0, r3[72] = C4, a7 = C4;
            }
            if ((m8 | 0) == 53) {
              G4(w4, l3, h4);
              break;
            } else if ((m8 | 0) == 55) {
              M3();
              break;
            }
          }
        while (false);
      }
      f2(W2, "l");
      function G4(t3, a7, h4) {
        t3 = t3 | 0, a7 = a7 | 0, h4 = h4 | 0;
        var l3 = 0, w4 = 0;
        switch (l3 = (r3[72] | 0) + 2 | 0, a7 << 16 >> 16) {
          case 39: {
            I4(39), w4 = 5;
            break;
          }
          case 34: {
            I4(34), w4 = 5;
            break;
          }
          default:
            M3();
        }
        do
          if ((w4 | 0) == 5) {
            if (ce2(t3, l3, r3[72] | 0, 1), h4 && (r3[(r3[63] | 0) + 28 >> 2] = 4), r3[72] = (r3[72] | 0) + 2, a7 = k3(0) | 0, h4 = a7 << 16 >> 16 == 97, h4 ? (l3 = r3[72] | 0, A3(l3 + 2 | 0, 94, 10) | 0 && (w4 = 13)) : (l3 = r3[72] | 0, a7 << 16 >> 16 == 119 && (d5[l3 + 2 >> 1] | 0) == 105 && (d5[l3 + 4 >> 1] | 0) == 116 && (d5[l3 + 6 >> 1] | 0) == 104 || (w4 = 13)), (w4 | 0) == 13) {
              r3[72] = l3 + -2;
              break;
            }
            if (r3[72] = l3 + ((h4 ? 6 : 4) << 1), (k3(1) | 0) << 16 >> 16 != 123) {
              r3[72] = l3;
              break;
            }
            h4 = r3[72] | 0, a7 = h4;
            e:
              for (; ; ) {
                switch (r3[72] = a7 + 2, a7 = k3(1) | 0, a7 << 16 >> 16) {
                  case 39: {
                    I4(39), r3[72] = (r3[72] | 0) + 2, a7 = k3(1) | 0;
                    break;
                  }
                  case 34: {
                    I4(34), r3[72] = (r3[72] | 0) + 2, a7 = k3(1) | 0;
                    break;
                  }
                  default:
                    a7 = j2(a7) | 0;
                }
                if (a7 << 16 >> 16 != 58) {
                  w4 = 22;
                  break;
                }
                switch (r3[72] = (r3[72] | 0) + 2, (k3(1) | 0) << 16 >> 16) {
                  case 39: {
                    I4(39);
                    break;
                  }
                  case 34: {
                    I4(34);
                    break;
                  }
                  default: {
                    w4 = 26;
                    break e;
                  }
                }
                switch (r3[72] = (r3[72] | 0) + 2, (k3(1) | 0) << 16 >> 16) {
                  case 125: {
                    w4 = 31;
                    break e;
                  }
                  case 44:
                    break;
                  default: {
                    w4 = 30;
                    break e;
                  }
                }
                if (r3[72] = (r3[72] | 0) + 2, (k3(1) | 0) << 16 >> 16 == 125) {
                  w4 = 31;
                  break;
                }
                a7 = r3[72] | 0;
              }
            if ((w4 | 0) == 22) {
              r3[72] = l3;
              break;
            } else if ((w4 | 0) == 26) {
              r3[72] = l3;
              break;
            } else if ((w4 | 0) == 30) {
              r3[72] = l3;
              break;
            } else if ((w4 | 0) == 31) {
              w4 = r3[63] | 0, r3[w4 + 16 >> 2] = h4, r3[w4 + 12 >> 2] = (r3[72] | 0) + 2;
              break;
            }
          }
        while (false);
      }
      f2(G4, "u");
      function pt(t3) {
        t3 = t3 | 0;
        e:
          do
            switch (d5[t3 >> 1] | 0) {
              case 100:
                switch (d5[t3 + -2 >> 1] | 0) {
                  case 105: {
                    t3 = O5(t3 + -4 | 0, 104, 2) | 0;
                    break e;
                  }
                  case 108: {
                    t3 = O5(t3 + -4 | 0, 108, 3) | 0;
                    break e;
                  }
                  default: {
                    t3 = 0;
                    break e;
                  }
                }
              case 101:
                switch (d5[t3 + -2 >> 1] | 0) {
                  case 115:
                    switch (d5[t3 + -4 >> 1] | 0) {
                      case 108: {
                        t3 = q2(t3 + -6 | 0, 101) | 0;
                        break e;
                      }
                      case 97: {
                        t3 = q2(t3 + -6 | 0, 99) | 0;
                        break e;
                      }
                      default: {
                        t3 = 0;
                        break e;
                      }
                    }
                  case 116: {
                    t3 = O5(t3 + -4 | 0, 114, 4) | 0;
                    break e;
                  }
                  case 117: {
                    t3 = O5(t3 + -4 | 0, 122, 6) | 0;
                    break e;
                  }
                  default: {
                    t3 = 0;
                    break e;
                  }
                }
              case 102: {
                if ((d5[t3 + -2 >> 1] | 0) == 111 && (d5[t3 + -4 >> 1] | 0) == 101)
                  switch (d5[t3 + -6 >> 1] | 0) {
                    case 99: {
                      t3 = O5(t3 + -8 | 0, 134, 6) | 0;
                      break e;
                    }
                    case 112: {
                      t3 = O5(t3 + -8 | 0, 146, 2) | 0;
                      break e;
                    }
                    default: {
                      t3 = 0;
                      break e;
                    }
                  }
                else
                  t3 = 0;
                break;
              }
              case 107: {
                t3 = O5(t3 + -2 | 0, 150, 4) | 0;
                break;
              }
              case 110: {
                t3 = t3 + -2 | 0, q2(t3, 105) | 0 ? t3 = 1 : t3 = O5(t3, 158, 5) | 0;
                break;
              }
              case 111: {
                t3 = q2(t3 + -2 | 0, 100) | 0;
                break;
              }
              case 114: {
                t3 = O5(t3 + -2 | 0, 168, 7) | 0;
                break;
              }
              case 116: {
                t3 = O5(t3 + -2 | 0, 182, 4) | 0;
                break;
              }
              case 119:
                switch (d5[t3 + -2 >> 1] | 0) {
                  case 101: {
                    t3 = q2(t3 + -4 | 0, 110) | 0;
                    break e;
                  }
                  case 111: {
                    t3 = O5(t3 + -4 | 0, 190, 3) | 0;
                    break e;
                  }
                  default: {
                    t3 = 0;
                    break e;
                  }
                }
              default:
                t3 = 0;
            }
          while (false);
        return t3 | 0;
      }
      f2(pt, "o");
      function Ee3() {
        var t3 = 0, a7 = 0, h4 = 0, l3 = 0;
        a7 = r3[73] | 0, h4 = r3[72] | 0;
        e:
          for (; ; ) {
            if (t3 = h4 + 2 | 0, h4 >>> 0 >= a7 >>> 0) {
              a7 = 10;
              break;
            }
            switch (d5[t3 >> 1] | 0) {
              case 96: {
                a7 = 7;
                break e;
              }
              case 36: {
                if ((d5[h4 + 4 >> 1] | 0) == 123) {
                  a7 = 6;
                  break e;
                }
                break;
              }
              case 92: {
                t3 = h4 + 4 | 0;
                break;
              }
              default:
            }
            h4 = t3;
          }
        (a7 | 0) == 6 ? (t3 = h4 + 4 | 0, r3[72] = t3, a7 = r3[70] | 0, l3 = d5[400] | 0, h4 = l3 & 65535, r3[a7 + (h4 << 3) >> 2] = 4, d5[400] = l3 + 1 << 16 >> 16, r3[a7 + (h4 << 3) + 4 >> 2] = t3) : (a7 | 0) == 7 ? (r3[72] = t3, h4 = r3[70] | 0, l3 = (d5[400] | 0) + -1 << 16 >> 16, d5[400] = l3, (r3[h4 + ((l3 & 65535) << 3) >> 2] | 0) != 3 && M3()) : (a7 | 0) == 10 && (r3[72] = t3, M3());
      }
      f2(Ee3, "h");
      function k3(t3) {
        t3 = t3 | 0;
        var a7 = 0, h4 = 0, l3 = 0;
        h4 = r3[72] | 0;
        e:
          do {
            a7 = d5[h4 >> 1] | 0;
            t:
              do
                if (a7 << 16 >> 16 != 47)
                  if (t3) {
                    if (P3(a7) | 0)
                      break;
                    break e;
                  } else {
                    if (ne(a7) | 0)
                      break;
                    break e;
                  }
                else
                  switch (d5[h4 + 2 >> 1] | 0) {
                    case 47: {
                      fe2();
                      break t;
                    }
                    case 42: {
                      le2(t3);
                      break t;
                    }
                    default: {
                      a7 = 47;
                      break e;
                    }
                  }
              while (false);
            l3 = r3[72] | 0, h4 = l3 + 2 | 0, r3[72] = h4;
          } while (l3 >>> 0 < (r3[73] | 0) >>> 0);
        return a7 | 0;
      }
      f2(k3, "w");
      function ce2(t3, a7, h4, l3) {
        t3 = t3 | 0, a7 = a7 | 0, h4 = h4 | 0, l3 = l3 | 0;
        var w4 = 0, m8 = 0;
        m8 = r3[67] | 0, r3[67] = m8 + 36, w4 = r3[63] | 0, r3[(w4 | 0 ? w4 + 32 | 0 : 236) >> 2] = m8, r3[64] = w4, r3[63] = m8, r3[m8 + 8 >> 2] = t3, (l3 | 0) == 2 ? (t3 = 3, w4 = h4) : (w4 = (l3 | 0) == 1, t3 = w4 ? 1 : 2, w4 = w4 ? h4 + 2 | 0 : 0), r3[m8 + 12 >> 2] = w4, r3[m8 + 28 >> 2] = t3, r3[m8 >> 2] = a7, r3[m8 + 4 >> 2] = h4, r3[m8 + 16 >> 2] = 0, r3[m8 + 20 >> 2] = l3, a7 = (l3 | 0) == 1, b3[m8 + 24 >> 0] = a7 & 1, r3[m8 + 32 >> 2] = 0, a7 | (l3 | 0) == 2 && (b3[803] = 1);
      }
      f2(ce2, "d");
      function I4(t3) {
        t3 = t3 | 0;
        var a7 = 0, h4 = 0, l3 = 0, w4 = 0;
        for (w4 = r3[73] | 0, a7 = r3[72] | 0; ; ) {
          if (l3 = a7 + 2 | 0, a7 >>> 0 >= w4 >>> 0) {
            a7 = 9;
            break;
          }
          if (h4 = d5[l3 >> 1] | 0, h4 << 16 >> 16 == t3 << 16 >> 16) {
            a7 = 10;
            break;
          }
          if (h4 << 16 >> 16 == 92)
            h4 = a7 + 4 | 0, (d5[h4 >> 1] | 0) == 13 ? (a7 = a7 + 6 | 0, a7 = (d5[a7 >> 1] | 0) == 10 ? a7 : h4) : a7 = h4;
          else if (Re2(h4) | 0) {
            a7 = 9;
            break;
          } else
            a7 = l3;
        }
        (a7 | 0) == 9 ? (r3[72] = l3, M3()) : (a7 | 0) == 10 && (r3[72] = l3);
      }
      f2(I4, "v");
      function Le2(t3, a7) {
        t3 = t3 | 0, a7 = a7 | 0;
        var h4 = 0, l3 = 0, w4 = 0, m8 = 0;
        return h4 = r3[72] | 0, l3 = d5[h4 >> 1] | 0, m8 = (t3 | 0) == (a7 | 0), w4 = m8 ? 0 : t3, m8 = m8 ? 0 : a7, l3 << 16 >> 16 == 97 && (r3[72] = h4 + 4, h4 = k3(1) | 0, t3 = r3[72] | 0, H3(h4) | 0 ? (I4(h4), a7 = (r3[72] | 0) + 2 | 0, r3[72] = a7) : (j2(h4) | 0, a7 = r3[72] | 0), l3 = k3(1) | 0, h4 = r3[72] | 0), (h4 | 0) != (t3 | 0) && B3(t3, a7, w4, m8), l3 | 0;
      }
      f2(Le2, "A");
      function wt() {
        var t3 = 0, a7 = 0, h4 = 0;
        h4 = r3[73] | 0, a7 = r3[72] | 0;
        e:
          for (; ; ) {
            if (t3 = a7 + 2 | 0, a7 >>> 0 >= h4 >>> 0) {
              a7 = 6;
              break;
            }
            switch (d5[t3 >> 1] | 0) {
              case 13:
              case 10: {
                a7 = 6;
                break e;
              }
              case 93: {
                a7 = 7;
                break e;
              }
              case 92: {
                t3 = a7 + 4 | 0;
                break;
              }
              default:
            }
            a7 = t3;
          }
        return (a7 | 0) == 6 ? (r3[72] = t3, M3(), t3 = 0) : (a7 | 0) == 7 && (r3[72] = t3, t3 = 93), t3 | 0;
      }
      f2(wt, "C");
      function ue2() {
        var t3 = 0, a7 = 0, h4 = 0;
        e:
          for (; ; ) {
            if (t3 = r3[72] | 0, a7 = t3 + 2 | 0, r3[72] = a7, t3 >>> 0 >= (r3[73] | 0) >>> 0) {
              h4 = 7;
              break;
            }
            switch (d5[a7 >> 1] | 0) {
              case 13:
              case 10: {
                h4 = 7;
                break e;
              }
              case 47:
                break e;
              case 91: {
                wt() | 0;
                break;
              }
              case 92: {
                r3[72] = t3 + 4;
                break;
              }
              default:
            }
          }
        (h4 | 0) == 7 && M3();
      }
      f2(ue2, "g");
      function mt(t3) {
        switch (t3 = t3 | 0, d5[t3 >> 1] | 0) {
          case 62: {
            t3 = (d5[t3 + -2 >> 1] | 0) == 61;
            break;
          }
          case 41:
          case 59: {
            t3 = 1;
            break;
          }
          case 104: {
            t3 = O5(t3 + -2 | 0, 210, 4) | 0;
            break;
          }
          case 121: {
            t3 = O5(t3 + -2 | 0, 218, 6) | 0;
            break;
          }
          case 101: {
            t3 = O5(t3 + -2 | 0, 230, 3) | 0;
            break;
          }
          default:
            t3 = 0;
        }
        return t3 | 0;
      }
      f2(mt, "p");
      function le2(t3) {
        t3 = t3 | 0;
        var a7 = 0, h4 = 0, l3 = 0, w4 = 0, m8 = 0;
        for (w4 = (r3[72] | 0) + 2 | 0, r3[72] = w4, h4 = r3[73] | 0; a7 = w4 + 2 | 0, !(w4 >>> 0 >= h4 >>> 0 || (l3 = d5[a7 >> 1] | 0, !t3 && Re2(l3) | 0)); ) {
          if (l3 << 16 >> 16 == 42 && (d5[w4 + 4 >> 1] | 0) == 47) {
            m8 = 8;
            break;
          }
          w4 = a7;
        }
        (m8 | 0) == 8 && (r3[72] = a7, a7 = w4 + 4 | 0), r3[72] = a7;
      }
      f2(le2, "y");
      function A3(t3, a7, h4) {
        t3 = t3 | 0, a7 = a7 | 0, h4 = h4 | 0;
        var l3 = 0, w4 = 0;
        e:
          do
            if (!h4)
              t3 = 0;
            else {
              for (; l3 = b3[t3 >> 0] | 0, w4 = b3[a7 >> 0] | 0, l3 << 24 >> 24 == w4 << 24 >> 24; )
                if (h4 = h4 + -1 | 0, h4)
                  t3 = t3 + 1 | 0, a7 = a7 + 1 | 0;
                else {
                  t3 = 0;
                  break e;
                }
              t3 = (l3 & 255) - (w4 & 255) | 0;
            }
          while (false);
        return t3 | 0;
      }
      f2(A3, "m");
      function te3(t3) {
        t3 = t3 | 0;
        e:
          do
            switch (t3 << 16 >> 16) {
              case 38:
              case 37:
              case 33: {
                t3 = 1;
                break;
              }
              default:
                if ((t3 & -8) << 16 >> 16 == 40 | (t3 + -58 & 65535) < 6)
                  t3 = 1;
                else {
                  switch (t3 << 16 >> 16) {
                    case 91:
                    case 93:
                    case 94: {
                      t3 = 1;
                      break e;
                    }
                    default:
                  }
                  t3 = (t3 + -123 & 65535) < 4;
                }
            }
          while (false);
        return t3 | 0;
      }
      f2(te3, "I");
      function kt(t3) {
        t3 = t3 | 0;
        e:
          do
            switch (t3 << 16 >> 16) {
              case 38:
              case 37:
              case 33:
                break;
              default:
                if (!((t3 + -58 & 65535) < 6 | (t3 + -40 & 65535) < 7 & t3 << 16 >> 16 != 41)) {
                  switch (t3 << 16 >> 16) {
                    case 91:
                    case 94:
                      break e;
                    default:
                  }
                  return t3 << 16 >> 16 != 125 & (t3 + -123 & 65535) < 4 | 0;
                }
            }
          while (false);
        return 1;
      }
      f2(kt, "U");
      function Oe2(t3) {
        t3 = t3 | 0;
        var a7 = 0;
        a7 = d5[t3 >> 1] | 0;
        e:
          do
            if ((a7 + -9 & 65535) >= 5) {
              switch (a7 << 16 >> 16) {
                case 160:
                case 32: {
                  a7 = 1;
                  break e;
                }
                default:
              }
              if (te3(a7) | 0)
                return a7 << 16 >> 16 != 46 | (de3(t3) | 0) | 0;
              a7 = 0;
            } else
              a7 = 1;
          while (false);
        return a7 | 0;
      }
      f2(Oe2, "x");
      function yt(t3) {
        t3 = t3 | 0;
        var a7 = 0, h4 = 0, l3 = 0, w4 = 0;
        return h4 = E6, E6 = E6 + 16 | 0, l3 = h4, r3[l3 >> 2] = 0, r3[66] = t3, a7 = r3[3] | 0, w4 = a7 + (t3 << 1) | 0, t3 = w4 + 2 | 0, d5[w4 >> 1] = 0, r3[l3 >> 2] = t3, r3[67] = t3, r3[59] = 0, r3[63] = 0, r3[61] = 0, r3[60] = 0, r3[65] = 0, r3[62] = 0, E6 = h4, a7 | 0;
      }
      f2(yt, "S");
      function B3(t3, a7, h4, l3) {
        t3 = t3 | 0, a7 = a7 | 0, h4 = h4 | 0, l3 = l3 | 0;
        var w4 = 0, m8 = 0;
        w4 = r3[67] | 0, r3[67] = w4 + 20, m8 = r3[65] | 0, r3[(m8 | 0 ? m8 + 16 | 0 : 240) >> 2] = w4, r3[65] = w4, r3[w4 >> 2] = t3, r3[w4 + 4 >> 2] = a7, r3[w4 + 8 >> 2] = h4, r3[w4 + 12 >> 2] = l3, r3[w4 + 16 >> 2] = 0, b3[803] = 1;
      }
      f2(B3, "O");
      function O5(t3, a7, h4) {
        t3 = t3 | 0, a7 = a7 | 0, h4 = h4 | 0;
        var l3 = 0, w4 = 0;
        return l3 = t3 + (0 - h4 << 1) | 0, w4 = l3 + 2 | 0, t3 = r3[3] | 0, w4 >>> 0 >= t3 >>> 0 && !(A3(w4, a7, h4 << 1) | 0) ? (w4 | 0) == (t3 | 0) ? t3 = 1 : t3 = Oe2(l3) | 0 : t3 = 0, t3 | 0;
      }
      f2(O5, "$");
      function Ct(t3) {
        switch (t3 = t3 | 0, d5[t3 >> 1] | 0) {
          case 107: {
            t3 = O5(t3 + -2 | 0, 150, 4) | 0;
            break;
          }
          case 101: {
            (d5[t3 + -2 >> 1] | 0) == 117 ? t3 = O5(t3 + -4 | 0, 122, 6) | 0 : t3 = 0;
            break;
          }
          default:
            t3 = 0;
        }
        return t3 | 0;
      }
      f2(Ct, "j");
      function q2(t3, a7) {
        t3 = t3 | 0, a7 = a7 | 0;
        var h4 = 0;
        return h4 = r3[3] | 0, h4 >>> 0 <= t3 >>> 0 && (d5[t3 >> 1] | 0) == a7 << 16 >> 16 ? (h4 | 0) == (t3 | 0) ? h4 = 1 : h4 = he2(d5[t3 + -2 >> 1] | 0) | 0 : h4 = 0, h4 | 0;
      }
      f2(q2, "B");
      function he2(t3) {
        t3 = t3 | 0;
        e:
          do
            if ((t3 + -9 & 65535) < 5)
              t3 = 1;
            else {
              switch (t3 << 16 >> 16) {
                case 32:
                case 160: {
                  t3 = 1;
                  break e;
                }
                default:
              }
              t3 = t3 << 16 >> 16 != 46 & (te3(t3) | 0);
            }
          while (false);
        return t3 | 0;
      }
      f2(he2, "E");
      function fe2() {
        var t3 = 0, a7 = 0, h4 = 0;
        t3 = r3[73] | 0, h4 = r3[72] | 0;
        e:
          for (; a7 = h4 + 2 | 0, !(h4 >>> 0 >= t3 >>> 0); )
            switch (d5[a7 >> 1] | 0) {
              case 13:
              case 10:
                break e;
              default:
                h4 = a7;
            }
        r3[72] = a7;
      }
      f2(fe2, "P");
      function j2(t3) {
        for (t3 = t3 | 0; !(P3(t3) | 0 || te3(t3) | 0); )
          if (t3 = (r3[72] | 0) + 2 | 0, r3[72] = t3, t3 = d5[t3 >> 1] | 0, !(t3 << 16 >> 16)) {
            t3 = 0;
            break;
          }
        return t3 | 0;
      }
      f2(j2, "q");
      function St() {
        var t3 = 0;
        switch (t3 = r3[(r3[61] | 0) + 20 >> 2] | 0, t3 | 0) {
          case 1: {
            t3 = -1;
            break;
          }
          case 2: {
            t3 = -2;
            break;
          }
          default:
            t3 = t3 - (r3[3] | 0) >> 1;
        }
        return t3 | 0;
      }
      f2(St, "z");
      function xt(t3) {
        return t3 = t3 | 0, !(O5(t3, 196, 5) | 0) && !(O5(t3, 44, 3) | 0) ? t3 = O5(t3, 206, 2) | 0 : t3 = 1, t3 | 0;
      }
      f2(xt, "D");
      function ne(t3) {
        switch (t3 = t3 | 0, t3 << 16 >> 16) {
          case 160:
          case 32:
          case 12:
          case 11:
          case 9: {
            t3 = 1;
            break;
          }
          default:
            t3 = 0;
        }
        return t3 | 0;
      }
      f2(ne, "F");
      function de3(t3) {
        return t3 = t3 | 0, (d5[t3 >> 1] | 0) == 46 && (d5[t3 + -2 >> 1] | 0) == 46 ? t3 = (d5[t3 + -4 >> 1] | 0) == 46 : t3 = 0, t3 | 0;
      }
      f2(de3, "G");
      function z3(t3) {
        return t3 = t3 | 0, (r3[3] | 0) == (t3 | 0) ? t3 = 1 : t3 = Oe2(t3 + -2 | 0) | 0, t3 | 0;
      }
      f2(z3, "H");
      function vt() {
        var t3 = 0;
        return t3 = r3[(r3[62] | 0) + 12 >> 2] | 0, t3 ? t3 = t3 - (r3[3] | 0) >> 1 : t3 = -1, t3 | 0;
      }
      f2(vt, "J");
      function _t() {
        var t3 = 0;
        return t3 = r3[(r3[61] | 0) + 12 >> 2] | 0, t3 ? t3 = t3 - (r3[3] | 0) >> 1 : t3 = -1, t3 | 0;
      }
      f2(_t, "K");
      function Et() {
        var t3 = 0;
        return t3 = r3[(r3[62] | 0) + 8 >> 2] | 0, t3 ? t3 = t3 - (r3[3] | 0) >> 1 : t3 = -1, t3 | 0;
      }
      f2(Et, "L");
      function Lt() {
        var t3 = 0;
        return t3 = r3[(r3[61] | 0) + 16 >> 2] | 0, t3 ? t3 = t3 - (r3[3] | 0) >> 1 : t3 = -1, t3 | 0;
      }
      f2(Lt, "M");
      function Ot() {
        var t3 = 0;
        return t3 = r3[(r3[61] | 0) + 4 >> 2] | 0, t3 ? t3 = t3 - (r3[3] | 0) >> 1 : t3 = -1, t3 | 0;
      }
      f2(Ot, "N");
      function Rt() {
        var t3 = 0;
        return t3 = r3[61] | 0, t3 = r3[(t3 | 0 ? t3 + 32 | 0 : 236) >> 2] | 0, r3[61] = t3, (t3 | 0) != 0 | 0;
      }
      f2(Rt, "Q");
      function At() {
        var t3 = 0;
        return t3 = r3[62] | 0, t3 = r3[(t3 | 0 ? t3 + 16 | 0 : 240) >> 2] | 0, r3[62] = t3, (t3 | 0) != 0 | 0;
      }
      f2(At, "R");
      function M3() {
        b3[802] = 1, r3[68] = (r3[72] | 0) - (r3[3] | 0) >> 1, r3[72] = (r3[73] | 0) + 2;
      }
      f2(M3, "T");
      function P3(t3) {
        return t3 = t3 | 0, (t3 | 128) << 16 >> 16 == 160 | (t3 + -9 & 65535) < 5 | 0;
      }
      f2(P3, "V");
      function H3(t3) {
        return t3 = t3 | 0, t3 << 16 >> 16 == 39 | t3 << 16 >> 16 == 34 | 0;
      }
      f2(H3, "W");
      function Nt() {
        return (r3[(r3[61] | 0) + 8 >> 2] | 0) - (r3[3] | 0) >> 1 | 0;
      }
      f2(Nt, "X");
      function It() {
        return (r3[(r3[62] | 0) + 4 >> 2] | 0) - (r3[3] | 0) >> 1 | 0;
      }
      f2(It, "Y");
      function Re2(t3) {
        return t3 = t3 | 0, t3 << 16 >> 16 == 13 | t3 << 16 >> 16 == 10 | 0;
      }
      f2(Re2, "Z");
      function Mt() {
        return (r3[r3[61] >> 2] | 0) - (r3[3] | 0) >> 1 | 0;
      }
      f2(Mt, "_");
      function $t() {
        return (r3[r3[62] >> 2] | 0) - (r3[3] | 0) >> 1 | 0;
      }
      f2($t, "ee");
      function Ut() {
        return R6[(r3[61] | 0) + 24 >> 0] | 0 | 0;
      }
      f2(Ut, "ae");
      function jt(t3) {
        t3 = t3 | 0, r3[3] = t3;
      }
      f2(jt, "re");
      function Dt() {
        return r3[(r3[61] | 0) + 28 >> 2] | 0;
      }
      f2(Dt, "ie");
      function Tt() {
        return (b3[803] | 0) != 0 | 0;
      }
      f2(Tt, "se");
      function Ft() {
        return (b3[804] | 0) != 0 | 0;
      }
      f2(Ft, "fe");
      function Wt() {
        return r3[68] | 0;
      }
      f2(Wt, "te");
      function Bt(t3) {
        return t3 = t3 | 0, E6 = t3 + 992 + 15 & -16, 992;
      }
      return f2(Bt, "ce"), { su: Bt, ai: Lt, e: Wt, ee: It, ele: vt, els: Et, es: $t, f: Ft, id: St, ie: Ot, ip: Ut, is: Mt, it: Dt, ms: Tt, p: N2, re: At, ri: Rt, sa: yt, se: _t, ses: jt, ss: Nt };
    }(typeof self < "u" ? self : global, {}, re2), ke2 = v2.su(Z2 - (2 << 17));
  }
  const i6 = _2.length + 1;
  v2.ses(ke2), v2.sa(i6 - 1), Fe2(_2, new Uint16Array(re2, ke2, i6)), v2.p() || (y = v2.e(), D());
  const o8 = [], c3 = [];
  for (; v2.ri(); ) {
    const u5 = v2.is(), p5 = v2.ie(), g2 = v2.ai(), b3 = v2.id(), d5 = v2.ss(), r3 = v2.se(), R6 = v2.it();
    let L3;
    v2.ip() && (L3 = ye2(b3 === -1 ? u5 : u5 + 1, _2.charCodeAt(b3 === -1 ? u5 - 1 : u5))), o8.push({ t: R6, n: L3, s: u5, e: p5, ss: d5, se: r3, d: b3, a: g2 });
  }
  for (; v2.re(); ) {
    const u5 = v2.es(), p5 = v2.ee(), g2 = v2.els(), b3 = v2.ele(), d5 = _2.charCodeAt(u5), r3 = g2 >= 0 ? _2.charCodeAt(g2) : -1;
    c3.push({ s: u5, e: p5, ls: g2, le: b3, n: d5 === 34 || d5 === 39 ? ye2(u5 + 1, d5) : _2.slice(u5, p5), ln: g2 < 0 ? void 0 : r3 === 34 || r3 === 39 ? ye2(g2 + 1, r3) : _2.slice(g2, b3) });
  }
  return [o8, c3, !!v2.f(), !!v2.ms()];
}
f2(fn, "parse");
function ye2(s5, e5) {
  y = s5;
  let n3 = "", i6 = y;
  for (; ; ) {
    y >= _2.length && D();
    const o8 = _2.charCodeAt(y);
    if (o8 === e5)
      break;
    o8 === 92 ? (n3 += _2.slice(i6, y), n3 += dn(), i6 = y) : (o8 === 8232 || o8 === 8233 || Be2(o8) && D(), ++y);
  }
  return n3 += _2.slice(i6, y++), n3;
}
f2(ye2, "b");
function dn() {
  let s5 = _2.charCodeAt(++y);
  switch (++y, s5) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(Ce(2));
    case 117:
      return function() {
        const e5 = _2.charCodeAt(y);
        let n3;
        return e5 === 123 ? (++y, n3 = Ce(_2.indexOf("}", y) - y), ++y, n3 > 1114111 && D()) : n3 = Ce(4), n3 <= 65535 ? String.fromCharCode(n3) : (n3 -= 65536, String.fromCharCode(55296 + (n3 >> 10), 56320 + (1023 & n3)));
      }();
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      _2.charCodeAt(y) === 10 && ++y;
    case 10:
      return "";
    case 56:
    case 57:
      D();
    default:
      if (s5 >= 48 && s5 <= 55) {
        let e5 = _2.substr(y - 1, 3).match(/^[0-7]+/)[0], n3 = parseInt(e5, 8);
        return n3 > 255 && (e5 = e5.slice(0, -1), n3 = parseInt(e5, 8)), y += e5.length - 1, s5 = _2.charCodeAt(y), e5 === "0" && s5 !== 56 && s5 !== 57 || D(), String.fromCharCode(n3);
      }
      return Be2(s5) ? "" : String.fromCharCode(s5);
  }
}
f2(dn, "k");
function Ce(s5) {
  const e5 = y;
  let n3 = 0, i6 = 0;
  for (let o8 = 0; o8 < s5; ++o8, ++y) {
    let c3, u5 = _2.charCodeAt(y);
    if (u5 !== 95) {
      if (u5 >= 97)
        c3 = u5 - 97 + 10;
      else if (u5 >= 65)
        c3 = u5 - 65 + 10;
      else {
        if (!(u5 >= 48 && u5 <= 57))
          break;
        c3 = u5 - 48;
      }
      if (c3 >= 16)
        break;
      i6 = u5, n3 = 16 * n3 + c3;
    } else
      i6 !== 95 && o8 !== 0 || D(), i6 = u5;
  }
  return i6 !== 95 && y - e5 === s5 || D(), n3;
}
f2(Ce, "l");
function Be2(s5) {
  return s5 === 13 || s5 === 10;
}
f2(Be2, "u");
function D() {
  throw Object.assign(Error(`Parse error ${We2}:${_2.slice(0, y).split(`
`).length}:${y - _2.lastIndexOf(`
`, y - 1)}`), { idx: y });
}
f2(D, "o");
var Se2;
typeof WebAssembly < "u" && (async () => {
  const { parse: s5, init: e5 } = await Promise.resolve().then(() => (init_lexer_DQCqS3nf(), lexer_DQCqS3nf_exports));
  await e5, Se2 = s5;
})();
var Pe2 = f2((s5, e5) => Se2 ? Se2(s5, e5) : fn(s5, e5), "parseEsm");
var gn = f2((s5) => {
  if (!s5.includes("import") && !s5.includes("export"))
    return false;
  try {
    return Pe2(s5)[3];
  } catch {
    return true;
  }
}, "isESM");
var Je2 = "2";
var bn = ((s5) => {
  const e5 = "default";
  return s5[e5] && typeof s5[e5] == "object" && "__esModule" in s5[e5] ? s5[e5] : s5;
}).toString();
var pn = `.then(${bn})`;
var xe2 = f2((s5, e5, n3) => {
  if (n3) {
    if (!e5.includes("import("))
      return;
  } else if (!e5.includes("import"))
    return;
  const o8 = Pe2(e5, s5)[0].filter((g2) => g2.d > -1);
  if (o8.length === 0)
    return;
  const c3 = new _e2(e5);
  for (const g2 of o8)
    c3.appendRight(g2.se, pn);
  const u5 = c3.toString(), p5 = c3.generateMap({ source: s5, includeContent: false, hires: "boundary" });
  return { code: u5, map: p5 };
}, "transformDynamicImport");
var Ge2 = f2((s5) => {
  try {
    const e5 = U2.readFileSync(s5, "utf8");
    return JSON.parse(e5);
  } catch {
  }
}, "readJsonFile");
var qe = f2(() => {
}, "noop");
var ze2 = f2(() => Math.floor(Date.now() / 1e8), "getTime");
var wn = class extends Map {
  static {
    f2(this, "FileCache");
  }
  cacheDirectory = e;
  oldCacheDirectory = X2.join(Xt.tmpdir(), "tsx");
  cacheFiles;
  constructor() {
    super(), U2.mkdirSync(this.cacheDirectory, { recursive: true }), this.cacheFiles = U2.readdirSync(this.cacheDirectory).map((e5) => {
      const [n3, i6] = e5.split("-");
      return { time: Number(n3), key: i6, fileName: e5 };
    }), setImmediate(() => {
      this.expireDiskCache(), this.removeOldCacheDirectory();
    });
  }
  get(e5) {
    const n3 = super.get(e5);
    if (n3)
      return n3;
    const i6 = this.cacheFiles.find((u5) => u5.key === e5);
    if (!i6)
      return;
    const o8 = X2.join(this.cacheDirectory, i6.fileName), c3 = Ge2(o8);
    if (!c3) {
      U2.promises.unlink(o8).then(() => {
        const u5 = this.cacheFiles.indexOf(i6);
        this.cacheFiles.splice(u5, 1);
      }, () => {
      });
      return;
    }
    return super.set(e5, c3), c3;
  }
  set(e5, n3) {
    if (super.set(e5, n3), n3) {
      const i6 = ze2();
      U2.promises.writeFile(X2.join(this.cacheDirectory, `${i6}-${e5}`), JSON.stringify(n3)).catch(qe);
    }
    return this;
  }
  expireDiskCache() {
    const e5 = ze2();
    for (const n3 of this.cacheFiles)
      e5 - n3.time > 7 && U2.promises.unlink(X2.join(this.cacheDirectory, n3.fileName)).catch(qe);
  }
  async removeOldCacheDirectory() {
    try {
      await U2.promises.access(this.oldCacheDirectory).then(() => true) && ("rm" in U2.promises ? await U2.promises.rm(this.oldCacheDirectory, { recursive: true, force: true }) : await U2.promises.rmdir(this.oldCacheDirectory, { recursive: true }));
    } catch {
    }
  }
};
var ie2 = process.env.TSX_DISABLE_CACHE ? /* @__PURE__ */ new Map() : new wn();
var mn = /^[\w+.-]+:\/\//;
var kn = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var yn = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function Cn(s5) {
  return mn.test(s5);
}
f2(Cn, "isAbsoluteUrl");
function Sn(s5) {
  return s5.startsWith("//");
}
f2(Sn, "isSchemeRelativeUrl");
function He2(s5) {
  return s5.startsWith("/");
}
f2(He2, "isAbsolutePath");
function xn(s5) {
  return s5.startsWith("file:");
}
f2(xn, "isFileUrl");
function Xe2(s5) {
  return /^[.?#]/.test(s5);
}
f2(Xe2, "isRelative");
function se2(s5) {
  const e5 = kn.exec(s5);
  return Ke(e5[1], e5[2] || "", e5[3], e5[4] || "", e5[5] || "/", e5[6] || "", e5[7] || "");
}
f2(se2, "parseAbsoluteUrl");
function vn(s5) {
  const e5 = yn.exec(s5), n3 = e5[2];
  return Ke("file:", "", e5[1] || "", "", He2(n3) ? n3 : "/" + n3, e5[3] || "", e5[4] || "");
}
f2(vn, "parseFileUrl");
function Ke(s5, e5, n3, i6, o8, c3, u5) {
  return { scheme: s5, user: e5, host: n3, port: i6, path: o8, query: c3, hash: u5, type: 7 };
}
f2(Ke, "makeUrl");
function Ye(s5) {
  if (Sn(s5)) {
    const n3 = se2("http:" + s5);
    return n3.scheme = "", n3.type = 6, n3;
  }
  if (He2(s5)) {
    const n3 = se2("http://foo.com" + s5);
    return n3.scheme = "", n3.host = "", n3.type = 5, n3;
  }
  if (xn(s5))
    return vn(s5);
  if (Cn(s5))
    return se2(s5);
  const e5 = se2("http://foo.com/" + s5);
  return e5.scheme = "", e5.host = "", e5.type = s5 ? s5.startsWith("?") ? 3 : s5.startsWith("#") ? 2 : 4 : 1, e5;
}
f2(Ye, "parseUrl");
function _n(s5) {
  if (s5.endsWith("/.."))
    return s5;
  const e5 = s5.lastIndexOf("/");
  return s5.slice(0, e5 + 1);
}
f2(_n, "stripPathFilename");
function En(s5, e5) {
  Qe2(e5, e5.type), s5.path === "/" ? s5.path = e5.path : s5.path = _n(e5.path) + s5.path;
}
f2(En, "mergePaths");
function Qe2(s5, e5) {
  const n3 = e5 <= 4, i6 = s5.path.split("/");
  let o8 = 1, c3 = 0, u5 = false;
  for (let g2 = 1; g2 < i6.length; g2++) {
    const b3 = i6[g2];
    if (!b3) {
      u5 = true;
      continue;
    }
    if (u5 = false, b3 !== ".") {
      if (b3 === "..") {
        c3 ? (u5 = true, c3--, o8--) : n3 && (i6[o8++] = b3);
        continue;
      }
      i6[o8++] = b3, c3++;
    }
  }
  let p5 = "";
  for (let g2 = 1; g2 < o8; g2++)
    p5 += "/" + i6[g2];
  (!p5 || u5 && !p5.endsWith("/..")) && (p5 += "/"), s5.path = p5;
}
f2(Qe2, "normalizePath");
function Ln(s5, e5) {
  if (!s5 && !e5)
    return "";
  const n3 = Ye(s5);
  let i6 = n3.type;
  if (e5 && i6 !== 7) {
    const c3 = Ye(e5), u5 = c3.type;
    switch (i6) {
      case 1:
        n3.hash = c3.hash;
      case 2:
        n3.query = c3.query;
      case 3:
      case 4:
        En(n3, c3);
      case 5:
        n3.user = c3.user, n3.host = c3.host, n3.port = c3.port;
      case 6:
        n3.scheme = c3.scheme;
    }
    u5 > i6 && (i6 = u5);
  }
  Qe2(n3, i6);
  const o8 = n3.query + n3.hash;
  switch (i6) {
    case 2:
    case 3:
      return o8;
    case 4: {
      const c3 = n3.path.slice(1);
      return c3 ? Xe2(e5 || s5) && !Xe2(c3) ? "./" + c3 + o8 : c3 + o8 : o8 || ".";
    }
    case 5:
      return n3.path + o8;
    default:
      return n3.scheme + "//" + n3.user + n3.host + n3.port + n3.path + o8;
  }
}
f2(Ln, "resolve$1");
function Ze(s5, e5) {
  return e5 && !e5.endsWith("/") && (e5 += "/"), Ln(s5, e5);
}
f2(Ze, "resolve");
function On(s5) {
  if (!s5)
    return "";
  const e5 = s5.lastIndexOf("/");
  return s5.slice(0, e5 + 1);
}
f2(On, "stripFilename");
var F2 = 0;
function Rn(s5, e5) {
  const n3 = Ve2(s5, 0);
  if (n3 === s5.length)
    return s5;
  e5 || (s5 = s5.slice());
  for (let i6 = n3; i6 < s5.length; i6 = Ve2(s5, i6 + 1))
    s5[i6] = Nn(s5[i6], e5);
  return s5;
}
f2(Rn, "maybeSort");
function Ve2(s5, e5) {
  for (let n3 = e5; n3 < s5.length; n3++)
    if (!An(s5[n3]))
      return n3;
  return s5.length;
}
f2(Ve2, "nextUnsortedSegmentLine");
function An(s5) {
  for (let e5 = 1; e5 < s5.length; e5++)
    if (s5[e5][F2] < s5[e5 - 1][F2])
      return false;
  return true;
}
f2(An, "isSorted");
function Nn(s5, e5) {
  return e5 || (s5 = s5.slice()), s5.sort(In);
}
f2(Nn, "sortSegments");
function In(s5, e5) {
  return s5[F2] - e5[F2];
}
f2(In, "sortComparator");
var oe2 = false;
function Mn(s5, e5, n3, i6) {
  for (; n3 <= i6; ) {
    const o8 = n3 + (i6 - n3 >> 1), c3 = s5[o8][F2] - e5;
    if (c3 === 0)
      return oe2 = true, o8;
    c3 < 0 ? n3 = o8 + 1 : i6 = o8 - 1;
  }
  return oe2 = false, n3 - 1;
}
f2(Mn, "binarySearch");
function $n(s5, e5, n3) {
  for (let i6 = n3 - 1; i6 >= 0 && s5[i6][F2] === e5; n3 = i6--)
    ;
  return n3;
}
f2($n, "lowerBound");
function Un() {
  return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
}
f2(Un, "memoizedState");
function jn(s5, e5, n3, i6) {
  const { lastKey: o8, lastNeedle: c3, lastIndex: u5 } = n3;
  let p5 = 0, g2 = s5.length - 1;
  if (i6 === o8) {
    if (e5 === c3)
      return oe2 = u5 !== -1 && s5[u5][F2] === e5, u5;
    e5 >= c3 ? p5 = u5 === -1 ? 0 : u5 : g2 = u5;
  }
  return n3.lastKey = i6, n3.lastNeedle = e5, n3.lastIndex = Mn(s5, e5, p5, g2);
}
f2(jn, "memoizedBinarySearch");
var et = class {
  static {
    f2(this, "TraceMap");
  }
  constructor(e5, n3) {
    const i6 = typeof e5 == "string";
    if (!i6 && e5._decodedMemo)
      return e5;
    const o8 = i6 ? JSON.parse(e5) : e5, { version: c3, file: u5, names: p5, sourceRoot: g2, sources: b3, sourcesContent: d5 } = o8;
    this.version = c3, this.file = u5, this.names = p5 || [], this.sourceRoot = g2, this.sources = b3, this.sourcesContent = d5, this.ignoreList = o8.ignoreList || o8.x_google_ignoreList || void 0;
    const r3 = Ze(g2 || "", On(n3));
    this.resolvedSources = b3.map((L3) => Ze(L3 || "", r3));
    const { mappings: R6 } = o8;
    typeof R6 == "string" ? (this._encoded = R6, this._decoded = void 0) : (this._encoded = void 0, this._decoded = Rn(R6, i6)), this._decodedMemo = Un(), this._bySources = void 0, this._bySourceMemos = void 0;
  }
};
function vr(s5) {
  return s5;
}
f2(vr, "cast$2");
function tt(s5) {
  var e5;
  return (e5 = s5)._decoded || (e5._decoded = Qt(s5._encoded));
}
f2(tt, "decodedMappings");
function Dn(s5, e5, n3) {
  const i6 = tt(s5);
  if (e5 >= i6.length)
    return null;
  const o8 = i6[e5], c3 = Tn(o8, s5._decodedMemo, e5, n3);
  return c3 === -1 ? null : o8[c3];
}
f2(Dn, "traceSegment");
function Tn(s5, e5, n3, i6, o8) {
  let c3 = jn(s5, i6, e5, n3);
  return oe2 && (c3 = $n(s5, i6, c3)), c3 === -1 || c3 === s5.length ? -1 : c3;
}
f2(Tn, "traceSegmentInternal");
var ve2 = class {
  static {
    f2(this, "SetArray");
  }
  constructor() {
    this._indexes = { __proto__: null }, this.array = [];
  }
};
function _r(s5) {
  return s5;
}
f2(_r, "cast$1");
function nt(s5, e5) {
  return s5._indexes[e5];
}
f2(nt, "get");
function V2(s5, e5) {
  const n3 = nt(s5, e5);
  if (n3 !== void 0)
    return n3;
  const { array: i6, _indexes: o8 } = s5, c3 = i6.push(e5);
  return o8[e5] = c3 - 1;
}
f2(V2, "put");
function Fn(s5, e5) {
  const n3 = nt(s5, e5);
  if (n3 === void 0)
    return;
  const { array: i6, _indexes: o8 } = s5;
  for (let c3 = n3 + 1; c3 < i6.length; c3++) {
    const u5 = i6[c3];
    i6[c3 - 1] = u5, o8[u5]--;
  }
  o8[e5] = void 0, i6.pop();
}
f2(Fn, "remove");
var Wn = 0;
var Bn = 1;
var Pn = 2;
var Jn = 3;
var Gn = 4;
var rt = -1;
var qn = class {
  static {
    f2(this, "GenMapping");
  }
  constructor({ file: e5, sourceRoot: n3 } = {}) {
    this._names = new ve2(), this._sources = new ve2(), this._sourcesContent = [], this._mappings = [], this.file = e5, this.sourceRoot = n3, this._ignoreList = new ve2();
  }
};
function Er(s5) {
  return s5;
}
f2(Er, "cast");
var zn = f2((s5, e5, n3, i6, o8, c3, u5, p5) => Yn(true, s5, e5, n3, i6, o8, c3, u5), "maybeAddSegment");
function Hn(s5, e5, n3) {
  const { _sources: i6, _sourcesContent: o8 } = s5, c3 = V2(i6, e5);
  o8[c3] = n3;
}
f2(Hn, "setSourceContent");
function Xn(s5, e5, n3 = true) {
  const { _sources: i6, _sourcesContent: o8, _ignoreList: c3 } = s5, u5 = V2(i6, e5);
  u5 === o8.length && (o8[u5] = null), n3 ? V2(c3, u5) : Fn(c3, u5);
}
f2(Xn, "setIgnore");
function it(s5) {
  const { _mappings: e5, _sources: n3, _sourcesContent: i6, _names: o8, _ignoreList: c3 } = s5;
  return Vn(e5), { version: 3, file: s5.file || void 0, names: o8.array, sourceRoot: s5.sourceRoot || void 0, sources: n3.array, sourcesContent: i6, mappings: e5, ignoreList: c3.array };
}
f2(it, "toDecodedMap");
function Kn(s5) {
  const e5 = it(s5);
  return Object.assign(Object.assign({}, e5), { mappings: De2(e5.mappings) });
}
f2(Kn, "toEncodedMap");
function Yn(s5, e5, n3, i6, o8, c3, u5, p5, g2) {
  const { _mappings: b3, _sources: d5, _sourcesContent: r3, _names: R6 } = e5, L3 = Qn(b3, n3), E6 = Zn(L3, i6);
  if (!o8)
    return er(L3, E6) ? void 0 : st(L3, E6, [i6]);
  const N2 = V2(d5, o8), $3 = p5 ? V2(R6, p5) : rt;
  if (N2 === r3.length && (r3[N2] = null), !tr(L3, E6, N2, c3, u5, $3))
    return st(L3, E6, p5 ? [i6, N2, c3, u5, $3] : [i6, N2, c3, u5]);
}
f2(Yn, "addSegmentInternal");
function Qn(s5, e5) {
  for (let n3 = s5.length; n3 <= e5; n3++)
    s5[n3] = [];
  return s5[e5];
}
f2(Qn, "getLine");
function Zn(s5, e5) {
  let n3 = s5.length;
  for (let i6 = n3 - 1; i6 >= 0; n3 = i6--) {
    const o8 = s5[i6];
    if (e5 >= o8[Wn])
      break;
  }
  return n3;
}
f2(Zn, "getColumnIndex");
function st(s5, e5, n3) {
  for (let i6 = s5.length; i6 > e5; i6--)
    s5[i6] = s5[i6 - 1];
  s5[e5] = n3;
}
f2(st, "insert");
function Vn(s5) {
  const { length: e5 } = s5;
  let n3 = e5;
  for (let i6 = n3 - 1; i6 >= 0 && !(s5[i6].length > 0); n3 = i6, i6--)
    ;
  n3 < e5 && (s5.length = n3);
}
f2(Vn, "removeEmptyFinalLines");
function er(s5, e5) {
  return e5 === 0 ? true : s5[e5 - 1].length === 1;
}
f2(er, "skipSourceless");
function tr(s5, e5, n3, i6, o8, c3) {
  if (e5 === 0)
    return false;
  const u5 = s5[e5 - 1];
  return u5.length === 1 ? false : n3 === u5[Bn] && i6 === u5[Pn] && o8 === u5[Jn] && c3 === (u5.length === 5 ? u5[Gn] : rt);
}
f2(tr, "skipSource");
var ot = at("", -1, -1, "", null, false);
var nr = [];
function at(s5, e5, n3, i6, o8, c3) {
  return { source: s5, line: e5, column: n3, name: i6, content: o8, ignore: c3 };
}
f2(at, "SegmentObject");
function ct(s5, e5, n3, i6, o8) {
  return { map: s5, sources: e5, source: n3, content: i6, ignore: o8 };
}
f2(ct, "Source");
function ut(s5, e5) {
  return ct(s5, e5, "", null, false);
}
f2(ut, "MapSource");
function rr(s5, e5, n3) {
  return ct(null, nr, s5, e5, n3);
}
f2(rr, "OriginalSource");
function ir(s5) {
  const e5 = new qn({ file: s5.map.file }), { sources: n3, map: i6 } = s5, o8 = i6.names, c3 = tt(i6);
  for (let u5 = 0; u5 < c3.length; u5++) {
    const p5 = c3[u5];
    for (let g2 = 0; g2 < p5.length; g2++) {
      const b3 = p5[g2], d5 = b3[0];
      let r3 = ot;
      if (b3.length !== 1) {
        const G4 = n3[b3[1]];
        if (r3 = lt(G4, b3[2], b3[3], b3.length === 5 ? o8[b3[4]] : ""), r3 == null)
          continue;
      }
      const { column: R6, line: L3, name: E6, content: N2, source: $3, ignore: W2 } = r3;
      zn(e5, u5, d5, $3, L3, R6, E6), $3 && N2 != null && Hn(e5, $3, N2), W2 && Xn(e5, $3, true);
    }
  }
  return e5;
}
f2(ir, "traceMappings");
function lt(s5, e5, n3, i6) {
  if (!s5.map)
    return at(s5.source, e5, n3, i6, s5.content, s5.ignore);
  const o8 = Dn(s5.map, e5, n3);
  return o8 == null ? null : o8.length === 1 ? ot : lt(s5.sources[o8[1]], o8[2], o8[3], o8.length === 5 ? s5.map.names[o8[4]] : i6);
}
f2(lt, "originalPositionFor");
function sr(s5) {
  return Array.isArray(s5) ? s5 : [s5];
}
f2(sr, "asArray");
function or(s5, e5) {
  const n3 = sr(s5).map((c3) => new et(c3, "")), i6 = n3.pop();
  for (let c3 = 0; c3 < n3.length; c3++)
    if (n3[c3].sources.length > 1)
      throw new Error(`Transformation map ${c3} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
  let o8 = ht(i6, e5, "", 0);
  for (let c3 = n3.length - 1; c3 >= 0; c3--)
    o8 = ut(n3[c3], [o8]);
  return o8;
}
f2(or, "buildSourceMapTree");
function ht(s5, e5, n3, i6) {
  const { resolvedSources: o8, sourcesContent: c3, ignoreList: u5 } = s5, p5 = i6 + 1, g2 = o8.map((b3, d5) => {
    const r3 = { importer: n3, depth: p5, source: b3 || "", content: void 0, ignore: void 0 }, R6 = e5(r3.source, r3), { source: L3, content: E6, ignore: N2 } = r3;
    if (R6)
      return ht(new et(R6, L3), e5, L3, p5);
    const $3 = E6 !== void 0 ? E6 : c3 ? c3[d5] : null, W2 = N2 !== void 0 ? N2 : u5 ? u5.includes(d5) : false;
    return rr(L3, $3, W2);
  });
  return ut(s5, g2);
}
f2(ht, "build");
var ar = class {
  static {
    f2(this, "SourceMap");
  }
  constructor(e5, n3) {
    const i6 = n3.decodedMappings ? it(e5) : Kn(e5);
    this.version = i6.version, this.file = i6.file, this.mappings = i6.mappings, this.names = i6.names, this.ignoreList = i6.ignoreList, this.sourceRoot = i6.sourceRoot, this.sources = i6.sources, n3.excludeContent || (this.sourcesContent = i6.sourcesContent);
  }
  toString() {
    return JSON.stringify(this);
  }
};
function ft(s5, e5, n3) {
  const i6 = { excludeContent: !!n3, decodedMappings: false }, o8 = or(s5, e5);
  return new ar(ir(o8), i6);
}
f2(ft, "remapping");
var cr = f2((s5, e5, n3) => {
  const i6 = [], o8 = { code: e5 };
  for (const c3 of n3) {
    const u5 = c3(s5, o8.code);
    u5 && (Object.assign(o8, u5), i6.unshift(u5.map));
  }
  return { ...o8, map: ft(i6, () => null) };
}, "applyTransformersSync");
var ur = f2(async (s5, e5, n3) => {
  const i6 = [], o8 = { code: e5 };
  for (const c3 of n3) {
    const u5 = await c3(s5, o8.code);
    u5 && (Object.assign(o8, u5), i6.unshift(u5.map));
  }
  return { ...o8, map: ft(i6, () => null) };
}, "applyTransformers");
var lr = Object.freeze({ target: `node${process.versions.node}`, loader: "default" });
var hr = /^--inspect(?:-brk|-port|-publish-uid|-wait)?(?:=|$)/;
var fr = process.execArgv.some((s5) => hr.test(s5));
var dt = { ...lr, sourcemap: true, sourcesContent: !!process.env.NODE_V8_COVERAGE || fr, minifyWhitespace: true, keepNames: true };
var gt = f2((s5) => {
  const e5 = s5.sourcefile;
  if (e5) {
    const n3 = X2.extname(e5.split("?")[0]);
    n3 ? n3 === ".cts" || n3 === ".mts" ? s5.sourcefile = `${e5.slice(0, -3)}ts` : n3 === ".mjs" && (s5.sourcefile = `${e5.slice(0, -3)}js`) : s5.sourcefile += ".js";
  }
  return (n3) => (n3.map && (s5.sourcefile !== e5 && (n3.map = n3.map.replace(JSON.stringify(s5.sourcefile), JSON.stringify(e5))), n3.map = JSON.parse(n3.map)), n3);
}, "patchOptions");
var bt = f2((s5) => {
  throw s5.name = "TransformError", delete s5.errors, delete s5.warnings, s5;
}, "formatEsbuildError");
var dr = f2((s5, e5, n3) => {
  const i6 = {};
  let o8, c3, u5;
  if (e5.startsWith("file://")) {
    o8 = e5;
    const d5 = new URL(e5);
    c3 = Jt(d5);
  } else
    [c3, u5] = e5.split("?"), o8 = Gt(c3) + (u5 ? `?${u5}` : "");
  c3.endsWith(".cjs") || c3.endsWith(".cts") || (i6["import.meta.url"] = JSON.stringify(o8));
  const p5 = { ...dt, format: "cjs", sourcefile: c3, define: i6, banner: `__filename=${JSON.stringify(c3)};(()=>{`, footer: "})()", platform: "node", ...n3 }, g2 = Ne2([s5, JSON.stringify(p5), import_esbuild.version, Je2].join("-"));
  let b3 = ie2.get(g2);
  return b3 || (b3 = cr(e5, s5, [(d5, r3) => {
    const R6 = gt(p5);
    let L3;
    try {
      L3 = (0, import_esbuild.transformSync)(r3, p5);
    } catch (E6) {
      throw bt(E6);
    }
    return R6(L3);
  }, (d5, r3) => xe2(d5, r3, true)]), ie2.set(g2, b3)), b3;
}, "transformSync");
var gr = f2(async (s5, e5, n3) => {
  const i6 = { ...dt, format: "esm", sourcefile: e5, ...n3 }, o8 = Ne2([s5, JSON.stringify(i6), import_esbuild.version, Je2].join("-"));
  let c3 = ie2.get(o8);
  return c3 || (c3 = await ur(e5, s5, [async (u5, p5) => {
    const g2 = gt(i6);
    let b3;
    try {
      b3 = await (0, import_esbuild.transform)(p5, i6);
    } catch (d5) {
      throw bt(d5);
    }
    return g2(b3);
  }, (u5, p5) => xe2(u5, p5, true)]), ie2.set(o8, c3)), c3;
}, "transform");

// 
import p3 from "node:net";
var a4 = Object.defineProperty;
var o4 = (e5, n3) => a4(e5, "name", { value: n3, configurable: true });
var m4 = o4(() => new Promise((e5) => {
  const n3 = n(process.ppid), t3 = p3.createConnection(n3, () => {
    e5(o4((i6) => {
      const r3 = Buffer.from(JSON.stringify(i6)), s5 = Buffer.alloc(4);
      s5.writeInt32BE(r3.length, 0), t3.write(Buffer.concat([s5, r3]));
    }, "sendToParent"));
  });
  t3.on("error", () => {
    e5();
  }), t3.unref();
}), "connectToServer");
var c2 = { send: void 0 };
var f3 = m4();
f3.then((e5) => {
  c2.send = e5;
}, () => {
});

// 
import { inspect as oe3 } from "node:util";

// 
var u2 = Object.defineProperty;
var g = (s5, n3) => u2(s5, "name", { value: n3, configurable: true });
var t2 = true;
var l = typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {};
var i2 = 0;
if (l.process && l.process.env && l.process.stdout) {
  const { FORCE_COLOR: s5, NODE_DISABLE_COLORS: n3, NO_COLOR: r3, TERM: o8, COLORTERM: c3 } = l.process.env;
  n3 || r3 || s5 === "0" ? t2 = false : s5 === "1" || s5 === "2" || s5 === "3" ? t2 = true : o8 === "dumb" ? t2 = false : "CI" in l.process.env && ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((a7) => a7 in l.process.env) ? t2 = true : t2 = process.stdout.isTTY, t2 && (process.platform === "win32" || c3 && (c3 === "truecolor" || c3 === "24bit") ? i2 = 3 : o8 && (o8.endsWith("-256color") || o8.endsWith("256")) ? i2 = 2 : i2 = 1);
}
var f4 = { enabled: t2, supportLevel: i2 };
function e3(s5, n3, r3 = 1) {
  const o8 = `\x1B[${s5}m`, c3 = `\x1B[${n3}m`, a7 = new RegExp(`\\x1b\\[${n3}m`, "g");
  return (p5) => f4.enabled && f4.supportLevel >= r3 ? o8 + ("" + p5).replace(a7, o8) + c3 : "" + p5;
}
g(e3, "kolorist");
var b = e3(30, 39);
var d2 = e3(33, 39);
var O3 = e3(90, 39);
var C2 = e3(92, 39);
var R4 = e3(95, 39);
var I2 = e3(96, 39);
var L2 = e3(44, 49);
var E3 = e3(100, 49);
var T = e3(103, 49);

// 
var K3 = Object.defineProperty;
var o5 = (s5, e5) => K3(s5, "name", { value: e5, configurable: true });
var R5 = o5((s5) => {
  if (!s5.startsWith("data:text/javascript,"))
    return;
  const e5 = s5.indexOf("?");
  if (e5 === -1)
    return;
  const n3 = new URLSearchParams(s5.slice(e5 + 1)).get("filePath");
  if (n3)
    return n3;
}, "getOriginalFilePath");
var D2 = o5((s5) => {
  const e5 = R5(s5);
  return e5 && (d3._cache[e5] = d3._cache[s5], delete d3._cache[s5], s5 = e5), s5;
}, "interopCjsExports");
var me3 = o5((s5) => {
  const e5 = s5.indexOf(":");
  if (e5 !== -1)
    return s5.slice(0, e5);
}, "getScheme");
var N = o5((s5) => s5[0] === "." && (s5[1] === "/" || s5[1] === "." || s5[2] === "/"), "isRelativePath");
var j = o5((s5) => N(s5) || p4.isAbsolute(s5), "isFilePath");
var pe2 = o5((s5) => {
  if (j(s5))
    return true;
  const e5 = me3(s5);
  return e5 && e5 !== "node";
}, "requestAcceptsQuery");
var y2 = "file://";
var C3 = /\.([cm]?ts|[tj]sx)($|\?)/;
var de2 = /[/\\].+\.(?:cts|cjs)(?:$|\?)/;
var E4 = /\/(?:$|\?)/;
var ge2 = /^(?:@[^/]+\/)?[^/\\]+$/;
var Q4 = `${p4.sep}node_modules${p4.sep}`;
var M2;
var _3;
var S = false;
var A2 = o5((s5) => {
  let e5 = null;
  if (s5) {
    const a7 = p4.resolve(s5);
    e5 = { path: a7, config: ae(a7) };
  } else {
    try {
      e5 = he();
    } catch {
    }
    if (!e5)
      return;
  }
  M2 = Xe(e5), _3 = Re(e5), S = e5?.config.compilerOptions?.allowJs ?? false;
}, "loadTsconfig");
var T2 = o5((s5) => Array.from(s5).length > 0 ? `?${s5.toString()}` : "", "urlSearchParamsStringify");
var Pe3 = `
//# sourceMappingURL=data:application/json;base64,`;
var I3 = o5(() => process.sourceMapsEnabled ?? true, "shouldApplySourceMap");
var F3 = o5(({ code: s5, map: e5 }) => s5 + Pe3 + Buffer.from(JSON.stringify(e5), "utf8").toString("base64"), "inlineSourceMap");
var v3 = Number(process.env.TSX_DEBUG);
v3 && (f4.enabled = true, f4.supportLevel = 3);
var J2 = o5((s5) => (e5, ...a7) => {
  if (!v3 || e5 > v3)
    return;
  const n3 = `${E3(` tsx P${process.pid} `)} ${s5}`, t3 = a7.map((r3) => typeof r3 == "string" ? r3 : oe3(r3, { colors: true })).join(" ");
  te2(1, `${n3} ${t3}
`);
}, "createLog");
var P2 = J2(T(b(" CJS ")));
var je3 = J2(L2(" ESM "));
var be = [".cts", ".mts", ".ts", ".tsx", ".jsx"];
var xe3 = [".js", ".cjs", ".mjs"];
var k2 = [".ts", ".tsx", ".jsx"];
var $2 = o5((s5, e5, a7, n3) => {
  const t3 = Object.getOwnPropertyDescriptor(s5, e5);
  t3?.set ? s5[e5] = a7 : (!t3 || t3.configurable) && Object.defineProperty(s5, e5, { value: a7, enumerable: t3?.enumerable || n3?.enumerable, writable: n3?.writable ?? (t3 ? t3.writable : true), configurable: n3?.configurable ?? (t3 ? t3.configurable : true) });
}, "safeSet");
var ye3 = o5((s5, e5, a7) => {
  const n3 = e5[".js"], t3 = o5((r3, c3) => {
    if (s5.enabled === false)
      return n3(r3, c3);
    const [i6, f6] = c3.split("?");
    if ((new URLSearchParams(f6).get("namespace") ?? void 0) !== a7)
      return n3(r3, c3);
    P2(2, "load", { filePath: c3 }), r3.id.startsWith("data:text/javascript,") && (r3.path = p4.dirname(i6)), c2?.send && c2.send({ type: "dependency", path: i6 });
    const u5 = be.some((m8) => i6.endsWith(m8)), g2 = xe3.some((m8) => i6.endsWith(m8));
    if (!u5 && !g2)
      return n3(r3, i6);
    let h4 = se3.readFileSync(i6, "utf8");
    if (i6.endsWith(".cjs")) {
      const m8 = xe2(c3, h4);
      m8 && (h4 = I3() ? F3(m8) : m8.code);
    } else if (u5 || gn(h4)) {
      const m8 = dr(h4, c3, { tsconfigRaw: M2?.(i6) });
      h4 = I3() ? F3(m8) : m8.code;
    }
    P2(1, "loaded", { filePath: i6 }), r3._compile(h4, i6);
  }, "transformer");
  $2(e5, ".js", t3);
  for (const r3 of k2)
    $2(e5, r3, t3, { enumerable: !a7, writable: true, configurable: true });
  return $2(e5, ".mjs", t3, { writable: true, configurable: true }), () => {
    e5[".js"] === t3 && (e5[".js"] = n3);
    for (const r3 of [...k2, ".mjs"])
      e5[r3] === t3 && delete e5[r3];
  };
}, "createExtensions");
var Ee2 = o5((s5) => (e5) => {
  if ((e5 === "." || e5 === ".." || e5.endsWith("/..")) && (e5 += "/"), E4.test(e5)) {
    let a7 = p4.join(e5, "index.js");
    e5.startsWith("./") && (a7 = `./${a7}`);
    try {
      return s5(a7);
    } catch {
    }
  }
  try {
    return s5(e5);
  } catch (a7) {
    const n3 = a7;
    if (n3.code === "MODULE_NOT_FOUND")
      try {
        return s5(`${e5}${p4.sep}index.js`);
      } catch {
      }
    throw n3;
  }
}, "createImplicitResolver");
var B2 = [".js", ".json"];
var G3 = [".ts", ".tsx", ".jsx"];
var _e3 = [...G3, ...B2];
var Se3 = [...B2, ...G3];
var b2 = /* @__PURE__ */ Object.create(null);
b2[".js"] = [".ts", ".tsx", ".js", ".jsx"], b2[".jsx"] = [".tsx", ".ts", ".jsx", ".js"], b2[".cjs"] = [".cts"], b2[".mjs"] = [".mts"];
var X3 = o5((s5) => {
  const e5 = s5.split("?"), a7 = e5[1] ? `?${e5[1]}` : "", [n3] = e5, t3 = p4.extname(n3), r3 = [], c3 = b2[t3];
  if (c3) {
    const f6 = n3.slice(0, -t3.length);
    r3.push(...c3.map((l3) => f6 + l3 + a7));
  }
  const i6 = !(s5.startsWith(y2) || j(n3)) || n3.includes(Q4) || n3.includes("/node_modules/") ? Se3 : _e3;
  return r3.push(...i6.map((f6) => n3 + f6 + a7)), r3;
}, "mapTsExtensions");
var w2 = o5((s5, e5, a7) => {
  if (P2(3, "resolveTsFilename", { request: e5, isDirectory: E4.test(e5), isTsParent: a7, allowJs: S }), E4.test(e5) || !a7 && !S)
    return;
  const n3 = X3(e5);
  if (n3)
    for (const t3 of n3)
      try {
        return s5(t3);
      } catch (r3) {
        const { code: c3 } = r3;
        if (c3 !== "MODULE_NOT_FOUND" && c3 !== "ERR_PACKAGE_PATH_NOT_EXPORTED")
          throw r3;
      }
}, "resolveTsFilename");
var ve3 = o5((s5, e5) => (a7) => {
  if (P2(3, "resolveTsFilename", { request: a7, isTsParent: e5, isFilePath: j(a7) }), j(a7)) {
    const n3 = w2(s5, a7, e5);
    if (n3)
      return n3;
  }
  try {
    return s5(a7);
  } catch (n3) {
    const t3 = n3;
    if (t3.code === "MODULE_NOT_FOUND") {
      if (t3.path) {
        const c3 = t3.message.match(/^Cannot find module '([^']+)'$/);
        if (c3) {
          const f6 = c3[1], l3 = w2(s5, f6, e5);
          if (l3)
            return l3;
        }
        const i6 = t3.message.match(/^Cannot find module '([^']+)'. Please verify that the package.json has a valid "main" entry$/);
        if (i6) {
          const f6 = i6[1], l3 = w2(s5, f6, e5);
          if (l3)
            return l3;
        }
      }
      const r3 = w2(s5, a7, e5);
      if (r3)
        return r3;
    }
    throw t3;
  }
}, "createTsExtensionResolver");
var z2 = "at cjsPreparseModuleExports (node:internal";
var we2 = o5((s5) => {
  const e5 = s5.stack.split(`
`).slice(1);
  return e5[1].includes(z2) || e5[2].includes(z2);
}, "isFromCjsLexer");
var Me3 = o5((s5, e5) => {
  const a7 = s5.split("?"), n3 = new URLSearchParams(a7[1]);
  if (e5?.filename) {
    const t3 = R5(e5.filename);
    let r3;
    if (t3) {
      const f6 = t3.split("?"), l3 = f6[0];
      r3 = f6[1], e5.filename = l3, e5.path = p4.dirname(l3), e5.paths = d3._nodeModulePaths(e5.path), d3._cache[l3] = e5;
    }
    r3 || (r3 = e5.filename.split("?")[1]);
    const i6 = new URLSearchParams(r3).get("namespace");
    i6 && n3.append("namespace", i6);
  }
  return [a7[0], n3, (t3, r3) => (p4.isAbsolute(t3) && !t3.endsWith(".json") && !t3.endsWith(".node") && !(r3 === 0 && we2(new Error())) && (t3 += T2(n3)), t3)];
}, "preserveQuery");
var Te2 = o5((s5, e5, a7) => {
  if (s5.startsWith(y2) && (s5 = O4(s5)), _3 && !j(s5) && !e5?.filename?.includes(Q4)) {
    const n3 = _3(s5);
    for (const t3 of n3)
      try {
        return a7(t3);
      } catch {
      }
  }
  return a7(s5);
}, "resolveTsPaths");
var Fe3 = o5((s5, e5, a7) => (n3, t3, ...r3) => {
  if (s5.enabled === false)
    return e5(n3, t3, ...r3);
  n3 = D2(n3);
  const [c3, i6, f6] = Me3(n3, t3);
  if ((i6.get("namespace") ?? void 0) !== a7)
    return e5(n3, t3, ...r3);
  P2(2, "resolve", { request: n3, parent: t3?.filename ?? t3, restOfArgs: r3 });
  let l3 = o5((g2) => e5(g2, t3, ...r3), "nextResolveSimple");
  l3 = ve3(l3, !!(a7 || t3?.filename && C3.test(t3.filename))), l3 = Ee2(l3);
  const u5 = f6(Te2(c3, t3, l3), r3.length);
  return P2(1, "resolved", { request: n3, parent: t3?.filename ?? t3, resolved: u5 }), u5;
}, "createResolveFilename");
var H2 = o5((s5, e5) => {
  if (!e5)
    throw new Error("The current file path (__filename or import.meta.url) must be provided in the second argument of tsx.require()");
  return s5.startsWith(".") ? ((typeof e5 == "string" && e5.startsWith(y2) || e5 instanceof URL) && (e5 = O4(e5)), p4.resolve(p4.dirname(e5), s5)) : s5;
}, "resolveContext");
var $e3 = o5((s5) => {
  const { sourceMapsEnabled: e5 } = process, a7 = { enabled: true };
  A2(process.env.TSX_TSCONFIG_PATH), process.setSourceMapsEnabled(true);
  const n3 = d3._resolveFilename, t3 = Fe3(a7, n3, s5?.namespace);
  d3._resolveFilename = t3;
  const r3 = ye3(a7, d3._extensions, s5?.namespace), c3 = o5(() => {
    e5 === false && process.setSourceMapsEnabled(false), a7.enabled = false, d3._resolveFilename === t3 && (d3._resolveFilename = n3), r3();
  }, "unregister");
  if (s5?.namespace) {
    const i6 = o5((l3, u5) => {
      const g2 = H2(l3, u5), [h4, m8] = g2.split("?"), x2 = new URLSearchParams(m8);
      return s5.namespace && !h4.startsWith("node:") && x2.set("namespace", s5.namespace), m(h4 + T2(x2));
    }, "scopedRequire");
    c3.require = i6;
    const f6 = o5((l3, u5, g2) => {
      const h4 = H2(l3, u5), [m8, x2] = h4.split("?"), L3 = new URLSearchParams(x2);
      return s5.namespace && !m8.startsWith("node:") && L3.set("namespace", s5.namespace), t3(m8 + T2(L3), module, false, g2);
    }, "scopedResolve");
    c3.resolve = f6, c3.unregister = c3;
  }
  return c3;
}, "register");

// 
import { pathToFileURL as h3 } from "node:url";
var d4 = Object.defineProperty;
var o6 = (r3, s5) => d4(r3, "name", { value: s5, configurable: true });
var w3 = o6((r3) => (s5, e5) => {
  if (!e5)
    throw new Error("The current file path (import.meta.url) must be provided in the second argument of tsImport()");
  const a7 = e5.startsWith(y2) ? e5 : h3(e5).toString();
  return import(`tsx://${JSON.stringify({ specifier: s5, parentURL: a7, namespace: r3 })}`);
}, "createScopedImport");
var l2 = false;
var E5 = o6((r3) => {
  if (!m5.register)
    throw new Error(`This version of Node.js (${process.version}) does not support module.register(). Please upgrade to Node v18.19 or v20.6 and above.`);
  if (!l2) {
    const { _resolveFilename: t3 } = m5;
    m5._resolveFilename = (p5, ...c3) => t3(D2(p5), ...c3), l2 = true;
  }
  const { sourceMapsEnabled: s5 } = process;
  process.setSourceMapsEnabled(true);
  const { port1: e5, port2: a7 } = new u3();
  m5.register(`./esm/index.mjs?${Date.now()}`, { parentURL: import.meta.url, data: { port: a7, namespace: r3?.namespace, tsconfig: r3?.tsconfig }, transferList: [a7] });
  const f6 = r3?.onImport, n3 = f6 && ((t3) => {
    t3.type === "load" && f6(t3.url);
  });
  n3 && (e5.on("message", n3), e5.unref());
  const i6 = o6(() => (s5 === false && process.setSourceMapsEnabled(false), n3 && e5.off("message", n3), e5.postMessage("deactivate"), new Promise((t3) => {
    const p5 = o6((c3) => {
      c3.type === "deactivated" && (t3(), e5.off("message", p5));
    }, "onDeactivated");
    e5.on("message", p5);
  })), "unregister");
  return r3?.namespace && (i6.import = w3(r3.namespace), i6.unregister = i6), i6;
}, "register");

// 
var m6 = Object.defineProperty;
var a5 = (r3, t3) => m6(r3, "name", { value: t3, configurable: true });
var e4;
var s3 = a5((r3, t3) => (e4 || (e4 = $e3({ namespace: Date.now().toString() })), e4.require(r3, t3)), "tsxRequire");
var i3 = a5((r3, t3, c3) => (e4 || (e4 = $e3({ namespace: Date.now().toString() })), e4.resolve(r3, t3, c3)), "resolve");
i3.paths = m.resolve.paths, s3.resolve = i3, s3.main = m.main, s3.extensions = m.extensions, s3.cache = m.cache;

// 
var i4 = Object.defineProperty;
var o7 = (e5, t3) => i4(e5, "name", { value: t3, configurable: true });
var n2 = o7((e5, t3) => {
  const r3 = e5[0] - t3[0];
  if (r3 === 0) {
    const s5 = e5[1] - t3[1];
    return s5 === 0 ? e5[2] >= t3[2] : s5 > 0;
  }
  return r3 > 0;
}, "isVersionGreaterOrEqual");
var a6 = process.versions.node.split(".").map(Number);
var u4 = o7((e5, t3 = a6) => {
  for (let r3 = 0; r3 < e5.length; r3 += 1) {
    const s5 = e5[r3];
    if (r3 === e5.length - 1 || t3[0] === s5[0])
      return n2(t3, s5);
  }
  return false;
}, "isFeatureSupported");
var m7 = [[20, 11, 0], [21, 3, 0]];

// 
var import_esbuild2 = __toESM(require_main(), 1);
var s4 = Object.defineProperty;
var i5 = (r3, t3) => s4(r3, "name", { value: t3, configurable: true });
var f5 = i5((r3, t3) => {
  if (!t3 || typeof t3 == "object" && !t3.parentURL)
    throw new Error("The current file path (import.meta.url) must be provided in the second argument of tsImport()");
  const e5 = typeof t3 == "string", o8 = e5 ? t3 : t3.parentURL, m8 = Date.now().toString(), a7 = $e3({ namespace: m8 });
  return !u4(m7) && !ge2.test(r3) && de2.test(r3) ? Promise.resolve(a7.require(r3, o8)) : E5({ namespace: m8, ...e5 ? {} : t3 }).import(r3, o8);
}, "tsImport");

// 
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red2, green2, blue2) => `\x1B[${38 + offset};2;${red2};${green2};${blue2}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red2, green2, blue2) {
        if (red2 === green2 && green2 === blue2) {
          if (red2 < 8) {
            return 16;
          }
          if (red2 > 248) {
            return 231;
          }
          return Math.round((red2 - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red2 / 255 * 5) + 6 * Math.round(green2 / 255 * 5) + Math.round(blue2 / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red2;
        let green2;
        let blue2;
        if (code >= 232) {
          red2 = ((code - 232) * 10 + 8) / 255;
          green2 = red2;
          blue2 = red2;
        } else {
          code -= 16;
          const remainder = code % 36;
          red2 = Math.floor(code / 36) / 5;
          green2 = Math.floor(remainder / 6) / 5;
          blue2 = remainder % 6 / 5;
        }
        const value = Math.max(red2, green2, blue2) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue2) << 2 | Math.round(green2) << 1 | Math.round(red2));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red2, green2, blue2) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red2, green2, blue2)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// 
import process2 from "node:process";
import os from "node:os";
import tty from "node:tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env)) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if (env.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// 
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// 
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// 
import process3 from "node:process";
import os2 from "node:os";
import tty2 from "node:tty";
function hasFlag2(flag, argv = globalThis.Deno ? globalThis.Deno.args : process3.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env: env2 } = process3;
var flagForceColor2;
if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
  flagForceColor2 = 0;
} else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
  flagForceColor2 = 1;
}
function envForceColor2() {
  if (!("FORCE_COLOR" in env2)) {
    return;
  }
  if (env2.FORCE_COLOR === "true") {
    return 1;
  }
  if (env2.FORCE_COLOR === "false") {
    return 0;
  }
  if (env2.FORCE_COLOR.length === 0) {
    return 1;
  }
  const level = Math.min(Number.parseInt(env2.FORCE_COLOR, 10), 3);
  if (![0, 1, 2, 3].includes(level)) {
    return;
  }
  return level;
}
function translateLevel2(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor2(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor2();
  if (noFlagForceColor !== void 0) {
    flagForceColor2 = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor2 : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env2 && "AGENT_NAME" in env2) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env2.TERM === "dumb") {
    return min;
  }
  if (process3.platform === "win32") {
    const osRelease = os2.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env2) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env2)) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env2) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env2.COLORTERM === "truecolor") {
    return 3;
  }
  if (env2.TERM === "xterm-kitty") {
    return 3;
  }
  if (env2.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env2.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env2) {
    const version = Number.parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env2.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env2.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env2) {
    return 1;
  }
  return min;
}
function createSupportsColor2(stream, options = {}) {
  const level = _supportsColor2(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel2(level);
}
var supportsColor2 = {
  stdout: createSupportsColor2({ isTTY: tty2.isatty(1) }),
  stderr: createSupportsColor2({ isTTY: tty2.isatty(2) })
};
var supports_color_default2 = supportsColor2;

// 
import { spawn as _spawn, spawnSync as _spawnSync, exec as _exec } from "child_process";
import assert from "assert";
var ChildProcess = class {
  static spawnInteractive(command, args, options = {}) {
    return new Promise((resolve, reject) => {
      const commandText = `${command} ${args.join(" ")}`;
      Log.debug(`Executing command: ${commandText}`);
      const childProcess = _spawn(command, args, { ...options, shell: true, stdio: "inherit" });
      childProcess.on("close", (status) => status === 0 ? resolve() : reject(status));
    });
  }
  static spawnSync(command, args, options = {}) {
    const commandText = `${command} ${args.join(" ")}`;
    const env3 = getEnvironmentForNonInteractiveCommand(options.env);
    Log.debug(`Executing command: ${commandText}`);
    const { status: exitCode, signal, stdout, stderr } = _spawnSync(command, args, { ...options, env: env3, encoding: "utf8", shell: true, stdio: "pipe" });
    const status = statusFromExitCodeAndSignal(exitCode, signal);
    if (status === 0 || options.suppressErrorOnFailingExitCode) {
      return { status, stdout, stderr };
    }
    throw new Error(stderr);
  }
  static spawn(command, args, options = {}) {
    const commandText = `${command} ${args.join(" ")}`;
    const env3 = getEnvironmentForNonInteractiveCommand(options.env);
    return processAsyncCmd(commandText, options, _spawn(command, args, { ...options, env: env3, shell: true, stdio: "pipe" }));
  }
  static exec(command, options = {}) {
    const env3 = getEnvironmentForNonInteractiveCommand(options.env);
    return processAsyncCmd(command, options, _exec(command, { ...options, env: env3 }));
  }
};
function statusFromExitCodeAndSignal(exitCode, signal) {
  return exitCode ?? signal ?? -1;
}
function getEnvironmentForNonInteractiveCommand(userProvidedEnv) {
  const forceColorValue = supports_color_default2.stdout !== false ? supports_color_default2.stdout.level.toString() : void 0;
  return { FORCE_COLOR: forceColorValue, ...userProvidedEnv ?? process.env };
}
function processAsyncCmd(command, options, childProcess) {
  return new Promise((resolve, reject) => {
    let logOutput = "";
    let stdout = "";
    let stderr = "";
    Log.debug(`Executing command: ${command}`);
    if (options.input !== void 0) {
      assert(childProcess.stdin, "Cannot write process `input` if there is no pipe `stdin` channel.");
      childProcess.stdin.write(options.input);
      childProcess.stdin.end();
    }
    childProcess.stderr?.on("data", (message) => {
      stderr += message;
      logOutput += message;
      if (options.mode === void 0 || options.mode === "enabled") {
        process.stderr.write(message);
      }
    });
    childProcess.stdout?.on("data", (message) => {
      stdout += message;
      logOutput += message;
      if (options.mode === void 0 || options.mode === "enabled") {
        process.stderr.write(message);
      }
    });
    childProcess.on("close", (exitCode, signal) => {
      const exitDescription = exitCode !== null ? `exit code "${exitCode}"` : `signal "${signal}"`;
      const printFn = options.mode === "on-error" ? Log.error : Log.debug;
      const status = statusFromExitCodeAndSignal(exitCode, signal);
      printFn(`Command "${command}" completed with ${exitDescription}.`);
      printFn(`Process output: 
${logOutput}`);
      if (status === 0 || options.suppressErrorOnFailingExitCode) {
        resolve({ stdout, stderr, status });
      } else {
        reject(options.mode === "silent" ? logOutput : void 0);
      }
    });
  });
}

// 
function determineRepoBaseDirFromCwd() {
  const { stdout, stderr, status } = ChildProcess.spawnSync("git", ["rev-parse --show-toplevel"]);
  if (status !== 0) {
    throw Error(`Unable to find the path to the base directory of the repository.
Was the command run from inside of the repo?

${stderr}`);
  }
  return stdout.trim();
}

// 
import { appendFile } from "fs/promises";
import { stripVTControlCharacters } from "util";
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["SILENT"] = 0] = "SILENT";
  LogLevel2[LogLevel2["ERROR"] = 1] = "ERROR";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["LOG"] = 3] = "LOG";
  LogLevel2[LogLevel2["INFO"] = 4] = "INFO";
  LogLevel2[LogLevel2["DEBUG"] = 5] = "DEBUG";
})(LogLevel || (LogLevel = {}));
var DEFAULT_LOG_LEVEL = LogLevel.INFO;
var red = source_default.red;
var reset = source_default.reset;
var green = source_default.green;
var yellow = source_default.yellow;
var bold = source_default.bold;
var blue = source_default.blue;
var underline = source_default.underline;
var Log = class {
};
Log.info = buildLogLevelFunction(() => console.info, LogLevel.INFO, null);
Log.error = buildLogLevelFunction(() => console.error, LogLevel.ERROR, source_default.red);
Log.debug = buildLogLevelFunction(() => console.debug, LogLevel.DEBUG, null);
Log.log = buildLogLevelFunction(() => console.log, LogLevel.LOG, null);
Log.warn = buildLogLevelFunction(() => console.warn, LogLevel.WARN, source_default.yellow);
function buildLogLevelFunction(loadCommand, level, defaultColor) {
  const loggingFunction = (...values) => {
    runConsoleCommand(loadCommand, level, ...values.map((v4) => typeof v4 === "string" && defaultColor ? defaultColor(v4) : v4));
  };
  loggingFunction.group = (label, collapsed = false) => {
    const command = collapsed ? console.groupCollapsed : console.group;
    runConsoleCommand(() => command, level, defaultColor ? defaultColor(label) : label);
  };
  loggingFunction.groupEnd = () => {
    runConsoleCommand(() => console.groupEnd, level);
  };
  return loggingFunction;
}
function runConsoleCommand(loadCommand, logLevel, ...text) {
  if (getLogLevel() >= logLevel) {
    loadCommand()(...text);
  }
  appendToLogFile(logLevel, ...text);
}
function getLogLevel() {
  const logLevel = Object.keys(LogLevel).indexOf((process.env[`LOG_LEVEL`] || "").toUpperCase());
  if (logLevel === -1) {
    return DEFAULT_LOG_LEVEL;
  }
  return logLevel;
}
var LOG_LEVEL_COLUMNS = 7;
var logFilePath = void 0;
function appendToLogFile(logLevel, ...text) {
  if (logFilePath === void 0) {
    return;
  }
  if (logLevel === void 0) {
    appendFile(logFilePath, text.join(" "));
    return;
  }
  const logLevelText = `${LogLevel[logLevel]}:`.padEnd(LOG_LEVEL_COLUMNS);
  appendFile(logFilePath, stripVTControlCharacters(text.join(" ").split("\n").map((l3) => `${logLevelText} ${l3}
`).join("")));
}

// 
var cachedConfig = null;
function setCachedConfig(config) {
  cachedConfig = config;
}
function getCachedConfig() {
  return cachedConfig;
}

// 
import { pathToFileURL } from "url";
var CONFIG_FILE_PATH_MATCHER = ".ng-dev/config.{mjs,mts}";
var setConfig = setCachedConfig;
async function getConfig(baseDirOrAssertions) {
  let cachedConfig2 = getCachedConfig();
  if (cachedConfig2 === null) {
    let baseDir;
    if (typeof baseDirOrAssertions === "string") {
      baseDir = baseDirOrAssertions;
    } else {
      baseDir = determineRepoBaseDirFromCwd();
    }
    const [matchedFile] = await (0, import_fast_glob.default)(CONFIG_FILE_PATH_MATCHER, { cwd: baseDir });
    const configPath = join2(baseDir, matchedFile);
    cachedConfig2 = await readConfigFile(configPath);
    setCachedConfig(cachedConfig2);
  }
  if (Array.isArray(baseDirOrAssertions)) {
    for (const assertion of baseDirOrAssertions) {
      assertion(cachedConfig2);
    }
  }
  return { ...cachedConfig2, __isNgDevConfigObject: true };
}
var ConfigValidationError = class extends Error {
  constructor(message, errors = []) {
    super(message);
    this.errors = errors;
  }
};
function assertValidGithubConfig(config) {
  const errors = [];
  if (config.github === void 0) {
    errors.push(`Github repository not configured. Set the "github" option.`);
  } else {
    if (config.github.name === void 0) {
      errors.push(`"github.name" is not defined`);
    }
    if (config.github.owner === void 0) {
      errors.push(`"github.owner" is not defined`);
    }
  }
  if (errors.length) {
    throw new ConfigValidationError("Invalid `github` configuration", errors);
  }
}
async function readConfigFile(configPath, returnEmptyObjectOnError = false) {
  const unregister = E5({ tsconfig: false });
  try {
    return await import(pathToFileURL(configPath).toString());
  } catch (e5) {
    if (returnEmptyObjectOnError) {
      Log.debug(`Could not read configuration file at ${configPath}, returning empty object instead.`);
      Log.debug(e5);
      return {};
    }
    Log.error(`Could not read configuration file at ${configPath}.`);
    Log.error(e5);
    process.exit(1);
  } finally {
    unregister();
  }
}

// 
var ScopeRequirement;
(function(ScopeRequirement2) {
  ScopeRequirement2[ScopeRequirement2["Required"] = 0] = "Required";
  ScopeRequirement2[ScopeRequirement2["Optional"] = 1] = "Optional";
  ScopeRequirement2[ScopeRequirement2["Forbidden"] = 2] = "Forbidden";
})(ScopeRequirement || (ScopeRequirement = {}));
var ReleaseNotesLevel;
(function(ReleaseNotesLevel2) {
  ReleaseNotesLevel2[ReleaseNotesLevel2["Hidden"] = 0] = "Hidden";
  ReleaseNotesLevel2[ReleaseNotesLevel2["Visible"] = 1] = "Visible";
})(ReleaseNotesLevel || (ReleaseNotesLevel = {}));
var COMMIT_TYPES = {
  build: {
    name: "build",
    description: "Changes to local repository build system and tooling",
    scope: ScopeRequirement.Optional,
    releaseNotesLevel: ReleaseNotesLevel.Hidden
  },
  ci: {
    name: "ci",
    description: "Changes to CI configuration and CI specific tooling",
    scope: ScopeRequirement.Forbidden,
    releaseNotesLevel: ReleaseNotesLevel.Hidden
  },
  docs: {
    name: "docs",
    description: "Changes which exclusively affects documentation.",
    scope: ScopeRequirement.Optional,
    releaseNotesLevel: ReleaseNotesLevel.Hidden
  },
  feat: {
    name: "feat",
    description: "Creates a new feature",
    scope: ScopeRequirement.Required,
    releaseNotesLevel: ReleaseNotesLevel.Visible
  },
  fix: {
    name: "fix",
    description: "Fixes a previously discovered failure/bug",
    scope: ScopeRequirement.Required,
    releaseNotesLevel: ReleaseNotesLevel.Visible
  },
  perf: {
    name: "perf",
    description: "Improves performance without any change in functionality or API",
    scope: ScopeRequirement.Required,
    releaseNotesLevel: ReleaseNotesLevel.Visible
  },
  refactor: {
    name: "refactor",
    description: "Refactor without any change in functionality or API (includes style changes)",
    scope: ScopeRequirement.Optional,
    releaseNotesLevel: ReleaseNotesLevel.Hidden
  },
  release: {
    name: "release",
    description: "A release point in the repository",
    scope: ScopeRequirement.Forbidden,
    releaseNotesLevel: ReleaseNotesLevel.Hidden
  },
  test: {
    name: "test",
    description: "Improvements or corrections made to the project's test suite",
    scope: ScopeRequirement.Optional,
    releaseNotesLevel: ReleaseNotesLevel.Hidden
  }
};

// 
var createTypedObject = (LabelConstructor) => {
  return (val) => {
    for (const key in val) {
      val[key] = new LabelConstructor(val[key]);
    }
    return val;
  };
};
var Label = class {
  constructor(params2) {
    this.params = params2;
    this.repositories = this.params.repositories || [
      ManagedRepositories.ANGULAR,
      ManagedRepositories.ANGULAR_CLI,
      ManagedRepositories.COMPONENTS,
      ManagedRepositories.DEV_INFRA
    ];
    this.name = this.params.name;
    this.description = this.params.description;
    this.color = this.params.color;
  }
};
var ManagedRepositories;
(function(ManagedRepositories2) {
  ManagedRepositories2["COMPONENTS"] = "components";
  ManagedRepositories2["ANGULAR"] = "angular";
  ManagedRepositories2["ANGULAR_CLI"] = "angular-cli";
  ManagedRepositories2["DEV_INFRA"] = "dev-infra";
})(ManagedRepositories || (ManagedRepositories = {}));

// 
var ManagedLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.commitCheck = this.params.commitCheck;
  }
};
var managedLabels = createTypedObject(ManagedLabel)({
  DETECTED_BREAKING_CHANGE: {
    description: "PR contains a commit with a breaking change",
    name: "detected: breaking change",
    commitCheck: (c3) => c3.breakingChanges.length !== 0
  },
  DETECTED_DEPRECATION: {
    description: "PR contains a commit with a deprecation",
    name: "detected: deprecation",
    commitCheck: (c3) => c3.deprecations.length !== 0
  },
  DETECTED_FEATURE: {
    description: "PR contains a feature commit",
    name: "detected: feature",
    commitCheck: (c3) => c3.type === "feat"
  },
  DETECTED_DOCS_CHANGE: {
    description: "Related to the documentation",
    name: "area: docs",
    commitCheck: (c3) => c3.type === "docs"
  },
  DETECTED_INFRA_CHANGE: {
    description: "Related the build and CI infrastructure of the project",
    name: "area: build & ci",
    commitCheck: (c3) => c3.type === "build" || c3.type === "ci"
  },
  DETECTED_PERF_CHANGE: {
    description: "Issues related to performance",
    name: "area: performance",
    commitCheck: (c3) => c3.type === "perf"
  },
  DETECTED_HTTP_CHANGE: {
    description: "Issues related to HTTP and HTTP Client",
    name: "area: common/http",
    commitCheck: (c3) => c3.scope === "common/http" || c3.scope === "http",
    repositories: [ManagedRepositories.ANGULAR]
  },
  DETECTED_COMPILER_CHANGE: {
    description: "Issues related to `ngc`, Angular's template compiler",
    name: "area: compiler",
    commitCheck: (c3) => c3.scope === "compiler" || c3.scope === "compiler-cli",
    repositories: [ManagedRepositories.ANGULAR]
  },
  DETECTED_PLATFORM_BROWSER_CHANGE: {
    description: "Issues related to the framework runtime",
    name: "area: core",
    commitCheck: (c3) => c3.scope === "platform-browser" || c3.scope === "core" || c3.scope === "platform-browser-dynamic",
    repositories: [ManagedRepositories.ANGULAR]
  },
  DETECTED_PLATFORM_SERVER_CHANGE: {
    description: "Issues related to server-side rendering",
    name: "area: server",
    commitCheck: (c3) => c3.scope === "platform-server",
    repositories: [ManagedRepositories.ANGULAR]
  },
  DETECTED_ZONES_CHANGE: {
    description: "Issues related to zone.js",
    name: "area: zones",
    commitCheck: (c3) => c3.scope === "zone.js",
    repositories: [ManagedRepositories.ANGULAR]
  },
  DETECTED_LOCALIZE_CHANGE: {
    description: "Issues related to localization and internationalization",
    name: "area: i18n",
    commitCheck: (c3) => c3.scope === "localize",
    repositories: [ManagedRepositories.ANGULAR]
  }
});

// 
var ActionLabel = class extends Label {
};
var actionLabels = createTypedObject(ActionLabel)({
  ACTION_MERGE: {
    description: "The PR is ready for merge by the caretaker",
    name: "action: merge"
  },
  ACTION_CLEANUP: {
    description: "The PR is in need of cleanup, either due to needing a rebase or in response to comments from reviews",
    name: "action: cleanup"
  },
  ACTION_PRESUBMIT: {
    description: "The PR is in need of a google3 presubmit",
    name: "action: presubmit"
  },
  ACTION_GLOBAL_PRESUBMIT: {
    description: "The PR is in need of a google3 global presubmit",
    name: "action: global presubmit"
  },
  ACTION_REVIEW: {
    description: "The PR is still awaiting reviews from at least one requested reviewer",
    name: "action: review"
  }
});

// 
var MergeLabel = class extends Label {
};
var mergeLabels = createTypedObject(MergeLabel)({
  MERGE_PRESERVE_COMMITS: {
    description: "When the PR is merged, a rebase and merge should be performed",
    name: "merge: preserve commits"
  },
  MERGE_SQUASH_COMMITS: {
    description: "When the PR is merged, a squash and merge should be performed",
    name: "merge: squash commits"
  },
  MERGE_FIX_COMMIT_MESSAGE: {
    description: "When the PR is merged, rewrites/fixups of the commit messages are needed",
    name: "merge: fix commit message",
    repositories: [ManagedRepositories.COMPONENTS, ManagedRepositories.ANGULAR_CLI]
  },
  MERGE_CARETAKER_NOTE: {
    description: "Alert the caretaker performing the merge to check the PR for an out of normal action needed or note",
    name: "merge: caretaker note"
  }
});

// 
var TargetLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.__hasTargetLabelMarker__ = true;
  }
};
var targetLabels = createTypedObject(TargetLabel)({
  TARGET_FEATURE: {
    description: "This PR is targeted for a feature branch (outside of main and semver branches)",
    name: "target: feature"
  },
  TARGET_LTS: {
    description: "This PR is targeting a version currently in long-term support",
    name: "target: lts"
  },
  TARGET_MAJOR: {
    description: "This PR is targeted for the next major release",
    name: "target: major"
  },
  TARGET_MINOR: {
    description: "This PR is targeted for the next minor release",
    name: "target: minor"
  },
  TARGET_PATCH: {
    description: "This PR is targeted for the next patch release",
    name: "target: patch"
  },
  TARGET_RC: {
    description: "This PR is targeted for the next release-candidate",
    name: "target: rc"
  }
});

// 
var PriorityLabel = class extends Label {
};
var priorityLabels = createTypedObject(PriorityLabel)({
  P0: {
    name: "P0",
    description: "Issue that causes an outage, breakage, or major function to be unusable, with no known workarounds"
  },
  P1: {
    name: "P1",
    description: "Impacts a large percentage of users; if a workaround exists it is partial or overly painful"
  },
  P2: {
    name: "P2",
    description: "The issue is important to a large percentage of users, with a workaround"
  },
  P3: {
    name: "P3",
    description: "An issue that is relevant to core functions, but does not impede progress. Important, but not urgent"
  },
  P4: {
    name: "P4",
    description: "A relatively minor issue that is not relevant to core functions"
  },
  P5: {
    name: "P5",
    description: "The team acknowledges the request but does not plan to address it, it remains open for discussion"
  }
});

// 
var FeatureLabel = class extends Label {
};
var featureLabels = createTypedObject(FeatureLabel)({
  FEATURE_IN_BACKLOG: {
    name: "feature: in backlog",
    description: "Feature request for which voting has completed and is now in the backlog"
  },
  FEATURE_VOTES_REQUIRED: {
    name: "feature: votes required",
    description: "Feature request which is currently still in the voting phase"
  },
  FEATURE_UNDER_CONSIDERATION: {
    name: "feature: under consideration",
    description: "Feature request for which voting has completed and the request is now under consideration"
  },
  FEATURE_INSUFFICIENT_VOTES: {
    name: "feature: insufficient votes",
    description: "Label to add when the not a sufficient number of votes or comments from unique authors"
  }
});

// 
var RequiresLabel = class extends Label {
};
var requiresLabels = createTypedObject(RequiresLabel)({
  REQUIRES_TGP: {
    name: "requires: TGP",
    description: "This PR requires a passing TGP before merging is allowed"
  }
});

// 
var allLabels = {
  ...managedLabels,
  ...actionLabels,
  ...mergeLabels,
  ...targetLabels,
  ...priorityLabels,
  ...featureLabels,
  ...requiresLabels
};

// 
var import_semver2 = __toESM(require_semver2());

// 
var ReleaseTrain = class {
  constructor(branchName, version) {
    this.branchName = branchName;
    this.version = version;
    this.isMajor = this.version.minor === 0 && this.version.patch === 0;
  }
};

// 
var import_semver = __toESM(require_semver2());
var versionBranchNameRegex = /^(\d+)\.(\d+)\.x$/;
var exceptionalMinorPackageIndicator = "__ngDevExceptionalMinor__";
async function getVersionInfoForBranch(repo, branchName) {
  const { data } = await repo.api.repos.getContent({
    owner: repo.owner,
    repo: repo.name,
    path: "/package.json",
    ref: branchName
  });
  const content = data.content;
  if (!content) {
    throw Error(`Unable to read "package.json" file from repository.`);
  }
  const pkgJson = JSON.parse(Buffer.from(content, "base64").toString());
  const parsedVersion = import_semver.default.parse(pkgJson.version);
  if (parsedVersion === null) {
    throw Error(`Invalid version detected in following branch: ${branchName}.`);
  }
  return {
    version: parsedVersion,
    isExceptionalMinor: pkgJson[exceptionalMinorPackageIndicator] === true
  };
}
function isVersionBranch(branchName) {
  return versionBranchNameRegex.test(branchName);
}
async function getBranchesForMajorVersions(repo, majorVersions) {
  const branchData = await repo.api.paginate(repo.api.repos.listBranches, {
    owner: repo.owner,
    repo: repo.name,
    protected: true
  });
  const branches = [];
  for (const { name } of branchData) {
    if (!isVersionBranch(name)) {
      continue;
    }
    const parsed = convertVersionBranchToSemVer(name);
    if (parsed !== null && majorVersions.includes(parsed.major)) {
      branches.push({ name, parsed });
    }
  }
  return branches.sort((a7, b3) => import_semver.default.rcompare(a7.parsed, b3.parsed));
}
function convertVersionBranchToSemVer(branchName) {
  return import_semver.default.parse(branchName.replace(versionBranchNameRegex, "$1.$2.0"));
}

// 
var ActiveReleaseTrains = class {
  constructor(trains) {
    this.trains = trains;
    this.releaseCandidate = this.trains.releaseCandidate;
    this.next = this.trains.next;
    this.latest = this.trains.latest;
    this.exceptionalMinor = this.trains.exceptionalMinor;
  }
  isFeatureFreeze() {
    return this.releaseCandidate !== null && this.releaseCandidate.version.prerelease[0] === "next";
  }
  static async fetch(repo) {
    return fetchActiveReleaseTrains(repo);
  }
};
async function fetchActiveReleaseTrains(repo) {
  const nextBranchName = repo.nextBranchName;
  const { version: nextVersion } = await getVersionInfoForBranch(repo, nextBranchName);
  const next = new ReleaseTrain(nextBranchName, nextVersion);
  const majorVersionsToFetch = [];
  const checks = {
    canHaveExceptionalMinor: () => false,
    isValidReleaseCandidateVersion: () => false,
    isValidExceptionalMinorVersion: () => false
  };
  if (nextVersion.minor === 0) {
    majorVersionsToFetch.push(nextVersion.major - 1, nextVersion.major - 2);
    checks.isValidReleaseCandidateVersion = (v4) => v4.major === nextVersion.major - 1;
    checks.canHaveExceptionalMinor = (rc) => rc === null || rc.isMajor;
    checks.isValidExceptionalMinorVersion = (v4, rc) => v4.major === (rc === null ? nextVersion.major : rc.version.major) - 1;
  } else if (nextVersion.minor === 1) {
    majorVersionsToFetch.push(nextVersion.major, nextVersion.major - 1);
    checks.isValidReleaseCandidateVersion = (v4) => v4.major === nextVersion.major;
    checks.canHaveExceptionalMinor = (rc) => rc !== null && rc.isMajor;
    checks.isValidExceptionalMinorVersion = (v4, rc) => v4.major === rc.version.major - 1;
  } else {
    majorVersionsToFetch.push(nextVersion.major);
    checks.isValidReleaseCandidateVersion = (v4) => v4.major === nextVersion.major;
    checks.canHaveExceptionalMinor = () => false;
  }
  const branches = await getBranchesForMajorVersions(repo, majorVersionsToFetch);
  const { latest, releaseCandidate, exceptionalMinor } = await findActiveReleaseTrainsFromVersionBranches(repo, next, branches, checks);
  if (latest === null) {
    throw Error(`Unable to determine the latest release-train. The following branches have been considered: [${branches.map((b3) => b3.name).join(", ")}]`);
  }
  return new ActiveReleaseTrains({ releaseCandidate, next, latest, exceptionalMinor });
}
async function findActiveReleaseTrainsFromVersionBranches(repo, next, branches, checks) {
  const nextReleaseTrainVersion = import_semver2.default.parse(`${next.version.major}.${next.version.minor}.0`);
  const nextBranchName = repo.nextBranchName;
  let latest = null;
  let releaseCandidate = null;
  let exceptionalMinor = null;
  for (const { name, parsed } of branches) {
    if (import_semver2.default.gt(parsed, nextReleaseTrainVersion)) {
      throw Error(`Discovered unexpected version-branch "${name}" for a release-train that is more recent than the release-train currently in the "${nextBranchName}" branch. Please either delete the branch if created by accident, or update the outdated version in the next branch (${nextBranchName}).`);
    } else if (import_semver2.default.eq(parsed, nextReleaseTrainVersion)) {
      throw Error(`Discovered unexpected version-branch "${name}" for a release-train that is already active in the "${nextBranchName}" branch. Please either delete the branch if created by accident, or update the version in the next branch (${nextBranchName}).`);
    }
    const { version, isExceptionalMinor } = await getVersionInfoForBranch(repo, name);
    const releaseTrain = new ReleaseTrain(name, version);
    const isPrerelease = version.prerelease[0] === "rc" || version.prerelease[0] === "next";
    if (isExceptionalMinor) {
      if (exceptionalMinor !== null) {
        throw Error(`Unable to determine latest release-train. Found an additional exceptional minor version branch: "${name}". Already discovered: ${exceptionalMinor.branchName}.`);
      }
      if (!checks.canHaveExceptionalMinor(releaseCandidate)) {
        throw Error(`Unable to determine latest release-train. Found an unexpected exceptional minor version branch: "${name}". No exceptional minor is currently allowed.`);
      }
      if (!checks.isValidExceptionalMinorVersion(version, releaseCandidate)) {
        throw Error(`Unable to determine latest release-train. Found an invalid exceptional minor version branch: "${name}". Invalid version: ${version}.`);
      }
      exceptionalMinor = releaseTrain;
      continue;
    }
    if (isPrerelease) {
      if (exceptionalMinor !== null) {
        throw Error(`Unable to determine latest release-train. Discovered a feature-freeze/release-candidate version branch (${name}) that is older than an in-progress exceptional minor (${exceptionalMinor.branchName}).`);
      }
      if (releaseCandidate !== null) {
        throw Error(`Unable to determine latest release-train. Found two consecutive pre-release version branches. No exceptional minors are allowed currently, and there cannot be multiple feature-freeze/release-candidate branches: "${name}".`);
      }
      if (!checks.isValidReleaseCandidateVersion(version)) {
        throw Error(`Discovered unexpected old feature-freeze/release-candidate branch. Expected no version-branch in feature-freeze/release-candidate mode for v${version.major}.`);
      }
      releaseCandidate = releaseTrain;
      continue;
    }
    latest = releaseTrain;
    break;
  }
  return { releaseCandidate, exceptionalMinor, latest };
}

// 
var import_semver3 = __toESM(require_semver2());

// 
var _npmPackageInfoCache = {};
async function fetchProjectNpmPackageInfo(config) {
  return await fetchPackageInfoFromNpmRegistry(config.representativeNpmPackage);
}
async function fetchPackageInfoFromNpmRegistry(pkgName) {
  if (_npmPackageInfoCache[pkgName] === void 0) {
    _npmPackageInfoCache[pkgName] = fetch(`https://registry.npmjs.org/${pkgName}`).then((r3) => r3.json());
  }
  return await _npmPackageInfoCache[pkgName];
}

// 
var majorActiveSupportDuration = 6;
var majorLongTermSupportDuration = 12;
var ltsNpmDistTagRegex = /^v(\d+)-lts$/;
async function fetchLongTermSupportBranchesFromNpm(config) {
  const { "dist-tags": distTags, time } = await fetchProjectNpmPackageInfo(config);
  const today = /* @__PURE__ */ new Date();
  const active = [];
  const inactive = [];
  for (const npmDistTag in distTags) {
    if (isLtsDistTag(npmDistTag)) {
      const version = import_semver3.default.parse(distTags[npmDistTag]);
      const branchName = `${version.major}.${version.minor}.x`;
      const majorReleaseDate = new Date(time[`${version.major}.0.0`]);
      const ltsEndDate = computeLtsEndDateOfMajor(majorReleaseDate);
      const ltsBranch = { name: branchName, version, npmDistTag };
      if (today <= ltsEndDate) {
        active.push(ltsBranch);
      } else {
        inactive.push(ltsBranch);
      }
    }
  }
  active.sort((a7, b3) => import_semver3.default.rcompare(a7.version, b3.version));
  inactive.sort((a7, b3) => import_semver3.default.rcompare(a7.version, b3.version));
  return { active, inactive };
}
function isLtsDistTag(tagName) {
  return ltsNpmDistTagRegex.test(tagName);
}
function computeLtsEndDateOfMajor(majorReleaseDate) {
  return new Date(majorReleaseDate.getFullYear(), majorReleaseDate.getMonth() + majorActiveSupportDuration + majorLongTermSupportDuration, majorReleaseDate.getDate(), majorReleaseDate.getHours(), majorReleaseDate.getMinutes(), majorReleaseDate.getSeconds(), majorReleaseDate.getMilliseconds());
}

// 
var import_typed_graphqlify = __toESM(require_dist());
var findOwnedForksOfRepoQuery = (0, import_typed_graphqlify.params)({
  $owner: "String!",
  $name: "String!"
}, {
  repository: (0, import_typed_graphqlify.params)({ owner: "$owner", name: "$name" }, {
    forks: (0, import_typed_graphqlify.params)({ affiliations: "OWNER", first: 1, orderBy: { field: "NAME", direction: "ASC" } }, {
      nodes: [
        {
          owner: {
            login: import_typed_graphqlify.types.string
          },
          name: import_typed_graphqlify.types.string
        }
      ]
    })
  })
});

// 
function isDryRun() {
  return process.env["DRY_RUN"] !== void 0;
}
var DryRunError = class extends Error {
  constructor() {
    super("Cannot call this function in dryRun mode.");
  }
};

// 
import { spawnSync as spawnSync2 } from "child_process";

// 
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// 
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// 
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// 
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// 
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// 
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto2 = Object.getPrototypeOf(value);
  if (proto2 === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a7, b3) => a7.concat(b3), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c3) {
    return "%" + c3.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context2, operator, key, modifier) {
  var value = context2[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k3) {
            if (isDefined(value[k3])) {
              result.push(encodeValue(operator, value[k3], k3));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k3) {
            if (isDefined(value[k3])) {
              tmp.push(encodeUnreserved(k3));
              tmp.push(encodeValue(operator, value[k3].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context2) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_4, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context2, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// 
var import_fast_content_type_parse = __toESM(require_fast_content_type_parse());

// 
var RequestError = class extends Error {
  name;
  /**
   * http status code
   */
  status;
  /**
   * Request options that lead to the error.
   */
  request;
  /**
   * Response object if a response was received
   */
  response;
  constructor(message, statusCode, options) {
    super(message);
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          /(?<! ) .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// 
var VERSION2 = "10.0.3";
var defaults_default = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
  }
};
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto2 = Object.getPrototypeOf(value);
  if (proto2 === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper(requestOptions) {
  const fetch2 = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch2) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  const log = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(
    Object.entries(requestOptions.headers).map(([name, value]) => [
      name,
      String(value)
    ])
  );
  let fetchResponse;
  try {
    fetchResponse = await fetch2(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      // duplex must be set if request.body is ReadableStream or Async Iterables.
      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log.warn(
      `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
    );
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError(toErrorMessage(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = (0, import_fast_content_type_parse.safeParse)(contentType);
  if (isJSONResponse(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v4) => JSON.stringify(v4)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, defaults_default);

// 
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e5) => ` - ${e5.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  name = "GraphqlResponseError";
  errors;
  data;
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType",
  "operationName"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query2, options) {
  if (options) {
    if (typeof query2 === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query2 === "string" ? Object.assign({ query: query2 }, options) : query2;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query2, options) => {
    return graphql(newRequest, query2, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// 
var b64url = "(?:[a-zA-Z0-9_-]+)";
var sep = "\\.";
var jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
var isJWT = jwtRE.test.bind(jwtRE);
async function auth(token) {
  const isApp = isJWT(token);
  const isInstallation = token.startsWith("v1.") || token.startsWith("ghs_");
  const isUserToServer = token.startsWith("ghu_");
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// 
var VERSION4 = "7.0.3";

// 
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
function createLogger(logger = {}) {
  if (typeof logger.debug !== "function") {
    logger.debug = noop;
  }
  if (typeof logger.info !== "function") {
    logger.info = noop;
  }
  if (typeof logger.warn !== "function") {
    logger.warn = consoleWarn;
  }
  if (typeof logger.error !== "function") {
    logger.error = consoleError;
  }
  return logger;
}
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  static VERSION = VERSION4;
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  static plugins = [];
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    const currentPlugins = this.plugins;
    const NewOctokit = class extends this {
      static plugins = currentPlugins.concat(
        newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
      );
    };
    return NewOctokit;
  }
  constructor(options = {}) {
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = createLogger(options.log);
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i6 = 0; i6 < classConstructor.plugins.length; ++i6) {
      Object.assign(this, classConstructor.plugins[i6](this, options));
    }
  }
  // assigned during constructor
  request;
  graphql;
  log;
  hook;
  // TODO: type `octokit.auth` based on passed options.authStrategy
  auth;
};

// 
var VERSION5 = "6.0.0";

// 
function requestLog(octokit) {
  octokit.hook.wrap("request", (request2, options) => {
    octokit.log.debug("request", options);
    const start = Date.now();
    const requestOptions = octokit.request.endpoint.parse(options);
    const path = requestOptions.url.replace(options.baseUrl, "");
    return request2(options).then((response) => {
      const requestId = response.headers["x-github-request-id"];
      octokit.log.info(
        `${requestOptions.method} ${path} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`
      );
      return response;
    }).catch((error) => {
      const requestId = error.response?.headers["x-github-request-id"] || "UNKNOWN";
      octokit.log.error(
        `${requestOptions.method} ${path} - ${error.status} with id ${requestId} in ${Date.now() - start}ms`
      );
      throw error;
    });
  });
}
requestLog.VERSION = VERSION5;

// 
var VERSION6 = "0.0.0-development";
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = ("total_count" in response.data || "total_commits" in response.data) && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  const totalCommits = response.data.total_commits;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  delete response.data.total_commits;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  response.data.total_commits = totalCommits;
  return response;
}
function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url)
          return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || "").match(
            /<([^<>]+)>;\s*rel="next"/
          ) || [])[1];
          if (!url && "total_commits" in normalizedResponse.data) {
            const parsedUrl = new URL(normalizedResponse.url);
            const params2 = parsedUrl.searchParams;
            const page = parseInt(params2.get("page") || "1", 10);
            const per_page = parseInt(params2.get("per_page") || "250", 10);
            if (page * per_page < normalizedResponse.data.total_commits) {
              params2.set("page", String(page + 1));
              url = parsedUrl.toString();
            }
          }
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409)
            throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = void 0;
  }
  return gather(
    octokit,
    [],
    iterator(octokit, route, parameters)[Symbol.asyncIterator](),
    mapFn
  );
}
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results = results.concat(
      mapFn ? mapFn(result.value, done) : result.value.data
    );
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}
var composePaginateRest = Object.assign(paginate, {
  iterator
});
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION6;

// 
var VERSION7 = "16.0.0";

// 
var Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addRepoAccessToSelfHostedRunnerGroupInOrg: [
      "PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    createHostedRunnerForOrg: ["POST /orgs/{org}/actions/hosted-runners"],
    createOrUpdateEnvironmentSecret: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    deleteHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getCustomOidcSubClaimForRepo: [
      "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    getEnvironmentPublicKey: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
    ],
    getHostedRunnersGithubOwnedImagesForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/images/github-owned"
    ],
    getHostedRunnersLimitsForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/limits"
    ],
    getHostedRunnersMachineSpecsForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/machine-sizes"
    ],
    getHostedRunnersPartnerImagesForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/images/partner"
    ],
    getHostedRunnersPlatformsForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/platforms"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    listGithubHostedRunnersInGroupForOrg: [
      "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners"
    ],
    listHostedRunnersForOrg: ["GET /orgs/{org}/actions/hosted-runners"],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setCustomOidcSubClaimForRepo: [
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    updateHostedRunnerForOrg: [
      "PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubBillingUsageReportOrg: [
      "GET /organizations/{org}/settings/billing/usage"
    ],
    getGithubBillingUsageReportUser: [
      "GET /users/{username}/settings/billing/usage"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  campaigns: {
    createCampaign: ["POST /orgs/{org}/campaigns"],
    deleteCampaign: ["DELETE /orgs/{org}/campaigns/{campaign_number}"],
    getCampaignSummary: ["GET /orgs/{org}/campaigns/{campaign_number}"],
    listOrgCampaigns: ["GET /orgs/{org}/campaigns"],
    updateCampaign: ["PATCH /orgs/{org}/campaigns/{campaign_number}"]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    commitAutofix: [
      "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits"
    ],
    createAutofix: [
      "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
    ],
    createVariantAnalysis: [
      "POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses"
    ],
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    deleteCodeqlDatabase: [
      "DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getAutofix: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    getVariantAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}"
    ],
    getVariantAnalysisRepoTask: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}"
    ],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codeSecurity: {
    attachConfiguration: [
      "POST /orgs/{org}/code-security/configurations/{configuration_id}/attach"
    ],
    attachEnterpriseConfiguration: [
      "POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach"
    ],
    createConfiguration: ["POST /orgs/{org}/code-security/configurations"],
    createConfigurationForEnterprise: [
      "POST /enterprises/{enterprise}/code-security/configurations"
    ],
    deleteConfiguration: [
      "DELETE /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    deleteConfigurationForEnterprise: [
      "DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ],
    detachConfiguration: [
      "DELETE /orgs/{org}/code-security/configurations/detach"
    ],
    getConfiguration: [
      "GET /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    getConfigurationForRepository: [
      "GET /repos/{owner}/{repo}/code-security-configuration"
    ],
    getConfigurationsForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations"
    ],
    getConfigurationsForOrg: ["GET /orgs/{org}/code-security/configurations"],
    getDefaultConfigurations: [
      "GET /orgs/{org}/code-security/configurations/defaults"
    ],
    getDefaultConfigurationsForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations/defaults"
    ],
    getRepositoriesForConfiguration: [
      "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories"
    ],
    getRepositoriesForEnterpriseConfiguration: [
      "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories"
    ],
    getSingleConfigurationForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ],
    setConfigurationAsDefault: [
      "PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults"
    ],
    setConfigurationAsDefaultForEnterprise: [
      "PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults"
    ],
    updateConfiguration: [
      "PATCH /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    updateEnterpriseConfiguration: [
      "PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    copilotMetricsForOrganization: ["GET /orgs/{org}/copilot/metrics"],
    copilotMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/metrics"],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
  },
  credentials: { revoke: ["POST /credentials/revoke"] },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  hostedCompute: {
    createNetworkConfigurationForOrg: [
      "POST /orgs/{org}/settings/network-configurations"
    ],
    deleteNetworkConfigurationFromOrg: [
      "DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}"
    ],
    getNetworkConfigurationForOrg: [
      "GET /orgs/{org}/settings/network-configurations/{network_configuration_id}"
    ],
    getNetworkSettingsForOrg: [
      "GET /orgs/{org}/settings/network-settings/{network_settings_id}"
    ],
    listNetworkConfigurationsForOrg: [
      "GET /orgs/{org}/settings/network-configurations"
    ],
    updateNetworkConfigurationForOrg: [
      "PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}"
    ]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    addSubIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
    ],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    listSubIssues: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
    ],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    removeSubIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue"
    ],
    reprioritizeSubIssue: [
      "PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ]
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: [
      "GET /orgs/{org}/actions/oidc/customization/sub"
    ],
    updateOidcCustomSubTemplateForOrg: [
      "PUT /orgs/{org}/actions/oidc/customization/sub"
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}",
      {},
      {
        deprecated: "octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team"
      }
    ],
    assignTeamToOrgRole: [
      "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    assignUserToOrgRole: [
      "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createIssueType: ["POST /orgs/{org}/issue-types"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteIssueType: ["DELETE /orgs/{org}/issue-types/{issue_type_id}"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}",
      {},
      {
        deprecated: "octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization"
      }
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
    getOrgRulesetHistory: ["GET /orgs/{org}/rulesets/{ruleset_id}/history"],
    getOrgRulesetVersion: [
      "GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}"
    ],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listAttestations: ["GET /orgs/{org}/attestations/{subject_digest}"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listIssueTypes: ["GET /orgs/{org}/issue-types"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
    listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
    listOrgRoles: ["GET /orgs/{org}/organization-roles"],
    listOrganizationFineGrainedPermissions: [
      "GET /orgs/{org}/organization-fine-grained-permissions"
    ],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: [
      "GET /orgs/{org}/security-managers",
      {},
      {
        deprecated: "octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams"
      }
    ],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}",
      {},
      {
        deprecated: "octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team"
      }
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    revokeAllOrgRolesTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
    ],
    revokeAllOrgRolesUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}"
    ],
    revokeOrgRoleTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    revokeOrgRoleUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateIssueType: ["PUT /orgs/{org}/issue-types/{issue_type_id}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  privateRegistries: {
    createOrgPrivateRegistry: ["POST /orgs/{org}/private-registries"],
    deleteOrgPrivateRegistry: [
      "DELETE /orgs/{org}/private-registries/{secret_name}"
    ],
    getOrgPrivateRegistry: ["GET /orgs/{org}/private-registries/{secret_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/private-registries/public-key"],
    listOrgPrivateRegistries: ["GET /orgs/{org}/private-registries"],
    updateOrgPrivateRegistry: [
      "PATCH /orgs/{org}/private-registries/{secret_name}"
    ]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    cancelPagesDeployment: [
      "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkPrivateVulnerabilityReporting: [
      "GET /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAttestation: ["POST /repos/{owner}/{repo}/attestations"],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateCustomPropertiesValues: [
      "PATCH /repos/{owner}/{repo}/properties/values"
    ],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesDeployment: [
      "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
    ],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesetHistory: [
      "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history"
    ],
    getRepoRulesetVersion: [
      "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}"
    ],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAttestations: [
      "GET /repos/{owner}/{repo}/attestations/{subject_digest}"
    ],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: [
      "GET /search/issues",
      {},
      {
        deprecated: "octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests"
      }
    ],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    createPushProtectionBypass: [
      "POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    getScanHistory: ["GET /repos/{owner}/{repo}/secret-scanning/scan-history"],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createFork: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
    ],
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getById: ["GET /user/{account_id}"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listAttestations: ["GET /users/{username}/attestations/{subject_digest}"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var endpoints_default = Endpoints;

// 
var endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint2] of Object.entries(endpoints)) {
    const [route, defaults, decorations] = endpoint2;
    const [method, url] = route.split(/ /);
    const endpointDefaults = Object.assign(
      {
        method,
        url
      },
      defaults
    );
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations
    });
  }
}
var handler = {
  has({ scope }, methodName) {
    return endpointMethodsMap.get(scope).has(methodName);
  },
  getOwnPropertyDescriptor(target, methodName) {
    return {
      value: this.get(target, methodName),
      // ensures method is in the cache
      configurable: true,
      writable: true,
      enumerable: true
    };
  },
  defineProperty(target, methodName, descriptor) {
    Object.defineProperty(target.cache, methodName, descriptor);
    return true;
  },
  deleteProperty(target, methodName) {
    delete target.cache[methodName];
    return true;
  },
  ownKeys({ scope }) {
    return [...endpointMethodsMap.get(scope).keys()];
  },
  set(target, methodName, value) {
    return target.cache[methodName] = value;
  },
  get({ octokit, scope, cache }, methodName) {
    if (cache[methodName]) {
      return cache[methodName];
    }
    const method = endpointMethodsMap.get(scope).get(methodName);
    if (!method) {
      return void 0;
    }
    const { endpointDefaults, decorations } = method;
    if (decorations) {
      cache[methodName] = decorate(
        octokit,
        scope,
        methodName,
        endpointDefaults,
        decorations
      );
    } else {
      cache[methodName] = octokit.request.defaults(endpointDefaults);
    }
    return cache[methodName];
  }
};
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: void 0
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(
        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
      );
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(
        decorations.renamedParameters
      )) {
        if (name in options2) {
          octokit.log.warn(
            `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
          );
          if (!(alias in options2)) {
            options2[alias] = options2[name];
          }
          delete options2[name];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}

// 
function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION7;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
legacyRestEndpointMethods.VERSION = VERSION7;

// 
var VERSION8 = "22.0.0";

// 
var Octokit2 = Octokit.plugin(requestLog, legacyRestEndpointMethods, paginateRest).defaults(
  {
    userAgent: `octokit-rest.js/${VERSION8}`
  }
);

// 
var import_typed_graphqlify2 = __toESM(require_dist());
var GithubClient = class {
  constructor(_octokitOptions) {
    this._octokitOptions = _octokitOptions;
    this._octokit = new Octokit2({ ...this._octokitOptions });
    this.pulls = this._octokit.pulls;
    this.orgs = this._octokit.orgs;
    this.repos = this._octokit.repos;
    this.issues = this._octokit.issues;
    this.git = this._octokit.git;
    this.rateLimit = this._octokit.rateLimit;
    this.teams = this._octokit.teams;
    this.search = this._octokit.search;
    this.rest = this._octokit.rest;
    this.paginate = this._octokit.paginate;
    this.checks = this._octokit.checks;
  }
};
var AuthenticatedGithubClient = class extends GithubClient {
  constructor(_token) {
    super({ auth: _token });
    this._token = _token;
    this._graphql = this._octokit.graphql.defaults({
      headers: { authorization: `token ${this._token}` }
    });
  }
  async graphql(queryObject, params2 = {}) {
    return await this._graphql((0, import_typed_graphqlify2.query)(queryObject).toString(), params2);
  }
};

// 
import { URL as URL2 } from "url";
var GITHUB_TOKEN_SETTINGS_URL = "https://github.com/settings/tokens";
var GITHUB_TOKEN_GENERATE_URL = "https://github.com/settings/tokens/new";
function addTokenToGitHttpsUrl(githubHttpsUrl, token) {
  const url = new URL2(githubHttpsUrl);
  url.password = token;
  url.username = "x-access-token";
  return url.href;
}
function getRepositoryGitUrl(config, githubToken) {
  if (config.useSsh) {
    return `git@github.com:${config.owner}/${config.name}.git`;
  }
  const baseHttpUrl = `https://github.com/${config.owner}/${config.name}.git`;
  if (githubToken !== void 0) {
    return addTokenToGitHttpsUrl(baseHttpUrl, githubToken);
  }
  return baseHttpUrl;
}

// 
var GitCommandError = class extends Error {
  constructor(client, unsanitizedArgs) {
    super(`Command failed: git ${client.sanitizeConsoleOutput(unsanitizedArgs.join(" "))}`);
  }
};
var GitClient = class _GitClient {
  constructor(config, baseDir = determineRepoBaseDirFromCwd()) {
    this.baseDir = baseDir;
    this.github = new GithubClient();
    this.gitBinPath = "git";
    this.config = config;
    this.remoteConfig = config.github;
    this.remoteParams = { owner: config.github.owner, repo: config.github.name };
    this.mainBranchName = config.github.mainBranchName;
  }
  run(args, options) {
    const result = this.runGraceful(args, options);
    if (result.status !== 0) {
      throw new GitCommandError(this, args);
    }
    return result;
  }
  runGraceful(args, options = {}) {
    const gitCommand = args[0];
    if (isDryRun() && gitCommand === "push") {
      Log.debug(`"git push" is not able to be run in dryRun mode.`);
      throw new DryRunError();
    }
    args = ["-c", "credential.helper=", ...args];
    Log.debug("Executing: git", this.sanitizeConsoleOutput(args.join(" ")));
    const result = spawnSync2(this.gitBinPath, args, {
      cwd: this.baseDir,
      stdio: "pipe",
      ...options,
      encoding: "utf8"
    });
    Log.debug(`Status: ${result.status}, Error: ${!!result.error}, Signal: ${result.signal}`);
    if (result.status !== 0 && result.stderr !== null) {
      process.stderr.write(this.sanitizeConsoleOutput(result.stderr));
    }
    Log.debug("Stdout:", result.stdout);
    Log.debug("Stderr:", result.stderr);
    Log.debug("Process Error:", result.error);
    if (result.error !== void 0) {
      process.stderr.write(this.sanitizeConsoleOutput(result.error.message));
    }
    return result;
  }
  getRepoGitUrl() {
    return getRepositoryGitUrl(this.remoteConfig);
  }
  hasCommit(branchName, sha) {
    return this.run(["branch", branchName, "--contains", sha]).stdout !== "";
  }
  isShallowRepo() {
    return this.run(["rev-parse", "--is-shallow-repository"]).stdout.trim() === "true";
  }
  getCurrentBranchOrRevision() {
    const branchName = this.run(["rev-parse", "--abbrev-ref", "HEAD"]).stdout.trim();
    if (branchName === "HEAD") {
      return this.run(["rev-parse", "HEAD"]).stdout.trim();
    }
    return branchName;
  }
  hasUncommittedChanges() {
    this.runGraceful(["update-index", "-q", "--refresh"]);
    return this.runGraceful(["diff-index", "--quiet", "HEAD"]).status !== 0;
  }
  checkout(branchOrRevision, cleanState) {
    if (cleanState) {
      this.runGraceful(["am", "--abort"], { stdio: "ignore" });
      this.runGraceful(["cherry-pick", "--abort"], { stdio: "ignore" });
      this.runGraceful(["rebase", "--abort"], { stdio: "ignore" });
      this.runGraceful(["reset", "--hard"], { stdio: "ignore" });
    }
    return this.runGraceful(["checkout", branchOrRevision], { stdio: "ignore" }).status === 0;
  }
  allChangesFilesSince(shaOrRef = "HEAD") {
    return Array.from(/* @__PURE__ */ new Set([
      ...gitOutputAsArray(this.runGraceful(["diff", "--name-only", "--diff-filter=d", shaOrRef])),
      ...gitOutputAsArray(this.runGraceful(["ls-files", "--others", "--exclude-standard"]))
    ]));
  }
  allStagedFiles() {
    return gitOutputAsArray(this.runGraceful(["diff", "--name-only", "--diff-filter=ACM", "--staged"]));
  }
  allFiles() {
    return gitOutputAsArray(this.runGraceful(["ls-files"]));
  }
  sanitizeConsoleOutput(value) {
    return value;
  }
  static async get() {
    if (_GitClient._unauthenticatedInstance === null) {
      _GitClient._unauthenticatedInstance = (async () => {
        return new _GitClient(await getConfig([assertValidGithubConfig]));
      })();
    }
    return _GitClient._unauthenticatedInstance;
  }
};
GitClient._unauthenticatedInstance = null;
function gitOutputAsArray(gitCommandResult) {
  return gitCommandResult.stdout.split("\n").map((x2) => x2.trim()).filter((x2) => !!x2);
}

// 
var AuthenticatedGitClient = class _AuthenticatedGitClient extends GitClient {
  constructor(githubToken, userType, config, baseDir) {
    super(config, baseDir);
    this.githubToken = githubToken;
    this.userType = userType;
    this._githubTokenRegex = new RegExp(this.githubToken, "g");
    this._cachedOauthScopes = null;
    this._cachedForkRepositories = null;
    this.github = new AuthenticatedGithubClient(this.githubToken);
  }
  sanitizeConsoleOutput(value) {
    return value.replace(this._githubTokenRegex, "<TOKEN>");
  }
  getRepoGitUrl() {
    return getRepositoryGitUrl(this.remoteConfig, this.githubToken);
  }
  async hasOauthScopes(testFn) {
    if (this.userType === "bot") {
      return true;
    }
    const scopes = await this._fetchAuthScopesForToken();
    const missingScopes = [];
    testFn(scopes, missingScopes);
    if (missingScopes.length === 0) {
      return true;
    }
    const error = `The provided <TOKEN> does not have required permissions due to missing scope(s): ${yellow(missingScopes.join(", "))}

Update the token in use at:
  ${GITHUB_TOKEN_SETTINGS_URL}

Alternatively, a new token can be created at: ${GITHUB_TOKEN_GENERATE_URL}
`;
    return { error };
  }
  async getForkOfAuthenticatedUser() {
    const forks = await this.getAllForksOfAuthenticatedUser();
    if (forks.length === 0) {
      throw Error("Unable to find fork a for currently authenticated user.");
    }
    return forks[0];
  }
  async getAllForksOfAuthenticatedUser() {
    if (this._cachedForkRepositories !== null) {
      return this._cachedForkRepositories;
    }
    const { owner, name } = this.remoteConfig;
    const result = await this.github.graphql(findOwnedForksOfRepoQuery, { owner, name });
    return this._cachedForkRepositories = result.repository.forks.nodes.map((node) => ({
      owner: node.owner.login,
      name: node.name
    }));
  }
  _fetchAuthScopesForToken() {
    if (this._cachedOauthScopes !== null) {
      return this._cachedOauthScopes;
    }
    return this._cachedOauthScopes = this.github.rateLimit.get().then((response) => {
      const scopes = response.headers["x-oauth-scopes"];
      if (scopes === void 0) {
        throw Error("Unable to retrieve OAuth scopes for token provided to Git client.");
      }
      return scopes.split(",").map((scope) => scope.trim()).filter((scope) => scope !== "");
    });
  }
  static async get() {
    if (_AuthenticatedGitClient._token === null) {
      throw new Error("No instance of `AuthenticatedGitClient` has been configured.");
    }
    if (_AuthenticatedGitClient._authenticatedInstance === null) {
      _AuthenticatedGitClient._authenticatedInstance = (async (token, userType) => {
        return new _AuthenticatedGitClient(token, userType, await getConfig([assertValidGithubConfig]));
      })(_AuthenticatedGitClient._token, _AuthenticatedGitClient._userType);
    }
    return _AuthenticatedGitClient._authenticatedInstance;
  }
  static configure(token, userType = "user") {
    if (_AuthenticatedGitClient._token) {
      throw Error("Unable to configure `AuthenticatedGitClient` as it has been configured already.");
    }
    _AuthenticatedGitClient._token = token;
    _AuthenticatedGitClient._userType = userType;
  }
};
AuthenticatedGitClient._token = null;
AuthenticatedGitClient._authenticatedInstance = null;

// 
var import_which = __toESM(require_lib2());
var import_lockfile = __toESM(require_lockfile());
var import_yaml = __toESM(require_dist2());

// .github/actions/deploy-docs-site/lib/deployments.mjs
async function getDeployments() {
  const { github } = await AuthenticatedGitClient.get();
  const releaseTrains = await ActiveReleaseTrains.fetch({
    api: github,
    name: "angular",
    owner: "angular",
    nextBranchName: "main"
  });
  const ltsBranches = await fetchLongTermSupportBranchesFromNpm({
    representativeNpmPackage: "@angular/core"
  });
  const docSites = /* @__PURE__ */ new Map();
  [...ltsBranches.active, ...ltsBranches.inactive].forEach((branch) => {
    docSites.set(branch.name, {
      branch: branch.name,
      destination: `v${branch.version.major}-angular-dev`
    });
  });
  docSites.set(releaseTrains.latest.branchName, {
    branch: releaseTrains.latest.branchName,
    redirect: {
      from: `v${releaseTrains.latest.version.major}-angular-dev`,
      to: "https://angular.dev"
    },
    destination: "angular-dev-site"
  });
  if (releaseTrains.releaseCandidate) {
    docSites.set(releaseTrains.next.branchName, {
      branch: releaseTrains.next.branchName
    });
    docSites.set(releaseTrains.releaseCandidate.branchName, {
      branch: releaseTrains.releaseCandidate.branchName,
      destination: "next-angular-dev",
      redirect: {
        from: `v${releaseTrains.releaseCandidate.version.major}-angular-dev`,
        to: "https://next.angular.dev"
      }
    });
  } else {
    docSites.set(releaseTrains.next.branchName, {
      branch: releaseTrains.next.branchName,
      destination: "next-angular-dev"
    });
  }
  return docSites;
}

// .github/actions/deploy-docs-site/lib/main.mts
var refMatcher = /refs\/heads\/(.*)/;
async function deployDocs() {
  setConfig({
    github: {
      mainBranchName: "main",
      name: "angular",
      owner: "angular"
    }
  });
  AuthenticatedGitClient.configure(githubReleaseTrainReadToken);
  if (import_github3.context.eventName !== "push") {
    throw Error();
  }
  const matchedRef = import_github3.context.ref.match(refMatcher);
  if (matchedRef === null) {
    throw Error();
  }
  const currentBranch = matchedRef[1];
  const configPath = (0, import_core3.getInput)("configPath");
  const distDir = (0, import_core3.getInput)("distDir");
  const deployment = (await getDeployments()).get(currentBranch);
  if (deployment === void 0) {
    console.log(`Current branch (${currentBranch}) does not deploy a documentation site.`);
    console.log(`Exiting...`);
    process.exit(0);
  }
  console.log("Doc site deployment information");
  console.log("");
  console.log("Current Branch:");
  console.log(`  ${deployment.branch}`);
  console.log("");
  console.log("Firebase Site:");
  if (deployment.destination === void 0) {
    console.log("  No deployment of a documenation site is necessary");
  } else {
    console.log(`  Deploying to: ${deployment.destination}`);
  }
  console.log("");
  console.log("Redirect Configuration:");
  if (deployment.redirect === void 0) {
    console.log("  No redirects are necessary");
  } else {
    console.log(`  From: ${deployment.redirect.from}`);
    console.log(`  To: ${deployment.redirect.to}`);
  }
  await deployToFirebase(deployment, configPath, distDir);
  await setupRedirect(deployment);
}
if (import_github3.context.repo.owner === "angular") {
  deployDocs().catch((e5) => {
    (0, import_core3.setFailed)(e5.message);
    console.error(e5);
  });
} else {
  console.warn(
    "The action was skipped as this action is only meant to run in repos belonging to the Angular organization."
  );
}
/*! Bundled license information:

tmp/lib/tmp.js:
  (*!
   * Tmp
   *
   * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
   *
   * MIT Licensed
   *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
