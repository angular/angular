/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
import {ExternalExpr, ExternalReference, WrappedNodeExpr} from '@angular/compiler';
import ts from 'typescript';
import {
  ErrorCode,
  FatalDiagnosticError,
  makeDiagnosticChain,
  makeRelatedInformation,
} from '../../diagnostics';
import {
  absoluteFromSourceFile,
  dirname,
  LogicalProjectPath,
  relative,
  toRelativeImport,
} from '../../file_system';
import {stripExtension} from '../../file_system/src/util';
import {
  getSourceFile,
  identifierOfNode,
  isDeclaration,
  isNamedDeclaration,
  isTypeDeclaration,
  nodeNameForError,
} from '../../util/src/typescript';
import {findExportedNameOfNode} from './find_export';
/**
 * Flags which alter the imports generated by the `ReferenceEmitter`.
 */
export var ImportFlags;
(function (ImportFlags) {
  ImportFlags[(ImportFlags['None'] = 0)] = 'None';
  /**
   * Force the generation of a new import when generating a reference, even if an identifier already
   * exists in the target file which could be used instead.
   *
   * This is sometimes required if there's a risk TypeScript might remove imports during emit.
   */
  ImportFlags[(ImportFlags['ForceNewImport'] = 1)] = 'ForceNewImport';
  /**
   * Don't make use of any aliasing information when emitting a reference.
   *
   * This is sometimes required if emitting into a context where generated references will be fed
   * into TypeScript and type-checked (such as in template type-checking).
   */
  ImportFlags[(ImportFlags['NoAliasing'] = 2)] = 'NoAliasing';
  /**
   * Indicates that an import to a type-only declaration is allowed.
   *
   * For references that occur in type-positions, the referred declaration may be a type-only
   * declaration that is not retained during emit. Including this flag allows to emit references to
   * type-only declarations as used in e.g. template type-checking.
   */
  ImportFlags[(ImportFlags['AllowTypeImports'] = 4)] = 'AllowTypeImports';
  /**
   * Indicates that importing from a declaration file using a relative import path is allowed.
   *
   * The generated imports should normally use module specifiers that are valid for use in
   * production code, where arbitrary relative imports into e.g. node_modules are not allowed. For
   * template type-checking code it is however acceptable to use relative imports, as such files are
   * never emitted to JS code.
   *
   * Non-declaration files have to be contained within a configured `rootDir` so using relative
   * paths may not be possible for those, hence this flag only applies when importing from a
   * declaration file.
   */
  ImportFlags[(ImportFlags['AllowRelativeDtsImports'] = 8)] = 'AllowRelativeDtsImports';
  /**
   * Indicates that references coming from ambient imports are allowed.
   */
  ImportFlags[(ImportFlags['AllowAmbientReferences'] = 16)] = 'AllowAmbientReferences';
})(ImportFlags || (ImportFlags = {}));
export var ReferenceEmitKind;
(function (ReferenceEmitKind) {
  ReferenceEmitKind[(ReferenceEmitKind['Success'] = 0)] = 'Success';
  ReferenceEmitKind[(ReferenceEmitKind['Failed'] = 1)] = 'Failed';
})(ReferenceEmitKind || (ReferenceEmitKind = {}));
/**
 * Verifies that a reference was emitted successfully, or raises a `FatalDiagnosticError` otherwise.
 * @param result The emit result that should have been successful.
 * @param origin The node that is used to report the failure diagnostic.
 * @param typeKind The kind of the symbol that the reference represents, e.g. 'component' or
 *     'class'.
 */
export function assertSuccessfulReferenceEmit(result, origin, typeKind) {
  if (result.kind === ReferenceEmitKind.Success) {
    return;
  }
  const message = makeDiagnosticChain(
    `Unable to import ${typeKind} ${nodeNameForError(result.ref.node)}.`,
    [makeDiagnosticChain(result.reason)],
  );
  throw new FatalDiagnosticError(ErrorCode.IMPORT_GENERATION_FAILURE, origin, message, [
    makeRelatedInformation(result.ref.node, `The ${typeKind} is declared here.`),
  ]);
}
/**
 * Generates `Expression`s which refer to `Reference`s in a given context.
 *
 * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an
 * `Expression` which refers to a `Reference` in the context of a particular file.
 */
export class ReferenceEmitter {
  strategies;
  constructor(strategies) {
    this.strategies = strategies;
  }
  emit(ref, context, importFlags = ImportFlags.None) {
    for (const strategy of this.strategies) {
      const emitted = strategy.emit(ref, context, importFlags);
      if (emitted !== null) {
        return emitted;
      }
    }
    return {
      kind: ReferenceEmitKind.Failed,
      ref,
      context,
      reason: `Unable to write a reference to ${nodeNameForError(ref.node)}.`,
    };
  }
}
/**
 * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if
 * such identifiers are available.
 */
export class LocalIdentifierStrategy {
  emit(ref, context, importFlags) {
    const refSf = getSourceFile(ref.node);
    // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a
    // local identifier at all, *except* in the source file where the node is actually declared.
    if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {
      return null;
    }
    // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,
    // etc) and it is in the current file then just use it directly.
    // This is important because the reference could be a property access (e.g. `exports.foo`). In
    // such a case, the reference's `identities` property would be `[foo]`, which would result in an
    // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.
    if (!isDeclaration(ref.node) && refSf === context) {
      return {
        kind: ReferenceEmitKind.Success,
        expression: new WrappedNodeExpr(ref.node),
        importedFile: null,
      };
    }
    // If the reference is to an ambient type, it can be referenced directly.
    if (ref.isAmbient && importFlags & ImportFlags.AllowAmbientReferences) {
      const identifier = identifierOfNode(ref.node);
      if (identifier !== null) {
        return {
          kind: ReferenceEmitKind.Success,
          expression: new WrappedNodeExpr(identifier),
          importedFile: null,
        };
      } else {
        return null;
      }
    }
    // A Reference can have multiple identities in different files, so it may already have an
    // Identifier in the requested context file.
    const identifier = ref.getIdentityIn(context);
    if (identifier !== null) {
      return {
        kind: ReferenceEmitKind.Success,
        expression: new WrappedNodeExpr(identifier),
        importedFile: null,
      };
    } else {
      return null;
    }
  }
}
/**
 * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using
 * an absolute import.
 *
 * Part of this strategy involves looking at the target entry point and identifying the exported
 * name of the targeted declaration, as it might be different from the declared name (e.g. a
 * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found
 * which maps back to the original directive, an error is thrown.
 */
export class AbsoluteModuleStrategy {
  program;
  checker;
  moduleResolver;
  reflectionHost;
  /**
   * A cache of the exports of specific modules, because resolving a module to its exports is a
   * costly operation.
   */
  moduleExportsCache = new Map();
  constructor(program, checker, moduleResolver, reflectionHost) {
    this.program = program;
    this.checker = checker;
    this.moduleResolver = moduleResolver;
    this.reflectionHost = reflectionHost;
  }
  emit(ref, context, importFlags) {
    if (ref.bestGuessOwningModule === null) {
      // There is no module name available for this Reference, meaning it was arrived at via a
      // relative path.
      return null;
    } else if (!isDeclaration(ref.node)) {
      // It's not possible to import something which isn't a declaration.
      throw new Error(
        `Debug assert: unable to import a Reference to non-declaration of type ${ts.SyntaxKind[ref.node.kind]}.`,
      );
    } else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && isTypeDeclaration(ref.node)) {
      throw new Error(
        `Importing a type-only declaration of type ${ts.SyntaxKind[ref.node.kind]} in a value position is not allowed.`,
      );
    }
    // Try to find the exported name of the declaration, if one is available.
    const {specifier, resolutionContext} = ref.bestGuessOwningModule;
    const exports = this.getExportsOfModule(specifier, resolutionContext);
    if (exports.module === null) {
      return {
        kind: ReferenceEmitKind.Failed,
        ref,
        context,
        reason: `The module '${specifier}' could not be found.`,
      };
    } else if (exports.exportMap === null || !exports.exportMap.has(ref.node)) {
      return {
        kind: ReferenceEmitKind.Failed,
        ref,
        context,
        reason: `The symbol is not exported from ${exports.module.fileName} (module '${specifier}').`,
      };
    }
    const symbolName = exports.exportMap.get(ref.node);
    return {
      kind: ReferenceEmitKind.Success,
      expression: new ExternalExpr(new ExternalReference(specifier, symbolName)),
      importedFile: exports.module,
    };
  }
  getExportsOfModule(moduleName, fromFile) {
    if (!this.moduleExportsCache.has(moduleName)) {
      this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));
    }
    return this.moduleExportsCache.get(moduleName);
  }
  enumerateExportsOfModule(specifier, fromFile) {
    // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.
    const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);
    if (entryPointFile === null) {
      return {module: null, exportMap: null};
    }
    const exports = this.reflectionHost.getExportsOfModule(entryPointFile);
    if (exports === null) {
      return {module: entryPointFile, exportMap: null};
    }
    const exportMap = new Map();
    for (const [name, declaration] of exports) {
      if (exportMap.has(declaration.node)) {
        // An export for this declaration has already been registered. We prefer an export that
        // has the same name as the declared name, i.e. is not an aliased export. This is relevant
        // for partial compilations where emitted references should import symbols using a stable
        // name. This is particularly relevant for declarations inside VE-generated libraries, as
        // such libraries contain private, unstable reexports of symbols.
        const existingExport = exportMap.get(declaration.node);
        if (isNamedDeclaration(declaration.node) && declaration.node.name.text === existingExport) {
          continue;
        }
      }
      exportMap.set(declaration.node, name);
    }
    return {module: entryPointFile, exportMap};
  }
}
/**
 * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're
 * both in the logical project "space" of paths.
 *
 * This is trickier than it sounds, as the two files may be in different root directories in the
 * project. Simply calculating a file system relative path between the two is not sufficient.
 * Instead, `LogicalProjectPath`s are used.
 */
export class LogicalProjectStrategy {
  reflector;
  logicalFs;
  relativePathStrategy;
  constructor(reflector, logicalFs) {
    this.reflector = reflector;
    this.logicalFs = logicalFs;
    this.relativePathStrategy = new RelativePathStrategy(this.reflector);
  }
  emit(ref, context, importFlags) {
    const destSf = getSourceFile(ref.node);
    // Compute the relative path from the importing file to the file being imported. This is done
    // as a logical path computation, because the two files might be in different rootDirs.
    const destPath = this.logicalFs.logicalPathOfSf(destSf);
    if (destPath === null) {
      // The imported file is not within the logical project filesystem. An import into a
      // declaration file is exempt from `TS6059: File is not under 'rootDir'` so we choose to allow
      // using a filesystem relative path as fallback, if allowed per the provided import flags.
      if (destSf.isDeclarationFile && importFlags & ImportFlags.AllowRelativeDtsImports) {
        return this.relativePathStrategy.emit(ref, context);
      }
      // Note: this error is analogous to `TS6059: File is not under 'rootDir'` that TypeScript
      // reports.
      return {
        kind: ReferenceEmitKind.Failed,
        ref,
        context,
        reason: `The file ${destSf.fileName} is outside of the configured 'rootDir'.`,
      };
    }
    const originPath = this.logicalFs.logicalPathOfSf(context);
    if (originPath === null) {
      throw new Error(
        `Debug assert: attempt to import from ${context.fileName} but it's outside the program?`,
      );
    }
    // There's no way to emit a relative reference from a file to itself.
    if (destPath === originPath) {
      return null;
    }
    const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
    if (name === null) {
      // The target declaration isn't exported from the file it's declared in. This is an issue!
      return {
        kind: ReferenceEmitKind.Failed,
        ref,
        context,
        reason: `The symbol is not exported from ${destSf.fileName}.`,
      };
    }
    // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative
    // path is now straightforward.
    const moduleName = LogicalProjectPath.relativePathBetween(originPath, destPath);
    return {
      kind: ReferenceEmitKind.Success,
      expression: new ExternalExpr({moduleName, name}),
      importedFile: destSf,
    };
  }
}
/**
 * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.
 *
 * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which
 * necessitates the stronger logic of `LogicalProjectStrategy`.
 */
export class RelativePathStrategy {
  reflector;
  constructor(reflector) {
    this.reflector = reflector;
  }
  emit(ref, context) {
    const destSf = getSourceFile(ref.node);
    const relativePath = relative(
      dirname(absoluteFromSourceFile(context)),
      absoluteFromSourceFile(destSf),
    );
    const moduleName = toRelativeImport(stripExtension(relativePath));
    const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
    if (name === null) {
      return {
        kind: ReferenceEmitKind.Failed,
        ref,
        context,
        reason: `The symbol is not exported from ${destSf.fileName}.`,
      };
    }
    return {
      kind: ReferenceEmitKind.Success,
      expression: new ExternalExpr({moduleName, name}),
      importedFile: destSf,
    };
  }
}
/**
 * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import
 * references.
 */
export class UnifiedModulesStrategy {
  reflector;
  unifiedModulesHost;
  constructor(reflector, unifiedModulesHost) {
    this.reflector = reflector;
    this.unifiedModulesHost = unifiedModulesHost;
  }
  emit(ref, context) {
    const destSf = getSourceFile(ref.node);
    const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
    if (name === null) {
      return null;
    }
    const moduleName = this.unifiedModulesHost.fileNameToModuleName(
      destSf.fileName,
      context.fileName,
    );
    return {
      kind: ReferenceEmitKind.Success,
      expression: new ExternalExpr({moduleName, name}),
      importedFile: destSf,
    };
  }
}
//# sourceMappingURL=emitter.js.map
