{"version":3,"file":"validators.js","sourceRoot":"","sources":["validators.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  InjectionToken,\n  ɵisPromise as isPromise,\n  ɵisSubscribable as isSubscribable,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\nimport {forkJoin, from, Observable} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport type {\n  AsyncValidator,\n  AsyncValidatorFn,\n  ValidationErrors,\n  Validator,\n  ValidatorFn,\n} from './directives/validators';\nimport {RuntimeErrorCode} from './errors';\nimport type {AbstractControl} from './model/abstract_model';\n\nfunction isEmptyInputValue(value: unknown): boolean {\n  return value == null || lengthOrSize(value) === 0;\n}\n\n/**\n * Extract the length property in case it's an array or a string.\n * Extract the size property in case it's a set.\n * Return null else.\n * @param value Either an array, set or undefined.\n */\nfunction lengthOrSize(value: unknown): number | null {\n  // non-strict comparison is intentional, to check for both `null` and `undefined` values\n  if (value == null) {\n    return null;\n  } else if (Array.isArray(value) || typeof value === 'string') {\n    return value.length;\n  } else if (value instanceof Set) {\n    return value.size;\n  }\n\n  return null;\n}\n\n/**\n * @description\n * An `InjectionToken` for registering additional synchronous validators used with\n * `AbstractControl`s.\n *\n * @see {@link NG_ASYNC_VALIDATORS}\n *\n * @usageNotes\n *\n * ### Providing a custom validator\n *\n * The following example registers a custom validator directive. Adding the validator to the\n * existing collection of validators requires the `multi: true` option.\n *\n * ```ts\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: forwardRef(() => CustomValidatorDirective), multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return { 'custom': true };\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport const NG_VALIDATORS = new InjectionToken<ReadonlyArray<Validator | Function>>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'NgValidators' : '',\n);\n\n/**\n * @description\n * An `InjectionToken` for registering additional asynchronous validators used with\n * `AbstractControl`s.\n *\n * @see {@link NG_VALIDATORS}\n *\n * @usageNotes\n *\n * ### Provide a custom async validator directive\n *\n * The following example implements the `AsyncValidator` interface to create an\n * async validator directive with a custom error key.\n *\n * ```ts\n * @Directive({\n *   selector: '[customAsyncValidator]',\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\n * true}]\n * })\n * class CustomAsyncValidatorDirective implements AsyncValidator {\n *   validate(control: AbstractControl): Promise<ValidationErrors|null> {\n *     return Promise.resolve({'custom': true});\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport const NG_ASYNC_VALIDATORS = new InjectionToken<ReadonlyArray<Validator | Function>>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'NgAsyncValidators' : '',\n);\n\n/**\n * A regular expression that matches valid e-mail addresses.\n *\n * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:\n * - `local-part` consists of one or more of the allowed characters (alphanumeric and some\n *   punctuation symbols).\n * - `local-part` cannot begin or end with a period (`.`).\n * - `local-part` cannot be longer than 64 characters.\n * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or\n *   `foo.com`.\n * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and\n *   periods (`.`)).\n * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).\n * - A `label` cannot be longer than 63 characters.\n * - The whole address cannot be longer than 254 characters.\n *\n * ## Implementation background\n *\n * This regexp was ported over from AngularJS (see there for git history):\n * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27\n * It is based on the\n * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n * lengths of different parts of the address). The main differences from the WHATWG version are:\n *   - Disallow `local-part` to begin or end with a period (`.`).\n *   - Disallow `local-part` length to exceed 64 characters.\n *   - Disallow total address length to exceed 254 characters.\n *\n * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.\n */\nconst EMAIL_REGEXP =\n  /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n/**\n * @description\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * @see [Form Validation](guide/forms/form-validation)\n *\n * @publicApi\n */\nexport class Validators {\n  /**\n   * @description\n   * Validator that requires the control's value to be greater than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a minimum of 3\n   *\n   * ```ts\n   * const control = new FormControl(2, Validators.min(3));\n   *\n   * console.log(control.errors); // {min: {min: 3, actual: 2}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `min` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static min(min: number): ValidatorFn {\n    return minValidator(min);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value to be less than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a maximum of 15\n   *\n   * ```ts\n   * const control = new FormControl(16, Validators.max(15));\n   *\n   * console.log(control.errors); // {max: {max: 15, actual: 16}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `max` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static max(max: number): ValidatorFn {\n    return maxValidator(max);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control have a non-empty value.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field is non-empty\n   *\n   * ```ts\n   * const control = new FormControl('', Validators.required);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map with the `required` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static required(control: AbstractControl): ValidationErrors | null {\n    return requiredValidator(control);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value be true. This validator is commonly\n   * used for required checkboxes.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field value is true\n   *\n   * ```ts\n   * const control = new FormControl('some value', Validators.requiredTrue);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map that contains the `required` property\n   * set to `true` if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors | null {\n    return requiredTrueValidator(control);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value pass an email validation test.\n   *\n   * Tests the value using a [regular\n   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n   * pattern suitable for common use cases. The pattern is based on the definition of a valid email\n   * address in the [WHATWG HTML\n   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n   * lengths of different parts of the address).\n   *\n   * The differences from the WHATWG version include:\n   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\n   * - Disallow `local-part` to be longer than 64 characters.\n   * - Disallow the whole address to be longer than 254 characters.\n   *\n   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\n   * validate the value against a different pattern.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field matches a valid email pattern\n   *\n   * ```ts\n   * const control = new FormControl('bad@', Validators.email);\n   *\n   * console.log(control.errors); // {email: true}\n   * ```\n   *\n   * @returns An error map with the `email` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static email(control: AbstractControl): ValidationErrors | null {\n    return emailValidator(control);\n  }\n\n  /**\n   * @description\n   * Validator that requires the number of items in the control's value to be greater than or equal\n   * to the provided minimum length. This validator is also provided by default if you use\n   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\n   * only for types that have a numeric `length` or `size` property, such as strings, arrays or\n   * sets. The `minLength` validator logic is also not invoked for values when their `length` or\n   * `size` property is 0 (for example in case of an empty string or an empty array), to support\n   * optional controls. You can use the standard `required` validator if empty values should not be\n   * considered valid.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has a minimum of 3 characters\n   *\n   * ```ts\n   * const control = new FormControl('ng', Validators.minLength(3));\n   *\n   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n   * ```\n   *\n   * ```html\n   * <input minlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `minlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static minLength(minLength: number): ValidatorFn {\n    return minLengthValidator(minLength);\n  }\n\n  /**\n   * @description\n   * Validator that requires the number of items in the control's value to be less than or equal\n   * to the provided maximum length. This validator is also provided by default if you use\n   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\n   * only for types that have a numeric `length` or `size` property, such as strings, arrays or\n   * sets.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has maximum of 5 characters\n   *\n   * ```ts\n   * const control = new FormControl('Angular', Validators.maxLength(5));\n   *\n   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n   * ```\n   *\n   * ```html\n   * <input maxlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `maxlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static maxLength(maxLength: number): ValidatorFn {\n    return maxLengthValidator(maxLength);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value to match a regex pattern. This validator is also\n   * provided by default if you use the HTML5 `pattern` attribute.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field only contains letters or spaces\n   *\n   * ```ts\n   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n   *\n   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n   * ```\n   *\n   * ```html\n   * <input pattern=\"[a-zA-Z ]*\">\n   * ```\n   *\n   * ### Pattern matching with the global or sticky flag\n   *\n   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`\n   * can produce different results on the same input when validations are run consecutively. This is\n   * due to how the behavior of `RegExp.prototype.test` is\n   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)\n   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).\n   * Due to this behavior, it is recommended that when using\n   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky\n   * flag enabled.\n   *\n   * ```ts\n   * // Not recommended (since the `g` flag is used)\n   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));\n   *\n   * // Good\n   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));\n   * ```\n   *\n   * @param pattern A regular expression to be used as is to test the values, or a string.\n   * If a string is passed, the `^` character is prepended and the `$` character is\n   * appended to the provided string (if not already present), and the resulting regular\n   * expression is used to test the values.\n   *\n   * @returns A validator function that returns an error map with the\n   * `pattern` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static pattern(pattern: string | RegExp): ValidatorFn {\n    return patternValidator(pattern);\n  }\n\n  /**\n   * @description\n   * Validator that performs no operation.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors | null {\n    return nullValidator(control);\n  }\n\n  /**\n   * @description\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error maps of the validators if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static compose(validators: null): null;\n  static compose(validators: (ValidatorFn | null | undefined)[]): ValidatorFn | null;\n  static compose(validators: (ValidatorFn | null | undefined)[] | null): ValidatorFn | null {\n    return compose(validators);\n  }\n\n  /**\n   * @description\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error objects for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error objects of the async validators if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static composeAsync(validators: (AsyncValidatorFn | null)[]): AsyncValidatorFn | null {\n    return composeAsync(validators);\n  }\n}\n\n/**\n * Validator that requires the control's value to be greater than or equal to the provided number.\n * See `Validators.min` for additional information.\n */\nexport function minValidator(min: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    if (control.value == null || min == null) {\n      return null; // don't validate empty values to allow optional controls\n    }\n    const value = parseFloat(control.value);\n    // Controls with NaN values after parsing should be treated as not having a\n    // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n    return !isNaN(value) && value < min ? {'min': {'min': min, 'actual': control.value}} : null;\n  };\n}\n\n/**\n * Validator that requires the control's value to be less than or equal to the provided number.\n * See `Validators.max` for additional information.\n */\nexport function maxValidator(max: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    if (control.value == null || max == null) {\n      return null; // don't validate empty values to allow optional controls\n    }\n    const value = parseFloat(control.value);\n    // Controls with NaN values after parsing should be treated as not having a\n    // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n    return !isNaN(value) && value > max ? {'max': {'max': max, 'actual': control.value}} : null;\n  };\n}\n\n/**\n * Validator that requires the control have a non-empty value.\n * See `Validators.required` for additional information.\n */\nexport function requiredValidator(control: AbstractControl): ValidationErrors | null {\n  return isEmptyInputValue(control.value) ? {'required': true} : null;\n}\n\n/**\n * Validator that requires the control's value be true. This validator is commonly\n * used for required checkboxes.\n * See `Validators.requiredTrue` for additional information.\n */\nexport function requiredTrueValidator(control: AbstractControl): ValidationErrors | null {\n  return control.value === true ? null : {'required': true};\n}\n\n/**\n * Validator that requires the control's value pass an email validation test.\n * See `Validators.email` for additional information.\n */\nexport function emailValidator(control: AbstractControl): ValidationErrors | null {\n  if (isEmptyInputValue(control.value)) {\n    return null; // don't validate empty values to allow optional controls\n  }\n  return EMAIL_REGEXP.test(control.value) ? null : {'email': true};\n}\n\n/**\n * Validator that requires the number of items in the control's value to be greater than or equal\n * to the provided minimum length. See `Validators.minLength` for additional information.\n *\n * The minLengthValidator respects every length property in an object, regardless of whether it's an array.\n * For example, the object {id: 1, length: 0, width: 0} should be validated.\n */\nexport function minLengthValidator(minLength: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const length = control.value?.length ?? lengthOrSize(control.value);\n    if (length === null || length === 0) {\n      // don't validate empty values to allow optional controls\n      // don't validate values without `length` or `size` property\n      return null;\n    }\n\n    return length < minLength\n      ? {'minlength': {'requiredLength': minLength, 'actualLength': length}}\n      : null;\n  };\n}\n\n/**\n * Validator that requires the number of items in the control's value to be less than or equal\n * to the provided maximum length. See `Validators.maxLength` for additional information.\n *\n * The maxLengthValidator respects every length property in an object, regardless of whether it's an array.\n * For example, the object {id: 1, length: 0, width: 0} should be validated.\n */\nexport function maxLengthValidator(maxLength: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const length = control.value?.length ?? lengthOrSize(control.value);\n    if (length !== null && length > maxLength) {\n      return {'maxlength': {'requiredLength': maxLength, 'actualLength': length}};\n    }\n    return null;\n  };\n}\n\n/**\n * Validator that requires the control's value to match a regex pattern.\n * See `Validators.pattern` for additional information.\n */\nexport function patternValidator(pattern: string | RegExp): ValidatorFn {\n  if (!pattern) return nullValidator;\n  let regex: RegExp;\n  let regexStr: string;\n  if (typeof pattern === 'string') {\n    regexStr = '';\n\n    if (pattern.charAt(0) !== '^') regexStr += '^';\n\n    regexStr += pattern;\n\n    if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n\n    regex = new RegExp(regexStr);\n  } else {\n    regexStr = pattern.toString();\n    regex = pattern;\n  }\n  return (control: AbstractControl): ValidationErrors | null => {\n    if (isEmptyInputValue(control.value)) {\n      return null; // don't validate empty values to allow optional controls\n    }\n    const value: string = control.value;\n    return regex.test(value)\n      ? null\n      : {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n  };\n}\n\n/**\n * Function that has `ValidatorFn` shape, but performs no operation.\n */\nexport function nullValidator(control: AbstractControl): ValidationErrors | null {\n  return null;\n}\n\nfunction isPresent(o: any): boolean {\n  return o != null;\n}\n\nexport function toObservable(value: any): Observable<any> {\n  const obs = isPromise(value) ? from(value) : value;\n  if ((typeof ngDevMode === 'undefined' || ngDevMode) && !isSubscribable(obs)) {\n    let errorMessage = `Expected async validator to return Promise or Observable.`;\n    // A synchronous validator will return object or null.\n    if (typeof value === 'object') {\n      errorMessage +=\n        ' Are you using a synchronous validator where an async validator is expected?';\n    }\n    throw new RuntimeError(RuntimeErrorCode.WRONG_VALIDATOR_RETURN_TYPE, errorMessage);\n  }\n  return obs;\n}\n\nfunction mergeErrors(arrayOfErrors: (ValidationErrors | null)[]): ValidationErrors | null {\n  let res: {[key: string]: any} = {};\n  arrayOfErrors.forEach((errors: ValidationErrors | null) => {\n    res = errors != null ? {...res!, ...errors} : res!;\n  });\n\n  return Object.keys(res).length === 0 ? null : res;\n}\n\ntype GenericValidatorFn = (control: AbstractControl) => any;\n\nfunction executeValidators<V extends GenericValidatorFn>(\n  control: AbstractControl,\n  validators: V[],\n): ReturnType<V>[] {\n  return validators.map((validator) => validator(control));\n}\n\nfunction isValidatorFn<V>(validator: V | Validator | AsyncValidator): validator is V {\n  return !(validator as Validator).validate;\n}\n\n/**\n * Given the list of validators that may contain both functions as well as classes, return the list\n * of validator functions (convert validator classes into validator functions). This is needed to\n * have consistent structure in validators list before composing them.\n *\n * @param validators The set of validators that may contain validators both in plain function form\n *     as well as represented as a validator class.\n */\nexport function normalizeValidators<V>(validators: (V | Validator | AsyncValidator)[]): V[] {\n  return validators.map((validator) => {\n    return isValidatorFn<V>(validator)\n      ? validator\n      : (((c: AbstractControl) => validator.validate(c)) as unknown as V);\n  });\n}\n\n/**\n * Merges synchronous validators into a single validator function.\n * See `Validators.compose` for additional information.\n */\nfunction compose(validators: (ValidatorFn | null | undefined)[] | null): ValidatorFn | null {\n  if (!validators) return null;\n  const presentValidators: ValidatorFn[] = validators.filter(isPresent) as any;\n  if (presentValidators.length == 0) return null;\n\n  return function (control: AbstractControl) {\n    return mergeErrors(executeValidators<ValidatorFn>(control, presentValidators));\n  };\n}\n\n/**\n * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),\n * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single\n * validator function.\n */\nexport function composeValidators(validators: Array<Validator | ValidatorFn>): ValidatorFn | null {\n  return validators != null ? compose(normalizeValidators<ValidatorFn>(validators)) : null;\n}\n\n/**\n * Merges asynchronous validators into a single validator function.\n * See `Validators.composeAsync` for additional information.\n */\nfunction composeAsync(validators: (AsyncValidatorFn | null)[]): AsyncValidatorFn | null {\n  if (!validators) return null;\n  const presentValidators: AsyncValidatorFn[] = validators.filter(isPresent) as any;\n  if (presentValidators.length == 0) return null;\n\n  return function (control: AbstractControl) {\n    const observables = executeValidators<AsyncValidatorFn>(control, presentValidators).map(\n      toObservable,\n    );\n    return forkJoin(observables).pipe(map(mergeErrors));\n  };\n}\n\n/**\n * Accepts a list of async validators of different possible shapes (`AsyncValidator` and\n * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges\n * them into a single validator function.\n */\nexport function composeAsyncValidators(\n  validators: Array<AsyncValidator | AsyncValidatorFn>,\n): AsyncValidatorFn | null {\n  return validators != null\n    ? composeAsync(normalizeValidators<AsyncValidatorFn>(validators))\n    : null;\n}\n\n/**\n * Merges raw control validators with a given directive validator and returns the combined list of\n * validators as an array.\n */\nexport function mergeValidators<V>(controlValidators: V | V[] | null, dirValidator: V): V[] {\n  if (controlValidators === null) return [dirValidator];\n  return Array.isArray(controlValidators)\n    ? [...controlValidators, dirValidator]\n    : [controlValidators, dirValidator];\n}\n\n/**\n * Retrieves the list of raw synchronous validators attached to a given control.\n */\nexport function getControlValidators(control: AbstractControl): ValidatorFn | ValidatorFn[] | null {\n  return (control as any)._rawValidators as ValidatorFn | ValidatorFn[] | null;\n}\n\n/**\n * Retrieves the list of raw asynchronous validators attached to a given control.\n */\nexport function getControlAsyncValidators(\n  control: AbstractControl,\n): AsyncValidatorFn | AsyncValidatorFn[] | null {\n  return (control as any)._rawAsyncValidators as AsyncValidatorFn | AsyncValidatorFn[] | null;\n}\n\n/**\n * Accepts a singleton validator, an array, or null, and returns an array type with the provided\n * validators.\n *\n * @param validators A validator, validators, or null.\n * @returns A validators array.\n */\nexport function makeValidatorsArray<T extends ValidatorFn | AsyncValidatorFn>(\n  validators: T | T[] | null,\n): T[] {\n  if (!validators) return [];\n  return Array.isArray(validators) ? validators : [validators];\n}\n\n/**\n * Determines whether a validator or validators array has a given validator.\n *\n * @param validators The validator or validators to compare against.\n * @param validator The validator to check.\n * @returns Whether the validator is present.\n */\nexport function hasValidator<T extends ValidatorFn | AsyncValidatorFn>(\n  validators: T | T[] | null,\n  validator: T,\n): boolean {\n  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;\n}\n\n/**\n * Combines two arrays of validators into one. If duplicates are provided, only one will be added.\n *\n * @param validators The new validators.\n * @param currentValidators The base array of current validators.\n * @returns An array of validators.\n */\nexport function addValidators<T extends ValidatorFn | AsyncValidatorFn>(\n  validators: T | T[],\n  currentValidators: T | T[] | null,\n): T[] {\n  const current = makeValidatorsArray(currentValidators);\n  const validatorsToAdd = makeValidatorsArray(validators);\n  validatorsToAdd.forEach((v: T) => {\n    // Note: if there are duplicate entries in the new validators array,\n    // only the first one would be added to the current list of validators.\n    // Duplicate ones would be ignored since `hasValidator` would detect\n    // the presence of a validator function and we update the current list in place.\n    if (!hasValidator(current, v)) {\n      current.push(v);\n    }\n  });\n  return current;\n}\n\nexport function removeValidators<T extends ValidatorFn | AsyncValidatorFn>(\n  validators: T | T[],\n  currentValidators: T | T[] | null,\n): T[] {\n  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));\n}\n"]}