{"version":3,"file":"form_builder.js","sourceRoot":"","sources":["form_builder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable} from '@angular/core';\n\nimport {AsyncValidatorFn, ValidatorFn} from './directives/validators';\nimport {AbstractControl, AbstractControlOptions, FormHooks} from './model/abstract_model';\nimport {FormArray, UntypedFormArray} from './model/form_array';\nimport {\n  FormControl,\n  FormControlOptions,\n  FormControlState,\n  UntypedFormControl,\n} from './model/form_control';\nimport {FormGroup, FormRecord, UntypedFormGroup} from './model/form_group';\n\nfunction isAbstractControlOptions(\n  options: AbstractControlOptions | {[key: string]: any} | null | undefined,\n): options is AbstractControlOptions {\n  return (\n    !!options &&\n    ((options as AbstractControlOptions).asyncValidators !== undefined ||\n      (options as AbstractControlOptions).validators !== undefined ||\n      (options as AbstractControlOptions).updateOn !== undefined)\n  );\n}\n\n/**\n * The union of all validator types that can be accepted by a ControlConfig.\n */\ntype ValidatorConfig = ValidatorFn | AsyncValidatorFn | ValidatorFn[] | AsyncValidatorFn[];\n\n/**\n * The compiler may not always be able to prove that the elements of the control config are a tuple\n * (i.e. occur in a fixed order). This slightly looser type is used for inference, to catch cases\n * where the compiler cannot prove order and position.\n *\n * For example, consider the simple case `fb.group({foo: ['bar', Validators.required]})`. The\n * compiler will infer this as an array, not as a tuple.\n */\ntype PermissiveControlConfig<T> = Array<T | FormControlState<T> | ValidatorConfig>;\n\n/**\n * Helper type to allow the compiler to accept [XXXX, { updateOn: string }] as a valid shorthand\n * argument for .group()\n */\ninterface PermissiveAbstractControlOptions extends Omit<AbstractControlOptions, 'updateOn'> {\n  updateOn?: string;\n}\n\n// Note: these two types have been extracted into type aliases to work around a .d.ts generation\n// issue in TypeScript 5.7. See: https://github.com/Microsoft/TypeScript/issues/60506. The types\n// have to be exported for the workaround to work.\n/** A map of nullable form controls. */\nexport type ɵNullableFormControls<T> = {[K in keyof T]: ɵElement<T[K], null>};\n\n/** A map of non-nullable form controls. */\nexport type ɵNonNullableFormControls<T> = {[K in keyof T]: ɵElement<T[K], never>};\n\n/**\n * ControlConfig<T> is a tuple containing a value of type T, plus optional validators and async\n * validators.\n *\n * @publicApi\n */\nexport type ControlConfig<T> = [\n  T | FormControlState<T>,\n  (ValidatorFn | ValidatorFn[])?,\n  (AsyncValidatorFn | AsyncValidatorFn[])?,\n];\n\n/**\n * FormBuilder accepts values in various container shapes, as well as raw values.\n * Element returns the appropriate corresponding model class, given the container T.\n * The flag N, if not never, makes the resulting `FormControl` have N in its type.\n */\nexport type ɵElement<T, N extends null> =\n  // The `extends` checks are wrapped in arrays in order to prevent TypeScript from applying type unions\n  // through the distributive conditional type. This is the officially recommended solution:\n  // https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n  //\n  // Identify FormControl container types.\n  [T] extends [FormControl<infer U>]\n    ? FormControl<U>\n    : // Or FormControl containers that are optional in their parent group.\n      [T] extends [FormControl<infer U> | undefined]\n      ? FormControl<U>\n      : // FormGroup containers.\n        [T] extends [FormGroup<infer U>]\n        ? FormGroup<U>\n        : // Optional FormGroup containers.\n          [T] extends [FormGroup<infer U> | undefined]\n          ? FormGroup<U>\n          : // FormRecord containers.\n            [T] extends [FormRecord<infer U>]\n            ? FormRecord<U>\n            : // Optional FormRecord containers.\n              [T] extends [FormRecord<infer U> | undefined]\n              ? FormRecord<U>\n              : // FormArray containers.\n                [T] extends [FormArray<infer U>]\n                ? FormArray<U>\n                : // Optional FormArray containers.\n                  [T] extends [FormArray<infer U> | undefined]\n                  ? FormArray<U>\n                  : // Otherwise unknown AbstractControl containers.\n                    [T] extends [AbstractControl<infer U>]\n                    ? AbstractControl<U>\n                    : // Optional AbstractControl containers.\n                      [T] extends [AbstractControl<infer U> | undefined]\n                      ? AbstractControl<U>\n                      : // FormControlState object container, which produces a nullable control.\n                        [T] extends [FormControlState<infer U>]\n                        ? FormControl<U | N>\n                        : // A ControlConfig tuple, which produces a nullable control.\n                          [T] extends [PermissiveControlConfig<infer U>]\n                          ? FormControl<\n                              Exclude<U, ValidatorConfig | PermissiveAbstractControlOptions> | N\n                            >\n                          : FormControl<T | N>;\n\n/**\n * @description\n * Creates an `AbstractControl` from a user-specified configuration.\n *\n * The `FormBuilder` provides syntactic sugar that shortens creating instances of a\n * `FormControl`, `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to\n * build complex forms.\n *\n * @see [Reactive Forms Guide](guide/forms/reactive-forms)\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class FormBuilder {\n  private useNonNullable: boolean = false;\n\n  /**\n   * @description\n   * Returns a FormBuilder in which automatically constructed `FormControl` elements\n   * have `{nonNullable: true}` and are non-nullable.\n   *\n   * **Constructing non-nullable controls**\n   *\n   * When constructing a control, it will be non-nullable, and will reset to its initial value.\n   *\n   * ```ts\n   * let nnfb = new FormBuilder().nonNullable;\n   * let name = nnfb.control('Alex'); // FormControl<string>\n   * name.reset();\n   * console.log(name); // 'Alex'\n   * ```\n   *\n   * **Constructing non-nullable groups or arrays**\n   *\n   * When constructing a group or array, all automatically created inner controls will be\n   * non-nullable, and will reset to their initial values.\n   *\n   * ```ts\n   * let nnfb = new FormBuilder().nonNullable;\n   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>\n   * name.reset();\n   * console.log(name); // {who: 'Alex'}\n   * ```\n   * **Constructing *nullable* fields on groups or arrays**\n   *\n   * It is still possible to have a nullable field. In particular, any `FormControl` which is\n   * *already* constructed will not be altered. For example:\n   *\n   * ```ts\n   * let nnfb = new FormBuilder().nonNullable;\n   * // FormGroup<{who: FormControl<string|null>}>\n   * let name = nnfb.group({who: new FormControl('Alex')});\n   * name.reset(); console.log(name); // {who: null}\n   * ```\n   *\n   * Because the inner control is constructed explicitly by the caller, the builder has\n   * no control over how it is created, and cannot exclude the `null`.\n   */\n  get nonNullable(): NonNullableFormBuilder {\n    const nnfb = new FormBuilder();\n    nnfb.useNonNullable = true;\n    return nnfb as NonNullableFormBuilder;\n  }\n\n  /**\n   * @description\n   * Constructs a new `FormGroup` instance. Accepts a single generic argument, which is an object\n   * containing all the keys and corresponding inner control types.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param options Configuration options object for the `FormGroup`. The object should have the\n   * `AbstractControlOptions` type and might contain the following fields:\n   * * `validators`: A synchronous validator function, or an array of validator functions.\n   * * `asyncValidators`: A single async validator or array of async validator functions.\n   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'\n   * | submit').\n   */\n  group<T extends {}>(\n    controls: T,\n    options?: AbstractControlOptions | null,\n  ): FormGroup<ɵNullableFormControls<T>>;\n\n  /**\n   * @description\n   * Constructs a new `FormGroup` instance.\n   *\n   * @deprecated This API is not typesafe and can result in issues with Closure Compiler renaming.\n   * Use the `FormBuilder#group` overload with `AbstractControlOptions` instead.\n   * Note that `AbstractControlOptions` expects `validators` and `asyncValidators` to be valid\n   * validators. If you have custom validators, make sure their validation function parameter is\n   * `AbstractControl` and not a sub-class, such as `FormGroup`. These functions will be called\n   * with an object of type `AbstractControl` and that cannot be automatically downcast to a\n   * subclass, so TypeScript sees this as an error. For example, change the `(group: FormGroup) =>\n   * ValidationErrors|null` signature to be `(group: AbstractControl) => ValidationErrors|null`.\n   *\n   * @param controls A record of child controls. The key for each child is the name\n   * under which the control is registered.\n   *\n   * @param options Configuration options object for the `FormGroup`. The legacy configuration\n   * object consists of:\n   * * `validator`: A synchronous validator function, or an array of validator functions.\n   * * `asyncValidator`: A single async validator or array of async validator functions\n   * Note: the legacy format is deprecated and might be removed in one of the next major versions\n   * of Angular.\n   */\n  group(controls: {[key: string]: any}, options: {[key: string]: any}): FormGroup;\n\n  group(\n    controls: {[key: string]: any},\n    options: AbstractControlOptions | {[key: string]: any} | null = null,\n  ): FormGroup {\n    const reducedControls = this._reduceControls(controls);\n    let newOptions: FormControlOptions = {};\n    if (isAbstractControlOptions(options)) {\n      // `options` are `AbstractControlOptions`\n      newOptions = options;\n    } else if (options !== null) {\n      // `options` are legacy form group options\n      newOptions.validators = (options as any).validator;\n      newOptions.asyncValidators = (options as any).asyncValidator;\n    }\n    return new FormGroup(reducedControls, newOptions);\n  }\n\n  /**\n   * @description\n   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object\n   * containing all the keys and corresponding inner control types.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param options Configuration options object for the `FormRecord`. The object should have the\n   * `AbstractControlOptions` type and might contain the following fields:\n   * * `validators`: A synchronous validator function, or an array of validator functions.\n   * * `asyncValidators`: A single async validator or array of async validator functions.\n   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'\n   * | submit').\n   */\n  record<T>(\n    controls: {[key: string]: T},\n    options: AbstractControlOptions | null = null,\n  ): FormRecord<ɵElement<T, null>> {\n    const reducedControls = this._reduceControls(controls);\n    // Cast to `any` because the inferred types are not as specific as Element.\n    return new FormRecord(reducedControls, options) as any;\n  }\n\n  /** @deprecated Use `nonNullable` instead. */\n  control<T>(\n    formState: T | FormControlState<T>,\n    opts: FormControlOptions & {\n      initialValueIsDefault: true;\n    },\n  ): FormControl<T>;\n\n  control<T>(\n    formState: T | FormControlState<T>,\n    opts: FormControlOptions & {nonNullable: true},\n  ): FormControl<T>;\n\n  /**\n   * @deprecated When passing an `options` argument, the `asyncValidator` argument has no effect.\n   */\n  control<T>(\n    formState: T | FormControlState<T>,\n    opts: FormControlOptions,\n    asyncValidator: AsyncValidatorFn | AsyncValidatorFn[],\n  ): FormControl<T | null>;\n\n  control<T>(\n    formState: T | FormControlState<T>,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): FormControl<T | null>;\n\n  /**\n   * @description\n   * Constructs a new `FormControl` with the given state, validators and options. Sets\n   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the\n   * control will be nullable. Accepts a single generic argument, which is the type  of the\n   * control's value.\n   *\n   * @param formState Initializes the control with an initial state value, or\n   * with an object that contains both a value and a disabled status.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or a `FormControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator\n   * functions.\n   *\n   * @usageNotes\n   *\n   * ### Initialize a control as disabled\n   *\n   * The following example returns a control with an initial value in a disabled state.\n   *\n   * {@example forms/ts/formBuilder/form_builder_example.ts region='disabled-control'}\n   */\n  control<T>(\n    formState: T | FormControlState<T>,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): FormControl {\n    let newOptions: FormControlOptions = {};\n    if (!this.useNonNullable) {\n      return new FormControl(formState, validatorOrOpts, asyncValidator);\n    }\n    if (isAbstractControlOptions(validatorOrOpts)) {\n      // If the second argument is options, then they are copied.\n      newOptions = validatorOrOpts;\n    } else {\n      // If the other arguments are validators, they are copied into an options object.\n      newOptions.validators = validatorOrOpts;\n      newOptions.asyncValidators = asyncValidator;\n    }\n    return new FormControl<T>(formState, {...newOptions, nonNullable: true});\n  }\n\n  /**\n   * Constructs a new `FormArray` from the given array of configurations,\n   * validators and options. Accepts a single generic argument, which is the type of each control\n   * inside the array.\n   *\n   * @param controls An array of child controls or control configs. Each child control is given an\n   *     index when it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an\n   *     `AbstractControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions.\n   */\n  array<T>(\n    controls: Array<T>,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): FormArray<ɵElement<T, null>> {\n    const createdControls = controls.map((c) => this._createControl(c));\n    // Cast to `any` because the inferred types are not as specific as Element.\n    return new FormArray(createdControls, validatorOrOpts, asyncValidator) as any;\n  }\n\n  /** @internal */\n  _reduceControls<T>(controls: {\n    [k: string]: T | ControlConfig<T> | FormControlState<T> | AbstractControl<T>;\n  }): {[key: string]: AbstractControl} {\n    const createdControls: {[key: string]: AbstractControl} = {};\n    Object.keys(controls).forEach((controlName) => {\n      createdControls[controlName] = this._createControl(controls[controlName]);\n    });\n    return createdControls;\n  }\n\n  /** @internal */\n  _createControl<T>(\n    controls: T | FormControlState<T> | ControlConfig<T> | FormControl<T> | AbstractControl<T>,\n  ): FormControl<T> | FormControl<T | null> | AbstractControl<T> {\n    if (controls instanceof FormControl) {\n      return controls as FormControl<T>;\n    } else if (controls instanceof AbstractControl) {\n      // A control; just return it\n      return controls;\n    } else if (Array.isArray(controls)) {\n      // ControlConfig Tuple\n      const value: T | FormControlState<T> = controls[0];\n      const validator: ValidatorFn | ValidatorFn[] | null =\n        controls.length > 1 ? controls[1]! : null;\n      const asyncValidator: AsyncValidatorFn | AsyncValidatorFn[] | null =\n        controls.length > 2 ? controls[2]! : null;\n      return this.control<T>(value, validator, asyncValidator);\n    } else {\n      // T or FormControlState<T>\n      return this.control<T>(controls);\n    }\n  }\n}\n\n/**\n * @description\n * `NonNullableFormBuilder` is similar to {@link FormBuilder}, but automatically constructed\n * {@link FormControl} elements have `{nonNullable: true}` and are non-nullable.\n *\n * @publicApi\n */\n@Injectable({\n  providedIn: 'root',\n  useFactory: () => inject(FormBuilder).nonNullable,\n})\nexport abstract class NonNullableFormBuilder {\n  /**\n   * Similar to `FormBuilder#group`, except any implicitly constructed `FormControl`\n   * will be non-nullable (i.e. it will have `nonNullable` set to true). Note\n   * that already-constructed controls will not be altered.\n   */\n  abstract group<T extends {}>(\n    controls: T,\n    options?: AbstractControlOptions | null,\n  ): FormGroup<ɵNonNullableFormControls<T>>;\n\n  /**\n   * Similar to `FormBuilder#record`, except any implicitly constructed `FormControl`\n   * will be non-nullable (i.e. it will have `nonNullable` set to true). Note\n   * that already-constructed controls will not be altered.\n   */\n  abstract record<T>(\n    controls: {[key: string]: T},\n    options?: AbstractControlOptions | null,\n  ): FormRecord<ɵElement<T, never>>;\n\n  /**\n   * Similar to `FormBuilder#array`, except any implicitly constructed `FormControl`\n   * will be non-nullable (i.e. it will have `nonNullable` set to true). Note\n   * that already-constructed controls will not be altered.\n   */\n  abstract array<T>(\n    controls: Array<T>,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): FormArray<ɵElement<T, never>>;\n\n  /**\n   * Similar to `FormBuilder#control`, except this overridden version of `control` forces\n   * `nonNullable` to be `true`, resulting in the control always being non-nullable.\n   */\n  abstract control<T>(\n    formState: T | FormControlState<T>,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): FormControl<T>;\n}\n\n/**\n * UntypedFormBuilder is the same as `FormBuilder`, but it provides untyped controls.\n */\n@Injectable({providedIn: 'root'})\nexport class UntypedFormBuilder extends FormBuilder {\n  /**\n   * Like `FormBuilder#group`, except the resulting group is untyped.\n   */\n  override group(\n    controlsConfig: {[key: string]: any},\n    options?: AbstractControlOptions | null,\n  ): UntypedFormGroup;\n\n  /**\n   * @deprecated This API is not typesafe and can result in issues with Closure Compiler renaming.\n   * Use the `FormBuilder#group` overload with `AbstractControlOptions` instead.\n   */\n  override group(\n    controlsConfig: {[key: string]: any},\n    options: {[key: string]: any},\n  ): UntypedFormGroup;\n\n  override group(\n    controlsConfig: {[key: string]: any},\n    options: AbstractControlOptions | {[key: string]: any} | null = null,\n  ): UntypedFormGroup {\n    return super.group(controlsConfig, options);\n  }\n\n  /**\n   * Like `FormBuilder#control`, except the resulting control is untyped.\n   */\n  override control(\n    formState: any,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): UntypedFormControl {\n    return super.control(formState, validatorOrOpts, asyncValidator);\n  }\n\n  /**\n   * Like `FormBuilder#array`, except the resulting array is untyped.\n   */\n  override array(\n    controlsConfig: any[],\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): UntypedFormArray {\n    return super.array(controlsConfig, validatorOrOpts, asyncValidator);\n  }\n}\n"]}