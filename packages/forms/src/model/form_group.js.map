{"version":3,"file":"form_group.js","sourceRoot":"","sources":["form_group.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵWritable as Writable} from '@angular/core';\n\nimport {AsyncValidatorFn, ValidatorFn} from '../directives/validators';\n\nimport {\n  AbstractControl,\n  AbstractControlOptions,\n  assertAllValuesPresent,\n  assertControlPresent,\n  FormResetEvent,\n  pickAsyncValidators,\n  pickValidators,\n  ɵRawValue,\n  ɵTypedOrUntyped,\n  ɵValue,\n} from './abstract_model';\nimport {FormControlState} from './form_control';\n\n/**\n * FormGroupValue extracts the type of `.value` from a FormGroup's inner object type. The untyped\n * case falls back to {[key: string]: any}.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n *\n * For internal use only.\n */\n\nexport type ɵFormGroupArgumentValue<T extends {[K in keyof T]?: AbstractControl<any>}> =\n  ɵTypedOrUntyped<\n    T,\n    Partial<{[K in keyof T]: ɵValue<T[K]> | FormControlState<ɵValue<T[K]>>}>,\n    {[key: string]: any}\n  >;\n\nexport type ɵFormGroupValue<T extends {[K in keyof T]?: AbstractControl<any>}> = ɵTypedOrUntyped<\n  T,\n  Partial<{[K in keyof T]: ɵValue<T[K]>}>,\n  {[key: string]: any}\n>;\n\n/**\n * FormGroupRawValue extracts the type of `.getRawValue()` from a FormGroup's inner object type. The\n * untyped case falls back to {[key: string]: any}.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n *\n * For internal use only.\n */\nexport type ɵFormGroupRawValue<T extends {[K in keyof T]?: AbstractControl<any>}> = ɵTypedOrUntyped<\n  T,\n  {[K in keyof T]: ɵRawValue<T[K]>},\n  {[key: string]: any}\n>;\n\n/**\n * OptionalKeys returns the union of all optional keys in the object.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n */\nexport type ɵOptionalKeys<T> = {\n  [K in keyof T]-?: undefined extends T[K] ? K : never;\n}[keyof T];\n\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the four fundamental building blocks used to define forms in Angular,\n * along with `FormControl`, `FormArray`, and `FormRecord`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * `FormGroup` is intended for use cases where the keys are known ahead of time.\n * If you need to dynamically add and remove controls, use {@link FormRecord} instead.\n *\n * `FormGroup` accepts an optional type parameter `TControl`, which is an object type with inner\n * control types as values.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```ts\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### The type argument, and optional controls\n *\n * `FormGroup` accepts one generic argument, which is an object containing its inner controls.\n * This type will usually be inferred automatically, but you can always specify it explicitly if you\n * wish.\n *\n * If you have controls that are optional (i.e. they can be removed, you can use the `?` in the\n * type):\n *\n * ```ts\n * const form = new FormGroup<{\n *   first: FormControl<string|null>,\n *   middle?: FormControl<string|null>, // Middle name is optional.\n *   last: FormControl<string|null>,\n * }>({\n *   first: new FormControl('Nancy'),\n *   last: new FormControl('Drew'),\n * });\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```ts\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```ts\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n *\n * ### Using a FormGroup with optional controls\n *\n * It is possible to have optional controls in a FormGroup. An optional control can be removed later\n * using `removeControl`, and can be omitted when calling `reset`. Optional controls must be\n * declared optional in the group's type.\n *\n * ```ts\n * const c = new FormGroup<{one?: FormControl<string>}>({\n *   one: new FormControl('')\n * });\n * ```\n *\n * Notice that `c.value.one` has type `string|null|undefined`. This is because calling `c.reset({})`\n * without providing the optional key `one` will cause it to become `null`.\n *\n * @publicApi\n */\nexport class FormGroup<\n  TControl extends {[K in keyof TControl]: AbstractControl<any>} = any,\n> extends AbstractControl<\n  ɵTypedOrUntyped<TControl, ɵFormGroupValue<TControl>, any>,\n  ɵTypedOrUntyped<TControl, ɵFormGroupRawValue<TControl>, any>,\n  ɵTypedOrUntyped<TControl, ɵFormGroupArgumentValue<TControl>, any>\n> {\n  /**\n   * Creates a new `FormGroup` instance.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n    controls: TControl,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateFormGroupControls(controls);\n    this.controls = controls;\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,\n      // so we set `emitEvent` to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator,\n    });\n  }\n\n  public controls: ɵTypedOrUntyped<TControl, TControl, {[key: string]: AbstractControl<any>}>;\n\n  /**\n   * Registers a control with the group's list of controls. In a strongly-typed group, the control\n   * must be in the group's type (possibly as an optional key).\n   *\n   * This method does not update the value or validity of the control.\n   * Use {@link FormGroup#addControl addControl} instead.\n   *\n   * @param name The control name to register in the collection\n   * @param control Provides the control for the given name\n   */\n  registerControl<K extends string & keyof TControl>(name: K, control: TControl[K]): TControl[K];\n  registerControl(\n    this: FormGroup<{[key: string]: AbstractControl<any>}>,\n    name: string,\n    control: AbstractControl<any>,\n  ): AbstractControl<any>;\n\n  registerControl<K extends string & keyof TControl>(name: K, control: TControl[K]): TControl[K] {\n    if (this.controls[name]) return (this.controls as any)[name];\n    this.controls[name] = control;\n    control.setParent(this as FormGroup);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n\n  /**\n   * Add a control to this group. In a strongly-typed group, the control must be in the group's type\n   * (possibly as an optional key).\n   *\n   * If a control with a given name already exists, it would *not* be replaced with a new one.\n   * If you want to replace an existing control, use the {@link FormGroup#setControl setControl}\n   * method instead. This method also updates the value and validity of the control.\n   *\n   * @param name The control name to add to the collection\n   * @param control Provides the control for the given name\n   * @param options Specifies whether this FormGroup instance should emit events after a new\n   *     control is added.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * added. When false, no events are emitted.\n   */\n  addControl(\n    this: FormGroup<{[key: string]: AbstractControl<any>}>,\n    name: string,\n    control: AbstractControl,\n    options?: {emitEvent?: boolean},\n  ): void;\n  addControl<K extends string & keyof TControl>(\n    name: K,\n    control: Required<TControl>[K],\n    options?: {\n      emitEvent?: boolean;\n    },\n  ): void;\n\n  addControl<K extends string & keyof TControl>(\n    name: K,\n    control: Required<TControl>[K],\n    options: {\n      emitEvent?: boolean;\n    } = {},\n  ): void {\n    this.registerControl(name, control);\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n    this._onCollectionChange();\n  }\n\n  removeControl(\n    this: FormGroup<{[key: string]: AbstractControl<any>}>,\n    name: string,\n    options?: {\n      emitEvent?: boolean;\n    },\n  ): void;\n  removeControl<S extends string>(\n    name: ɵOptionalKeys<TControl> & S,\n    options?: {\n      emitEvent?: boolean;\n    },\n  ): void;\n\n  /**\n   * Remove a control from this group. In a strongly-typed group, required controls cannot be\n   * removed.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to remove from the collection\n   * @param options Specifies whether this FormGroup instance should emit events after a\n   *     control is removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * removed. When false, no events are emitted.\n   */\n  removeControl(name: string, options: {emitEvent?: boolean} = {}): void {\n    if ((this.controls as any)[name])\n      (this.controls as any)[name]._registerOnCollectionChange(() => {});\n    delete (this.controls as any)[name];\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n    this._onCollectionChange();\n  }\n\n  /**\n   * Replace an existing control. In a strongly-typed group, the control must be in the group's type\n   * (possibly as an optional key).\n   *\n   * If a control with a given name does not exist in this `FormGroup`, it will be added.\n   *\n   * @param name The control name to replace in the collection\n   * @param control Provides the control for the given name\n   * @param options Specifies whether this FormGroup instance should emit events after an\n   *     existing control is replaced.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * replaced with a new one. When false, no events are emitted.\n   */\n  setControl<K extends string & keyof TControl>(\n    name: K,\n    control: TControl[K],\n    options?: {\n      emitEvent?: boolean;\n    },\n  ): void;\n  setControl(\n    this: FormGroup<{[key: string]: AbstractControl<any>}>,\n    name: string,\n    control: AbstractControl,\n    options?: {emitEvent?: boolean},\n  ): void;\n\n  setControl<K extends string & keyof TControl>(\n    name: K,\n    control: TControl[K],\n    options: {\n      emitEvent?: boolean;\n    } = {},\n  ): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete this.controls[name];\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n    this._onCollectionChange();\n  }\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * Reports false for disabled controls. If you'd like to check for existence in the group\n   * only, use {@link AbstractControl#get get} instead.\n   *\n   * @param controlName The control name to check for existence in the collection\n   *\n   * @returns false for disabled controls, true otherwise.\n   */\n  contains<K extends string>(controlName: K): boolean;\n  contains(this: FormGroup<{[key: string]: AbstractControl<any>}>, controlName: string): boolean;\n\n  contains<K extends string & keyof TControl>(controlName: K): boolean {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * @usageNotes\n   * ### Set the complete value for the form group\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl(),\n   *   last: new FormControl()\n   * });\n   *\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.setValue({first: 'Nancy', last: 'Drew'});\n   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n   * ```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you exclude a value of a control that does exist.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n  override setValue(\n    value: ɵFormGroupRawValue<TControl>,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n    } = {},\n  ): void {\n    assertAllValuesPresent(this, true, value);\n    (Object.keys(value) as Array<keyof TControl>).forEach((name) => {\n      assertControlPresent(this, true, name as any);\n      (this.controls as any)[name].setValue((value as any)[name], {\n        onlySelf: true,\n        emitEvent: options.emitEvent,\n      });\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the value for a form group\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *    first: new FormControl(),\n   *    last: new FormControl()\n   * });\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.patchValue({first: 'Nancy'});\n   * console.log(form.value);   // {first: 'Nancy', last: null}\n   * ```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control value\n   * is updated. When false, no events are emitted. The configuration options are passed to\n   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n   */\n  override patchValue(\n    value: ɵFormGroupValue<TControl>,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n    } = {},\n  ): void {\n    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n    // `patchValue` can be called recursively and inner data structures might have these values, so\n    // we just ignore such cases when a field containing FormGroup instance receives `null` or\n    // `undefined` as a value.\n    if (value == null /* both `null` and `undefined` */) return;\n    (Object.keys(value) as Array<keyof TControl>).forEach((name) => {\n      // The compiler cannot see through the uninstantiated conditional type of `this.controls`, so\n      // `as any` is required.\n      const control = (this.controls as any)[name];\n      if (control) {\n        control.patchValue(\n          /* Guaranteed to be present, due to the outer forEach. */ value[\n            name as keyof ɵFormGroupValue<TControl>\n          ]!,\n          {onlySelf: true, emitEvent: options.emitEvent},\n        );\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets\n   * the value of all descendants to their default values, or null if no defaults were provided.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param value Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * @usageNotes\n   *\n   * ### Reset the form group values\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * console.log(form.value);  // {first: 'first name', last: 'last name'}\n   *\n   * form.reset({ first: 'name', last: 'last name' });\n   *\n   * console.log(form.value);  // {first: 'name', last: 'last name'}\n   * ```\n   *\n   * ### Reset the form group values and disabled status\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * form.reset({\n   *   first: {value: 'name', disabled: true},\n   *   last: 'last'\n   * });\n   *\n   * console.log(form.value);  // {last: 'last'}\n   * console.log(form.get('first').status);  // 'DISABLED'\n   * ```\n   */\n  override reset(\n    value: ɵTypedOrUntyped<TControl, ɵFormGroupArgumentValue<TControl>, any> = {},\n    options: {onlySelf?: boolean; emitEvent?: boolean} = {},\n  ): void {\n    this._forEachChild((control: AbstractControl, name) => {\n      control.reset(value ? (value as any)[name] : null, {\n        onlySelf: true,\n        emitEvent: options.emitEvent,\n      });\n    });\n    this._updatePristine(options, this);\n    this._updateTouched(options, this);\n    this.updateValueAndValidity(options);\n    if (options?.emitEvent !== false) {\n      this._events.next(new FormResetEvent(this));\n    }\n  }\n\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   */\n  override getRawValue(): ɵTypedOrUntyped<TControl, ɵFormGroupRawValue<TControl>, any> {\n    return this._reduceChildren({}, (acc, control, name) => {\n      (acc as any)[name] = (control as any).getRawValue();\n      return acc;\n    }) as any;\n  }\n\n  /** @internal */\n  override _syncPendingControls(): boolean {\n    let subtreeUpdated = this._reduceChildren(false, (updated: boolean, child) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  override _forEachChild(cb: (v: any, k: any) => void): void {\n    Object.keys(this.controls).forEach((key) => {\n      // The list of controls can change (for ex. controls might be removed) while the loop\n      // is running (as a result of invoking Forms API in `valueChanges` subscription), so we\n      // have to null check before invoking the callback.\n      const control = (this.controls as any)[key];\n      control && cb(control, key);\n    });\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control) => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n\n  /** @internal */\n  override _updateValue(): void {\n    (this as Writable<this>).value = this._reduceValue() as any;\n  }\n\n  /** @internal */\n  override _anyControls(condition: (c: AbstractControl) => boolean): boolean {\n    for (const [controlName, control] of Object.entries(this.controls)) {\n      if (this.contains(controlName as any) && condition(control as any)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @internal */\n  _reduceValue(): Partial<TControl> {\n    let acc: Partial<TControl> = {};\n    return this._reduceChildren(acc, (acc, control, name) => {\n      if (control.enabled || this.disabled) {\n        acc[name] = control.value;\n      }\n      return acc;\n    });\n  }\n\n  /** @internal */\n  _reduceChildren<T, K extends keyof TControl>(\n    initValue: T,\n    fn: (acc: T, control: TControl[K], name: K) => T,\n  ): T {\n    let res = initValue;\n    this._forEachChild((control: TControl[K], name: K) => {\n      res = fn(res, control, name);\n    });\n    return res;\n  }\n\n  /** @internal */\n  override _allControlsDisabled(): boolean {\n    for (const controlName of Object.keys(this.controls) as Array<keyof TControl>) {\n      if ((this.controls as any)[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n\n  /** @internal */\n  override _find(name: string | number): AbstractControl | null {\n    return this.controls.hasOwnProperty(name as string)\n      ? (this.controls as any)[name as keyof TControl]\n      : null;\n  }\n}\n\n/**\n * Will validate that none of the controls has a key with a dot\n * Throws other wise\n */\nfunction validateFormGroupControls<TControl>(controls: {\n  [K in keyof TControl]: AbstractControl<any, any>;\n}) {\n  const invalidKeys = Object.keys(controls).filter((key) => key.includes('.'));\n  if (invalidKeys.length > 0) {\n    // TODO: make this an error once there are no more uses in G3\n    console.warn(\n      `FormGroup keys cannot include \\`.\\`, please replace the keys for: ${invalidKeys.join(',')}.`,\n    );\n  }\n}\n\ninterface UntypedFormGroupCtor {\n  new (\n    controls: {[key: string]: AbstractControl},\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): UntypedFormGroup;\n\n  /**\n   * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n   * manually inspect the prototype chain.\n   */\n  prototype: FormGroup<any>;\n}\n\n/**\n * UntypedFormGroup is a non-strongly-typed version of `FormGroup`.\n */\nexport type UntypedFormGroup = FormGroup<any>;\n\nexport const UntypedFormGroup: UntypedFormGroupCtor = FormGroup;\n\n/**\n * @description\n * Asserts that the given control is an instance of `FormGroup`\n *\n * @publicApi\n */\nexport const isFormGroup = (control: unknown): control is FormGroup => control instanceof FormGroup;\n\n/**\n * Tracks the value and validity state of a collection of `FormControl` instances, each of which has\n * the same value type.\n *\n * `FormRecord` is very similar to {@link FormGroup}, except it can be used with a dynamic keys,\n * with controls added and removed as needed.\n *\n * `FormRecord` accepts one generic argument, which describes the type of the controls it contains.\n *\n * @usageNotes\n *\n * ```ts\n * let numbers = new FormRecord({bill: new FormControl('415-123-456')});\n * numbers.addControl('bob', new FormControl('415-234-567'));\n * numbers.removeControl('bill');\n * ```\n *\n * @publicApi\n */\nexport class FormRecord<TControl extends AbstractControl = AbstractControl> extends FormGroup<{\n  [key: string]: TControl;\n}> {}\n\nexport interface FormRecord<TControl> {\n  /**\n   * Registers a control with the records's list of controls.\n   *\n   * See `FormGroup#registerControl` for additional information.\n   */\n  registerControl(name: string, control: TControl): TControl;\n\n  /**\n   * Add a control to this group.\n   *\n   * See `FormGroup#addControl` for additional information.\n   */\n  addControl(name: string, control: TControl, options?: {emitEvent?: boolean}): void;\n\n  /**\n   * Remove a control from this group.\n   *\n   * See `FormGroup#removeControl` for additional information.\n   */\n  removeControl(name: string, options?: {emitEvent?: boolean}): void;\n\n  /**\n   * Replace an existing control.\n   *\n   * See `FormGroup#setControl` for additional information.\n   */\n  setControl(name: string, control: TControl, options?: {emitEvent?: boolean}): void;\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * See `FormGroup#contains` for additional information.\n   */\n  contains(controlName: string): boolean;\n\n  /**\n   * Sets the value of the `FormRecord`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * See `FormGroup#setValue` for additional information.\n   */\n  setValue(\n    value: {[key: string]: ɵRawValue<TControl>},\n    options?: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n    },\n  ): void;\n\n  /**\n   * Patches the value of the `FormRecord`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * See `FormGroup#patchValue` for additional information.\n   */\n  patchValue(\n    value: {[key: string]: ɵValue<TControl>},\n    options?: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n    },\n  ): void;\n\n  /**\n   * Resets the `FormRecord`, marks all descendants `pristine` and `untouched` and sets\n   * the value of all descendants to null.\n   *\n   * See `FormGroup#reset` for additional information.\n   */\n  reset(\n    value?: {[key: string]: ɵValue<TControl> | FormControlState<ɵValue<TControl>>},\n    options?: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n    },\n  ): void;\n\n  /**\n   * The aggregate value of the `FormRecord`, including any disabled controls.\n   *\n   * See `FormGroup#getRawValue` for additional information.\n   */\n  getRawValue(): {[key: string]: ɵRawValue<TControl>};\n}\n\n/**\n * @description\n * Asserts that the given control is an instance of `FormRecord`\n *\n * @publicApi\n */\nexport const isFormRecord = (control: unknown): control is FormRecord =>\n  control instanceof FormRecord;\n"]}