{"version":3,"file":"form_control.js","sourceRoot":"","sources":["form_control.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵWritable as Writable} from '@angular/core';\n\nimport {AsyncValidatorFn, ValidatorFn} from '../directives/validators';\nimport {removeListItem} from '../util';\n\nimport {\n  AbstractControl,\n  AbstractControlOptions,\n  FormResetEvent,\n  isOptionsObj,\n  pickAsyncValidators,\n  pickValidators,\n} from './abstract_model';\n\n/**\n * FormControlState is a boxed form value. It is an object with a `value` key and a `disabled` key.\n *\n * @publicApi\n */\nexport interface FormControlState<T> {\n  value: T;\n  disabled: boolean;\n}\n\n/**\n * Interface for options provided to a `FormControl`.\n *\n * This interface extends all options from {@link AbstractControlOptions}, plus some options\n * unique to `FormControl`.\n *\n * @publicApi\n */\nexport interface FormControlOptions extends AbstractControlOptions {\n  /**\n   * @description\n   * Whether to use the initial value used to construct the `FormControl` as its default value\n   * as well. If this option is false or not provided, the default value of a FormControl is `null`.\n   * When a FormControl is reset without an explicit value, its value reverts to\n   * its default value.\n   */\n  nonNullable?: boolean;\n\n  /**\n   * @deprecated Use `nonNullable` instead.\n   */\n  initialValueIsDefault?: boolean;\n}\n\n/**\n * Tracks the value and validation status of an individual form control.\n *\n * This is one of the four fundamental building blocks of Angular forms, along with\n * `FormGroup`, `FormArray` and `FormRecord`. It extends the `AbstractControl` class that\n * implements most of the base functionality for accessing the value, validation status,\n * user interactions and events.\n *\n * `FormControl` takes a single generic argument, which describes the type of its value. This\n * argument always implicitly includes `null` because the control can be reset. To change this\n * behavior, set `nonNullable` or see the usage notes below.\n *\n * See [usage examples below](#usage-notes).\n *\n * @see {@link AbstractControl}\n * @see [Reactive Forms Guide](guide/forms/reactive-forms)\n * @see [Usage Notes](#usage-notes)\n *\n * @publicApi\n *\n * @overriddenImplementation ɵFormControlCtor\n *\n * @usageNotes\n *\n * ### Initializing Form Controls\n *\n * Instantiate a `FormControl`, with an initial value.\n *\n * ```ts\n * const control = new FormControl('some value');\n * console.log(control.value);     // 'some value'\n * ```\n *\n * The following example initializes the control with a form state object. The `value`\n * and `disabled` keys are required in this case.\n *\n * ```ts\n * const control = new FormControl({ value: 'n/a', disabled: true });\n * console.log(control.value);     // 'n/a'\n * console.log(control.status);    // 'DISABLED'\n * ```\n *\n * The following example initializes the control with a synchronous validator.\n *\n * ```ts\n * const control = new FormControl('', Validators.required);\n * console.log(control.value);      // ''\n * console.log(control.status);     // 'INVALID'\n * ```\n *\n * The following example initializes the control using an options object.\n *\n * ```ts\n * const control = new FormControl('', {\n *    validators: Validators.required,\n *    asyncValidators: myAsyncValidator\n * });\n * ```\n *\n * ### The single type argument\n *\n * `FormControl` accepts a generic argument, which describes the type of its value.\n * In most cases, this argument will be inferred.\n *\n * If you are initializing the control to `null`, or you otherwise wish to provide a\n * wider type, you may specify the argument explicitly:\n *\n * ```ts\n * let fc = new FormControl<string|null>(null);\n * fc.setValue('foo');\n * ```\n *\n * You might notice that `null` is always added to the type of the control.\n * This is because the control will become `null` if you call `reset`. You can change\n * this behavior by setting `{nonNullable: true}`.\n *\n * ### Configure the control to update on a blur event\n *\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'blur' });\n * ```\n *\n * ### Configure the control to update on a submit event\n *\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'submit' });\n * ```\n *\n * ### Reset the control back to a specific value\n *\n * You reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n *\n * ```ts\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset('Drew');\n *\n * console.log(control.value); // 'Drew'\n * ```\n *\n * ### Reset the control to its initial value\n *\n * If you wish to always reset the control to its initial value (instead of null),\n * you can pass the `nonNullable` option:\n *\n * ```ts\n * const control = new FormControl('Nancy', {nonNullable: true});\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset();\n *\n * console.log(control.value); // 'Nancy'\n * ```\n *\n * ### Reset the control back to an initial value and disabled\n *\n * ```ts\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n * console.log(control.status); // 'VALID'\n *\n * control.reset({ value: 'Drew', disabled: true });\n *\n * console.log(control.value); // 'Drew'\n * console.log(control.status); // 'DISABLED'\n * ```\n */\nexport interface FormControl<TValue = any> extends AbstractControl<TValue> {\n  /**\n   * The default value of this FormControl, used whenever the control is reset without an explicit\n   * value. See {@link FormControlOptions#nonNullable} for more information on configuring\n   * a default value.\n   */\n  readonly defaultValue: TValue;\n\n  /** @internal */\n  _onChange: Function[];\n\n  /**\n   * This field holds a pending value that has not yet been applied to the form's value.\n   * @internal\n   */\n  _pendingValue: TValue;\n\n  /** @internal */\n  _pendingChange: boolean;\n\n  /**\n   * Sets a new value for the form control.\n   *\n   * @param value The new value for the control.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n   * `onChange` event to\n   * update the view.\n   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n   * `ngModelChange`\n   * event to update the model.\n   *\n   */\n  setValue(\n    value: TValue,\n    options?: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n      emitModelToViewChange?: boolean;\n      emitViewToModelChange?: boolean;\n    },\n  ): void;\n\n  /**\n   * Patches the value of a control.\n   *\n   * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\n   * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\n   * `FormArrays`, where it does behave differently.\n   *\n   * @see {@link FormControl#setValue} for options\n   */\n  patchValue(\n    value: TValue,\n    options?: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n      emitModelToViewChange?: boolean;\n      emitViewToModelChange?: boolean;\n    },\n  ): void;\n\n  /**\n   * Resets the form control, marking it `pristine` and `untouched`, and resetting\n   * the value. The new value will be the provided value (if passed), `null`, or the initial value\n   * if `nonNullable` was set in the constructor via {@link FormControlOptions}.\n   *\n   * ```ts\n   * // By default, the control will reset to null.\n   * const dog = new FormControl('spot');\n   * dog.reset(); // dog.value is null\n   *\n   * // If this flag is set, the control will instead reset to the initial value.\n   * const cat = new FormControl('tabby', {nonNullable: true});\n   * cat.reset(); // cat.value is \"tabby\"\n   *\n   * // A value passed to reset always takes precedence.\n   * const fish = new FormControl('finn', {nonNullable: true});\n   * fish.reset('bubble'); // fish.value is \"bubble\"\n   * ```\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   *\n   */\n  reset(\n    formState?: TValue | FormControlState<TValue>,\n    options?: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n    },\n  ): void;\n\n  /**\n   * For a simple FormControl, the raw value is equivalent to the value.\n   */\n  getRawValue(): TValue;\n\n  /**\n   * @internal\n   */\n  _updateValue(): void;\n\n  /**\n   * @internal\n   */\n  _anyControls(condition: (c: AbstractControl) => boolean): boolean;\n\n  /**\n   * @internal\n   */\n  _allControlsDisabled(): boolean;\n\n  /**\n   * Register a listener for change events.\n   *\n   * @param fn The method that is called when the value changes\n   */\n  registerOnChange(fn: Function): void;\n\n  /**\n   * Internal function to unregister a change events listener.\n   * @internal\n   */\n  _unregisterOnChange(fn: (value?: any, emitModelEvent?: boolean) => void): void;\n\n  /**\n   * Register a listener for disabled events.\n   *\n   * @param fn The method that is called when the disabled status changes.\n   */\n  registerOnDisabledChange(fn: (isDisabled: boolean) => void): void;\n\n  /**\n   * Internal function to unregister a disabled event listener.\n   * @internal\n   */\n  _unregisterOnDisabledChange(fn: (isDisabled: boolean) => void): void;\n\n  /**\n   * @internal\n   */\n  _forEachChild(cb: (c: AbstractControl) => void): void;\n\n  /** @internal */\n  _syncPendingControls(): boolean;\n}\n\n// This internal interface is present to avoid a naming clash, resulting in the wrong `FormControl`\n// symbol being used.\ntype FormControlInterface<TValue = any> = FormControl<TValue>;\n\n/**\n * Various available constructors for `FormControl`.\n * Do not use this interface directly. Instead, use `FormControl`:\n * ```ts\n * const fc = new FormControl('foo');\n * ```\n * This symbol is prefixed with ɵ to make plain that it is an internal symbol.\n */\nexport interface ɵFormControlCtor {\n  /**\n   * Construct a FormControl with no initial value or validators.\n   */\n  new (): FormControl<any>;\n\n  /**\n   * Creates a new `FormControl` instance.\n   *\n   * @param value Initializes the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param opts A `FormControlOptions` object that contains validation functions and a\n   * validation trigger. `nonNullable` have to be `true`\n   */\n  new <T = any>(\n    value: FormControlState<T> | T,\n    opts: FormControlOptions & {nonNullable: true},\n  ): FormControl<T>;\n\n  /**\n   * @deprecated Use `nonNullable` instead.\n   */\n  new <T = any>(\n    value: FormControlState<T> | T,\n    opts: FormControlOptions & {\n      initialValueIsDefault: true;\n    },\n  ): FormControl<T>;\n\n  /**\n   * @deprecated When passing an `options` argument, the `asyncValidator` argument has no effect.\n   */\n  new <T = any>(\n    value: FormControlState<T> | T,\n    opts: FormControlOptions,\n    asyncValidator: AsyncValidatorFn | AsyncValidatorFn[],\n  ): FormControl<T | null>;\n\n  /**\n   * Creates a new `FormControl` instance.\n   *\n   * @param value Initializes the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or a `FormControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   */\n  new <T = any>(\n    value: FormControlState<T> | T,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): FormControl<T | null>;\n\n  /**\n   * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n   * manually inspect the prototype chain.\n   */\n  prototype: FormControl<any>;\n}\n\nfunction isFormControlState(formState: unknown): formState is FormControlState<unknown> {\n  return (\n    typeof formState === 'object' &&\n    formState !== null &&\n    Object.keys(formState).length === 2 &&\n    'value' in formState &&\n    'disabled' in formState\n  );\n}\n\nexport const FormControl: ɵFormControlCtor = class FormControl<TValue = any>\n  extends AbstractControl<TValue>\n  implements FormControlInterface<TValue>\n{\n  /** @publicApi */\n  public readonly defaultValue: TValue = null as unknown as TValue;\n\n  /** @internal */\n  _onChange: Array<Function> = [];\n\n  /** @internal */\n  _pendingValue!: TValue;\n\n  /** @internal */\n  _pendingChange: boolean = false;\n\n  constructor(\n    // formState and defaultValue will only be null if T is nullable\n    formState: FormControlState<TValue> | TValue = null as unknown as TValue,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this._applyFormState(formState);\n    this._setUpdateStrategy(validatorOrOpts);\n    this._initObservables();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`.\n      // The status should be broadcasted via the `statusChanges` observable, so we set\n      // `emitEvent` to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator,\n    });\n    if (\n      isOptionsObj(validatorOrOpts) &&\n      (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)\n    ) {\n      if (isFormControlState(formState)) {\n        this.defaultValue = formState.value;\n      } else {\n        this.defaultValue = formState;\n      }\n    }\n  }\n\n  override setValue(\n    value: TValue,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n      emitModelToViewChange?: boolean;\n      emitViewToModelChange?: boolean;\n    } = {},\n  ): void {\n    (this as Writable<this>).value = this._pendingValue = value;\n    if (this._onChange.length && options.emitModelToViewChange !== false) {\n      this._onChange.forEach((changeFn) =>\n        changeFn(this.value, options.emitViewToModelChange !== false),\n      );\n    }\n    this.updateValueAndValidity(options);\n  }\n\n  override patchValue(\n    value: TValue,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n      emitModelToViewChange?: boolean;\n      emitViewToModelChange?: boolean;\n    } = {},\n  ): void {\n    this.setValue(value, options);\n  }\n\n  override reset(\n    formState: TValue | FormControlState<TValue> = this.defaultValue,\n    options: {onlySelf?: boolean; emitEvent?: boolean} = {},\n  ): void {\n    this._applyFormState(formState);\n    this.markAsPristine(options);\n    this.markAsUntouched(options);\n    this.setValue(this.value, options);\n    this._pendingChange = false;\n    if (options?.emitEvent !== false) {\n      this._events.next(new FormResetEvent(this));\n    }\n  }\n\n  /**  @internal */\n  override _updateValue(): void {}\n\n  /**  @internal */\n  override _anyControls(condition: (c: AbstractControl) => boolean): boolean {\n    return false;\n  }\n\n  /**  @internal */\n  override _allControlsDisabled(): boolean {\n    return this.disabled;\n  }\n\n  registerOnChange(fn: Function): void {\n    this._onChange.push(fn);\n  }\n\n  /** @internal */\n  _unregisterOnChange(fn: (value?: any, emitModelEvent?: boolean) => void): void {\n    removeListItem(this._onChange, fn);\n  }\n\n  registerOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n    this._onDisabledChange.push(fn);\n  }\n\n  /** @internal */\n  _unregisterOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n    removeListItem(this._onDisabledChange, fn);\n  }\n\n  /** @internal */\n  override _forEachChild(cb: (c: AbstractControl) => void): void {}\n\n  /** @internal */\n  override _syncPendingControls(): boolean {\n    if (this.updateOn === 'submit') {\n      if (this._pendingDirty) this.markAsDirty();\n      if (this._pendingTouched) this.markAsTouched();\n      if (this._pendingChange) {\n        this.setValue(this._pendingValue, {onlySelf: true, emitModelToViewChange: false});\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private _applyFormState(formState: FormControlState<TValue> | TValue) {\n    if (isFormControlState(formState)) {\n      (this as Writable<this>).value = this._pendingValue = formState.value;\n      formState.disabled\n        ? this.disable({onlySelf: true, emitEvent: false})\n        : this.enable({onlySelf: true, emitEvent: false});\n    } else {\n      (this as Writable<this>).value = this._pendingValue = formState;\n    }\n  }\n};\n\ninterface UntypedFormControlCtor {\n  new (): UntypedFormControl;\n\n  new (\n    formState?: any,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | FormControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ): UntypedFormControl;\n\n  /**\n   * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n   * manually inspect the prototype chain.\n   */\n  prototype: FormControl<any>;\n}\n\n/**\n * UntypedFormControl is a non-strongly-typed version of `FormControl`.\n */\nexport type UntypedFormControl = FormControl<any>;\n\nexport const UntypedFormControl: UntypedFormControlCtor = FormControl;\n\n/**\n * @description\n * Asserts that the given control is an instance of `FormControl`\n *\n * @publicApi\n */\nexport const isFormControl = (control: unknown): control is FormControl =>\n  control instanceof FormControl;\n"]}