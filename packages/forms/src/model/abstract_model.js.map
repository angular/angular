{"version":3,"file":"abstract_model.js","sourceRoot":"","sources":["abstract_model.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EventEmitter,\n  signal,\n  ɵRuntimeError as RuntimeError,\n  ɵWritable as Writable,\n  untracked,\n  computed,\n} from '@angular/core';\nimport {Observable, Subject} from 'rxjs';\n\nimport {\n  asyncValidatorsDroppedWithOptsWarning,\n  missingControlError,\n  missingControlValueError,\n  noControlsError,\n} from '../directives/reactive_errors';\nimport type {AsyncValidatorFn, ValidationErrors, ValidatorFn} from '../directives/validators';\nimport {RuntimeErrorCode} from '../errors';\nimport {\n  addValidators,\n  composeAsyncValidators,\n  composeValidators,\n  hasValidator,\n  removeValidators,\n  toObservable,\n} from '../validators';\nimport type {FormArray} from './form_array';\nimport type {FormGroup} from './form_group';\n\n/**\n * Reports that a control is valid, meaning that no errors exist in the input value.\n *\n * @see {@link status}\n */\nexport const VALID = 'VALID';\n\n/**\n * Reports that a control is invalid, meaning that an error exists in the input value.\n *\n * @see {@link status}\n */\nexport const INVALID = 'INVALID';\n\n/**\n * Reports that a control is pending, meaning that async validation is occurring and\n * errors are not yet available for the input value.\n *\n * @see {@link markAsPending}\n * @see {@link status}\n */\nexport const PENDING = 'PENDING';\n\n/**\n * Reports that a control is disabled, meaning that the control is exempt from ancestor\n * calculations of validity or value.\n *\n * @see {@link markAsDisabled}\n * @see {@link status}\n */\nexport const DISABLED = 'DISABLED';\n\n/**\n * A form can have several different statuses. Each\n * possible status is returned as a string literal.\n *\n * * **VALID**: Reports that a control is valid, meaning that no errors exist in the input\n * value.\n * * **INVALID**: Reports that a control is invalid, meaning that an error exists in the input\n * value.\n * * **PENDING**: Reports that a control is pending, meaning that async validation is\n * occurring and errors are not yet available for the input value.\n * * **DISABLED**: Reports that a control is\n * disabled, meaning that the control is exempt from ancestor calculations of validity or value.\n *\n * @publicApi\n */\nexport type FormControlStatus = 'VALID' | 'INVALID' | 'PENDING' | 'DISABLED';\n\n/**\n * Base class for every event sent by `AbstractControl.events()`\n *\n * @publicApi\n */\nexport abstract class ControlEvent<T = any> {\n  /**\n   * Form control from which this event is originated.\n   *\n   * Note: the type of the control can't be infered from T as the event can be emitted by any of child controls\n   */\n  public abstract readonly source: AbstractControl<unknown>;\n}\n\n/**\n * Event fired when the value of a control changes.\n *\n * @publicApi\n */\nexport class ValueChangeEvent<T> extends ControlEvent<T> {\n  constructor(\n    public readonly value: T,\n    public readonly source: AbstractControl,\n  ) {\n    super();\n  }\n}\n\n/**\n * Event fired when the control's pristine state changes (pristine <=> dirty).\n *\n * @publicApi */\nexport class PristineChangeEvent extends ControlEvent {\n  constructor(\n    public readonly pristine: boolean,\n    public readonly source: AbstractControl,\n  ) {\n    super();\n  }\n}\n\n/**\n * Event fired when the control's touched status changes (touched <=> untouched).\n *\n * @publicApi\n */\nexport class TouchedChangeEvent extends ControlEvent {\n  constructor(\n    public readonly touched: boolean,\n    public readonly source: AbstractControl,\n  ) {\n    super();\n  }\n}\n\n/**\n * Event fired when the control's status changes.\n *\n * @publicApi\n */\nexport class StatusChangeEvent extends ControlEvent {\n  constructor(\n    public readonly status: FormControlStatus,\n    public readonly source: AbstractControl,\n  ) {\n    super();\n  }\n}\n\n/**\n * Event fired when a form is submitted\n *\n * @publicApi\n */\nexport class FormSubmittedEvent extends ControlEvent {\n  constructor(public readonly source: AbstractControl) {\n    super();\n  }\n}\n/**\n * Event fired when a form is reset.\n *\n * @publicApi\n */\nexport class FormResetEvent extends ControlEvent {\n  constructor(public readonly source: AbstractControl) {\n    super();\n  }\n}\n\n/**\n * Gets validators from either an options object or given validators.\n */\nexport function pickValidators(\n  validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n): ValidatorFn | ValidatorFn[] | null {\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;\n}\n\n/**\n * Creates validator function by combining provided validators.\n */\nfunction coerceToValidator(validator: ValidatorFn | ValidatorFn[] | null): ValidatorFn | null {\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\n\n/**\n * Gets async validators from either an options object or given validators.\n */\nexport function pickAsyncValidators(\n  asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n): AsyncValidatorFn | AsyncValidatorFn[] | null {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (isOptionsObj(validatorOrOpts) && asyncValidator) {\n      console.warn(asyncValidatorsDroppedWithOptsWarning);\n    }\n  }\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;\n}\n\n/**\n * Creates async validator function by combining provided async validators.\n */\nfunction coerceToAsyncValidator(\n  asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,\n): AsyncValidatorFn | null {\n  return Array.isArray(asyncValidator)\n    ? composeAsyncValidators(asyncValidator)\n    : asyncValidator || null;\n}\n\nexport type FormHooks = 'change' | 'blur' | 'submit';\n\n/**\n * Interface for options provided to an `AbstractControl`.\n *\n * @publicApi\n */\nexport interface AbstractControlOptions {\n  /**\n   * @description\n   * The list of validators applied to a control.\n   */\n  validators?: ValidatorFn | ValidatorFn[] | null;\n  /**\n   * @description\n   * The list of async validators applied to control.\n   */\n  asyncValidators?: AsyncValidatorFn | AsyncValidatorFn[] | null;\n  /**\n   * @description\n   * The event name for control to update upon.\n   */\n  updateOn?: 'change' | 'blur' | 'submit';\n}\n\nexport function isOptionsObj(\n  validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n): validatorOrOpts is AbstractControlOptions {\n  return (\n    validatorOrOpts != null &&\n    !Array.isArray(validatorOrOpts) &&\n    typeof validatorOrOpts === 'object'\n  );\n}\n\nexport function assertControlPresent(parent: any, isGroup: boolean, key: string | number): void {\n  const controls = parent.controls as {[key: string | number]: unknown};\n  const collection = isGroup ? Object.keys(controls) : controls;\n  if (!collection.length) {\n    throw new RuntimeError(\n      RuntimeErrorCode.NO_CONTROLS,\n      typeof ngDevMode === 'undefined' || ngDevMode ? noControlsError(isGroup) : '',\n    );\n  }\n  if (!controls[key]) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISSING_CONTROL,\n      typeof ngDevMode === 'undefined' || ngDevMode ? missingControlError(isGroup, key) : '',\n    );\n  }\n}\n\nexport function assertAllValuesPresent(control: any, isGroup: boolean, value: any): void {\n  control._forEachChild((_: unknown, key: string | number) => {\n    if (value[key] === undefined) {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_CONTROL_VALUE,\n        typeof ngDevMode === 'undefined' || ngDevMode ? missingControlValueError(isGroup, key) : '',\n      );\n    }\n  });\n}\n\n// IsAny checks if T is `any`, by checking a condition that couldn't possibly be true otherwise.\nexport type ɵIsAny<T, Y, N> = 0 extends 1 & T ? Y : N;\n\n/**\n * `TypedOrUntyped` allows one of two different types to be selected, depending on whether the Forms\n * class it's applied to is typed or not.\n *\n * This is for internal Angular usage to support typed forms; do not directly use it.\n */\nexport type ɵTypedOrUntyped<T, Typed, Untyped> = ɵIsAny<T, Untyped, Typed>;\n\n/**\n * Value gives the value type corresponding to a control type.\n *\n * Note that the resulting type will follow the same rules as `.value` on your control, group, or\n * array, including `undefined` for each group element which might be disabled.\n *\n * If you are trying to extract a value type for a data model, you probably want {@link RawValue},\n * which will not have `undefined` in group keys.\n *\n * @usageNotes\n *\n * ### `FormControl` value type\n *\n * You can extract the value type of a single control:\n *\n * ```ts\n * type NameControl = FormControl<string>;\n * type NameValue = Value<NameControl>;\n * ```\n *\n * The resulting type is `string`.\n *\n * ### `FormGroup` value type\n *\n * Imagine you have an interface defining the controls in your group. You can extract the shape of\n * the values as follows:\n *\n * ```ts\n * interface PartyFormControls {\n *   address: FormControl<string>;\n * }\n *\n * // Value operates on controls; the object must be wrapped in a FormGroup.\n * type PartyFormValues = Value<FormGroup<PartyFormControls>>;\n * ```\n *\n * The resulting type is `{address: string|undefined}`.\n *\n * ### `FormArray` value type\n *\n * You can extract values from FormArrays as well:\n *\n * ```ts\n * type GuestNamesControls = FormArray<FormControl<string>>;\n *\n * type NamesValues = Value<GuestNamesControls>;\n * ```\n *\n * The resulting type is `string[]`.\n *\n * **Internal: not for public use.**\n */\nexport type ɵValue<T extends AbstractControl | undefined> =\n  T extends AbstractControl<any, any> ? T['value'] : never;\n\n/**\n * RawValue gives the raw value type corresponding to a control type.\n *\n * Note that the resulting type will follow the same rules as `.getRawValue()` on your control,\n * group, or array. This means that all controls inside a group will be required, not optional,\n * regardless of their disabled state.\n *\n * You may also wish to use {@link ɵValue}, which will have `undefined` in group keys (which can be\n * disabled).\n *\n * @usageNotes\n *\n * ### `FormGroup` raw value type\n *\n * Imagine you have an interface defining the controls in your group. You can extract the shape of\n * the raw values as follows:\n *\n * ```ts\n * interface PartyFormControls {\n *   address: FormControl<string>;\n * }\n *\n * // RawValue operates on controls; the object must be wrapped in a FormGroup.\n * type PartyFormValues = RawValue<FormGroup<PartyFormControls>>;\n * ```\n *\n * The resulting type is `{address: string}`. (Note the absence of `undefined`.)\n *\n *  **Internal: not for public use.**\n */\nexport type ɵRawValue<T extends AbstractControl | undefined> =\n  T extends AbstractControl<any, any>\n    ? T['setValue'] extends (v: infer R) => void\n      ? R\n      : never\n    : never;\n\n/**\n * Tokenize splits a string literal S by a delimiter D.\n */\nexport type ɵTokenize<S extends string, D extends string> = string extends S\n  ? string[] /* S must be a literal */\n  : S extends `${infer T}${D}${infer U}`\n    ? [T, ...ɵTokenize<U, D>]\n    : [S] /* Base case */;\n\n/**\n * CoerceStrArrToNumArr accepts an array of strings, and converts any numeric string to a number.\n */\nexport type ɵCoerceStrArrToNumArr<S> =\n  // Extract the head of the array.\n  S extends [infer Head, ...infer Tail]\n    ? // Using a template literal type, coerce the head to `number` if possible.\n      // Then, recurse on the tail.\n      Head extends `${number}`\n      ? [number, ...ɵCoerceStrArrToNumArr<Tail>]\n      : [Head, ...ɵCoerceStrArrToNumArr<Tail>]\n    : [];\n\n/**\n * Navigate takes a type T and an array K, and returns the type of T[K[0]][K[1]][K[2]]...\n */\nexport type ɵNavigate<\n  T,\n  K extends Array<string | number>,\n> = T extends object /* T must be indexable (object or array) */\n  ? K extends [infer Head, ...infer Tail] /* Split K into head and tail */\n    ? Head extends keyof T /* head(K) must index T */\n      ? Tail extends (string | number)[] /* tail(K) must be an array */\n        ? [] extends Tail\n          ? T[Head] /* base case: K can be split, but Tail is empty */\n          : ɵNavigate<T[Head], Tail> /* explore T[head(K)] by tail(K) */\n        : any /* tail(K) was not an array, give up */\n      : never /* head(K) does not index T, give up */\n    : any /* K cannot be split, give up */\n  : any /* T is not indexable, give up */;\n\n/**\n * ɵWriteable removes readonly from all keys.\n */\nexport type ɵWriteable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * GetProperty takes a type T and some property names or indices K.\n * If K is a dot-separated string, it is tokenized into an array before proceeding.\n * Then, the type of the nested property at K is computed: T[K[0]][K[1]][K[2]]...\n * This works with both objects, which are indexed by property name, and arrays, which are indexed\n * numerically.\n *\n * For internal use only.\n */\nexport type ɵGetProperty<T, K> =\n  // K is a string\n  K extends string\n    ? ɵGetProperty<T, ɵCoerceStrArrToNumArr<ɵTokenize<K, '.'>>>\n    : // Is it an array\n      ɵWriteable<K> extends Array<string | number>\n      ? ɵNavigate<T, ɵWriteable<K>>\n      : // Fall through permissively if we can't calculate the type of K.\n        any;\n\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * The first type parameter TValue represents the value type of the control (`control.value`).\n * The optional type parameter TRawValue  represents the raw value type (`control.getRawValue()`).\n *\n * @see [Forms Guide](guide/forms)\n * @see [Reactive Forms Guide](guide/forms/reactive-forms)\n * @see [Dynamic Forms Guide](guide/forms/dynamic-forms)\n *\n * @publicApi\n */\nexport abstract class AbstractControl<\n  TValue = any,\n  TRawValue extends TValue = TValue,\n  TValueWithOptionalControlStates = any,\n> {\n  /** @internal */\n  _pendingDirty = false;\n\n  /**\n   * Indicates that a control has its own pending asynchronous validation in progress.\n   * It also stores if the control should emit events when the validation status changes.\n   *\n   * @internal\n   */\n  _hasOwnPendingAsyncValidator: null | {emitEvent: boolean; shouldHaveEmitted: boolean} = null;\n\n  /** @internal */\n  _pendingTouched = false;\n\n  /** @internal */\n  _onCollectionChange = () => {};\n\n  /** @internal */\n  _updateOn?: FormHooks;\n\n  private _parent: FormGroup | FormArray | null = null;\n  private _asyncValidationSubscription: any;\n\n  /**\n   * Contains the result of merging synchronous validators into a single validator function\n   * (combined using `Validators.compose`).\n   *\n   * @internal\n   */\n  private _composedValidatorFn!: ValidatorFn | null;\n\n  /**\n   * Contains the result of merging asynchronous validators into a single validator function\n   * (combined using `Validators.composeAsync`).\n   *\n   * @internal\n   */\n  private _composedAsyncValidatorFn!: AsyncValidatorFn | null;\n\n  /**\n   * Synchronous validators as they were provided:\n   *  - in `AbstractControl` constructor\n   *  - as an argument while calling `setValidators` function\n   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)\n   *\n   * @internal\n   */\n  private _rawValidators!: ValidatorFn | ValidatorFn[] | null;\n\n  /**\n   * Asynchronous validators as they were provided:\n   *  - in `AbstractControl` constructor\n   *  - as an argument while calling `setAsyncValidators` function\n   *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =\n   * asyncValidatorFn`)\n   *\n   * @internal\n   */\n  private _rawAsyncValidators!: AsyncValidatorFn | AsyncValidatorFn[] | null;\n\n  /**\n   * The current value of the control.\n   *\n   * * For a `FormControl`, the current value.\n   * * For an enabled `FormGroup`, the values of enabled controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a disabled `FormGroup`, the values of all controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a `FormArray`, the values of enabled controls as an array.\n   *\n   */\n  public readonly value!: TValue;\n\n  /**\n   * Initialize the AbstractControl instance.\n   *\n   * @param validators The function or array of functions that is used to determine the validity of\n   *     this control synchronously.\n   * @param asyncValidators The function or array of functions that is used to determine validity of\n   *     this control asynchronously.\n   */\n  constructor(\n    validators: ValidatorFn | ValidatorFn[] | null,\n    asyncValidators: AsyncValidatorFn | AsyncValidatorFn[] | null,\n  ) {\n    this._assignValidators(validators);\n    this._assignAsyncValidators(asyncValidators);\n  }\n\n  /**\n   * Returns the function that is used to determine the validity of this control synchronously.\n   * If multiple validators have been added, this will be a single composed function.\n   * See `Validators.compose()` for additional information.\n   */\n  get validator(): ValidatorFn | null {\n    return this._composedValidatorFn;\n  }\n  set validator(validatorFn: ValidatorFn | null) {\n    this._rawValidators = this._composedValidatorFn = validatorFn;\n  }\n\n  /**\n   * Returns the function that is used to determine the validity of this control asynchronously.\n   * If multiple validators have been added, this will be a single composed function.\n   * See `Validators.compose()` for additional information.\n   */\n  get asyncValidator(): AsyncValidatorFn | null {\n    return this._composedAsyncValidatorFn;\n  }\n  set asyncValidator(asyncValidatorFn: AsyncValidatorFn | null) {\n    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;\n  }\n\n  /**\n   * The parent control.\n   */\n  get parent(): FormGroup | FormArray | null {\n    return this._parent;\n  }\n\n  /**\n   * The validation status of the control.\n   *\n   * @see {@link FormControlStatus}\n   *\n   * These status values are mutually exclusive, so a control cannot be\n   * both valid AND invalid or invalid AND disabled.\n   */\n  get status(): FormControlStatus {\n    return untracked(this.statusReactive)!;\n  }\n  private set status(v: FormControlStatus) {\n    untracked(() => this.statusReactive.set(v));\n  }\n  /** @internal */\n  readonly _status = computed(() => this.statusReactive());\n  private readonly statusReactive = signal<FormControlStatus | undefined>(undefined);\n\n  /**\n   * A control is `valid` when its `status` is `VALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control has passed all of its validation tests,\n   * false otherwise.\n   */\n  get valid(): boolean {\n    return this.status === VALID;\n  }\n\n  /**\n   * A control is `invalid` when its `status` is `INVALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control has failed one or more of its validation checks,\n   * false otherwise.\n   */\n  get invalid(): boolean {\n    return this.status === INVALID;\n  }\n\n  /**\n   * A control is `pending` when its `status` is `PENDING`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control is in the process of conducting a validation check,\n   * false otherwise.\n   */\n  get pending(): boolean {\n    return this.status == PENDING;\n  }\n\n  /**\n   * A control is `disabled` when its `status` is `DISABLED`.\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control is disabled, false otherwise.\n   */\n  get disabled(): boolean {\n    return this.status === DISABLED;\n  }\n\n  /**\n   * A control is `enabled` as long as its `status` is not `DISABLED`.\n   *\n   * @returns True if the control has any status other than 'DISABLED',\n   * false if the status is 'DISABLED'.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   */\n  get enabled(): boolean {\n    return this.status !== DISABLED;\n  }\n\n  /**\n   * An object containing any errors generated by failing validation,\n   * or null if there are no errors.\n   */\n  public readonly errors!: ValidationErrors | null;\n\n  /**\n   * A control is `pristine` if the user has not yet changed\n   * the value in the UI.\n   *\n   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  get pristine(): boolean {\n    return untracked(this.pristineReactive);\n  }\n  private set pristine(v: boolean) {\n    untracked(() => this.pristineReactive.set(v));\n  }\n  /** @internal */\n  readonly _pristine = computed(() => this.pristineReactive());\n  private readonly pristineReactive = signal(true);\n\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  get dirty(): boolean {\n    return !this.pristine;\n  }\n\n  /**\n   * True if the control is marked as `touched`.\n   *\n   * A control is marked `touched` once the user has triggered\n   * a `blur` event on it.\n   */\n  get touched(): boolean {\n    return untracked(this.touchedReactive);\n  }\n  private set touched(v: boolean) {\n    untracked(() => this.touchedReactive.set(v));\n  }\n  /** @internal */\n  readonly _touched = computed(() => this.touchedReactive());\n  private readonly touchedReactive = signal(false);\n\n  /**\n   * True if the control has not been marked as touched\n   *\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   */\n  get untouched(): boolean {\n    return !this.touched;\n  }\n\n  /**\n   * Exposed as observable, see below.\n   *\n   * @internal\n   */\n  readonly _events = new Subject<ControlEvent<TValue>>();\n\n  /**\n   * A multicasting observable that emits an event every time the state of the control changes.\n   * It emits for value, status, pristine or touched changes.\n   *\n   * **Note**: On value change, the emit happens right after a value of this control is updated. The\n   * value of a parent control (for example if this FormControl is a part of a FormGroup) is updated\n   * later, so accessing a value of a parent control (using the `value` property) from the callback\n   * of this event might result in getting a value that has not been updated yet. Subscribe to the\n   * `events` of the parent control instead.\n   * For other event types, the events are emitted after the parent control has been updated.\n   *\n   */\n  public readonly events = this._events.asObservable();\n\n  /**\n   * A multicasting observable that emits an event every time the value of the control changes, in\n   * the UI or programmatically. It also emits an event each time you call enable() or disable()\n   * without passing along {emitEvent: false} as a function argument.\n   *\n   * **Note**: the emit happens right after a value of this control is updated. The value of a\n   * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so\n   * accessing a value of a parent control (using the `value` property) from the callback of this\n   * event might result in getting a value that has not been updated yet. Subscribe to the\n   * `valueChanges` event of the parent control instead.\n   */\n  public readonly valueChanges!: Observable<TValue>;\n\n  /**\n   * A multicasting observable that emits an event every time the validation `status` of the control\n   * recalculates.\n   *\n   * @see {@link FormControlStatus}\n   * @see {@link AbstractControl.status}\n   */\n  public readonly statusChanges!: Observable<FormControlStatus>;\n\n  /**\n   * Reports the update strategy of the `AbstractControl` (meaning\n   * the event on which the control updates itself).\n   * Possible values: `'change'` | `'blur'` | `'submit'`\n   * Default value: `'change'`\n   */\n  get updateOn(): FormHooks {\n    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : 'change';\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this overwrites any existing synchronous validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * If you want to add a new validator without affecting existing ones, consider\n   * using `addValidators()` method instead.\n   */\n  setValidators(validators: ValidatorFn | ValidatorFn[] | null): void {\n    this._assignValidators(validators);\n  }\n\n  /**\n   * Sets the asynchronous validators that are active on this control. Calling this\n   * overwrites any existing asynchronous validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * If you want to add a new validator without affecting existing ones, consider\n   * using `addAsyncValidators()` method instead.\n   */\n  setAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[] | null): void {\n    this._assignAsyncValidators(validators);\n  }\n\n  /**\n   * Add a synchronous validator or validators to this control, without affecting other validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * Adding a validator that already exists will have no effect. If duplicate validator functions\n   * are present in the `validators` array, only the first instance would be added to a form\n   * control.\n   *\n   * @param validators The new validator function or functions to add to this control.\n   */\n  addValidators(validators: ValidatorFn | ValidatorFn[]): void {\n    this.setValidators(addValidators(validators, this._rawValidators));\n  }\n\n  /**\n   * Add an asynchronous validator or validators to this control, without affecting other\n   * validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * Adding a validator that already exists will have no effect.\n   *\n   * @param validators The new asynchronous validator function or functions to add to this control.\n   */\n  addAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void {\n    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));\n  }\n\n  /**\n   * Remove a synchronous validator from this control, without affecting other validators.\n   * Validators are compared by function reference; you must pass a reference to the exact same\n   * validator function as the one that was originally set. If a provided validator is not found,\n   * it is ignored.\n   *\n   * @usageNotes\n   *\n   * ### Reference to a ValidatorFn\n   *\n   * ```\n   * // Reference to the RequiredValidator\n   * const ctrl = new FormControl<string | null>('', Validators.required);\n   * ctrl.removeValidators(Validators.required);\n   *\n   * // Reference to anonymous function inside MinValidator\n   * const minValidator = Validators.min(3);\n   * const ctrl = new FormControl<string | null>('', minValidator);\n   * expect(ctrl.hasValidator(minValidator)).toEqual(true)\n   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)\n   *\n   * ctrl.removeValidators(minValidator);\n   * ```\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * @param validators The validator or validators to remove.\n   */\n  removeValidators(validators: ValidatorFn | ValidatorFn[]): void {\n    this.setValidators(removeValidators(validators, this._rawValidators));\n  }\n\n  /**\n   * Remove an asynchronous validator from this control, without affecting other validators.\n   * Validators are compared by function reference; you must pass a reference to the exact same\n   * validator function as the one that was originally set. If a provided validator is not found, it\n   * is ignored.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * @param validators The asynchronous validator or validators to remove.\n   */\n  removeAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void {\n    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));\n  }\n\n  /**\n   * Check whether a synchronous validator function is present on this control. The provided\n   * validator must be a reference to the exact same function that was provided.\n   *\n   * @usageNotes\n   *\n   * ### Reference to a ValidatorFn\n   *\n   * ```\n   * // Reference to the RequiredValidator\n   * const ctrl = new FormControl<number | null>(0, Validators.required);\n   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)\n   *\n   * // Reference to anonymous function inside MinValidator\n   * const minValidator = Validators.min(3);\n   * const ctrl = new FormControl<number | null>(0, minValidator);\n   * expect(ctrl.hasValidator(minValidator)).toEqual(true)\n   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)\n   * ```\n   *\n   * @param validator The validator to check for presence. Compared by function reference.\n   * @returns Whether the provided validator was found on this control.\n   */\n  hasValidator(validator: ValidatorFn): boolean {\n    return hasValidator(this._rawValidators, validator);\n  }\n\n  /**\n   * Check whether an asynchronous validator function is present on this control. The provided\n   * validator must be a reference to the exact same function that was provided.\n   *\n   * @param validator The asynchronous validator to check for presence. Compared by function\n   *     reference.\n   * @returns Whether the provided asynchronous validator was found on this control.\n   */\n  hasAsyncValidator(validator: AsyncValidatorFn): boolean {\n    return hasValidator(this._rawAsyncValidators, validator);\n  }\n\n  /**\n   * Empties out the synchronous validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  clearValidators(): void {\n    this.validator = null;\n  }\n\n  /**\n   * Empties out the async validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  clearAsyncValidators(): void {\n    this.asyncValidator = null;\n  }\n\n  /**\n   * Marks the control as `touched`. A control is touched by focus and\n   * blur events that do not change the value.\n   *\n   * @see {@link markAsUntouched()}\n   * @see {@link markAsDirty()}\n   * @see {@link markAsPristine()}\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `events`\n   * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.\n   * When false, no events are emitted.\n   */\n  markAsTouched(opts?: {onlySelf?: boolean; emitEvent?: boolean}): void;\n  /**\n   * @internal Used to propagate the source control downwards\n   */\n  markAsTouched(opts?: {\n    onlySelf?: boolean;\n    emitEvent?: boolean;\n    sourceControl?: AbstractControl;\n  }): void;\n  markAsTouched(\n    opts: {onlySelf?: boolean; emitEvent?: boolean; sourceControl?: AbstractControl} = {},\n  ): void {\n    const changed = this.touched === false;\n    this.touched = true;\n\n    const sourceControl = opts.sourceControl ?? this;\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched({...opts, sourceControl});\n    }\n\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new TouchedChangeEvent(true, sourceControl));\n    }\n  }\n\n  /**\n   * Marks the control and all its descendant controls as `dirty`.\n   * @see {@link markAsDirty()}\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `emitEvent`: When true or not supplied (the default), the `events`\n   * observable emits a `PristineChangeEvent` with the `pristine` property being `false`.\n   * When false, no events are emitted.\n   */\n  markAllAsDirty(opts: {emitEvent?: boolean} = {}): void {\n    this.markAsDirty({onlySelf: true, emitEvent: opts.emitEvent, sourceControl: this});\n\n    this._forEachChild((control: AbstractControl) => control.markAllAsDirty(opts));\n  }\n\n  /**\n   * Marks the control and all its descendant controls as `touched`.\n   * @see {@link markAsTouched()}\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `emitEvent`: When true or not supplied (the default), the `events`\n   * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.\n   * When false, no events are emitted.\n   */\n  markAllAsTouched(opts: {emitEvent?: boolean} = {}): void {\n    this.markAsTouched({onlySelf: true, emitEvent: opts.emitEvent, sourceControl: this});\n\n    this._forEachChild((control: AbstractControl) => control.markAllAsTouched(opts));\n  }\n\n  /**\n   * Marks the control as `untouched`.\n   *\n   * If the control has any children, also marks all children as `untouched`\n   * and recalculates the `touched` status of all parent controls.\n   *\n   * @see {@link markAsTouched()}\n   * @see {@link markAsDirty()}\n   * @see {@link markAsPristine()}\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after the marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `events`\n   * observable emits a `TouchedChangeEvent` with the `touched` property being `false`.\n   * When false, no events are emitted.\n   */\n  markAsUntouched(opts?: {onlySelf?: boolean; emitEvent?: boolean}): void;\n  /**\n   *\n   * @internal Used to propagate the source control downwards\n   */\n  markAsUntouched(opts: {\n    onlySelf?: boolean;\n    emitEvent?: boolean;\n    sourceControl?: AbstractControl;\n  }): void;\n  markAsUntouched(\n    opts: {onlySelf?: boolean; emitEvent?: boolean; sourceControl?: AbstractControl} = {},\n  ): void {\n    const changed = this.touched === true;\n    this.touched = false;\n    this._pendingTouched = false;\n\n    const sourceControl = opts.sourceControl ?? this;\n    this._forEachChild((control: AbstractControl) => {\n      control.markAsUntouched({onlySelf: true, emitEvent: opts.emitEvent, sourceControl});\n    });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts, sourceControl);\n    }\n\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new TouchedChangeEvent(false, sourceControl));\n    }\n  }\n\n  /**\n   * Marks the control as `dirty`. A control becomes dirty when\n   * the control's value is changed through the UI; compare `markAsTouched`.\n   *\n   * @see {@link markAsTouched()}\n   * @see {@link markAsUntouched()}\n   * @see {@link markAsPristine()}\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `events`\n   * observable emits a `PristineChangeEvent` with the `pristine` property being `false`.\n   * When false, no events are emitted.\n   */\n  markAsDirty(opts?: {onlySelf?: boolean; emitEvent?: boolean}): void;\n  /**\n   * @internal Used to propagate the source control downwards\n   */\n  markAsDirty(opts: {\n    onlySelf?: boolean;\n    emitEvent?: boolean;\n    sourceControl?: AbstractControl;\n  }): void;\n  markAsDirty(\n    opts: {onlySelf?: boolean; emitEvent?: boolean; sourceControl?: AbstractControl} = {},\n  ): void {\n    const changed = this.pristine === true;\n    this.pristine = false;\n\n    const sourceControl = opts.sourceControl ?? this;\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty({...opts, sourceControl});\n    }\n\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new PristineChangeEvent(false, sourceControl));\n    }\n  }\n\n  /**\n   * Marks the control as `pristine`.\n   *\n   * If the control has any children, marks all children as `pristine`,\n   * and recalculates the `pristine` status of all parent\n   * controls.\n   *\n   * @see {@link markAsTouched()}\n   * @see {@link markAsUntouched()}\n   * @see {@link markAsDirty()}\n   *\n   * @param opts Configuration options that determine how the control emits events after\n   * marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `events`\n   * observable emits a `PristineChangeEvent` with the `pristine` property being `true`.\n   * When false, no events are emitted.\n   */\n  markAsPristine(opts?: {onlySelf?: boolean; emitEvent?: boolean}): void;\n  /**\n   * @internal Used to propagate the source control downwards\n   */\n  markAsPristine(opts: {\n    onlySelf?: boolean;\n    emitEvent?: boolean;\n    sourceControl?: AbstractControl;\n  }): void;\n  markAsPristine(\n    opts: {onlySelf?: boolean; emitEvent?: boolean; sourceControl?: AbstractControl} = {},\n  ): void {\n    const changed = this.pristine === false;\n    this.pristine = true;\n    this._pendingDirty = false;\n\n    const sourceControl = opts.sourceControl ?? this;\n    this._forEachChild((control: AbstractControl) => {\n      /** We don't propagate the source control downwards */\n      control.markAsPristine({onlySelf: true, emitEvent: opts.emitEvent});\n    });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts, sourceControl);\n    }\n\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new PristineChangeEvent(true, sourceControl));\n    }\n  }\n\n  /**\n   * Marks the control as `pending`.\n   *\n   * A control is pending while the control performs async validation.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configuration options that determine how the control propagates changes and\n   * emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n   * observable emits an event with the latest status the control is marked pending\n   * and the `events` observable emits a `StatusChangeEvent` with the `status` property being\n   * `PENDING` When false, no events are emitted.\n   *\n   */\n  markAsPending(opts?: {onlySelf?: boolean; emitEvent?: boolean}): void;\n  /**\n   * @internal Used to propagate the source control downwards\n   */\n  markAsPending(opts: {\n    onlySelf?: boolean;\n    emitEvent?: boolean;\n    sourceControl?: AbstractControl;\n  }): void;\n  markAsPending(\n    opts: {onlySelf?: boolean; emitEvent?: boolean; sourceControl?: AbstractControl} = {},\n  ): void {\n    this.status = PENDING;\n\n    const sourceControl = opts.sourceControl ?? this;\n    if (opts.emitEvent !== false) {\n      this._events.next(new StatusChangeEvent(this.status, sourceControl));\n      (this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending({...opts, sourceControl});\n    }\n  }\n\n  /**\n   * Disables the control. This means the control is exempt from validation checks and\n   * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n   *\n   * If the control has children, all children are also disabled.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configuration options that determine how the control propagates\n   * changes and emits events after the control is disabled.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,\n   * `valueChanges` and `events`\n   * observables emit events with the latest status and value when the control is disabled.\n   * When false, no events are emitted.\n   */\n  disable(opts?: {onlySelf?: boolean; emitEvent?: boolean}): void;\n  /**\n   * @internal Used to propagate the source control downwards\n   */\n  disable(opts: {onlySelf?: boolean; emitEvent?: boolean; sourceControl?: AbstractControl}): void;\n  disable(\n    opts: {onlySelf?: boolean; emitEvent?: boolean; sourceControl?: AbstractControl} = {},\n  ): void {\n    // If parent has been marked artificially dirty we don't want to re-calculate the\n    // parent's dirtiness based on the children.\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n\n    this.status = DISABLED;\n    (this as Writable<this>).errors = null;\n    this._forEachChild((control: AbstractControl) => {\n      /** We don't propagate the source control downwards */\n      control.disable({...opts, onlySelf: true});\n    });\n    this._updateValue();\n\n    const sourceControl = opts.sourceControl ?? this;\n    if (opts.emitEvent !== false) {\n      this._events.next(new ValueChangeEvent(this.value, sourceControl));\n      this._events.next(new StatusChangeEvent(this.status, sourceControl));\n      (this.valueChanges as EventEmitter<TValue>).emit(this.value);\n      (this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);\n    }\n\n    this._updateAncestors({...opts, skipPristineCheck}, this);\n    this._onDisabledChange.forEach((changeFn) => changeFn(true));\n  }\n\n  /**\n   * Enables the control. This means the control is included in validation checks and\n   * the aggregate value of its parent. Its status recalculates based on its value and\n   * its validators.\n   *\n   * By default, if the control has children, all children are enabled.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configure options that control how the control propagates changes and\n   * emits events when marked as untouched\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,\n   * `valueChanges` and `events`\n   * observables emit events with the latest status and value when the control is enabled.\n   * When false, no events are emitted.\n   */\n  enable(opts: {onlySelf?: boolean; emitEvent?: boolean} = {}): void {\n    // If parent has been marked artificially dirty we don't want to re-calculate the\n    // parent's dirtiness based on the children.\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n\n    this.status = VALID;\n    this._forEachChild((control: AbstractControl) => {\n      control.enable({...opts, onlySelf: true});\n    });\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n\n    this._updateAncestors({...opts, skipPristineCheck}, this);\n    this._onDisabledChange.forEach((changeFn) => changeFn(false));\n  }\n\n  private _updateAncestors(\n    opts: {onlySelf?: boolean; emitEvent?: boolean; skipPristineCheck?: boolean},\n    sourceControl: AbstractControl,\n  ): void {\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n      if (!opts.skipPristineCheck) {\n        this._parent._updatePristine({}, sourceControl);\n      }\n      this._parent._updateTouched({}, sourceControl);\n    }\n  }\n\n  /**\n   * Sets the parent of the control\n   *\n   * @param parent The new parent.\n   */\n  setParent(parent: FormGroup | FormArray | null): void {\n    this._parent = parent;\n  }\n\n  /**\n   * Sets the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract setValue(value: TRawValue, options?: Object): void;\n\n  /**\n   * Patches the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract patchValue(value: TValue, options?: Object): void;\n\n  /**\n   * Resets the control. Abstract method (implemented in sub-classes).\n   */\n  abstract reset(value?: TValueWithOptionalControlStates, options?: Object): void;\n\n  /**\n   * The raw value of this control. For most control implementations, the raw value will include\n   * disabled children.\n   */\n  getRawValue(): any {\n    return this.value;\n  }\n\n  /**\n   * Recalculates the value and validation status of the control.\n   *\n   * By default, it also updates the value and validity of its ancestors.\n   *\n   * @param opts Configuration options determine how the control propagates changes and emits events\n   * after updates and validity checks are applied.\n   * * `onlySelf`: When true, only update this control. When false or not supplied,\n   * update all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,\n   * `valueChanges` and `events`\n   * observables emit events with the latest status and value when the control is updated.\n   * When false, no events are emitted.\n   */\n  updateValueAndValidity(opts?: {onlySelf?: boolean; emitEvent?: boolean}): void;\n  /**\n   * @internal Used to propagate the source control downwards\n   */\n  updateValueAndValidity(opts: {\n    onlySelf?: boolean;\n    emitEvent?: boolean;\n    sourceControl?: AbstractControl;\n  }): void;\n  updateValueAndValidity(\n    opts: {onlySelf?: boolean; emitEvent?: boolean; sourceControl?: AbstractControl} = {},\n  ): void {\n    this._setInitialStatus();\n    this._updateValue();\n\n    if (this.enabled) {\n      const shouldHaveEmitted = this._cancelExistingSubscription();\n\n      (this as Writable<this>).errors = this._runValidator();\n      this.status = this._calculateStatus();\n\n      if (this.status === VALID || this.status === PENDING) {\n        // If the canceled subscription should have emitted\n        // we make sure the async validator emits the status change on completion\n        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);\n      }\n    }\n\n    const sourceControl = opts.sourceControl ?? this;\n    if (opts.emitEvent !== false) {\n      this._events.next(new ValueChangeEvent<TValue>(this.value, sourceControl));\n      this._events.next(new StatusChangeEvent(this.status, sourceControl));\n      (this.valueChanges as EventEmitter<TValue>).emit(this.value);\n      (this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity({...opts, sourceControl});\n    }\n  }\n\n  /** @internal */\n  _updateTreeValidity(opts: {emitEvent?: boolean} = {emitEvent: true}): void {\n    this._forEachChild((ctrl: AbstractControl) => ctrl._updateTreeValidity(opts));\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n  }\n\n  private _setInitialStatus() {\n    this.status = this._allControlsDisabled() ? DISABLED : VALID;\n  }\n\n  private _runValidator(): ValidationErrors | null {\n    return this.validator ? this.validator(this) : null;\n  }\n\n  private _runAsyncValidator(shouldHaveEmitted: boolean, emitEvent?: boolean): void {\n    if (this.asyncValidator) {\n      this.status = PENDING;\n      this._hasOwnPendingAsyncValidator = {\n        emitEvent: emitEvent !== false,\n        shouldHaveEmitted: shouldHaveEmitted !== false,\n      };\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription = obs.subscribe((errors: ValidationErrors | null) => {\n        this._hasOwnPendingAsyncValidator = null;\n        // This will trigger the recalculation of the validation status, which depends on\n        // the state of the asynchronous validation (whether it is in progress or not). So, it is\n        // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.\n        this.setErrors(errors, {emitEvent, shouldHaveEmitted});\n      });\n    }\n  }\n\n  private _cancelExistingSubscription(): boolean {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n\n      // we're cancelling the validator subscribtion, we keep if it should have emitted\n      // because we want to emit eventually if it was required at least once.\n      const shouldHaveEmitted =\n        (this._hasOwnPendingAsyncValidator?.emitEvent ||\n          this._hasOwnPendingAsyncValidator?.shouldHaveEmitted) ??\n        false;\n      this._hasOwnPendingAsyncValidator = null;\n      return shouldHaveEmitted;\n    }\n    return false;\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * Note: Manually set errors are always overwritten by the results of the next validation run.\n   *\n   * @param opts Configuration options that determine how the control propagates\n   * changes and emits events after the control errors are set.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n   * observable emits an event after the errors are set.\n   *\n   * @usageNotes\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```ts\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors | null, opts?: {emitEvent?: boolean}): void;\n\n  /** @internal */\n  setErrors(\n    errors: ValidationErrors | null,\n    opts?: {emitEvent?: boolean; shouldHaveEmitted?: boolean},\n  ): void;\n  setErrors(\n    errors: ValidationErrors | null,\n    opts: {emitEvent?: boolean; shouldHaveEmitted?: boolean} = {},\n  ): void {\n    (this as Writable<this>).errors = errors;\n    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);\n  }\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * This signature for get supports strings and `const` arrays (`.get(['foo', 'bar'] as const)`).\n   */\n  get<P extends string | readonly (string | number)[]>(\n    path: P,\n  ): AbstractControl<ɵGetProperty<TRawValue, P>> | null;\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * This signature for `get` supports non-const (mutable) arrays. Inferred type\n   * information will not be as robust, so prefer to pass a `readonly` array if possible.\n   */\n  get<P extends string | Array<string | number>>(\n    path: P,\n  ): AbstractControl<ɵGetProperty<TRawValue, P>> | null;\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * @param path A dot-delimited string or array of string/number values that define the path to the\n   * control. If a string is provided, passing it as a string literal will result in improved type\n   * information. Likewise, if an array is provided, passing it `as const` will cause improved type\n   * information to be available.\n   *\n   * @usageNotes\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n   *\n   * * `this.form.get('person.name');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings\n   *\n   * ### Retrieve a control in a FormArray\n   *\n   * When accessing an element inside a FormArray, you can use an element index.\n   * For example, to get a `price` control from the first element in an `items` array you can use:\n   *\n   * * `this.form.get('items.0.price');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['items', 0, 'price']);`\n   */\n  get<P extends string | (string | number)[]>(\n    path: P,\n  ): AbstractControl<ɵGetProperty<TRawValue, P>> | null {\n    let currPath: Array<string | number> | string = path;\n    if (currPath == null) return null;\n    if (!Array.isArray(currPath)) currPath = currPath.split('.');\n    if (currPath.length === 0) return null;\n    return currPath.reduce(\n      (control: AbstractControl | null, name) => control && control._find(name),\n      this,\n    );\n  }\n\n  /**\n   * @description\n   * Reports error data for the control with the given path.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```ts\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError(errorCode: string, path?: Array<string | number> | string): any {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```ts\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * If no path is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given path.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError(errorCode: string, path?: Array<string | number> | string): boolean {\n    return !!this.getError(errorCode, path);\n  }\n\n  /**\n   * Retrieves the top-level ancestor of this control.\n   */\n  get root(): AbstractControl {\n    let x: AbstractControl = this;\n\n    while (x._parent) {\n      x = x._parent;\n    }\n\n    return x;\n  }\n\n  /** @internal */\n  _updateControlsErrors(\n    emitEvent: boolean,\n    changedControl: AbstractControl,\n    shouldHaveEmitted?: boolean,\n  ): void {\n    this.status = this._calculateStatus();\n\n    if (emitEvent) {\n      (this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);\n    }\n\n    // The Events Observable expose a slight different bevahior than the statusChanges obs\n    // An async validator will still emit a StatusChangeEvent is a previously cancelled\n    // async validator has emitEvent set to true\n    if (emitEvent || shouldHaveEmitted) {\n      this._events.next(new StatusChangeEvent(this.status, changedControl));\n    }\n\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);\n    }\n  }\n\n  /** @internal */\n  _initObservables() {\n    // TODO: this should be piped from events() but is breaking in G3\n    (this as Writable<this>).valueChanges = new EventEmitter();\n    (this as Writable<this>).statusChanges = new EventEmitter();\n  }\n\n  private _calculateStatus(): FormControlStatus {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n\n  /** @internal */\n  abstract _updateValue(): void;\n\n  /** @internal */\n  abstract _forEachChild(cb: (c: AbstractControl) => void): void;\n\n  /** @internal */\n  abstract _anyControls(condition: (c: AbstractControl) => boolean): boolean;\n\n  /** @internal */\n  abstract _allControlsDisabled(): boolean;\n\n  /** @internal */\n  abstract _syncPendingControls(): boolean;\n\n  /** @internal */\n  _anyControlsHaveStatus(status: FormControlStatus): boolean {\n    return this._anyControls((control: AbstractControl) => control.status === status);\n  }\n\n  /** @internal */\n  _anyControlsDirty(): boolean {\n    return this._anyControls((control: AbstractControl) => control.dirty);\n  }\n\n  /** @internal */\n  _anyControlsTouched(): boolean {\n    return this._anyControls((control: AbstractControl) => control.touched);\n  }\n\n  /** @internal */\n  _updatePristine(opts: {onlySelf?: boolean}, changedControl: AbstractControl): void {\n    const newPristine = !this._anyControlsDirty();\n    const changed = this.pristine !== newPristine;\n    this.pristine = newPristine;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts, changedControl);\n    }\n\n    if (changed) {\n      this._events.next(new PristineChangeEvent(this.pristine, changedControl));\n    }\n  }\n\n  /** @internal */\n  _updateTouched(opts: {onlySelf?: boolean} = {}, changedControl: AbstractControl): void {\n    this.touched = this._anyControlsTouched();\n    this._events.next(new TouchedChangeEvent(this.touched, changedControl));\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts, changedControl);\n    }\n  }\n\n  /** @internal */\n  _onDisabledChange: Array<(isDisabled: boolean) => void> = [];\n\n  /** @internal */\n  _registerOnCollectionChange(fn: () => void): void {\n    this._onCollectionChange = fn;\n  }\n\n  /** @internal */\n  _setUpdateStrategy(opts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null): void {\n    if (isOptionsObj(opts) && opts.updateOn != null) {\n      this._updateOn = opts.updateOn!;\n    }\n  }\n  /**\n   * Check to see if parent has been marked artificially dirty.\n   *\n   * @internal\n   */\n  private _parentMarkedDirty(onlySelf?: boolean): boolean {\n    const parentDirty = this._parent && this._parent.dirty;\n    return !onlySelf && !!parentDirty && !this._parent!._anyControlsDirty();\n  }\n\n  /** @internal */\n  _find(name: string | number): AbstractControl | null {\n    return null;\n  }\n\n  /**\n   * Internal implementation of the `setValidators` method. Needs to be separated out into a\n   * different method, because it is called in the constructor and it can break cases where\n   * a control is extended.\n   */\n  private _assignValidators(validators: ValidatorFn | ValidatorFn[] | null): void {\n    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;\n    this._composedValidatorFn = coerceToValidator(this._rawValidators);\n  }\n\n  /**\n   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a\n   * different method, because it is called in the constructor and it can break cases where\n   * a control is extended.\n   */\n  private _assignAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[] | null): void {\n    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;\n    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);\n  }\n}\n"]}