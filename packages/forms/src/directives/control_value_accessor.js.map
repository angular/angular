{"version":3,"file":"control_value_accessor.js","sourceRoot":"","sources":["control_value_accessor.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;AAEH,OAAO,EAAC,SAAS,EAAc,cAAc,EAAY,MAAM,eAAe,CAAC;AA6H/E;;;;;;GAMG;AAEI,IAAM,wBAAwB,GAA9B,MAAM,wBAAwB;IAcnC,YACU,SAAoB,EACpB,WAAuB;QADvB,cAAS,GAAT,SAAS,CAAW;QACpB,gBAAW,GAAX,WAAW,CAAY;QAfjC;;;;WAIG;QACH,aAAQ,GAAG,CAAC,CAAM,EAAE,EAAE,GAAE,CAAC,CAAC;QAE1B;;;WAGG;QACH,cAAS,GAAG,GAAG,EAAE,GAAE,CAAC,CAAC;IAKlB,CAAC;IAEJ;;;;OAIG;IACO,WAAW,CAAC,GAAW,EAAE,KAAU;QAC3C,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;IACzE,CAAC;IAED;;;OAGG;IACH,iBAAiB,CAAC,EAAc;QAC9B,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;IACtB,CAAC;IAED;;;OAGG;IACH,gBAAgB,CAAC,EAAkB;QACjC,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;IACrB,CAAC;IAED;;;OAGG;IACH,gBAAgB,CAAC,UAAmB;QAClC,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;IAC3C,CAAC;CACF,CAAA;AAnDY,wBAAwB;IADpC,SAAS,EAAE;GACC,wBAAwB,CAmDpC;;AAED;;;;;;;;GAQG;AAEI,IAAM,2BAA2B,GAAjC,MAAM,2BAA4B,SAAQ,wBAAwB;CAAG,CAAA;AAA/D,2BAA2B;IADvC,SAAS,EAAE;GACC,2BAA2B,CAAoC;;AAE5E;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,iBAAiB,GAAG,IAAI,cAAc,CACjD,OAAO,SAAS,KAAK,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE,CACrE,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, ElementRef, InjectionToken, Renderer2} from '@angular/core';\n\n/**\n * @description\n * Defines an interface that acts as a bridge between the Angular forms API and a\n * native element in the DOM.\n *\n * Implement this interface to create a custom form control directive\n * that integrates with Angular forms.\n *\n * @see {@link DefaultValueAccessor}\n *\n * @publicApi\n */\nexport interface ControlValueAccessor {\n  /**\n   * @description\n   * Writes a new value to the element.\n   *\n   * This method is called by the forms API to write to the view when programmatic\n   * changes from model to view are requested.\n   *\n   * @usageNotes\n   * ### Write a value to the element\n   *\n   * The following example writes a value to the native DOM element.\n   *\n   * ```ts\n   * writeValue(value: any): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\n   * }\n   * ```\n   *\n   * @param obj The new value for the element\n   */\n  writeValue(obj: any): void;\n\n  /**\n   * @description\n   * Registers a callback function that is called when the control's value\n   * changes in the UI.\n   *\n   * This method is called by the forms API on initialization to update the form\n   * model when values propagate from the view to the model.\n   *\n   * When implementing the `registerOnChange` method in your own value accessor,\n   * save the given function so your class calls it at the appropriate time.\n   *\n   * @usageNotes\n   * ### Store the change function\n   *\n   * The following example stores the provided function as an internal method.\n   *\n   * ```ts\n   * registerOnChange(fn: (_: any) => void): void {\n   *   this._onChange = fn;\n   * }\n   * ```\n   *\n   * When the value changes in the UI, call the registered\n   * function to allow the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    '(change)': '_onChange($event.target.value)'\n   * }\n   * ```\n   *\n   * @param fn The callback function to register\n   */\n  registerOnChange(fn: any): void;\n\n  /**\n   * @description\n   * Registers a callback function that is called by the forms API on initialization\n   * to update the form model on blur.\n   *\n   * When implementing `registerOnTouched` in your own value accessor, save the given\n   * function so your class calls it when the control should be considered\n   * blurred or \"touched\".\n   *\n   * @usageNotes\n   * ### Store the callback function\n   *\n   * The following example stores the provided function as an internal method.\n   *\n   * ```ts\n   * registerOnTouched(fn: any): void {\n   *   this._onTouched = fn;\n   * }\n   * ```\n   *\n   * On blur (or equivalent), your class should call the registered function to allow\n   * the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    '(blur)': '_onTouched()'\n   * }\n   * ```\n   *\n   * @param fn The callback function to register\n   */\n  registerOnTouched(fn: any): void;\n\n  /**\n   * @description\n   * Function that is called by the forms API when the control status changes to\n   * or from 'DISABLED'. Depending on the status, it enables or disables the\n   * appropriate DOM element.\n   *\n   * @usageNotes\n   * The following is an example of writing the disabled property to a native DOM element:\n   *\n   * ```ts\n   * setDisabledState(isDisabled: boolean): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n   * }\n   * ```\n   *\n   * @param isDisabled The disabled status to set on the element\n   */\n  setDisabledState?(isDisabled: boolean): void;\n}\n\n/**\n * Base class for all ControlValueAccessor classes defined in Forms package.\n * Contains common logic and utility functions.\n *\n * Note: this is an *internal-only* class and should not be extended or used directly in\n * applications code.\n */\n@Directive()\nexport class BaseControlValueAccessor {\n  /**\n   * The registered callback function called when a change or input event occurs on the input\n   * element.\n   * @docs-private\n   */\n  onChange = (_: any) => {};\n\n  /**\n   * The registered callback function called when a blur event occurs on the input element.\n   * @docs-private\n   */\n  onTouched = () => {};\n\n  constructor(\n    private _renderer: Renderer2,\n    private _elementRef: ElementRef,\n  ) {}\n\n  /**\n   * Helper method that sets a property on a target element using the current Renderer\n   * implementation.\n   * @docs-private\n   */\n  protected setProperty(key: string, value: any): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, key, value);\n  }\n\n  /**\n   * Registers a function called when the control is touched.\n   * @docs-private\n   */\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Registers a function called when the control value changes.\n   * @docs-private\n   */\n  registerOnChange(fn: (_: any) => {}): void {\n    this.onChange = fn;\n  }\n\n  /**\n   * Sets the \"disabled\" property on the range input element.\n   * @docs-private\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.setProperty('disabled', isDisabled);\n  }\n}\n\n/**\n * Base class for all built-in ControlValueAccessor classes (except DefaultValueAccessor, which is\n * used in case no other CVAs can be found). We use this class to distinguish between default CVA,\n * built-in CVAs and custom CVAs, so that Forms logic can recognize built-in CVAs and treat custom\n * ones with higher priority (when both built-in and custom CVAs are present).\n *\n * Note: this is an *internal-only* class and should not be extended or used directly in\n * applications code.\n */\n@Directive()\nexport class BuiltInControlValueAccessor extends BaseControlValueAccessor {}\n\n/**\n * Used to provide a `ControlValueAccessor` for form controls.\n *\n * See `DefaultValueAccessor` for how to implement one.\n *\n * @publicApi\n */\nexport const NG_VALUE_ACCESSOR = new InjectionToken<ReadonlyArray<ControlValueAccessor>>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'NgValueAccessor' : '',\n);\n"]}