{"version":3,"file":"shared.js","sourceRoot":"","sources":["shared.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\nimport type {AbstractControl} from '../model/abstract_model';\nimport type {FormArray} from '../model/form_array';\nimport type {FormControl} from '../model/form_control';\nimport type {FormGroup} from '../model/form_group';\nimport {getControlAsyncValidators, getControlValidators, mergeValidators} from '../validators';\n\nimport type {AbstractControlDirective} from './abstract_control_directive';\nimport type {AbstractFormGroupDirective} from './abstract_form_group_directive';\nimport type {ControlContainer} from './control_container';\nimport {BuiltInControlValueAccessor, ControlValueAccessor} from './control_value_accessor';\nimport {DefaultValueAccessor} from './default_value_accessor';\nimport type {NgControl} from './ng_control';\nimport type {FormArrayName} from './reactive_directives/form_group_name';\nimport {ngModelWarning} from './reactive_errors';\nimport {AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n\n/**\n * Token to provide to allow SetDisabledState to always be called when a CVA is added, regardless of\n * whether the control is disabled or enabled.\n *\n * @see {@link FormsModule#withconfig}\n */\nexport const CALL_SET_DISABLED_STATE = new InjectionToken(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'CallSetDisabledState' : '',\n  {\n    providedIn: 'root',\n    factory: () => setDisabledStateDefault,\n  },\n);\n\n/**\n * The type for CALL_SET_DISABLED_STATE. If `always`, then ControlValueAccessor will always call\n * `setDisabledState` when attached, which is the most correct behavior. Otherwise, it will only be\n * called when disabled, which is the legacy behavior for compatibility.\n *\n * @publicApi\n * @see {@link FormsModule#withconfig}\n */\nexport type SetDisabledStateOption = 'whenDisabledForLegacyCode' | 'always';\n\n/**\n * Whether to use the fixed setDisabledState behavior by default.\n */\nexport const setDisabledStateDefault: SetDisabledStateOption = 'always';\n\nexport function controlPath(name: string | null, parent: ControlContainer): string[] {\n  return [...parent.path!, name!];\n}\n\n/**\n * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both\n * instances. This function is typically invoked when form directive is being initialized.\n *\n * @param control Form control instance that should be linked.\n * @param dir Directive that should be linked with a given control.\n */\nexport function setUpControl(\n  control: FormControl,\n  dir: NgControl,\n  callSetDisabledState: SetDisabledStateOption = setDisabledStateDefault,\n): void {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!control) _throwError(dir, 'Cannot find control with');\n    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);\n  }\n\n  setUpValidators(control, dir);\n\n  dir.valueAccessor!.writeValue(control.value);\n\n  // The legacy behavior only calls the CVA's `setDisabledState` if the control is disabled.\n  // If the `callSetDisabledState` option is set to `always`, then this bug is fixed and\n  // the method is always called.\n  if (control.disabled || callSetDisabledState === 'always') {\n    dir.valueAccessor!.setDisabledState?.(control.disabled);\n  }\n\n  setUpViewChangePipeline(control, dir);\n  setUpModelChangePipeline(control, dir);\n\n  setUpBlurPipeline(control, dir);\n\n  setUpDisabledChangeHandler(control, dir);\n}\n\n/**\n * Reverts configuration performed by the `setUpControl` control function.\n * Effectively disconnects form control with a given form directive.\n * This function is typically invoked when corresponding form directive is being destroyed.\n *\n * @param control Form control which should be cleaned up.\n * @param dir Directive that should be disconnected from a given control.\n * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should\n *     contain asserts to verify that it's not called once directive is destroyed. We need this flag\n *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.\n */\nexport function cleanUpControl(\n  control: FormControl | null,\n  dir: NgControl,\n  validateControlPresenceOnChange: boolean = true,\n): void {\n  const noop = () => {\n    if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      _noControlError(dir);\n    }\n  };\n\n  // The `valueAccessor` field is typically defined on FromControl and FormControlName directive\n  // instances and there is a logic in `selectValueAccessor` function that throws if it's not the\n  // case. We still check the presence of `valueAccessor` before invoking its methods to make sure\n  // that cleanup works correctly if app code or tests are setup to ignore the error thrown from\n  // `selectValueAccessor`. See https://github.com/angular/angular/issues/40521.\n  if (dir.valueAccessor) {\n    dir.valueAccessor.registerOnChange(noop);\n    dir.valueAccessor.registerOnTouched(noop);\n  }\n\n  cleanUpValidators(control, dir);\n\n  if (control) {\n    dir._invokeOnDestroyCallbacks();\n    control._registerOnCollectionChange(() => {});\n  }\n}\n\nfunction registerOnValidatorChange<V>(validators: (V | Validator)[], onChange: () => void): void {\n  validators.forEach((validator: V | Validator) => {\n    if ((<Validator>validator).registerOnValidatorChange)\n      (<Validator>validator).registerOnValidatorChange!(onChange);\n  });\n}\n\n/**\n * Sets up disabled change handler function on a given form control if ControlValueAccessor\n * associated with a given directive instance supports the `setDisabledState` call.\n *\n * @param control Form control where disabled change handler should be setup.\n * @param dir Corresponding directive instance associated with this control.\n */\nexport function setUpDisabledChangeHandler(control: FormControl, dir: NgControl): void {\n  if (dir.valueAccessor!.setDisabledState) {\n    const onDisabledChange = (isDisabled: boolean) => {\n      dir.valueAccessor!.setDisabledState!(isDisabled);\n    };\n    control.registerOnDisabledChange(onDisabledChange);\n\n    // Register a callback function to cleanup disabled change handler\n    // from a control instance when a directive is destroyed.\n    dir._registerOnDestroy(() => {\n      control._unregisterOnDisabledChange(onDisabledChange);\n    });\n  }\n}\n\n/**\n * Sets up sync and async directive validators on provided form control.\n * This function merges validators from the directive into the validators of the control.\n *\n * @param control Form control where directive validators should be setup.\n * @param dir Directive instance that contains validators to be setup.\n */\nexport function setUpValidators(control: AbstractControl, dir: AbstractControlDirective): void {\n  const validators = getControlValidators(control);\n  if (dir.validator !== null) {\n    control.setValidators(mergeValidators<ValidatorFn>(validators, dir.validator));\n  } else if (typeof validators === 'function') {\n    // If sync validators are represented by a single validator function, we force the\n    // `Validators.compose` call to happen by executing the `setValidators` function with\n    // an array that contains that function. We need this to avoid possible discrepancies in\n    // validators behavior, so sync validators are always processed by the `Validators.compose`.\n    // Note: we should consider moving this logic inside the `setValidators` function itself, so we\n    // have consistent behavior on AbstractControl API level. The same applies to the async\n    // validators logic below.\n    control.setValidators([validators]);\n  }\n\n  const asyncValidators = getControlAsyncValidators(control);\n  if (dir.asyncValidator !== null) {\n    control.setAsyncValidators(\n      mergeValidators<AsyncValidatorFn>(asyncValidators, dir.asyncValidator),\n    );\n  } else if (typeof asyncValidators === 'function') {\n    control.setAsyncValidators([asyncValidators]);\n  }\n\n  // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n  const onValidatorChange = () => control.updateValueAndValidity();\n  registerOnValidatorChange<ValidatorFn>(dir._rawValidators, onValidatorChange);\n  registerOnValidatorChange<AsyncValidatorFn>(dir._rawAsyncValidators, onValidatorChange);\n}\n\n/**\n * Cleans up sync and async directive validators on provided form control.\n * This function reverts the setup performed by the `setUpValidators` function, i.e.\n * removes directive-specific validators from a given control instance.\n *\n * @param control Form control from where directive validators should be removed.\n * @param dir Directive instance that contains validators to be removed.\n * @returns true if a control was updated as a result of this action.\n */\nexport function cleanUpValidators(\n  control: AbstractControl | null,\n  dir: AbstractControlDirective,\n): boolean {\n  let isControlUpdated = false;\n  if (control !== null) {\n    if (dir.validator !== null) {\n      const validators = getControlValidators(control);\n      if (Array.isArray(validators) && validators.length > 0) {\n        // Filter out directive validator function.\n        const updatedValidators = validators.filter((validator) => validator !== dir.validator);\n        if (updatedValidators.length !== validators.length) {\n          isControlUpdated = true;\n          control.setValidators(updatedValidators);\n        }\n      }\n    }\n\n    if (dir.asyncValidator !== null) {\n      const asyncValidators = getControlAsyncValidators(control);\n      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {\n        // Filter out directive async validator function.\n        const updatedAsyncValidators = asyncValidators.filter(\n          (asyncValidator) => asyncValidator !== dir.asyncValidator,\n        );\n        if (updatedAsyncValidators.length !== asyncValidators.length) {\n          isControlUpdated = true;\n          control.setAsyncValidators(updatedAsyncValidators);\n        }\n      }\n    }\n  }\n\n  // Clear onValidatorChange callbacks by providing a noop function.\n  const noop = () => {};\n  registerOnValidatorChange<ValidatorFn>(dir._rawValidators, noop);\n  registerOnValidatorChange<AsyncValidatorFn>(dir._rawAsyncValidators, noop);\n\n  return isControlUpdated;\n}\n\nfunction setUpViewChangePipeline(control: FormControl, dir: NgControl): void {\n  dir.valueAccessor!.registerOnChange((newValue: any) => {\n    control._pendingValue = newValue;\n    control._pendingChange = true;\n    control._pendingDirty = true;\n\n    if (control.updateOn === 'change') updateControl(control, dir);\n  });\n}\n\nfunction setUpBlurPipeline(control: FormControl, dir: NgControl): void {\n  dir.valueAccessor!.registerOnTouched(() => {\n    control._pendingTouched = true;\n\n    if (control.updateOn === 'blur' && control._pendingChange) updateControl(control, dir);\n    if (control.updateOn !== 'submit') control.markAsTouched();\n  });\n}\n\nfunction updateControl(control: FormControl, dir: NgControl): void {\n  if (control._pendingDirty) control.markAsDirty();\n  control.setValue(control._pendingValue, {emitModelToViewChange: false});\n  dir.viewToModelUpdate(control._pendingValue);\n  control._pendingChange = false;\n}\n\nfunction setUpModelChangePipeline(control: FormControl, dir: NgControl): void {\n  const onChange = (newValue?: any, emitModelEvent?: boolean) => {\n    // control -> view\n    dir.valueAccessor!.writeValue(newValue);\n\n    // control -> ngModel\n    if (emitModelEvent) dir.viewToModelUpdate(newValue);\n  };\n  control.registerOnChange(onChange);\n\n  // Register a callback function to cleanup onChange handler\n  // from a control instance when a directive is destroyed.\n  dir._registerOnDestroy(() => {\n    control._unregisterOnChange(onChange);\n  });\n}\n\n/**\n * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators\n * present in the view.\n *\n * @param control FormGroup or FormArray instance that should be linked.\n * @param dir Directive that provides view validators.\n */\nexport function setUpFormContainer(\n  control: FormGroup | FormArray,\n  dir: AbstractFormGroupDirective | FormArrayName,\n) {\n  if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode))\n    _throwError(dir, 'Cannot find control with');\n  setUpValidators(control, dir);\n}\n\n/**\n * Reverts the setup performed by the `setUpFormContainer` function.\n *\n * @param control FormGroup or FormArray instance that should be cleaned up.\n * @param dir Directive that provided view validators.\n * @returns true if a control was updated as a result of this action.\n */\nexport function cleanUpFormContainer(\n  control: FormGroup | FormArray,\n  dir: AbstractFormGroupDirective | FormArrayName,\n): boolean {\n  return cleanUpValidators(control, dir);\n}\n\nfunction _noControlError(dir: NgControl) {\n  return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n}\n\nfunction _throwError(dir: AbstractControlDirective, message: string): void {\n  const messageEnd = _describeControlLocation(dir);\n  throw new Error(`${message} ${messageEnd}`);\n}\n\nfunction _describeControlLocation(dir: AbstractControlDirective): string {\n  const path = dir.path;\n  if (path && path.length > 1) return `path: '${path.join(' -> ')}'`;\n  if (path?.[0]) return `name: '${path}'`;\n  return 'unspecified name attribute';\n}\n\nfunction _throwMissingValueAccessorError(dir: AbstractControlDirective) {\n  const loc = _describeControlLocation(dir);\n  throw new RuntimeError(\n    RuntimeErrorCode.NG_MISSING_VALUE_ACCESSOR,\n    `No value accessor for form control ${loc}.`,\n  );\n}\n\nfunction _throwInvalidValueAccessorError(dir: AbstractControlDirective) {\n  const loc = _describeControlLocation(dir);\n  throw new RuntimeError(\n    RuntimeErrorCode.NG_VALUE_ACCESSOR_NOT_PROVIDED,\n    `Value accessor was not provided as an array for form control with ${loc}. ` +\n      `Check that the \\`NG_VALUE_ACCESSOR\\` token is configured as a \\`multi: true\\` provider.`,\n  );\n}\n\nexport function isPropertyUpdated(changes: {[key: string]: any}, viewModel: any): boolean {\n  if (!changes.hasOwnProperty('model')) return false;\n  const change = changes['model'];\n\n  if (change.isFirstChange()) return true;\n  return !Object.is(viewModel, change.currentValue);\n}\n\nexport function isBuiltInAccessor(valueAccessor: ControlValueAccessor): boolean {\n  // Check if a given value accessor is an instance of a class that directly extends\n  // `BuiltInControlValueAccessor` one.\n  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;\n}\n\nexport function syncPendingControls(\n  form: AbstractControl,\n  directives: Set<NgControl> | NgControl[],\n): void {\n  form._syncPendingControls();\n  directives.forEach((dir: NgControl) => {\n    const control = dir.control as FormControl;\n    if (control.updateOn === 'submit' && control._pendingChange) {\n      dir.viewToModelUpdate(control._pendingValue);\n      control._pendingChange = false;\n    }\n  });\n}\n\n// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented\nexport function selectValueAccessor(\n  dir: NgControl,\n  valueAccessors: ControlValueAccessor[],\n): ControlValueAccessor | null {\n  if (!valueAccessors) return null;\n\n  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode))\n    _throwInvalidValueAccessorError(dir);\n\n  let defaultAccessor: ControlValueAccessor | undefined = undefined;\n  let builtinAccessor: ControlValueAccessor | undefined = undefined;\n  let customAccessor: ControlValueAccessor | undefined = undefined;\n\n  valueAccessors.forEach((v: ControlValueAccessor) => {\n    if (v.constructor === DefaultValueAccessor) {\n      defaultAccessor = v;\n    } else if (isBuiltInAccessor(v)) {\n      if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))\n        _throwError(dir, 'More than one built-in value accessor matches form control with');\n      builtinAccessor = v;\n    } else {\n      if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))\n        _throwError(dir, 'More than one custom value accessor matches form control with');\n      customAccessor = v;\n    }\n  });\n\n  if (customAccessor) return customAccessor;\n  if (builtinAccessor) return builtinAccessor;\n  if (defaultAccessor) return defaultAccessor;\n\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    _throwError(dir, 'No valid value accessor for form control with');\n  }\n  return null;\n}\n\nexport function removeListItem<T>(list: T[], el: T): void {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n}\n\n// TODO(kara): remove after deprecation period\nexport function _ngModelWarning(\n  name: string,\n  type: {_ngModelWarningSentOnce: boolean},\n  instance: {_ngModelWarningSent: boolean},\n  warningConfig: string | null,\n) {\n  if (warningConfig === 'never') return;\n\n  if (\n    ((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce) ||\n    (warningConfig === 'always' && !instance._ngModelWarningSent)\n  ) {\n    console.warn(ngModelWarning(name));\n    type._ngModelWarningSentOnce = true;\n    instance._ngModelWarningSent = true;\n  }\n}\n"]}