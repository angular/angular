{"version":3,"file":"output_ast.js","sourceRoot":"","sources":["output_ast.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computeMsgId} from '../i18n/digest';\nimport {Message} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\nimport type {I18nMeta} from '../render3/view/i18n/meta';\n\n//// Types\nexport enum TypeModifier {\n  None = 0,\n  Const = 1 << 0,\n}\n\nexport abstract class Type {\n  constructor(public modifiers: TypeModifier = TypeModifier.None) {}\n  abstract visitType(visitor: TypeVisitor, context: any): any;\n\n  hasModifier(modifier: TypeModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\n\nexport enum BuiltinTypeName {\n  Dynamic,\n  Bool,\n  String,\n  Int,\n  Number,\n  Function,\n  Inferred,\n  None,\n}\n\nexport class BuiltinType extends Type {\n  constructor(\n    public name: BuiltinTypeName,\n    modifiers?: TypeModifier,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\n\nexport class ExpressionType extends Type {\n  constructor(\n    public value: Expression,\n    modifiers?: TypeModifier,\n    public typeParams: Type[] | null = null,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitExpressionType(this, context);\n  }\n}\n\nexport class ArrayType extends Type {\n  constructor(\n    public of: Type,\n    modifiers?: TypeModifier,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitArrayType(this, context);\n  }\n}\n\nexport class MapType extends Type {\n  public valueType: Type | null;\n  constructor(valueType: Type | null | undefined, modifiers?: TypeModifier) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitMapType(this, context);\n  }\n}\n\nexport class TransplantedType<T> extends Type {\n  constructor(\n    readonly type: T,\n    modifiers?: TypeModifier,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitTransplantedType(this, context);\n  }\n}\n\nexport const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nexport const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n\nexport interface TypeVisitor {\n  visitBuiltinType(type: BuiltinType, context: any): any;\n  visitExpressionType(type: ExpressionType, context: any): any;\n  visitArrayType(type: ArrayType, context: any): any;\n  visitMapType(type: MapType, context: any): any;\n  visitTransplantedType(type: TransplantedType<unknown>, context: any): any;\n}\n\n///// Expressions\n\nexport enum UnaryOperator {\n  Minus,\n  Plus,\n}\n\nexport enum BinaryOperator {\n  Equals,\n  NotEquals,\n  Assign,\n  Identical,\n  NotIdentical,\n  Minus,\n  Plus,\n  Divide,\n  Multiply,\n  Modulo,\n  And,\n  Or,\n  BitwiseOr,\n  BitwiseAnd,\n  Lower,\n  LowerEquals,\n  Bigger,\n  BiggerEquals,\n  NullishCoalesce,\n  Exponentiation,\n  In,\n  AdditionAssignment,\n  SubtractionAssignment,\n  MultiplicationAssignment,\n  DivisionAssignment,\n  RemainderAssignment,\n  ExponentiationAssignment,\n  AndAssignment,\n  OrAssignment,\n  NullishCoalesceAssignment,\n}\n\nexport function nullSafeIsEquivalent<T extends {isEquivalent(other: T): boolean}>(\n  base: T | null,\n  other: T | null,\n) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalentPredicate<T>(\n  base: T[],\n  other: T[],\n  equivalentPredicate: (baseElement: T, otherElement: T) => boolean,\n) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function areAllEquivalent<T extends {isEquivalent(other: T): boolean}>(\n  base: T[],\n  other: T[],\n) {\n  return areAllEquivalentPredicate(base, other, (baseElement: T, otherElement: T) =>\n    baseElement.isEquivalent(otherElement),\n  );\n}\n\nexport abstract class Expression {\n  public type: Type | null;\n  public sourceSpan: ParseSourceSpan | null;\n\n  constructor(type: Type | null | undefined, sourceSpan?: ParseSourceSpan | null) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\n\n  /**\n   * Calculates whether this expression produces the same value as the given expression.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(e: Expression): boolean;\n\n  /**\n   * Return true if the expression is constant.\n   */\n  abstract isConstant(): boolean;\n\n  abstract clone(): Expression;\n\n  prop(name: string, sourceSpan?: ParseSourceSpan | null): ReadPropExpr {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n\n  key(index: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null): ReadKeyExpr {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n\n  callFn(\n    params: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n    pure?: boolean,\n  ): InvokeFunctionExpr {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n\n  instantiate(\n    params: Expression[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ): InstantiateExpr {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n\n  conditional(\n    trueCase: Expression,\n    falseCase: Expression | null = null,\n    sourceSpan?: ParseSourceSpan | null,\n  ): ConditionalExpr {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n\n  equals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  power(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Exponentiation, this, rhs, null, sourceSpan);\n  }\n  and(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseOr(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseOr, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan);\n  }\n  or(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan?: ParseSourceSpan | null): Expression {\n    // Note: We use equals by purpose here to compare to null and undefined in JS.\n    // We use the typed null to allow strictNullChecks to narrow types.\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n\n  toStmt(): Statement {\n    return new ExpressionStatement(this, null);\n  }\n}\n\nexport class ReadVarExpr extends Expression {\n  constructor(\n    public name: string,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadVarExpr(this, context);\n  }\n\n  override clone(): ReadVarExpr {\n    return new ReadVarExpr(this.name, this.type, this.sourceSpan);\n  }\n\n  set(value: Expression): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this, value, null, this.sourceSpan);\n  }\n}\n\nexport class TypeofExpr extends Expression {\n  constructor(\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): TypeofExpr {\n    return new TypeofExpr(this.expr.clone());\n  }\n}\n\nexport class VoidExpr extends Expression {\n  constructor(\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitVoidExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof VoidExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): VoidExpr {\n    return new VoidExpr(this.expr.clone());\n  }\n}\n\nexport class WrappedNodeExpr<T> extends Expression {\n  constructor(\n    public node: T,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n\n  override clone(): WrappedNodeExpr<T> {\n    return new WrappedNodeExpr(this.node, this.type, this.sourceSpan);\n  }\n}\n\nexport class InvokeFunctionExpr extends Expression {\n  constructor(\n    public fn: Expression,\n    public args: Expression[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public pure = false,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  // An alias for fn, which allows other logic to handle calls and property reads together.\n  get receiver(): Expression {\n    return this.fn;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof InvokeFunctionExpr &&\n      this.fn.isEquivalent(e.fn) &&\n      areAllEquivalent(this.args, e.args) &&\n      this.pure === e.pure\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n\n  override clone(): InvokeFunctionExpr {\n    return new InvokeFunctionExpr(\n      this.fn.clone(),\n      this.args.map((arg) => arg.clone()),\n      this.type,\n      this.sourceSpan,\n      this.pure,\n    );\n  }\n}\n\nexport class TaggedTemplateLiteralExpr extends Expression {\n  constructor(\n    public tag: Expression,\n    public template: TemplateLiteralExpr,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof TaggedTemplateLiteralExpr &&\n      this.tag.isEquivalent(e.tag) &&\n      this.template.isEquivalent(e.template)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTaggedTemplateLiteralExpr(this, context);\n  }\n\n  override clone(): TaggedTemplateLiteralExpr {\n    return new TaggedTemplateLiteralExpr(\n      this.tag.clone(),\n      this.template.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class InstantiateExpr extends Expression {\n  constructor(\n    public classExpr: Expression,\n    public args: Expression[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof InstantiateExpr &&\n      this.classExpr.isEquivalent(e.classExpr) &&\n      areAllEquivalent(this.args, e.args)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n\n  override clone(): InstantiateExpr {\n    return new InstantiateExpr(\n      this.classExpr.clone(),\n      this.args.map((arg) => arg.clone()),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class RegularExpressionLiteral extends Expression {\n  constructor(\n    public body: string,\n    public flags: string | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(null, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof RegularExpressionLiteral && this.body === e.body && this.flags === e.flags;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitRegularExpressionLiteral(this, context);\n  }\n\n  override clone(): RegularExpressionLiteral {\n    return new RegularExpressionLiteral(this.body, this.flags, this.sourceSpan);\n  }\n}\n\nexport class LiteralExpr extends Expression {\n  constructor(\n    public value: number | string | boolean | null | undefined,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralExpr(this, context);\n  }\n\n  override clone(): LiteralExpr {\n    return new LiteralExpr(this.value, this.type, this.sourceSpan);\n  }\n}\n\nexport class TemplateLiteralExpr extends Expression {\n  constructor(\n    public elements: TemplateLiteralElementExpr[],\n    public expressions: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(null, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof TemplateLiteralExpr &&\n      areAllEquivalentPredicate(this.elements, e.elements, (a, b) => a.text === b.text) &&\n      areAllEquivalent(this.expressions, e.expressions)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTemplateLiteralExpr(this, context);\n  }\n\n  override clone(): TemplateLiteralExpr {\n    return new TemplateLiteralExpr(\n      this.elements.map((el) => el.clone()),\n      this.expressions.map((expr) => expr.clone()),\n    );\n  }\n}\nexport class TemplateLiteralElementExpr extends Expression {\n  readonly rawText: string;\n\n  constructor(\n    readonly text: string,\n    sourceSpan?: ParseSourceSpan | null,\n    rawText?: string,\n  ) {\n    super(STRING_TYPE, sourceSpan);\n\n    // If `rawText` is not provided, \"fake\" the raw string by escaping the following sequences:\n    // - \"\\\" would otherwise indicate that the next character is a control character.\n    // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n    // indicate the end of the template literal element.\n    // Note that we can't rely on the `sourceSpan` here, because it may be incorrect (see\n    // https://github.com/angular/angular/pull/60267#discussion_r1986402524).\n    this.rawText = rawText ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTemplateLiteralElementExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof TemplateLiteralElementExpr && e.text === this.text && e.rawText === this.rawText\n    );\n  }\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  override clone(): TemplateLiteralElementExpr {\n    return new TemplateLiteralElementExpr(this.text, this.sourceSpan, this.rawText);\n  }\n}\n\nexport class LiteralPiece {\n  constructor(\n    public text: string,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n}\nexport class PlaceholderPiece {\n  /**\n   * Create a new instance of a `PlaceholderPiece`.\n   *\n   * @param text the name of this placeholder (e.g. `PH_1`).\n   * @param sourceSpan the location of this placeholder in its localized message the source code.\n   * @param associatedMessage reference to another message that this placeholder is associated with.\n   * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n   * been extracted out from the message containing the placeholder.\n   */\n  constructor(\n    public text: string,\n    public sourceSpan: ParseSourceSpan,\n    public associatedMessage?: Message,\n  ) {}\n}\n\nexport type MessagePiece = LiteralPiece | PlaceholderPiece;\n\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nconst LEGACY_ID_INDICATOR = '';\n\nexport class LocalizedString extends Expression {\n  constructor(\n    readonly metaBlock: I18nMeta,\n    readonly messageParts: LiteralPiece[],\n    readonly placeHolderNames: PlaceholderPiece[],\n    readonly expressions: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(STRING_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    // return e instanceof LocalizedString && this.message === e.message;\n    return false;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLocalizedString(this, context);\n  }\n\n  override clone(): LocalizedString {\n    return new LocalizedString(\n      this.metaBlock,\n      this.messageParts,\n      this.placeHolderNames,\n      this.expressions.map((expr) => expr.clone()),\n      this.sourceSpan,\n    );\n  }\n\n  /**\n   * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n   * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n   * `parseI18nMeta()`.\n   *\n   * @param meta The metadata to serialize\n   * @param messagePart The first part of the tagged string\n   */\n  serializeI18nHead(): CookedRawString {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach((legacyId) => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(\n      metaBlock,\n      this.messageParts[0].text,\n      this.getMessagePartSourceSpan(0),\n    );\n  }\n\n  getMessagePartSourceSpan(i: number): ParseSourceSpan | null {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n\n  getPlaceholderSourceSpan(i: number): ParseSourceSpan {\n    return (\n      this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ?? this.sourceSpan\n    );\n  }\n\n  /**\n   * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n   * can be used in a `$localize` tagged string.\n   *\n   * The format is `:<placeholder-name>[@@<associated-id>]:`.\n   *\n   * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n   * refers.\n   *\n   * @param partIndex The index of the message part to serialize.\n   */\n  serializeI18nTemplatePart(partIndex: number): CookedRawString {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR}${computeMsgId(\n        placeholder.associatedMessage.messageString,\n        placeholder.associatedMessage.meaning,\n      )}`;\n    }\n    return createCookedRawString(\n      metaBlock,\n      messagePart.text,\n      this.getMessagePartSourceSpan(partIndex),\n    );\n  }\n}\n\n/**\n * A structure to hold the cooked and raw strings of a template literal element, along with its\n * source-span range.\n */\nexport interface CookedRawString {\n  cooked: string;\n  raw: string;\n  range: ParseSourceSpan | null;\n}\n\nconst escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str: string): string =>\n  str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(\n  metaBlock: string,\n  messagePart: string,\n  range: ParseSourceSpan | null,\n): CookedRawString {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range,\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(\n        `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`,\n      ),\n      range,\n    };\n  }\n}\n\nexport class ExternalExpr extends Expression {\n  constructor(\n    public value: ExternalReference,\n    type?: Type | null,\n    public typeParams: Type[] | null = null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ExternalExpr &&\n      this.value.name === e.value.name &&\n      this.value.moduleName === e.value.moduleName\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitExternalExpr(this, context);\n  }\n\n  override clone(): ExternalExpr {\n    return new ExternalExpr(this.value, this.type, this.typeParams, this.sourceSpan);\n  }\n}\n\nexport class ExternalReference {\n  constructor(\n    public moduleName: string | null,\n    public name: string | null,\n  ) {}\n  // Note: no isEquivalent method here as we use this as an interface too.\n}\n\nexport class ConditionalExpr extends Expression {\n  public trueCase: Expression;\n\n  constructor(\n    public condition: Expression,\n    trueCase: Expression,\n    public falseCase: Expression | null = null,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type || trueCase.type, sourceSpan);\n    this.trueCase = trueCase;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ConditionalExpr &&\n      this.condition.isEquivalent(e.condition) &&\n      this.trueCase.isEquivalent(e.trueCase) &&\n      nullSafeIsEquivalent(this.falseCase, e.falseCase)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitConditionalExpr(this, context);\n  }\n\n  override clone(): ConditionalExpr {\n    return new ConditionalExpr(\n      this.condition.clone(),\n      this.trueCase.clone(),\n      this.falseCase?.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class DynamicImportExpr extends Expression {\n  constructor(\n    public url: string | Expression,\n    sourceSpan?: ParseSourceSpan | null,\n    public urlComment?: string,\n  ) {\n    super(null, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof DynamicImportExpr && this.url === e.url && this.urlComment === e.urlComment;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitDynamicImportExpr(this, context);\n  }\n\n  override clone(): DynamicImportExpr {\n    return new DynamicImportExpr(\n      typeof this.url === 'string' ? this.url : this.url.clone(),\n      this.sourceSpan,\n      this.urlComment,\n    );\n  }\n}\n\nexport class NotExpr extends Expression {\n  constructor(\n    public condition: Expression,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(BOOL_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitNotExpr(this, context);\n  }\n\n  override clone(): NotExpr {\n    return new NotExpr(this.condition.clone(), this.sourceSpan);\n  }\n}\n\nexport class FnParam {\n  constructor(\n    public name: string,\n    public type: Type | null = null,\n  ) {}\n\n  isEquivalent(param: FnParam): boolean {\n    return this.name === param.name;\n  }\n\n  clone(): FnParam {\n    return new FnParam(this.name, this.type);\n  }\n}\n\nexport class FunctionExpr extends Expression {\n  constructor(\n    public params: FnParam[],\n    public statements: Statement[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public name?: string | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression | Statement): boolean {\n    return (\n      (e instanceof FunctionExpr || e instanceof DeclareFunctionStmt) &&\n      areAllEquivalent(this.params, e.params) &&\n      areAllEquivalent(this.statements, e.statements)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitFunctionExpr(this, context);\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareFunctionStmt {\n    return new DeclareFunctionStmt(\n      name,\n      this.params,\n      this.statements,\n      this.type,\n      modifiers,\n      this.sourceSpan,\n    );\n  }\n\n  override clone(): FunctionExpr {\n    // TODO: Should we deep clone statements?\n    return new FunctionExpr(\n      this.params.map((p) => p.clone()),\n      this.statements,\n      this.type,\n      this.sourceSpan,\n      this.name,\n    );\n  }\n}\n\nexport class ArrowFunctionExpr extends Expression {\n  // Note that `body: Expression` represents `() => expr` whereas\n  // `body: Statement[]` represents `() => { expr }`.\n\n  constructor(\n    public params: FnParam[],\n    public body: Expression | Statement[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    if (!(e instanceof ArrowFunctionExpr) || !areAllEquivalent(this.params, e.params)) {\n      return false;\n    }\n\n    if (this.body instanceof Expression && e.body instanceof Expression) {\n      return this.body.isEquivalent(e.body);\n    }\n\n    if (Array.isArray(this.body) && Array.isArray(e.body)) {\n      return areAllEquivalent(this.body, e.body);\n    }\n\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitArrowFunctionExpr(this, context);\n  }\n\n  override clone(): Expression {\n    // TODO: Should we deep clone statements?\n    return new ArrowFunctionExpr(\n      this.params.map((p) => p.clone()),\n      Array.isArray(this.body) ? this.body : this.body.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareVarStmt {\n    return new DeclareVarStmt(name, this, INFERRED_TYPE, modifiers, this.sourceSpan);\n  }\n}\n\nexport class UnaryOperatorExpr extends Expression {\n  constructor(\n    public operator: UnaryOperator,\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public parens: boolean = true,\n  ) {\n    super(type || NUMBER_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof UnaryOperatorExpr &&\n      this.operator === e.operator &&\n      this.expr.isEquivalent(e.expr)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n\n  override clone(): UnaryOperatorExpr {\n    return new UnaryOperatorExpr(\n      this.operator,\n      this.expr.clone(),\n      this.type,\n      this.sourceSpan,\n      this.parens,\n    );\n  }\n}\n\nexport class ParenthesizedExpr extends Expression {\n  constructor(\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitParenthesizedExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    // TODO: should this ignore paren depth? i.e. is `(1)` equivalent to `1`?\n    return e instanceof ParenthesizedExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): ParenthesizedExpr {\n    return new ParenthesizedExpr(this.expr.clone());\n  }\n}\n\nexport class BinaryOperatorExpr extends Expression {\n  public lhs: Expression;\n  constructor(\n    public operator: BinaryOperator,\n    lhs: Expression,\n    public rhs: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type || lhs.type, sourceSpan);\n    this.lhs = lhs;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof BinaryOperatorExpr &&\n      this.operator === e.operator &&\n      this.lhs.isEquivalent(e.lhs) &&\n      this.rhs.isEquivalent(e.rhs)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n\n  override clone(): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(\n      this.operator,\n      this.lhs.clone(),\n      this.rhs.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n\n  isAssignment(): boolean {\n    const op = this.operator;\n    return (\n      op === BinaryOperator.Assign ||\n      op === BinaryOperator.AdditionAssignment ||\n      op === BinaryOperator.SubtractionAssignment ||\n      op === BinaryOperator.MultiplicationAssignment ||\n      op === BinaryOperator.DivisionAssignment ||\n      op === BinaryOperator.RemainderAssignment ||\n      op === BinaryOperator.ExponentiationAssignment ||\n      op === BinaryOperator.AndAssignment ||\n      op === BinaryOperator.OrAssignment ||\n      op === BinaryOperator.NullishCoalesceAssignment\n    );\n  }\n}\n\nexport class ReadPropExpr extends Expression {\n  constructor(\n    public receiver: Expression,\n    public name: string,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  // An alias for name, which allows other logic to handle property reads and keyed reads together.\n  get index() {\n    return this.name;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadPropExpr(this, context);\n  }\n\n  set(value: Expression): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(\n      BinaryOperator.Assign,\n      this.receiver.prop(this.name),\n      value,\n      null,\n      this.sourceSpan,\n    );\n  }\n\n  override clone(): ReadPropExpr {\n    return new ReadPropExpr(this.receiver.clone(), this.name, this.type, this.sourceSpan);\n  }\n}\n\nexport class ReadKeyExpr extends Expression {\n  constructor(\n    public receiver: Expression,\n    public index: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ReadKeyExpr &&\n      this.receiver.isEquivalent(e.receiver) &&\n      this.index.isEquivalent(e.index)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n\n  set(value: Expression): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(\n      BinaryOperator.Assign,\n      this.receiver.key(this.index),\n      value,\n      null,\n      this.sourceSpan,\n    );\n  }\n\n  override clone(): ReadKeyExpr {\n    return new ReadKeyExpr(this.receiver.clone(), this.index.clone(), this.type, this.sourceSpan);\n  }\n}\n\nexport class LiteralArrayExpr extends Expression {\n  public entries: Expression[];\n  constructor(entries: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n\n  override isConstant() {\n    return this.entries.every((e) => e.isConstant());\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n\n  override clone(): LiteralArrayExpr {\n    return new LiteralArrayExpr(\n      this.entries.map((e) => e.clone()),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class LiteralMapEntry {\n  constructor(\n    public key: string,\n    public value: Expression,\n    public quoted: boolean,\n  ) {}\n  isEquivalent(e: LiteralMapEntry): boolean {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n\n  clone(): LiteralMapEntry {\n    return new LiteralMapEntry(this.key, this.value.clone(), this.quoted);\n  }\n}\n\nexport class LiteralMapExpr extends Expression {\n  public valueType: Type | null = null;\n  constructor(\n    public entries: LiteralMapEntry[],\n    type?: MapType | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n\n  override isConstant() {\n    return this.entries.every((e) => e.value.isConstant());\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n\n  override clone(): LiteralMapExpr {\n    const entriesClone = this.entries.map((entry) => entry.clone());\n    return new LiteralMapExpr(entriesClone, this.type as MapType | null, this.sourceSpan);\n  }\n}\n\nexport class CommaExpr extends Expression {\n  constructor(\n    public parts: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(parts[parts.length - 1].type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCommaExpr(this, context);\n  }\n\n  override clone(): CommaExpr {\n    return new CommaExpr(this.parts.map((p) => p.clone()));\n  }\n}\n\nexport interface ExpressionVisitor {\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any;\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\n  visitTaggedTemplateLiteralExpr(ast: TaggedTemplateLiteralExpr, context: any): any;\n  visitTemplateLiteralExpr(ast: TemplateLiteralExpr, context: any): any;\n  visitTemplateLiteralElementExpr(ast: TemplateLiteralElementExpr, context: any): any;\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\n  visitLiteralExpr(ast: LiteralExpr, context: any): any;\n  visitLocalizedString(ast: LocalizedString, context: any): any;\n  visitExternalExpr(ast: ExternalExpr, context: any): any;\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any;\n  visitDynamicImportExpr(ast: DynamicImportExpr, context: any): any;\n  visitNotExpr(ast: NotExpr, context: any): any;\n  visitFunctionExpr(ast: FunctionExpr, context: any): any;\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any;\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any;\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\n  visitCommaExpr(ast: CommaExpr, context: any): any;\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\n  visitTypeofExpr(ast: TypeofExpr, context: any): any;\n  visitVoidExpr(ast: VoidExpr, context: any): any;\n  visitArrowFunctionExpr(ast: ArrowFunctionExpr, context: any): any;\n  visitParenthesizedExpr(ast: ParenthesizedExpr, context: any): any;\n  visitRegularExpressionLiteral(ast: RegularExpressionLiteral, context: any): any;\n}\n\nexport const NULL_EXPR = new LiteralExpr(null, null, null);\nexport const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n\n//// Statements\nexport enum StmtModifier {\n  None = 0,\n  Final = 1 << 0,\n  Private = 1 << 1,\n  Exported = 1 << 2,\n  Static = 1 << 3,\n}\n\nexport class LeadingComment {\n  constructor(\n    public text: string,\n    public multiline: boolean,\n    public trailingNewline: boolean,\n  ) {}\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nexport class JSDocComment extends LeadingComment {\n  constructor(public tags: JSDocTag[]) {\n    super('', /* multiline */ true, /* trailingNewline */ true);\n  }\n  override toString(): string {\n    return serializeTags(this.tags);\n  }\n}\n\nexport abstract class Statement {\n  constructor(\n    public modifiers: StmtModifier = StmtModifier.None,\n    public sourceSpan: ParseSourceSpan | null = null,\n    public leadingComments?: LeadingComment[],\n  ) {}\n  /**\n   * Calculates whether this statement produces the same value as the given statement.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(stmt: Statement): boolean;\n\n  abstract visitStatement(visitor: StatementVisitor, context: any): any;\n\n  hasModifier(modifier: StmtModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n\n  addLeadingComment(leadingComment: LeadingComment): void {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\n\nexport class DeclareVarStmt extends Statement {\n  public type: Type | null;\n  constructor(\n    public name: string,\n    public value?: Expression,\n    type?: Type | null,\n    modifiers?: StmtModifier,\n    sourceSpan?: ParseSourceSpan | null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || (value && value.type) || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return (\n      stmt instanceof DeclareVarStmt &&\n      this.name === stmt.name &&\n      (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value)\n    );\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\n\nexport class DeclareFunctionStmt extends Statement {\n  public type: Type | null;\n  constructor(\n    public name: string,\n    public params: FnParam[],\n    public statements: Statement[],\n    type?: Type | null,\n    modifiers?: StmtModifier,\n    sourceSpan?: ParseSourceSpan | null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return (\n      stmt instanceof DeclareFunctionStmt &&\n      areAllEquivalent(this.params, stmt.params) &&\n      areAllEquivalent(this.statements, stmt.statements)\n    );\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\n\nexport class ExpressionStatement extends Statement {\n  constructor(\n    public expr: Expression,\n    sourceSpan?: ParseSourceSpan | null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\n\nexport class ReturnStatement extends Statement {\n  constructor(\n    public value: Expression,\n    sourceSpan: ParseSourceSpan | null = null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\n\nexport class IfStmt extends Statement {\n  constructor(\n    public condition: Expression,\n    public trueCase: Statement[],\n    public falseCase: Statement[] = [],\n    sourceSpan?: ParseSourceSpan | null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return (\n      stmt instanceof IfStmt &&\n      this.condition.isEquivalent(stmt.condition) &&\n      areAllEquivalent(this.trueCase, stmt.trueCase) &&\n      areAllEquivalent(this.falseCase, stmt.falseCase)\n    );\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitIfStmt(this, context);\n  }\n}\n\nexport interface StatementVisitor {\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\n  visitReturnStmt(stmt: ReturnStatement, context: any): any;\n  visitIfStmt(stmt: IfStmt, context: any): any;\n}\n\nexport class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\n  visitType(ast: Type, context: any): any {\n    return ast;\n  }\n  visitExpression(ast: Expression, context: any): any {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type: BuiltinType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type: ExpressionType, context: any): any {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach((param) => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type: ArrayType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitMapType(type: MapType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitTransplantedType(type: TransplantedType<unknown>, context: any): any {\n    return type;\n  }\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n    return ast;\n  }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitDynamicImportExpr(ast: DynamicImportExpr, context: any) {\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateLiteralExpr(ast: TaggedTemplateLiteralExpr, context: any): any {\n    ast.tag.visitExpression(this, context);\n    ast.template.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitRegularExpressionLiteral(ast: RegularExpressionLiteral, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    if (ast.typeParams) {\n      ast.typeParams.forEach((type) => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase!.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast: NotExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitArrowFunctionExpr(ast: ArrowFunctionExpr, context: any): any {\n    if (Array.isArray(ast.body)) {\n      this.visitAllStatements(ast.body, context);\n    } else {\n      // Note: `body.visitExpression`, rather than `this.visitExpressiont(body)`,\n      // because the latter won't recurse into the sub-expressions.\n      ast.body.visitExpression(this, context);\n    }\n\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTypeofExpr(ast: TypeofExpr, context: any): any {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitVoidExpr(ast: VoidExpr, context: any) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralExpr(ast: TemplateLiteralExpr, context: any) {\n    this.visitAllExpressions(ast.elements, context);\n    this.visitAllExpressions(ast.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralElementExpr(ast: TemplateLiteralElementExpr, context: any) {\n    return this.visitExpression(ast, context);\n  }\n  visitParenthesizedExpr(ast: ParenthesizedExpr, context: any) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs: Expression[], context: any): void {\n    exprs.forEach((expr) => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitAllStatements(stmts: Statement[], context: any): void {\n    stmts.forEach((stmt) => stmt.visitStatement(this, context));\n  }\n}\n\nexport function leadingComment(\n  text: string,\n  multiline: boolean = false,\n  trailingNewline: boolean = true,\n): LeadingComment {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\n\nexport function jsDocComment(tags: JSDocTag[] = []): JSDocComment {\n  return new JSDocComment(tags);\n}\n\nexport function variable(\n  name: string,\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n): ReadVarExpr {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nexport function importExpr(\n  id: ExternalReference,\n  typeParams: Type[] | null = null,\n  sourceSpan?: ParseSourceSpan | null,\n): ExternalExpr {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nexport function importType(\n  id: ExternalReference,\n  typeParams?: Type[] | null,\n  typeModifiers?: TypeModifier,\n): ExpressionType | null {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nexport function expressionType(\n  expr: Expression,\n  typeModifiers?: TypeModifier,\n  typeParams?: Type[] | null,\n): ExpressionType {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nexport function transplantedType<T>(type: T, typeModifiers?: TypeModifier): TransplantedType<T> {\n  return new TransplantedType(type, typeModifiers);\n}\n\nexport function typeofExpr(expr: Expression) {\n  return new TypeofExpr(expr);\n}\n\nexport function literalArr(\n  values: Expression[],\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n): LiteralArrayExpr {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nexport function literalMap(\n  values: {key: string; quoted: boolean; value: Expression}[],\n  type: MapType | null = null,\n): LiteralMapExpr {\n  return new LiteralMapExpr(\n    values.map((e) => new LiteralMapEntry(e.key, e.value, e.quoted)),\n    type,\n    null,\n  );\n}\n\nexport function unary(\n  operator: UnaryOperator,\n  expr: Expression,\n  type?: Type,\n  sourceSpan?: ParseSourceSpan | null,\n): UnaryOperatorExpr {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\n\nexport function not(expr: Expression, sourceSpan?: ParseSourceSpan | null): NotExpr {\n  return new NotExpr(expr, sourceSpan);\n}\n\nexport function fn(\n  params: FnParam[],\n  body: Statement[],\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n  name?: string | null,\n): FunctionExpr {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nexport function arrowFn(\n  params: FnParam[],\n  body: Expression | Statement[],\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n) {\n  return new ArrowFunctionExpr(params, body, type, sourceSpan);\n}\n\nexport function ifStmt(\n  condition: Expression,\n  thenClause: Statement[],\n  elseClause?: Statement[],\n  sourceSpan?: ParseSourceSpan,\n  leadingComments?: LeadingComment[],\n) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\n\nexport function taggedTemplate(\n  tag: Expression,\n  template: TemplateLiteralExpr,\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n): TaggedTemplateLiteralExpr {\n  return new TaggedTemplateLiteralExpr(tag, template, type, sourceSpan);\n}\n\nexport function literal(\n  value: any,\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n): LiteralExpr {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nexport function localizedString(\n  metaBlock: I18nMeta,\n  messageParts: LiteralPiece[],\n  placeholderNames: PlaceholderPiece[],\n  expressions: Expression[],\n  sourceSpan?: ParseSourceSpan | null,\n): LocalizedString {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nexport function isNull(exp: Expression): boolean {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n\n// The list of JSDoc tags that we currently support. Extend it if needed.\nexport const enum JSDocTagName {\n  Desc = 'desc',\n  Id = 'id',\n  Meaning = 'meaning',\n  Suppress = 'suppress',\n}\n\n/*\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier. See e.g. `ts.JSDocTag` and `ts.JSDocComment`.\n */\nexport type JSDocTag =\n  | {\n      // `tagName` is e.g. \"param\" in an `@param` declaration\n      tagName: JSDocTagName | string;\n      // Any remaining text on the tag, e.g. the description\n      text?: string;\n    }\n  | {\n      // no `tagName` for plain text documentation that occurs before any `@param` lines\n      tagName?: undefined;\n      text: string;\n    };\n\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag: JSDocTag): string {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\n\nfunction serializeTags(tags: JSDocTag[]): string {\n  if (tags.length === 0) return '';\n\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n    return `*${tagToString(tags[0])} `;\n  }\n\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\n"]}