{"version":3,"file":"output_jit_trusted_types.js","sourceRoot":"","sources":["output_jit_trusted_types.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH;;;;;;;;GAQG;AAEH,OAAO,EAAC,MAAM,EAAC,MAAM,SAAS,CAAC;AAqC/B;;;GAGG;AACH,IAAI,MAA4C,CAAC;AAEjD;;;GAGG;AACH,SAAS,SAAS;IAChB,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;QACzB,MAAM,YAAY,GAAG,MAAM,CAAC,cAAc,CAAyC,CAAC;QACpF,MAAM,GAAG,IAAI,CAAC;QAEd,IAAI,YAAY,EAAE,CAAC;YACjB,IAAI,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,YAAY,CAAC,oBAAoB,EAAE;oBACvD,YAAY,EAAE,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC;iBAC/B,CAAC,CAAC;YACL,CAAC;YAAC,MAAM,CAAC;gBACP,iEAAiE;gBACjE,uEAAuE;gBACvE,sEAAsE;gBACtE,mDAAmD;YACrD,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;;GAMG;AACH,SAAS,uBAAuB,CAAC,MAAc;IAC7C,OAAO,SAAS,EAAE,EAAE,YAAY,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC;AACrD,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,wBAAwB,CAAC,GAAG,IAAc;IACxD,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE,CAAC;QAC5B,0EAA0E;QAC1E,kCAAkC;QAClC,OAAO,IAAI,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAC;IAC/B,CAAC;IAED,0EAA0E;IAC1E,4EAA4E;IAC5E,oDAAoD;IACpD,6FAA6F;IAC7F,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC3C,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACrC,MAAM,IAAI,GAAG,uBAAuB,MAAM;MACtC,MAAM;GACT,CAAC;IAEF,0EAA0E;IAC1E,yEAAyE;IACzE,0BAA0B;IAC1B,MAAM,EAAE,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,uBAAuB,CAAC,IAAI,CAAW,CAAa,CAAC;IAC/E,IAAI,EAAE,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;QAC1B,4EAA4E;QAC5E,sEAAsE;QACtE,qEAAqE;QACrE,kBAAkB;QAClB,OAAO,IAAI,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAC;IAC/B,CAAC;IAED,uEAAuE;IACvE,yBAAyB;IACzB,uEAAuE;IACvE,EAAE,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC;IACzB,0EAA0E;IAC1E,OAAO,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAEvB,2EAA2E;IAC3E,4DAA4D;IAC5D,qEAAqE;AACvE,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy within the JIT\n * compiler. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../util';\n\n/**\n * While Angular only uses Trusted Types internally for the time being,\n * references to Trusted Types could leak into our core.d.ts, which would force\n * anyone compiling against @angular/core to provide the @types/trusted-types\n * package in their compilation unit.\n *\n * Until https://github.com/microsoft/TypeScript/issues/30024 is resolved, we\n * will keep Angular's public API surface free of references to Trusted Types.\n * For internal and semi-private APIs that need to reference Trusted Types, the\n * minimal type definitions for the Trusted Types API provided by this module\n * should be used instead. They are marked as \"declare\" to prevent them from\n * being renamed by compiler optimization.\n *\n * Adapted from\n * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/trusted-types/index.d.ts\n * but restricted to the API surface used within Angular.\n */\n\nexport declare interface TrustedScript {\n  __brand__: 'TrustedScript';\n}\n\nexport declare interface TrustedTypePolicyFactory {\n  createPolicy(\n    policyName: string,\n    policyOptions: {\n      createScript?: (input: string) => string;\n    },\n  ): TrustedTypePolicy;\n}\n\nexport declare interface TrustedTypePolicy {\n  createScript(input: string): TrustedScript;\n}\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy | null | undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy | null {\n  if (policy === undefined) {\n    const trustedTypes = global['trustedTypes'] as TrustedTypePolicyFactory | undefined;\n    policy = null;\n\n    if (trustedTypes) {\n      try {\n        policy = trustedTypes.createPolicy('angular#unsafe-jit', {\n          createScript: (s: string) => s,\n        });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script: string): TrustedScript | string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nexport function newTrustedFunctionForJIT(...args: string[]): Function {\n  if (!global['trustedTypes']) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(global);\n\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n"]}