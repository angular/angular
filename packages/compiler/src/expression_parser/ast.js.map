{"version":3,"file":"ast.js","sourceRoot":"","sources":["ast.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../core';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\n\nexport class ParseSpan {\n  constructor(\n    public start: number,\n    public end: number,\n  ) {}\n  toAbsolute(absoluteOffset: number): AbsoluteSourceSpan {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\n\nexport abstract class AST {\n  constructor(\n    public span: ParseSpan,\n    /**\n     * Absolute location of the expression AST in a source code file.\n     */\n    public sourceSpan: AbsoluteSourceSpan,\n  ) {}\n\n  abstract visit(visitor: AstVisitor, context?: any): any;\n\n  toString(): string {\n    return 'AST';\n  }\n}\n\nexport abstract class ASTWithName extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public nameSpan: AbsoluteSourceSpan,\n  ) {\n    super(span, sourceSpan);\n  }\n}\n\nexport class EmptyExpr extends AST {\n  override visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nexport class ThisReceiver extends ImplicitReceiver {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expressions: any[],\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public condition: AST,\n    public trueExp: AST,\n    public falseExp: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends ASTWithName {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    nameSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public name: string,\n  ) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class SafePropertyRead extends ASTWithName {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    nameSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public name: string,\n  ) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public key: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class SafeKeyedRead extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public key: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeKeyedRead(this, context);\n  }\n}\n\n/** Possible types for a pipe. */\nexport enum BindingPipeType {\n  /**\n   * Pipe is being referenced by its name, for example:\n   * `@Pipe({name: 'foo'}) class FooPipe` and `{{123 | foo}}`.\n   */\n  ReferencedByName,\n\n  /**\n   * Pipe is being referenced by its class name, for example:\n   * `@Pipe() class FooPipe` and `{{123 | FooPipe}}`.\n   */\n  ReferencedDirectly,\n}\n\nexport class BindingPipe extends ASTWithName {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public exp: AST,\n    public name: string,\n    public args: any[],\n    readonly type: BindingPipeType,\n    nameSpan: AbsoluteSourceSpan,\n  ) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public value: any,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expressions: any[],\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport type LiteralMapKey = {\n  key: string;\n  quoted: boolean;\n  isShorthandInitialized?: boolean;\n};\n\nexport class LiteralMap extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public keys: LiteralMapKey[],\n    public values: any[],\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public strings: string[],\n    public expressions: AST[],\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public operation: string,\n    public left: AST,\n    public right: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n\n  static isAssignmentOperation(op: string): boolean {\n    return (\n      op === '=' ||\n      op === '+=' ||\n      op === '-=' ||\n      op === '*=' ||\n      op === '/=' ||\n      op === '%=' ||\n      op === '**=' ||\n      op === '&&=' ||\n      op === '||=' ||\n      op === '??='\n    );\n  }\n}\n\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nexport class Unary extends Binary {\n  // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n  // depend on these fields when operating on `Unary`.\n  override left: never = null as never;\n  override right: never = null as never;\n  override operation: never = null as never;\n\n  /**\n   * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n   */\n  static createMinus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n      span,\n      sourceSpan,\n      '-',\n      expr,\n      '-',\n      new LiteralPrimitive(span, sourceSpan, 0),\n      expr,\n    );\n  }\n\n  /**\n   * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n   */\n  static createPlus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n      span,\n      sourceSpan,\n      '+',\n      expr,\n      '-',\n      expr,\n      new LiteralPrimitive(span, sourceSpan, 0),\n    );\n  }\n\n  /**\n   * During the deprecation period this constructor is private, to avoid consumers from creating\n   * a `Unary` with the fallback properties for `Binary`.\n   */\n  private constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public operator: string,\n    public expr: AST,\n    binaryOp: string,\n    binaryLeft: AST,\n    binaryRight: AST,\n  ) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n  }\n\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class TypeofExpression extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitTypeofExpression(this, context);\n  }\n}\n\nexport class VoidExpression extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitVoidExpression(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class Call extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public args: AST[],\n    public argumentSpan: AbsoluteSourceSpan,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitCall(this, context);\n  }\n}\n\nexport class SafeCall extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public args: AST[],\n    public argumentSpan: AbsoluteSourceSpan,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeCall(this, context);\n  }\n}\n\nexport class TaggedTemplateLiteral extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public tag: AST,\n    public template: TemplateLiteral,\n  ) {\n    super(span, sourceSpan);\n  }\n\n  override visit(visitor: AstVisitor, context?: any) {\n    return visitor.visitTaggedTemplateLiteral(this, context);\n  }\n}\n\nexport class TemplateLiteral extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public elements: TemplateLiteralElement[],\n    public expressions: AST[],\n  ) {\n    super(span, sourceSpan);\n  }\n\n  override visit(visitor: AstVisitor, context?: any) {\n    return visitor.visitTemplateLiteral(this, context);\n  }\n}\n\nexport class TemplateLiteralElement extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public text: string,\n  ) {\n    super(span, sourceSpan);\n  }\n\n  override visit(visitor: AstVisitor, context?: any) {\n    return visitor.visitTemplateLiteralElement(this, context);\n  }\n}\n\nexport class ParenthesizedExpression extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n\n  override visit(visitor: AstVisitor, context?: any) {\n    return visitor.visitParenthesizedExpression(this, context);\n  }\n}\n\nexport class RegularExpressionLiteral extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    readonly body: string,\n    readonly flags: string | null,\n  ) {\n    super(span, sourceSpan);\n  }\n\n  override visit(visitor: AstVisitor, context?: any) {\n    return visitor.visitRegularExpressionLiteral(this, context);\n  }\n}\n\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nexport class AbsoluteSourceSpan {\n  constructor(\n    public readonly start: number,\n    public readonly end: number,\n  ) {}\n}\n\nexport class ASTWithSource<T extends AST = AST> extends AST {\n  constructor(\n    public ast: T,\n    public source: string | null,\n    public location: string,\n    absoluteOffset: number,\n    public errors: ParseError[],\n  ) {\n    super(\n      new ParseSpan(0, source === null ? 0 : source.length),\n      new AbsoluteSourceSpan(\n        absoluteOffset,\n        source === null ? absoluteOffset : absoluteOffset + source.length,\n      ),\n    );\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  override toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\n/**\n * TemplateBinding refers to a particular key-value pair in a microsyntax\n * expression. A few examples are:\n *\n *   |---------------------|--------------|---------|--------------|\n *   |     expression      |     key      |  value  | binding type |\n *   |---------------------|--------------|---------|--------------|\n *   | 1. let item         |    item      |  null   |   variable   |\n *   | 2. of items         |   ngForOf    |  items  |  expression  |\n *   | 3. let x = y        |      x       |    y    |   variable   |\n *   | 4. index as i       |      i       |  index  |   variable   |\n *   | 5. trackBy: func    | ngForTrackBy |   func  |  expression  |\n *   | 6. *ngIf=\"cond\"     |     ngIf     |   cond  |  expression  |\n *   |---------------------|--------------|---------|--------------|\n *\n * (6) is a notable exception because it is a binding from the template key in\n * the LHS of a HTML attribute to the expression in the RHS. All other bindings\n * in the example above are derived solely from the RHS.\n */\nexport type TemplateBinding = VariableBinding | ExpressionBinding;\n\nexport class VariableBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key name of the LHS along with its span.\n   * @param value optional value for the RHS along with its span.\n   */\n  constructor(\n    public readonly sourceSpan: AbsoluteSourceSpan,\n    public readonly key: TemplateBindingIdentifier,\n    public readonly value: TemplateBindingIdentifier | null,\n  ) {}\n}\n\nexport class ExpressionBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n   * span. Note that the length of the span may not be the same as\n   * `key.source.length`. For example,\n   * 1. key.source = ngFor, key.span is for \"ngFor\"\n   * 2. key.source = ngForOf, key.span is for \"of\"\n   * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n   * @param value optional expression for the RHS.\n   */\n  constructor(\n    public readonly sourceSpan: AbsoluteSourceSpan,\n    public readonly key: TemplateBindingIdentifier,\n    public readonly value: ASTWithSource | null,\n  ) {}\n}\n\nexport interface TemplateBindingIdentifier {\n  source: string;\n  span: AbsoluteSourceSpan;\n}\n\nexport interface AstVisitor {\n  /**\n   * The `visitUnary` method is declared as optional for backwards compatibility. In an upcoming\n   * major release, this method will be made required.\n   */\n  visitUnary?(ast: Unary, context: any): any;\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  /**\n   * The `visitThisReceiver` method is declared as optional for backwards compatibility.\n   * In an upcoming major release, this method will be made required.\n   */\n  visitThisReceiver?(ast: ThisReceiver, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitTypeofExpression(ast: TypeofExpression, context: any): any;\n  visitVoidExpression(ast: TypeofExpression, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any;\n  visitCall(ast: Call, context: any): any;\n  visitSafeCall(ast: SafeCall, context: any): any;\n  visitTemplateLiteral(ast: TemplateLiteral, context: any): any;\n  visitTemplateLiteralElement(ast: TemplateLiteralElement, context: any): any;\n  visitTaggedTemplateLiteral(ast: TaggedTemplateLiteral, context: any): any;\n  visitParenthesizedExpression(ast: ParenthesizedExpression, context: any): any;\n  visitRegularExpressionLiteral(ast: RegularExpressionLiteral, context: any): any;\n  visitASTWithSource?(ast: ASTWithSource, context: any): any;\n  /**\n   * This function is optionally defined to allow classes that implement this\n   * interface to selectively decide if the specified `ast` should be visited.\n   * @param ast node to visit\n   * @param context context that gets passed to the node and all its children\n   */\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visit(ast: AST, context?: any): any {\n    // The default implementation just visits every node.\n    // Classes that extend RecursiveAstVisitor should override this function\n    // to selectively visit the specified node.\n    ast.visit(this, context);\n  }\n  visitUnary(ast: Unary, context: any): any {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast: Binary, context: any): any {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast: Chain, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast: ThisReceiver, context: any): any {}\n  visitThisReceiver(ast: ThisReceiver, context: any): any {}\n  visitInterpolation(ast: Interpolation, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {}\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitTypeofExpression(ast: TypeofExpression, context: any) {\n    this.visit(ast.expression, context);\n  }\n  visitVoidExpression(ast: VoidExpression, context: any) {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitCall(ast: Call, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitSafeCall(ast: SafeCall, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitTemplateLiteral(ast: TemplateLiteral, context: any) {\n    // Iterate in the declaration order. Note that there will\n    // always be one expression less than the number of elements.\n    for (let i = 0; i < ast.elements.length; i++) {\n      this.visit(ast.elements[i], context);\n\n      const expression = i < ast.expressions.length ? ast.expressions[i] : null;\n      if (expression !== null) {\n        this.visit(expression, context);\n      }\n    }\n  }\n  visitTemplateLiteralElement(ast: TemplateLiteralElement, context: any) {}\n  visitTaggedTemplateLiteral(ast: TaggedTemplateLiteral, context: any) {\n    this.visit(ast.tag, context);\n    this.visit(ast.template, context);\n  }\n  visitParenthesizedExpression(ast: ParenthesizedExpression, context: any) {\n    this.visit(ast.expression, context);\n  }\n  visitRegularExpressionLiteral(ast: RegularExpressionLiteral, context: any) {}\n  // This is not part of the AstVisitor interface, just a helper method\n  visitAll(asts: AST[], context: any): any {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\n\n// Bindings\n\nexport class ParsedProperty {\n  public readonly isLiteral: boolean;\n  public readonly isLegacyAnimation: boolean;\n  public readonly isAnimation: boolean;\n\n  constructor(\n    public name: string,\n    public expression: ASTWithSource,\n    public type: ParsedPropertyType,\n    public sourceSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan,\n    public valueSpan: ParseSourceSpan | undefined,\n  ) {\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isLegacyAnimation = this.type === ParsedPropertyType.LEGACY_ANIMATION;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\n\nexport enum ParsedPropertyType {\n  DEFAULT,\n  LITERAL_ATTR,\n  LEGACY_ANIMATION,\n  TWO_WAY,\n  ANIMATION,\n}\n\nexport enum ParsedEventType {\n  // DOM or Directive event\n  Regular,\n  // Legacy animation specific event\n  LegacyAnimation,\n  // Event side of a two-way binding (e.g. `[(property)]=\"expression\"`).\n  TwoWay,\n  // Animation specific event\n  Animation,\n}\n\nexport class ParsedEvent {\n  // Regular events have a target\n  // Legacy Animation events have a phase\n  constructor(\n    name: string,\n    targetOrPhase: string | null,\n    type: ParsedEventType.TwoWay,\n    handler: ASTWithSource<NonNullAssert | PropertyRead | KeyedRead>,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n  );\n\n  constructor(\n    name: string,\n    targetOrPhase: string | null,\n    type: ParsedEventType,\n    handler: ASTWithSource,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n  );\n\n  constructor(\n    public name: string,\n    public targetOrPhase: string | null,\n    public type: ParsedEventType,\n    public handler: ASTWithSource,\n    public sourceSpan: ParseSourceSpan,\n    public handlerSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan,\n  ) {}\n}\n\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nexport class ParsedVariable {\n  constructor(\n    public readonly name: string,\n    public readonly value: string,\n    public readonly sourceSpan: ParseSourceSpan,\n    public readonly keySpan: ParseSourceSpan,\n    public readonly valueSpan?: ParseSourceSpan,\n  ) {}\n}\n\nexport enum BindingType {\n  // A regular binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to a legacy animation reference (e.g. `[animate.key]=\"expression\"`).\n  LegacyAnimation,\n  // Property side of a two-way binding (e.g. `[(property)]=\"expression\"`).\n  TwoWay,\n  // A binding to an animation CSS class or function (e.g. `[animate.leave]=\"expression\"`).\n  Animation,\n}\n\nexport class BoundElementProperty {\n  constructor(\n    public name: string,\n    public type: BindingType,\n    public securityContext: SecurityContext,\n    public value: ASTWithSource,\n    public unit: string | null,\n    public sourceSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan | undefined,\n    public valueSpan: ParseSourceSpan | undefined,\n  ) {}\n}\n"]}