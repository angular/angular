{"version":3,"file":"parser.js","sourceRoot":"","sources":["parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as chars from '../chars';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/defaults';\nimport {\n  InterpolatedAttributeToken,\n  InterpolatedTextToken,\n  TokenType as MlParserTokenType,\n} from '../ml_parser/tokens';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\n\nimport {\n  AbsoluteSourceSpan,\n  AST,\n  ASTWithSource,\n  Binary,\n  BindingPipe,\n  BindingPipeType,\n  Call,\n  Chain,\n  Conditional,\n  EmptyExpr,\n  ExpressionBinding,\n  ImplicitReceiver,\n  Interpolation,\n  KeyedRead,\n  LiteralArray,\n  LiteralMap,\n  LiteralMapKey,\n  LiteralPrimitive,\n  NonNullAssert,\n  ParenthesizedExpression,\n  ParseSpan,\n  PrefixNot,\n  PropertyRead,\n  RecursiveAstVisitor,\n  RegularExpressionLiteral,\n  SafeCall,\n  SafeKeyedRead,\n  SafePropertyRead,\n  TaggedTemplateLiteral,\n  TemplateBinding,\n  TemplateBindingIdentifier,\n  TemplateLiteral,\n  TemplateLiteralElement,\n  ThisReceiver,\n  TypeofExpression,\n  Unary,\n  VariableBinding,\n  VoidExpression,\n} from './ast';\nimport {EOF, Lexer, StringTokenKind, Token, TokenType} from './lexer';\nexport interface InterpolationPiece {\n  text: string;\n  start: number;\n  end: number;\n}\nexport class SplitInterpolation {\n  constructor(\n    public strings: InterpolationPiece[],\n    public expressions: InterpolationPiece[],\n    public offsets: number[],\n  ) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n    public templateBindings: TemplateBinding[],\n    public warnings: string[],\n    public errors: ParseError[],\n  ) {}\n}\n\n/**\n * Represents the possible parse modes to be used as a bitmask.\n */\nexport const enum ParseFlags {\n  None = 0,\n\n  /**\n   * Whether an output binding is being parsed.\n   */\n  Action = 1 << 0,\n}\n\nfunction getLocation(span: ParseSourceSpan): string {\n  return span.start.toString() || '(unknown)';\n}\n\nexport class Parser {\n  constructor(\n    private readonly _lexer: Lexer,\n    private readonly _supportsDirectPipeReferences = false,\n  ) {}\n\n  parseAction(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): ASTWithSource {\n    const errors: ParseError[] = [];\n    this._checkNoInterpolation(errors, input, parseSourceSpan, interpolationConfig);\n    const {stripped: sourceToLex} = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast = new _ParseAST(\n      input,\n      parseSourceSpan,\n      absoluteOffset,\n      tokens,\n      ParseFlags.Action,\n      errors,\n      0,\n      this._supportsDirectPipeReferences,\n    ).parseChain();\n\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n\n  parseBinding(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): ASTWithSource {\n    const errors: ParseError[] = [];\n    const ast = this._parseBindingAst(\n      input,\n      parseSourceSpan,\n      absoluteOffset,\n      interpolationConfig,\n      errors,\n    );\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n\n  private checkSimpleExpression(ast: AST): string[] {\n    const checker = new SimpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n\n  // Host bindings parsed here\n  parseSimpleBinding(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): ASTWithSource {\n    const errors: ParseError[] = [];\n    const ast = this._parseBindingAst(\n      input,\n      parseSourceSpan,\n      absoluteOffset,\n      interpolationConfig,\n      errors,\n    );\n    const simplExpressionErrors = this.checkSimpleExpression(ast);\n\n    if (simplExpressionErrors.length > 0) {\n      errors.push(\n        getParseError(\n          `Host binding expression cannot contain ${simplExpressionErrors.join(' ')}`,\n          input,\n          '',\n          parseSourceSpan,\n        ),\n      );\n    }\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n\n  private _parseBindingAst(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolationConfig: InterpolationConfig,\n    errors: ParseError[],\n  ): AST {\n    this._checkNoInterpolation(errors, input, parseSourceSpan, interpolationConfig);\n    const {stripped: sourceToLex} = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(\n      input,\n      parseSourceSpan,\n      absoluteOffset,\n      tokens,\n      ParseFlags.None,\n      errors,\n      0,\n      this._supportsDirectPipeReferences,\n    ).parseChain();\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```html\n   *   <div *ngFor=\"let item of items\">\n   *         ^      ^ absoluteValueOffset for `templateValue`\n   *         absoluteKeyOffset for `templateKey`\n   * ```\n   * contains three bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   *\n   * This is apparent from the de-sugared template:\n   * ```html\n   *   <ng-template ngFor let-item [ngForOf]=\"items\">\n   * ```\n   *\n   * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n   * @param templateValue RHS of the microsyntax attribute\n   * @param templateUrl template filename if it's external, component filename if it's inline\n   * @param absoluteKeyOffset start of the `templateKey`\n   * @param absoluteValueOffset start of the `templateValue`\n   */\n  parseTemplateBindings(\n    templateKey: string,\n    templateValue: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteKeyOffset: number,\n    absoluteValueOffset: number,\n  ): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(templateValue);\n    const errors: ParseError[] = [];\n    const parser = new _ParseAST(\n      templateValue,\n      parseSourceSpan,\n      absoluteValueOffset,\n      tokens,\n      ParseFlags.None,\n      errors,\n      0 /* relative offset */,\n      this._supportsDirectPipeReferences,\n    );\n    return parser.parseTemplateBindings({\n      source: templateKey,\n      span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n    });\n  }\n\n  parseInterpolation(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): ASTWithSource | null {\n    const errors: ParseError[] = [];\n    const {strings, expressions, offsets} = this.splitInterpolation(\n      input,\n      parseSourceSpan,\n      errors,\n      interpolatedTokens,\n      interpolationConfig,\n    );\n    if (expressions.length === 0) return null;\n\n    const expressionNodes: AST[] = [];\n\n    for (let i = 0; i < expressions.length; ++i) {\n      // If we have a token for the specific expression, it's preferrable to use it because it\n      // allows us to produce more accurate error messages. The expressions are always at the odd\n      // indexes inside the tokens.\n      const expressionSpan = interpolatedTokens?.[i * 2 + 1]?.sourceSpan;\n      const expressionText = expressions[i].text;\n      const {stripped: sourceToLex, hasComments} = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n\n      if (hasComments && sourceToLex.trim().length === 0 && tokens.length === 0) {\n        // Empty expressions error are handled futher down, here we only take care of the comment case\n        errors.push(\n          getParseError(\n            'Interpolation expression cannot only contain a comment',\n            input,\n            `at column ${expressions[i].start} in`,\n            parseSourceSpan,\n          ),\n        );\n        continue;\n      }\n\n      const ast = new _ParseAST(\n        expressionSpan ? expressionText : input,\n        expressionSpan || parseSourceSpan,\n        absoluteOffset,\n        tokens,\n        ParseFlags.None,\n        errors,\n        offsets[i],\n        this._supportsDirectPipeReferences,\n      ).parseChain();\n      expressionNodes.push(ast);\n    }\n\n    return this.createInterpolationAst(\n      strings.map((s) => s.text),\n      expressionNodes,\n      input,\n      getLocation(parseSourceSpan),\n      absoluteOffset,\n      errors,\n    );\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(\n    expression: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n  ): ASTWithSource {\n    const {stripped: sourceToLex} = this._stripComments(expression);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const errors: ParseError[] = [];\n    const ast = new _ParseAST(\n      expression,\n      parseSourceSpan,\n      absoluteOffset,\n      tokens,\n      ParseFlags.None,\n      errors,\n      0,\n      this._supportsDirectPipeReferences,\n    ).parseChain();\n    const strings = ['', '']; // The prefix and suffix strings are both empty\n    return this.createInterpolationAst(\n      strings,\n      [ast],\n      expression,\n      getLocation(parseSourceSpan),\n      absoluteOffset,\n      errors,\n    );\n  }\n\n  private createInterpolationAst(\n    strings: string[],\n    expressions: AST[],\n    input: string,\n    location: string,\n    absoluteOffset: number,\n    errors: ParseError[],\n  ): ASTWithSource {\n    const span = new ParseSpan(0, input.length);\n    const interpolation = new Interpolation(\n      span,\n      span.toAbsolute(absoluteOffset),\n      strings,\n      expressions,\n    );\n    return new ASTWithSource(interpolation, input, location, absoluteOffset, errors);\n  }\n\n  /**\n   * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n   * the string.\n   * Returns `null` if there are no interpolations, otherwise a\n   * `SplitInterpolation` with splits that look like\n   *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n   */\n  splitInterpolation(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    errors: ParseError[],\n    interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): SplitInterpolation {\n    const strings: InterpolationPiece[] = [];\n    const expressions: InterpolationPiece[] = [];\n    const offsets: number[] = [];\n    const inputToTemplateIndexMap = interpolatedTokens\n      ? getIndexMapForOriginalTemplate(interpolatedTokens)\n      : null;\n    let i = 0;\n    let atInterpolation = false;\n    let extendLastString = false;\n    let {start: interpStart, end: interpEnd} = interpolationConfig;\n    while (i < input.length) {\n      if (!atInterpolation) {\n        // parse until starting {{\n        const start = i;\n        i = input.indexOf(interpStart, i);\n        if (i === -1) {\n          i = input.length;\n        }\n        const text = input.substring(start, i);\n        strings.push({text, start, end: i});\n\n        atInterpolation = true;\n      } else {\n        // parse from starting {{ to ending }} while ignoring content inside quotes.\n        const fullStart = i;\n        const exprStart = fullStart + interpStart.length;\n        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n        if (exprEnd === -1) {\n          // Could not find the end of the interpolation; do not parse an expression.\n          // Instead we should extend the content on the last raw string.\n          atInterpolation = false;\n          extendLastString = true;\n          break;\n        }\n        const fullEnd = exprEnd + interpEnd.length;\n\n        const text = input.substring(exprStart, exprEnd);\n        if (text.trim().length === 0) {\n          errors.push(\n            getParseError(\n              'Blank expressions are not allowed in interpolated strings',\n              input,\n              `at column ${i} in`,\n              parseSourceSpan,\n            ),\n          );\n        }\n        expressions.push({text, start: fullStart, end: fullEnd});\n        const startInOriginalTemplate = inputToTemplateIndexMap?.get(fullStart) ?? fullStart;\n        const offset = startInOriginalTemplate + interpStart.length;\n        offsets.push(offset);\n\n        i = fullEnd;\n        atInterpolation = false;\n      }\n    }\n    if (!atInterpolation) {\n      // If we are now at a text section, add the remaining content as a raw string.\n      if (extendLastString) {\n        const piece = strings[strings.length - 1];\n        piece.text += input.substring(i);\n        piece.end = input.length;\n      } else {\n        strings.push({text: input.substring(i), start: i, end: input.length});\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(\n    input: string | null,\n    sourceSpanOrLocation: ParseSourceSpan | string,\n    absoluteOffset: number,\n  ): ASTWithSource {\n    const span = new ParseSpan(0, input == null ? 0 : input.length);\n    return new ASTWithSource(\n      new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input),\n      input,\n      typeof sourceSpanOrLocation === 'string'\n        ? sourceSpanOrLocation\n        : getLocation(sourceSpanOrLocation),\n      absoluteOffset,\n      [],\n    );\n  }\n\n  private _stripComments(input: string): {stripped: string; hasComments: boolean} {\n    const i = this._commentStart(input);\n    return i != null\n      ? {stripped: input.substring(0, i), hasComments: true}\n      : {stripped: input, hasComments: false};\n  }\n\n  private _commentStart(input: string): number | null {\n    let outerQuote: number | null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && chars.isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(\n    errors: ParseError[],\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    {start, end}: InterpolationConfig,\n  ): void {\n    let startIndex = -1;\n    let endIndex = -1;\n\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith(start)) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n\n    if (startIndex > -1 && endIndex > -1) {\n      errors.push(\n        getParseError(\n          `Got interpolation (${start}${end}) where expression was expected`,\n          input,\n          `at column ${startIndex} in`,\n          parseSourceSpan,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Finds the index of the end of an interpolation expression\n   * while ignoring comments and quoted content.\n   */\n  private _getInterpolationEndIndex(input: string, expressionEnd: string, start: number): number {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n\n      // Nothing else in the expression matters after we've\n      // hit a comment so look directly for the end token.\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Generator used to iterate over the character indexes of a string that are outside of quotes.\n   * @param input String to loop through.\n   * @param start Index within the string at which to start.\n   */\n  private *_forEachUnquotedChar(input: string, start: number) {\n    let currentQuote: string | null = null;\n    let escapeCount = 0;\n    for (let i = start; i < input.length; i++) {\n      const char = input[i];\n      // Skip the characters inside quotes. Note that we only care about the outer-most\n      // quotes matching up and we need to account for escape characters.\n      if (\n        chars.isQuote(input.charCodeAt(i)) &&\n        (currentQuote === null || currentQuote === char) &&\n        escapeCount % 2 === 0\n      ) {\n        currentQuote = currentQuote === null ? char : null;\n      } else if (currentQuote === null) {\n        yield i;\n      }\n      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n    }\n  }\n}\n\n/** Describes a stateful context an expression parser is in. */\nenum ParseContextFlags {\n  None = 0,\n  /**\n   * A Writable context is one in which a value may be written to an lvalue.\n   * For example, after we see a property access, we may expect a write to the\n   * property via the \"=\" operator.\n   *   prop\n   *        ^ possible \"=\" after\n   */\n  Writable = 1,\n}\n\n/** Possible flags that can be used in a regex literal. */\nconst SUPPORTED_REGEX_FLAGS = new Set(['d', 'g', 'i', 'm', 's', 'u', 'v', 'y']);\n\nclass _ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n  private context = ParseContextFlags.None;\n\n  // Cache of expression start and input indeces to the absolute source span they map to, used to\n  // prevent creating superfluous source spans in `sourceSpan`.\n  // A serial of the expression start and input index is used for mapping because both are stateful\n  // and may change for subsequent expressions visited by the parser.\n  private sourceSpanCache = new Map<string, AbsoluteSourceSpan>();\n\n  private index: number = 0;\n\n  constructor(\n    private input: string,\n    private parseSourceSpan: ParseSourceSpan,\n    private absoluteOffset: number,\n    private tokens: Token[],\n    private parseFlags: ParseFlags,\n    private errors: ParseError[],\n    private offset: number,\n    private supportsDirectPipeReferences: boolean,\n  ) {}\n\n  private peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  private get next(): Token {\n    return this.peek(0);\n  }\n\n  /** Whether all the parser input has been processed. */\n  private get atEOF(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  /**\n   * Index of the next token to be processed, or the end of the last token if all have been\n   * processed.\n   */\n  private get inputIndex(): number {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n\n  /**\n   * End index of the last processed token, or the start of the first token if none have been\n   * processed.\n   */\n  private get currentEndIndex(): number {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    // No tokens have been processed yet; return the next token's start or the length of the input\n    // if there is no token.\n    if (this.tokens.length === 0) {\n      return this.input.length + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n\n  /**\n   * Returns the absolute offset of the start of the current token.\n   */\n  private get currentAbsoluteOffset(): number {\n    return this.absoluteOffset + this.inputIndex;\n  }\n\n  /**\n   * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n   * provided).\n   *\n   * @param start Position from which the `ParseSpan` will start.\n   * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n   *     natural ending index)\n   */\n  private span(start: number, artificialEndIndex?: number): ParseSpan {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n\n    // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n    // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n    // appears to be a deep-seated parser bug.\n    //\n    // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n    // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n    if (start > endIndex) {\n      const tmp = endIndex;\n      endIndex = start;\n      start = tmp;\n    }\n\n    return new ParseSpan(start, endIndex);\n  }\n\n  private sourceSpan(start: number, artificialEndIndex?: number): AbsoluteSourceSpan {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(\n        serial,\n        this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset),\n      );\n    }\n    return this.sourceSpanCache.get(serial)!;\n  }\n\n  private advance() {\n    this.index++;\n  }\n\n  /**\n   * Executes a callback in the provided context.\n   */\n  private withContext<T>(context: ParseContextFlags, cb: () => T): T {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }\n\n  private consumeOptionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n\n  private peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  /**\n   * Consumes an expected character, otherwise emits an error about the missing expected character\n   * and skips over the token stream until reaching a recoverable point.\n   *\n   * See `this.error` and `this.skip` for more details.\n   */\n  private expectCharacter(code: number) {\n    if (this.consumeOptionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  private consumeOptionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private isAssignmentOperator(token: Token): boolean {\n    return token.type === TokenType.Operator && Binary.isAssignmentOperation(token.strValue);\n  }\n\n  private expectOperator(operator: string) {\n    if (this.consumeOptionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  private prettyPrintToken(tok: Token): string {\n    return tok === EOF ? 'end of input' : `token ${tok}`;\n  }\n\n  private expectIdentifierOrKeyword(): string | null {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n      }\n      return null;\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  private expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n      } else {\n        this.error(\n          `Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`,\n        );\n      }\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        if (!(this.parseFlags & ParseFlags.Action)) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.consumeOptionalCharacter(chars.$SEMICOLON)) {} // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        const errorIndex = this.index;\n        this.error(`Unexpected token '${this.next}'`);\n        // The `error` call above will skip ahead to the next recovery point in an attempt to\n        // recover part of the expression, but that might be the token we started from which will\n        // lead to an infinite loop. If that's the case, break the loop assuming that we can't\n        // parse further.\n        if (this.index === errorIndex) {\n          break;\n        }\n      }\n    }\n    if (exprs.length === 0) {\n      // We have no expressions so create an empty expression that spans the entire input length\n      const artificialStart = this.offset;\n      const artificialEnd = this.offset + this.input.length;\n      return new EmptyExpr(\n        this.span(artificialStart, artificialEnd),\n        this.sourceSpan(artificialStart, artificialEnd),\n      );\n    }\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), this.sourceSpan(start), exprs);\n  }\n\n  private parsePipe(): AST {\n    const start = this.inputIndex;\n    let result = this.parseExpression();\n    if (this.consumeOptionalOperator('|')) {\n      if (this.parseFlags & ParseFlags.Action) {\n        this.error(`Cannot have a pipe in an action expression`);\n      }\n\n      do {\n        const nameStart = this.inputIndex;\n        let nameId = this.expectIdentifierOrKeyword();\n        let nameSpan: AbsoluteSourceSpan;\n        let fullSpanEnd: number | undefined = undefined;\n        if (nameId !== null) {\n          nameSpan = this.sourceSpan(nameStart);\n        } else {\n          // No valid identifier was found, so we'll assume an empty pipe name ('').\n          nameId = '';\n\n          // However, there may have been whitespace present between the pipe character and the next\n          // token in the sequence (or the end of input). We want to track this whitespace so that\n          // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n          // whitespace beyond it. Another way of thinking about this is that the zero-length name\n          // is assumed to be at the end of any whitespace beyond the pipe character.\n          //\n          // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n          // beginning of the next token, or until the end of input if the next token is EOF.\n          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n\n          // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n          // beyond the pipe character.\n          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n        }\n\n        const args: AST[] = [];\n        while (this.consumeOptionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n\n          // If there are additional expressions beyond the name, then the artificial end for the\n          // name is no longer relevant.\n        }\n        let type: BindingPipeType;\n        if (this.supportsDirectPipeReferences) {\n          const charCode = nameId.charCodeAt(0);\n          type =\n            charCode === chars.$_ || (charCode >= chars.$A && charCode <= chars.$Z)\n              ? BindingPipeType.ReferencedDirectly\n              : BindingPipeType.ReferencedByName;\n        } else {\n          type = BindingPipeType.ReferencedByName;\n        }\n\n        result = new BindingPipe(\n          this.span(start),\n          this.sourceSpan(start, fullSpanEnd),\n          result,\n          nameId,\n          args,\n          type,\n          nameSpan,\n        );\n      } while (this.consumeOptionalOperator('|'));\n    }\n\n    return result;\n  }\n\n  private parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  private parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.consumeOptionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.consumeOptionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  private parseLogicalOr(): AST {\n    // '||'\n    const start = this.inputIndex;\n    let result = this.parseLogicalAnd();\n    while (this.consumeOptionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n    }\n    return result;\n  }\n\n  private parseLogicalAnd(): AST {\n    // '&&'\n    const start = this.inputIndex;\n    let result = this.parseNullishCoalescing();\n    while (this.consumeOptionalOperator('&&')) {\n      const right = this.parseNullishCoalescing();\n      result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n    }\n    return result;\n  }\n\n  private parseNullishCoalescing(): AST {\n    // '??'\n    const start = this.inputIndex;\n    let result = this.parseEquality();\n    while (this.consumeOptionalOperator('??')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n    }\n    return result;\n  }\n\n  private parseEquality(): AST {\n    // '==','!=','===','!=='\n    const start = this.inputIndex;\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  private parseRelational(): AST {\n    // '<', '>', '<=', '>=', 'in'\n    const start = this.inputIndex;\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator || this.next.isKeywordIn) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'in':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  private parseAdditive(): AST {\n    // '+', '-'\n    const start = this.inputIndex;\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  private parseMultiplicative(): AST {\n    // '*', '%', '/'\n    const start = this.inputIndex;\n    let result = this.parseExponentiation();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          const right = this.parseExponentiation();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  private parseExponentiation(): AST {\n    // '**'\n    const start = this.inputIndex;\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator && this.next.strValue === '**') {\n      // This aligns with Javascript semantics which require any unary operator preceeding the\n      // exponentiation operation to be explicitly grouped as either applying to the base or result\n      // of the exponentiation operation.\n      if (\n        result instanceof Unary ||\n        result instanceof PrefixNot ||\n        result instanceof TypeofExpression ||\n        result instanceof VoidExpression\n      ) {\n        this.error(\n          'Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence',\n        );\n      }\n      this.advance();\n      const right = this.parseExponentiation();\n      result = new Binary(this.span(start), this.sourceSpan(start), '**', result, right);\n    }\n    return result;\n  }\n\n  private parsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n      }\n    } else if (this.next.isKeywordTypeof()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new TypeofExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordVoid()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new VoidExpression(this.span(start), this.sourceSpan(start), result);\n    }\n    return this.parseCallChain();\n  }\n\n  private parseCallChain(): AST {\n    const start = this.inputIndex;\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.consumeOptionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMember(result, start, false);\n      } else if (this.consumeOptionalOperator('?.')) {\n        if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n          result = this.parseCall(result, start, true);\n        } else {\n          result = this.consumeOptionalCharacter(chars.$LBRACKET)\n            ? this.parseKeyedReadOrWrite(result, start, true)\n            : this.parseAccessMember(result, start, true);\n        }\n      } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n        result = this.parseKeyedReadOrWrite(result, start, false);\n      } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n        result = this.parseCall(result, start, false);\n      } else if (this.consumeOptionalOperator('!')) {\n        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n      } else if (this.next.isTemplateLiteralEnd()) {\n        result = this.parseNoInterpolationTaggedTemplateLiteral(result, start);\n      } else if (this.next.isTemplateLiteralPart()) {\n        result = this.parseTaggedTemplateLiteral(result, start);\n      } else {\n        return result;\n      }\n    }\n  }\n\n  private parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      if (!this.consumeOptionalCharacter(chars.$RPAREN)) {\n        this.error('Missing closing parentheses');\n        // Calling into `error` above will attempt to recover up until the next closing paren.\n        // If that's the case, consume it so we can partially recover the expression.\n        this.consumeOptionalCharacter(chars.$RPAREN);\n      }\n      this.rparensExpected--;\n      return new ParenthesizedExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n    } else if (this.next.isKeywordIn()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), 'in');\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ThisReceiver(this.span(start), this.sourceSpan(start));\n    } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMember(\n        new ImplicitReceiver(this.span(start), this.sourceSpan(start)),\n        start,\n        false,\n      );\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n    } else if (this.next.isTemplateLiteralEnd()) {\n      return this.parseNoInterpolationTemplateLiteral();\n    } else if (this.next.isTemplateLiteralPart()) {\n      return this.parseTemplateLiteral();\n    } else if (this.next.isString() && this.next.kind === StringTokenKind.Plain) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n    } else if (this.next.isPrivateIdentifier()) {\n      this._reportErrorForPrivateIdentifier(this.next, null);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    } else if (this.next.isRegExpBody()) {\n      return this.parseRegularExpressionLiteral();\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    }\n  }\n\n  private parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n\n    do {\n      if (!this.next.isCharacter(terminator)) {\n        result.push(this.parsePipe());\n      } else {\n        break;\n      }\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return result;\n  }\n\n  private parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.consumeOptionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const keyStart = this.inputIndex;\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        const literalMapKey: LiteralMapKey = {key, quoted};\n        keys.push(literalMapKey);\n\n        // Properties with quoted keys can't use the shorthand syntax.\n        if (quoted) {\n          this.expectCharacter(chars.$COLON);\n          values.push(this.parsePipe());\n        } else if (this.consumeOptionalCharacter(chars.$COLON)) {\n          values.push(this.parsePipe());\n        } else {\n          literalMapKey.isShorthandInitialized = true;\n\n          const span = this.span(keyStart);\n          const sourceSpan = this.sourceSpan(keyStart);\n          values.push(\n            new PropertyRead(\n              span,\n              sourceSpan,\n              sourceSpan,\n              new ImplicitReceiver(span, sourceSpan),\n              key,\n            ),\n          );\n        }\n      } while (\n        this.consumeOptionalCharacter(chars.$COMMA) &&\n        !this.next.isCharacter(chars.$RBRACE)\n      );\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n  }\n\n  private parseAccessMember(readReceiver: AST, start: number, isSafe: boolean): AST {\n    const nameStart = this.inputIndex;\n    const id = this.withContext(ParseContextFlags.Writable, () => {\n      const id = this.expectIdentifierOrKeyword() ?? '';\n      if (id.length === 0) {\n        this.error(`Expected identifier for property access`, readReceiver.span.end);\n      }\n      return id;\n    });\n    const nameSpan = this.sourceSpan(nameStart);\n\n    if (isSafe) {\n      if (this.isAssignmentOperator(this.next)) {\n        this.advance();\n        this.error(\"The '?.' operator cannot be used in the assignment\");\n        return new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        return new SafePropertyRead(\n          this.span(start),\n          this.sourceSpan(start),\n          nameSpan,\n          readReceiver,\n          id,\n        );\n      }\n    } else {\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n\n        if (!(this.parseFlags & ParseFlags.Action)) {\n          this.advance();\n          this.error('Bindings cannot contain assignments');\n          return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n        const receiver = new PropertyRead(\n          this.span(start),\n          this.sourceSpan(start),\n          nameSpan,\n          readReceiver,\n          id,\n        );\n        this.advance();\n        const value = this.parseConditional();\n        return new Binary(this.span(start), this.sourceSpan(start), operation, receiver, value);\n      } else {\n        return new PropertyRead(\n          this.span(start),\n          this.sourceSpan(start),\n          nameSpan,\n          readReceiver,\n          id,\n        );\n      }\n    }\n  }\n\n  private parseCall(receiver: AST, start: number, isSafe: boolean): AST {\n    const argumentStart = this.inputIndex;\n    this.rparensExpected++;\n    const args = this.parseCallArguments();\n    const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n    this.expectCharacter(chars.$RPAREN);\n    this.rparensExpected--;\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return isSafe\n      ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan)\n      : new Call(span, sourceSpan, receiver, args, argumentSpan);\n  }\n\n  private parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * Parses an identifier, a keyword, a string with an optional `-` in between,\n   * and returns the string along with its absolute source span.\n   */\n  private expectTemplateBindingKey(): TemplateBindingIdentifier {\n    let result = '';\n    let operatorFound = false;\n    const start = this.currentAbsoluteOffset;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.consumeOptionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n    return {\n      source: result,\n      span: new AbsoluteSourceSpan(start, start + result.length),\n    };\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```html\n   *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n   * ```\n   * contains five bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   * 4. i -> NgForOfContext.index\n   * 5. ngForTrackBy -> func\n   *\n   * For a full description of the microsyntax grammar, see\n   * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n   *\n   * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n   * without the *, along with its absolute span.\n   */\n  parseTemplateBindings(templateKey: TemplateBindingIdentifier): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n\n    // The first binding is for the template key itself\n    // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n    // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n    bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n\n    while (this.index < this.tokens.length) {\n      // If it starts with 'let', then this must be variable declaration\n      const letBinding = this.parseLetBinding();\n      if (letBinding) {\n        bindings.push(letBinding);\n      } else {\n        // Two possible cases here, either `value \"as\" key` or\n        // \"directive-keyword expression\". We don't know which case, but both\n        // \"value\" and \"directive-keyword\" are template binding key, so consume\n        // the key first.\n        const key = this.expectTemplateBindingKey();\n        // Peek at the next token, if it is \"as\" then this must be variable\n        // declaration.\n        const binding = this.parseAsBinding(key);\n        if (binding) {\n          bindings.push(binding);\n        } else {\n          // Otherwise the key must be a directive keyword, like \"of\". Transform\n          // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n          key.source =\n            templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n          bindings.push(...this.parseDirectiveKeywordBindings(key));\n        }\n      }\n      this.consumeStatementTerminator();\n    }\n\n    return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n  }\n\n  private parseKeyedReadOrWrite(receiver: AST, start: number, isSafe: boolean): AST {\n    return this.withContext(ParseContextFlags.Writable, () => {\n      this.rbracketsExpected++;\n      const key = this.parsePipe();\n      if (key instanceof EmptyExpr) {\n        this.error(`Key access cannot be empty`);\n      }\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n\n        if (isSafe) {\n          this.advance();\n          this.error(\"The '?.' operator cannot be used in the assignment\");\n        } else {\n          const binaryReceiver = new KeyedRead(\n            this.span(start),\n            this.sourceSpan(start),\n            receiver,\n            key,\n          );\n          this.advance();\n          const value = this.parseConditional();\n          return new Binary(\n            this.span(start),\n            this.sourceSpan(start),\n            operation,\n            binaryReceiver,\n            value,\n          );\n        }\n      } else {\n        return isSafe\n          ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key)\n          : new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n      }\n\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    });\n  }\n\n  /**\n   * Parse a directive keyword, followed by a mandatory expression.\n   * For example, \"of items\", \"trackBy: func\".\n   * The bindings are: ngForOf -> items, ngForTrackBy -> func\n   * There could be an optional \"as\" binding that follows the expression.\n   * For example,\n   * ```\n   *   *ngFor=\"let item of items | slice:0:1 as collection\".\n   *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n   *               keyword    bound target   optional 'as' binding\n   * ```\n   *\n   * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n   * absolute span.\n   */\n  private parseDirectiveKeywordBindings(key: TemplateBindingIdentifier): TemplateBinding[] {\n    const bindings: TemplateBinding[] = [];\n    this.consumeOptionalCharacter(chars.$COLON); // trackBy: trackByFunction\n    const value = this.getDirectiveBoundTarget();\n    let spanEnd = this.currentAbsoluteOffset;\n    // The binding could optionally be followed by \"as\". For example,\n    // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n    // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n    // 'key' in the current context now becomes the \"value\" in the next binding.\n    const asBinding = this.parseAsBinding(key);\n    if (!asBinding) {\n      this.consumeStatementTerminator();\n      spanEnd = this.currentAbsoluteOffset;\n    }\n    const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n    bindings.push(new ExpressionBinding(sourceSpan, key, value));\n    if (asBinding) {\n      bindings.push(asBinding);\n    }\n    return bindings;\n  }\n\n  /**\n   * Return the expression AST for the bound target of a directive keyword\n   * binding. For example,\n   * ```\n   *   *ngIf=\"condition | pipe\"\n   *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n   *   *ngFor=\"let item of items\"\n   *                       ^^^^^ bound target for \"ngForOf\"\n   * ```\n   */\n  private getDirectiveBoundTarget(): ASTWithSource | null {\n    if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n      return null;\n    }\n    const ast = this.parsePipe(); // example: \"condition | async\"\n    const {start, end} = ast.span;\n    const value = this.input.substring(start, end);\n    return new ASTWithSource(\n      ast,\n      value,\n      getLocation(this.parseSourceSpan),\n      this.absoluteOffset + start,\n      this.errors,\n    );\n  }\n\n  /**\n   * Return the binding for a variable declared using `as`. Note that the order\n   * of the key-value pair in this declaration is reversed. For example,\n   * ```\n   *   *ngFor=\"let item of items; index as i\"\n   *                              ^^^^^    ^\n   *                              value    key\n   * ```\n   *\n   * @param value name of the value in the declaration, \"ngIf\" in the example\n   * above, along with its absolute span.\n   */\n  private parseAsBinding(value: TemplateBindingIdentifier): TemplateBinding | null {\n    if (!this.peekKeywordAs()) {\n      return null;\n    }\n    this.advance(); // consume the 'as' keyword\n    const key = this.expectTemplateBindingKey();\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Return the binding for a variable declared using `let`. For example,\n   * ```\n   *   *ngFor=\"let item of items; let i=index;\"\n   *           ^^^^^^^^           ^^^^^^^^^^^\n   * ```\n   * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n   * In the second binding, `i` is bound to `NgForOfContext.index`.\n   */\n  private parseLetBinding(): TemplateBinding | null {\n    if (!this.peekKeywordLet()) {\n      return null;\n    }\n    const spanStart = this.currentAbsoluteOffset;\n    this.advance(); // consume the 'let' keyword\n    const key = this.expectTemplateBindingKey();\n    let value: TemplateBindingIdentifier | null = null;\n    if (this.consumeOptionalOperator('=')) {\n      value = this.expectTemplateBindingKey();\n    }\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  private parseNoInterpolationTaggedTemplateLiteral(tag: AST, start: number) {\n    const template = this.parseNoInterpolationTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n\n  private parseNoInterpolationTemplateLiteral(): TemplateLiteral {\n    const text = this.next.strValue;\n    const start = this.inputIndex;\n    this.advance();\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return new TemplateLiteral(\n      span,\n      sourceSpan,\n      [new TemplateLiteralElement(span, sourceSpan, text)],\n      [],\n    );\n  }\n\n  private parseTaggedTemplateLiteral(tag: AST, start: number): AST {\n    const template = this.parseTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n\n  private parseTemplateLiteral(): TemplateLiteral {\n    const elements: TemplateLiteralElement[] = [];\n    const expressions: AST[] = [];\n    const start = this.inputIndex;\n\n    while (this.next !== EOF) {\n      const token = this.next;\n\n      if (token.isTemplateLiteralPart() || token.isTemplateLiteralEnd()) {\n        const partStart = this.inputIndex;\n        this.advance();\n        elements.push(\n          new TemplateLiteralElement(\n            this.span(partStart),\n            this.sourceSpan(partStart),\n            token.strValue,\n          ),\n        );\n        if (token.isTemplateLiteralEnd()) {\n          break;\n        }\n      } else if (token.isTemplateLiteralInterpolationStart()) {\n        this.advance();\n        const expression = this.parsePipe();\n        if (expression instanceof EmptyExpr) {\n          this.error('Template literal interpolation cannot be empty');\n        } else {\n          expressions.push(expression);\n        }\n      } else {\n        this.advance();\n      }\n    }\n\n    return new TemplateLiteral(this.span(start), this.sourceSpan(start), elements, expressions);\n  }\n\n  private parseRegularExpressionLiteral() {\n    const bodyToken = this.next;\n    this.advance();\n\n    if (!bodyToken.isRegExpBody()) {\n      return new EmptyExpr(this.span(this.inputIndex), this.sourceSpan(this.inputIndex));\n    }\n\n    let flagsToken: Token | null = null;\n\n    if (this.next.isRegExpFlags()) {\n      flagsToken = this.next;\n      this.advance();\n      const seenFlags = new Set<string>();\n\n      for (let i = 0; i < flagsToken.strValue.length; i++) {\n        const char = flagsToken.strValue[i];\n\n        if (!SUPPORTED_REGEX_FLAGS.has(char)) {\n          this.error(\n            `Unsupported regular expression flag \"${char}\". The supported flags are: ` +\n              Array.from(SUPPORTED_REGEX_FLAGS, (f) => `\"${f}\"`).join(', '),\n            flagsToken.index + i,\n          );\n        } else if (seenFlags.has(char)) {\n          this.error(`Duplicate regular expression flag \"${char}\"`, flagsToken.index + i);\n        } else {\n          seenFlags.add(char);\n        }\n      }\n    }\n\n    const start = bodyToken.index;\n    const end = flagsToken ? flagsToken.end : bodyToken.end;\n\n    return new RegularExpressionLiteral(\n      this.span(start, end),\n      this.sourceSpan(start, end),\n      bodyToken.strValue,\n      flagsToken ? flagsToken.strValue : null,\n    );\n  }\n\n  /**\n   * Consume the optional statement terminator: semicolon or comma.\n   */\n  private consumeStatementTerminator() {\n    this.consumeOptionalCharacter(chars.$SEMICOLON) || this.consumeOptionalCharacter(chars.$COMMA);\n  }\n\n  /**\n   * Records an error and skips over the token stream until reaching a recoverable point. See\n   * `this.skip` for more details on token skipping.\n   */\n  private error(message: string, index = this.index) {\n    this.errors.push(\n      getParseError(message, this.input, this.getErrorLocationText(index), this.parseSourceSpan),\n    );\n    this.skip();\n  }\n\n  private getErrorLocationText(index: number) {\n    return index < this.tokens.length\n      ? `at column ${this.tokens[index].index + 1} in`\n      : `at the end of the expression`;\n  }\n\n  /**\n   * Records an error for an unexpected private identifier being discovered.\n   * @param token Token representing a private identifier.\n   * @param extraMessage Optional additional message being appended to the error.\n   */\n  private _reportErrorForPrivateIdentifier(token: Token, extraMessage: string | null) {\n    let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n    if (extraMessage !== null) {\n      errorMessage += `, ${extraMessage}`;\n    }\n    this.error(errorMessage);\n  }\n\n  /**\n   * Error recovery should skip tokens until it encounters a recovery point.\n   *\n   * The following are treated as unconditional recovery points:\n   *   - end of input\n   *   - ';' (parseChain() is always the root production, and it expects a ';')\n   *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n   *\n   * The following are conditional recovery points:\n   *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n   *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n   *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n   *       an '(' <expr> ')' production).\n   *       The recovery points of grouping symbols must be conditional as they must be skipped if\n   *       none of the calling productions are not expecting the closing token else we will never\n   *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n   *       That is, we skip a closing symbol if we are not in a grouping production.\n   *   - Assignment in a `Writable` context\n   *     - In this context, we are able to recover after seeing the `=` operator, which\n   *       signals the presence of an independent rvalue expression following the `=` operator.\n   *\n   * If a production expects one of these token it increments the corresponding nesting count,\n   * and then decrements it just prior to checking if the token is in the input.\n   */\n  private skip() {\n    let n = this.next;\n    while (\n      this.index < this.tokens.length &&\n      !n.isCharacter(chars.$SEMICOLON) &&\n      !n.isOperator('|') &&\n      (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n      (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n      (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) &&\n      (!(this.context & ParseContextFlags.Writable) || !this.isAssignmentOperator(n))\n    ) {\n      if (this.next.isError()) {\n        this.errors.push(\n          getParseError(\n            this.next.toString()!,\n            this.input,\n            this.getErrorLocationText(this.next.index),\n            this.parseSourceSpan,\n          ),\n        );\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nfunction getParseError(\n  message: string,\n  input: string,\n  locationText: string,\n  parseSourceSpan: ParseSourceSpan,\n) {\n  if (locationText.length > 0) {\n    locationText = ` ${locationText} `;\n  }\n  const location = getLocation(parseSourceSpan);\n  const error = `Parser Error: ${message}${locationText}[${input}] in ${location}`;\n  return new ParseError(parseSourceSpan, error);\n}\n\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n  errors: string[] = [];\n\n  override visitPipe() {\n    this.errors.push('pipes');\n  }\n}\n/**\n * Computes the real offset in the original template for indexes in an interpolation.\n *\n * Because templates can have encoded HTML entities and the input passed to the parser at this stage\n * of the compiler is the _decoded_ value, we need to compute the real offset using the original\n * encoded values in the interpolated tokens. Note that this is only a special case handling for\n * `MlParserTokenType.ENCODED_ENTITY` token types. All other interpolated tokens are expected to\n * have parts which exactly match the input string for parsing the interpolation.\n *\n * @param interpolatedTokens The tokens for the interpolated value.\n *\n * @returns A map of index locations in the decoded template to indexes in the original template\n */\nfunction getIndexMapForOriginalTemplate(\n  interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[],\n): Map<number, number> {\n  let offsetMap = new Map<number, number>();\n  let consumedInOriginalTemplate = 0;\n  let consumedInInput = 0;\n  let tokenIndex = 0;\n  while (tokenIndex < interpolatedTokens.length) {\n    const currentToken = interpolatedTokens[tokenIndex];\n    if (currentToken.type === MlParserTokenType.ENCODED_ENTITY) {\n      const [decoded, encoded] = currentToken.parts;\n      consumedInOriginalTemplate += encoded.length;\n      consumedInInput += decoded.length;\n    } else {\n      const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);\n      consumedInInput += lengthOfParts;\n      consumedInOriginalTemplate += lengthOfParts;\n    }\n    offsetMap.set(consumedInInput, consumedInOriginalTemplate);\n    tokenIndex++;\n  }\n  return offsetMap;\n}\n"]}