{"version":3,"file":"parse_util.js","sourceRoot":"","sources":["parse_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as chars from './chars';\nimport {stringify} from './util';\n\nexport class ParseLocation {\n  constructor(\n    public file: ParseSourceFile,\n    public offset: number,\n    public line: number,\n    public col: number,\n  ) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n\n  moveBy(delta: number): ParseLocation {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == chars.$LF) {\n        line--;\n        const priorLine = source\n          .substring(0, offset - 1)\n          .lastIndexOf(String.fromCharCode(chars.$LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == chars.$LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string; after: string} | null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1),\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(\n    public content: string,\n    public url: string,\n  ) {}\n}\n\nexport class ParseSourceSpan {\n  /**\n   * Create an object that holds information about spans of tokens/nodes captured during\n   * lexing/parsing of text.\n   *\n   * @param start\n   * The location of the start of the span (having skipped leading trivia).\n   * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n   * elements will appear to begin at the start of the opening tag, rather than at the start of any\n   * leading trivia, which could include newlines.\n   *\n   * @param end\n   * The location of the end of the span.\n   *\n   * @param fullStart\n   * The start of the token without skipping the leading trivia.\n   * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n   * from text tokens. Such tooling creates new source-spans relative to the original token's\n   * source-span. If leading trivia characters have been skipped then the new source-spans may be\n   * incorrectly offset.\n   *\n   * @param details\n   * Additional information (such as identifier names) that should be associated with the span.\n   */\n  constructor(\n    public start: ParseLocation,\n    public end: ParseLocation,\n    public fullStart: ParseLocation = start,\n    public details: string | null = null,\n  ) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR,\n}\n\nexport class ParseError extends Error {\n  constructor(\n    /** Location of the error. */\n    readonly span: ParseSourceSpan,\n    /** Error message. */\n    readonly msg: string,\n    /** Severity level of the error. */\n    readonly level: ParseErrorLevel = ParseErrorLevel.ERROR,\n    /**\n     * Error that caused the error to be surfaced. For example, an error in a sub-expression that\n     * couldn't be parsed. Not guaranteed to be defined, but can be used to provide more context.\n     */\n    readonly relatedError?: unknown,\n  ) {\n    super(msg);\n\n    // Extending `Error` ends up breaking some internal tests. This appears to be a known issue\n    // when extending errors in TS and the workaround is to explicitly set the prototype.\n    // https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx\n      ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")`\n      : this.msg;\n  }\n\n  override toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nexport function r3JitTypeSourceSpan(\n  kind: string,\n  typeName: string,\n  sourceUrl: string,\n): ParseSourceSpan {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n    new ParseLocation(sourceFile, -1, -1, -1),\n    new ParseLocation(sourceFile, -1, -1, -1),\n  );\n}\n\nlet _anonymousTypeIndex = 0;\n\nexport function identifierName(\n  compileIdentifier: CompileIdentifierMetadata | null | undefined,\n): string | null {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  if (ref['__forward_ref__']) {\n    // We do not want to try to stringify a `forwardRef()` function because that would cause the\n    // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n    return '__forward_ref__';\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    // case: anonymous functions!\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\n\nexport interface CompileIdentifierMetadata {\n  reference: any;\n}\n\nexport function sanitizeIdentifier(name: string): string {\n  return name.replace(/\\W/g, '_');\n}\n"]}