{"version":3,"file":"parser.js","sourceRoot":"","sources":["parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ParseError, ParseLocation, ParseSourceSpan} from '../parse_util';\n\nimport * as html from './ast';\nimport {NAMED_ENTITIES} from './entities';\nimport {tokenize, TokenizeOptions} from './lexer';\nimport {getNsPrefix, mergeNsAndName, splitNsName, TagDefinition} from './tags';\nimport {\n  AttributeNameToken,\n  AttributeQuoteToken,\n  BlockCloseToken,\n  BlockOpenStartToken,\n  BlockParameterToken,\n  CdataStartToken,\n  CommentStartToken,\n  ComponentCloseToken,\n  ComponentOpenStartToken,\n  DirectiveNameToken,\n  ExpansionCaseExpressionEndToken,\n  ExpansionCaseExpressionStartToken,\n  ExpansionCaseValueToken,\n  ExpansionFormStartToken,\n  IncompleteBlockOpenToken,\n  IncompleteComponentOpenToken,\n  IncompleteLetToken,\n  IncompleteTagOpenToken,\n  InterpolatedAttributeToken,\n  InterpolatedTextToken,\n  LetEndToken,\n  LetStartToken,\n  LetValueToken,\n  TagCloseToken,\n  TagOpenStartToken,\n  TextToken,\n  Token,\n  TokenType,\n} from './tokens';\n\n/** Nodes that can contain other nodes. */\ntype NodeContainer = html.Element | html.Block | html.Component;\n\n/** Class that can construct a `NodeContainer`. */\ninterface NodeContainerConstructor extends Function {\n  new (...args: any[]): NodeContainer;\n}\n\nexport class TreeError extends ParseError {\n  static create(elementName: string | null, span: ParseSourceSpan, msg: string): TreeError {\n    return new TreeError(elementName, span, msg);\n  }\n\n  constructor(\n    public elementName: string | null,\n    span: ParseSourceSpan,\n    msg: string,\n  ) {\n    super(span, msg);\n  }\n}\n\nexport class ParseTreeResult {\n  constructor(\n    public rootNodes: html.Node[],\n    public errors: ParseError[],\n  ) {}\n}\n\nexport class Parser {\n  constructor(public getTagDefinition: (tagName: string) => TagDefinition) {}\n\n  parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n    const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n    parser.build();\n    return new ParseTreeResult(parser.rootNodes, [...tokenizeResult.errors, ...parser.errors]);\n  }\n}\n\nclass _TreeBuilder {\n  private _index: number = -1;\n  // `_peek` will be initialized by the call to `_advance()` in the constructor.\n  private _peek!: Token;\n  private _containerStack: NodeContainer[] = [];\n\n  rootNodes: html.Node[] = [];\n  errors: TreeError[] = [];\n\n  constructor(\n    private tokens: Token[],\n    private tagDefinitionResolver: (tagName: string) => TagDefinition,\n  ) {\n    this._advance();\n  }\n\n  build(): void {\n    while (this._peek.type !== TokenType.EOF) {\n      if (\n        this._peek.type === TokenType.TAG_OPEN_START ||\n        this._peek.type === TokenType.INCOMPLETE_TAG_OPEN\n      ) {\n        this._consumeElementStartTag(this._advance());\n      } else if (this._peek.type === TokenType.TAG_CLOSE) {\n        this._consumeElementEndTag(this._advance());\n      } else if (this._peek.type === TokenType.CDATA_START) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance());\n      } else if (this._peek.type === TokenType.COMMENT_START) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance());\n      } else if (\n        this._peek.type === TokenType.TEXT ||\n        this._peek.type === TokenType.RAW_TEXT ||\n        this._peek.type === TokenType.ESCAPABLE_RAW_TEXT\n      ) {\n        this._closeVoidElement();\n        this._consumeText(this._advance());\n      } else if (this._peek.type === TokenType.EXPANSION_FORM_START) {\n        this._consumeExpansion(this._advance());\n      } else if (this._peek.type === TokenType.BLOCK_OPEN_START) {\n        this._closeVoidElement();\n        this._consumeBlockOpen(this._advance());\n      } else if (this._peek.type === TokenType.BLOCK_CLOSE) {\n        this._closeVoidElement();\n        this._consumeBlockClose(this._advance());\n      } else if (this._peek.type === TokenType.INCOMPLETE_BLOCK_OPEN) {\n        this._closeVoidElement();\n        this._consumeIncompleteBlock(this._advance());\n      } else if (this._peek.type === TokenType.LET_START) {\n        this._closeVoidElement();\n        this._consumeLet(this._advance());\n      } else if (this._peek.type === TokenType.INCOMPLETE_LET) {\n        this._closeVoidElement();\n        this._consumeIncompleteLet(this._advance());\n      } else if (\n        this._peek.type === TokenType.COMPONENT_OPEN_START ||\n        this._peek.type === TokenType.INCOMPLETE_COMPONENT_OPEN\n      ) {\n        this._consumeComponentStartTag(this._advance());\n      } else if (this._peek.type === TokenType.COMPONENT_CLOSE) {\n        this._consumeComponentEndTag(this._advance());\n      } else {\n        // Skip all other tokens...\n        this._advance();\n      }\n    }\n\n    for (const leftoverContainer of this._containerStack) {\n      // Unlike HTML elements, blocks aren't closed implicitly by the end of the file.\n      if (leftoverContainer instanceof html.Block) {\n        this.errors.push(\n          TreeError.create(\n            leftoverContainer.name,\n            leftoverContainer.sourceSpan,\n            `Unclosed block \"${leftoverContainer.name}\"`,\n          ),\n        );\n      }\n    }\n  }\n\n  private _advance<T extends Token>(): T {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      // Note: there is always an EOF token at the end\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev as T;\n  }\n\n  private _advanceIf<T extends TokenType>(type: T): (Token & {type: T}) | null {\n    if (this._peek.type === type) {\n      return this._advance<Token & {type: T}>();\n    }\n    return null;\n  }\n\n  private _consumeCdata(_startToken: CdataStartToken) {\n    this._consumeText(this._advance<TextToken>());\n    this._advanceIf(TokenType.CDATA_END);\n  }\n\n  private _consumeComment(token: CommentStartToken) {\n    const text = this._advanceIf(TokenType.RAW_TEXT);\n    const endToken = this._advanceIf(TokenType.COMMENT_END);\n    const value = text != null ? text.parts[0].trim() : null;\n    const sourceSpan =\n      endToken == null\n        ? token.sourceSpan\n        : new ParseSourceSpan(\n            token.sourceSpan.start,\n            endToken.sourceSpan.end,\n            token.sourceSpan.fullStart,\n          );\n    this._addToParent(new html.Comment(value, sourceSpan));\n  }\n\n  private _consumeExpansion(token: ExpansionFormStartToken) {\n    const switchValue = this._advance<TextToken>();\n\n    const type = this._advance<TextToken>();\n    const cases: html.ExpansionCase[] = [];\n\n    // read =\n    while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) return; // error\n      cases.push(expCase);\n    }\n\n    // read the final }\n    if (this._peek.type !== TokenType.EXPANSION_FORM_END) {\n      this.errors.push(\n        TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`),\n      );\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(\n      token.sourceSpan.start,\n      this._peek.sourceSpan.end,\n      token.sourceSpan.fullStart,\n    );\n    this._addToParent(\n      new html.Expansion(\n        switchValue.parts[0],\n        type.parts[0],\n        cases,\n        sourceSpan,\n        switchValue.sourceSpan,\n      ),\n    );\n\n    this._advance();\n  }\n\n  private _parseExpansionCase(): html.ExpansionCase | null {\n    const value = this._advance<ExpansionCaseValueToken>();\n\n    // read {\n    if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {\n      this.errors.push(\n        TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`),\n      );\n      return null;\n    }\n\n    // read until }\n    const start = this._advance<ExpansionCaseExpressionStartToken>();\n\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) return null;\n\n    const end = this._advance<ExpansionCaseExpressionEndToken>();\n    exp.push({type: TokenType.EOF, parts: [], sourceSpan: end.sourceSpan});\n\n    // parse everything in between { and }\n    const expansionCaseParser = new _TreeBuilder(exp, this.tagDefinitionResolver);\n    expansionCaseParser.build();\n    if (expansionCaseParser.errors.length > 0) {\n      this.errors = this.errors.concat(expansionCaseParser.errors);\n      return null;\n    }\n\n    const sourceSpan = new ParseSourceSpan(\n      value.sourceSpan.start,\n      end.sourceSpan.end,\n      value.sourceSpan.fullStart,\n    );\n    const expSourceSpan = new ParseSourceSpan(\n      start.sourceSpan.start,\n      end.sourceSpan.end,\n      start.sourceSpan.fullStart,\n    );\n    return new html.ExpansionCase(\n      value.parts[0],\n      expansionCaseParser.rootNodes,\n      sourceSpan,\n      value.sourceSpan,\n      expSourceSpan,\n    );\n  }\n\n  private _collectExpansionExpTokens(start: Token): Token[] | null {\n    const exp: Token[] = [];\n    const expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];\n\n    while (true) {\n      if (\n        this._peek.type === TokenType.EXPANSION_FORM_START ||\n        this._peek.type === TokenType.EXPANSION_CASE_EXP_START\n      ) {\n        expansionFormStack.push(this._peek.type);\n      }\n\n      if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {\n        if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) return exp;\n        } else {\n          this.errors.push(\n            TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`),\n          );\n          return null;\n        }\n      }\n\n      if (this._peek.type === TokenType.EXPANSION_FORM_END) {\n        if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {\n          expansionFormStack.pop();\n        } else {\n          this.errors.push(\n            TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`),\n          );\n          return null;\n        }\n      }\n\n      if (this._peek.type === TokenType.EOF) {\n        this.errors.push(\n          TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`),\n        );\n        return null;\n      }\n\n      exp.push(this._advance());\n    }\n  }\n\n  private _consumeText(token: InterpolatedTextToken) {\n    const tokens = [token];\n    const startSpan = token.sourceSpan;\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === '\\n') {\n      const parent = this._getContainer();\n\n      if (\n        parent != null &&\n        parent.children.length === 0 &&\n        this._getTagDefinition(parent)?.ignoreFirstLf\n      ) {\n        text = text.substring(1);\n        tokens[0] = {type: token.type, sourceSpan: token.sourceSpan, parts: [text]} as typeof token;\n      }\n    }\n\n    while (\n      this._peek.type === TokenType.INTERPOLATION ||\n      this._peek.type === TokenType.TEXT ||\n      this._peek.type === TokenType.ENCODED_ENTITY\n    ) {\n      token = this._advance();\n      tokens.push(token);\n      if (token.type === TokenType.INTERPOLATION) {\n        // For backward compatibility we decode HTML entities that appear in interpolation\n        // expressions. This is arguably a bug, but it could be a considerable breaking change to\n        // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n        // chain after View Engine has been removed.\n        text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n      } else if (token.type === TokenType.ENCODED_ENTITY) {\n        text += token.parts[0];\n      } else {\n        text += token.parts.join('');\n      }\n    }\n\n    if (text.length > 0) {\n      const endSpan = token.sourceSpan;\n      this._addToParent(\n        new html.Text(\n          text,\n          new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details),\n          tokens,\n        ),\n      );\n    }\n  }\n\n  private _closeVoidElement(): void {\n    const el = this._getContainer();\n    if (el !== null && this._getTagDefinition(el)?.isVoid) {\n      this._containerStack.pop();\n    }\n  }\n\n  private _consumeElementStartTag(startTagToken: TagOpenStartToken | IncompleteTagOpenToken) {\n    const attrs: html.Attribute[] = [];\n    const directives: html.Directive[] = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n\n    const fullName = this._getElementFullName(startTagToken, this._getClosestElementLikeParent());\n    const tagDef = this._getTagDefinition(fullName);\n    let selfClosing = false;\n    // Note: There could have been a tokenizer error\n    // so that we don't get a token for the end tag...\n    if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {\n      this._advance();\n      selfClosing = true;\n      if (!(tagDef?.canSelfClose || getNsPrefix(fullName) !== null || tagDef?.isVoid)) {\n        this.errors.push(\n          TreeError.create(\n            fullName,\n            startTagToken.sourceSpan,\n            `Only void, custom and foreign elements can be self closed \"${startTagToken.parts[1]}\"`,\n          ),\n        );\n      }\n    } else if (this._peek.type === TokenType.TAG_OPEN_END) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(\n      startTagToken.sourceSpan.start,\n      end,\n      startTagToken.sourceSpan.fullStart,\n    );\n    // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n    const startSpan = new ParseSourceSpan(\n      startTagToken.sourceSpan.start,\n      end,\n      startTagToken.sourceSpan.fullStart,\n    );\n    const el = new html.Element(\n      fullName,\n      attrs,\n      directives,\n      [],\n      selfClosing,\n      span,\n      startSpan,\n      undefined,\n      tagDef?.isVoid ?? false,\n    );\n    const parent = this._getContainer();\n    const isClosedByChild =\n      parent !== null && !!this._getTagDefinition(parent)?.isClosedByChild(el.name);\n    this._pushContainer(el, isClosedByChild);\n\n    if (selfClosing) {\n      // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n      // element start tag also represents the end tag.\n      this._popContainer(fullName, html.Element, span);\n    } else if (startTagToken.type === TokenType.INCOMPLETE_TAG_OPEN) {\n      // We already know the opening tag is not complete, so it is unlikely it has a corresponding\n      // close tag. Let's optimistically parse it as a full element and emit an error.\n      this._popContainer(fullName, html.Element, null);\n      this.errors.push(\n        TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`),\n      );\n    }\n  }\n\n  private _consumeComponentStartTag(\n    startToken: ComponentOpenStartToken | IncompleteComponentOpenToken,\n  ) {\n    const componentName = startToken.parts[0];\n    const attrs: html.Attribute[] = [];\n    const directives: html.Directive[] = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n\n    const closestElement = this._getClosestElementLikeParent();\n    const tagName = this._getComponentTagName(startToken, closestElement);\n    const fullName = this._getComponentFullName(startToken, closestElement);\n    const selfClosing = this._peek.type === TokenType.COMPONENT_OPEN_END_VOID;\n    this._advance();\n\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(\n      startToken.sourceSpan.start,\n      end,\n      startToken.sourceSpan.fullStart,\n    );\n    const startSpan = new ParseSourceSpan(\n      startToken.sourceSpan.start,\n      end,\n      startToken.sourceSpan.fullStart,\n    );\n    const node = new html.Component(\n      componentName,\n      tagName,\n      fullName,\n      attrs,\n      directives,\n      [],\n      selfClosing,\n      span,\n      startSpan,\n      undefined,\n    );\n    const parent = this._getContainer();\n    const isClosedByChild =\n      parent !== null &&\n      node.tagName !== null &&\n      !!this._getTagDefinition(parent)?.isClosedByChild(node.tagName);\n    this._pushContainer(node, isClosedByChild);\n\n    if (selfClosing) {\n      this._popContainer(fullName, html.Component, span);\n    } else if (startToken.type === TokenType.INCOMPLETE_COMPONENT_OPEN) {\n      this._popContainer(fullName, html.Component, null);\n      this.errors.push(\n        TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`),\n      );\n    }\n  }\n\n  private _consumeAttributesAndDirectives(\n    attributesResult: html.Attribute[],\n    directivesResult: html.Directive[],\n  ) {\n    while (\n      this._peek.type === TokenType.ATTR_NAME ||\n      this._peek.type === TokenType.DIRECTIVE_NAME\n    ) {\n      if (this._peek.type === TokenType.DIRECTIVE_NAME) {\n        directivesResult.push(this._consumeDirective(this._peek));\n      } else {\n        attributesResult.push(this._consumeAttr(this._advance<AttributeNameToken>()));\n      }\n    }\n  }\n\n  private _consumeComponentEndTag(endToken: ComponentCloseToken) {\n    const fullName = this._getComponentFullName(endToken, this._getClosestElementLikeParent());\n\n    if (!this._popContainer(fullName, html.Component, endToken.sourceSpan)) {\n      const container = this._containerStack[this._containerStack.length - 1];\n      let suffix: string;\n\n      if (container instanceof html.Component && container.componentName === endToken.parts[0]) {\n        suffix = `, did you mean \"${container.fullName}\"?`;\n      } else {\n        suffix = '. It may happen when the tag has already been closed by another tag.';\n      }\n\n      const errMsg = `Unexpected closing tag \"${fullName}\"${suffix}`;\n      this.errors.push(TreeError.create(fullName, endToken.sourceSpan, errMsg));\n    }\n  }\n\n  private _getTagDefinition(nodeOrName: html.Node | string): TagDefinition | null {\n    if (typeof nodeOrName === 'string') {\n      return this.tagDefinitionResolver(nodeOrName);\n    } else if (nodeOrName instanceof html.Element) {\n      return this.tagDefinitionResolver(nodeOrName.name);\n    } else if (nodeOrName instanceof html.Component && nodeOrName.tagName !== null) {\n      return this.tagDefinitionResolver(nodeOrName.tagName);\n    } else {\n      return null;\n    }\n  }\n\n  private _pushContainer(node: NodeContainer, isClosedByChild: boolean) {\n    if (isClosedByChild) {\n      this._containerStack.pop();\n    }\n\n    this._addToParent(node);\n    this._containerStack.push(node);\n  }\n\n  private _consumeElementEndTag(endTagToken: TagCloseToken) {\n    const fullName = this._getElementFullName(endTagToken, this._getClosestElementLikeParent());\n\n    if (this._getTagDefinition(fullName)?.isVoid) {\n      this.errors.push(\n        TreeError.create(\n          fullName,\n          endTagToken.sourceSpan,\n          `Void elements do not have end tags \"${endTagToken.parts[1]}\"`,\n        ),\n      );\n    } else if (!this._popContainer(fullName, html.Element, endTagToken.sourceSpan)) {\n      const errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n\n  /**\n   * Closes the nearest element with the tag name `fullName` in the parse tree.\n   * `endSourceSpan` is the span of the closing tag, or null if the element does\n   * not have a closing tag (for example, this happens when an incomplete\n   * opening tag is recovered).\n   */\n  private _popContainer(\n    expectedName: string | null,\n    expectedType: NodeContainerConstructor,\n    endSourceSpan: ParseSourceSpan | null,\n  ): boolean {\n    let unexpectedCloseTagDetected = false;\n    for (let stackIndex = this._containerStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const node = this._containerStack[stackIndex];\n      const nodeName = node instanceof html.Component ? node.fullName : node.name;\n\n      if ((nodeName === expectedName || expectedName === null) && node instanceof expectedType) {\n        // Record the parse span with the element that is being closed. Any elements that are\n        // removed from the element stack at this point are closed implicitly, so they won't get\n        // an end source span (as there is no explicit closing element).\n        node.endSourceSpan = endSourceSpan;\n        node.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : node.sourceSpan.end;\n        this._containerStack.splice(stackIndex, this._containerStack.length - stackIndex);\n        return !unexpectedCloseTagDetected;\n      }\n\n      // Blocks and most elements are not self closing.\n      if (node instanceof html.Block || !this._getTagDefinition(node)?.closedByParent) {\n        // Note that we encountered an unexpected close tag but continue processing the element\n        // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\n        // end tag in the stack.\n        unexpectedCloseTagDetected = true;\n      }\n    }\n    return false;\n  }\n\n  private _consumeAttr(attrName: AttributeNameToken): html.Attribute {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let attrEnd = attrName.sourceSpan.end;\n\n    // Consume any quote\n    if (this._peek.type === TokenType.ATTR_QUOTE) {\n      this._advance();\n    }\n\n    // Consume the attribute value\n    let value = '';\n    const valueTokens: InterpolatedAttributeToken[] = [];\n    let valueStartSpan: ParseSourceSpan | undefined = undefined;\n    let valueEnd: ParseLocation | undefined = undefined;\n    // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of\n    // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from\n    // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not\n    // able to see that `_advance()` will actually mutate `_peek`.\n    const nextTokenType = this._peek.type as TokenType;\n    if (nextTokenType === TokenType.ATTR_VALUE_TEXT) {\n      valueStartSpan = this._peek.sourceSpan;\n      valueEnd = this._peek.sourceSpan.end;\n      while (\n        this._peek.type === TokenType.ATTR_VALUE_TEXT ||\n        this._peek.type === TokenType.ATTR_VALUE_INTERPOLATION ||\n        this._peek.type === TokenType.ENCODED_ENTITY\n      ) {\n        const valueToken = this._advance<InterpolatedAttributeToken>();\n        valueTokens.push(valueToken);\n        if (valueToken.type === TokenType.ATTR_VALUE_INTERPOLATION) {\n          // For backward compatibility we decode HTML entities that appear in interpolation\n          // expressions. This is arguably a bug, but it could be a considerable breaking change to\n          // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n          // chain after View Engine has been removed.\n          value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n        } else if (valueToken.type === TokenType.ENCODED_ENTITY) {\n          value += valueToken.parts[0];\n        } else {\n          value += valueToken.parts.join('');\n        }\n        valueEnd = attrEnd = valueToken.sourceSpan.end;\n      }\n    }\n\n    // Consume any quote\n    if (this._peek.type === TokenType.ATTR_QUOTE) {\n      const quoteToken = this._advance<AttributeQuoteToken>();\n      attrEnd = quoteToken.sourceSpan.end;\n    }\n\n    const valueSpan =\n      valueStartSpan &&\n      valueEnd &&\n      new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n    return new html.Attribute(\n      fullName,\n      value,\n      new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart),\n      attrName.sourceSpan,\n      valueSpan,\n      valueTokens.length > 0 ? valueTokens : undefined,\n      undefined,\n    );\n  }\n\n  private _consumeDirective(nameToken: DirectiveNameToken): html.Directive {\n    const attributes: html.Attribute[] = [];\n    let startSourceSpanEnd: ParseLocation = nameToken.sourceSpan.end;\n    let endSourceSpan: ParseSourceSpan | null = null;\n    this._advance();\n\n    if (this._peek.type === TokenType.DIRECTIVE_OPEN) {\n      // Capture the opening token in the start span.\n      startSourceSpanEnd = this._peek.sourceSpan.end;\n      this._advance();\n\n      // Cast here is necessary, because TS doesn't know that `_advance` changed `_peek`.\n      while ((this._peek as Token).type === TokenType.ATTR_NAME) {\n        attributes.push(this._consumeAttr(this._advance<AttributeNameToken>()));\n      }\n\n      if ((this._peek as Token).type === TokenType.DIRECTIVE_CLOSE) {\n        endSourceSpan = this._peek.sourceSpan;\n        this._advance();\n      } else {\n        this.errors.push(\n          TreeError.create(null, nameToken.sourceSpan, 'Unterminated directive definition'),\n        );\n      }\n    }\n\n    const startSourceSpan = new ParseSourceSpan(\n      nameToken.sourceSpan.start,\n      startSourceSpanEnd,\n      nameToken.sourceSpan.fullStart,\n    );\n\n    const sourceSpan = new ParseSourceSpan(\n      startSourceSpan.start,\n      endSourceSpan === null ? nameToken.sourceSpan.end : endSourceSpan.end,\n      startSourceSpan.fullStart,\n    );\n\n    return new html.Directive(\n      nameToken.parts[0],\n      attributes,\n      sourceSpan,\n      startSourceSpan,\n      endSourceSpan,\n    );\n  }\n\n  private _consumeBlockOpen(token: BlockOpenStartToken) {\n    const parameters: html.BlockParameter[] = [];\n\n    while (this._peek.type === TokenType.BLOCK_PARAMETER) {\n      const paramToken = this._advance<BlockParameterToken>();\n      parameters.push(new html.BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n\n    if (this._peek.type === TokenType.BLOCK_OPEN_END) {\n      this._advance();\n    }\n\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new html.Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n  }\n\n  private _consumeBlockClose(token: BlockCloseToken) {\n    if (!this._popContainer(null, html.Block, token.sourceSpan)) {\n      this.errors.push(\n        TreeError.create(\n          null,\n          token.sourceSpan,\n          `Unexpected closing block. The block may have been closed earlier. ` +\n            `If you meant to write the } character, you should use the \"&#125;\" ` +\n            `HTML entity instead.`,\n        ),\n      );\n    }\n  }\n\n  private _consumeIncompleteBlock(token: IncompleteBlockOpenToken) {\n    const parameters: html.BlockParameter[] = [];\n\n    while (this._peek.type === TokenType.BLOCK_PARAMETER) {\n      const paramToken = this._advance<BlockParameterToken>();\n      parameters.push(new html.BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new html.Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n\n    // Incomplete blocks don't have children so we close them immediately and report an error.\n    this._popContainer(null, html.Block, null);\n\n    this.errors.push(\n      TreeError.create(\n        token.parts[0],\n        span,\n        `Incomplete block \"${token.parts[0]}\". If you meant to write the @ character, ` +\n          `you should use the \"&#64;\" HTML entity instead.`,\n      ),\n    );\n  }\n\n  private _consumeLet(startToken: LetStartToken) {\n    const name = startToken.parts[0];\n    let valueToken: LetValueToken;\n    let endToken: LetEndToken;\n\n    if (this._peek.type !== TokenType.LET_VALUE) {\n      this.errors.push(\n        TreeError.create(\n          startToken.parts[0],\n          startToken.sourceSpan,\n          `Invalid @let declaration \"${name}\". Declaration must have a value.`,\n        ),\n      );\n      return;\n    } else {\n      valueToken = this._advance();\n    }\n\n    // Type cast is necessary here since TS narrowed the type of `peek` above.\n    if ((this._peek as Token).type !== TokenType.LET_END) {\n      this.errors.push(\n        TreeError.create(\n          startToken.parts[0],\n          startToken.sourceSpan,\n          `Unterminated @let declaration \"${name}\". Declaration must be terminated with a semicolon.`,\n        ),\n      );\n      return;\n    } else {\n      endToken = this._advance();\n    }\n\n    const end = endToken.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(\n      startToken.sourceSpan.start,\n      end,\n      startToken.sourceSpan.fullStart,\n    );\n\n    // The start token usually captures the `@let`. Construct a name span by\n    // offsetting the start by the length of any text before the name.\n    const startOffset = startToken.sourceSpan.toString().lastIndexOf(name);\n    const nameStart = startToken.sourceSpan.start.moveBy(startOffset);\n    const nameSpan = new ParseSourceSpan(nameStart, startToken.sourceSpan.end);\n    const node = new html.LetDeclaration(\n      name,\n      valueToken.parts[0],\n      span,\n      nameSpan,\n      valueToken.sourceSpan,\n    );\n\n    this._addToParent(node);\n  }\n\n  private _consumeIncompleteLet(token: IncompleteLetToken) {\n    // Incomplete `@let` declaration may end up with an empty name.\n    const name = token.parts[0] ?? '';\n    const nameString = name ? ` \"${name}\"` : '';\n\n    // If there's at least a name, we can salvage an AST node that can be used for completions.\n    if (name.length > 0) {\n      const startOffset = token.sourceSpan.toString().lastIndexOf(name);\n      const nameStart = token.sourceSpan.start.moveBy(startOffset);\n      const nameSpan = new ParseSourceSpan(nameStart, token.sourceSpan.end);\n      const valueSpan = new ParseSourceSpan(\n        token.sourceSpan.start,\n        token.sourceSpan.start.moveBy(0),\n      );\n      const node = new html.LetDeclaration(name, '', token.sourceSpan, nameSpan, valueSpan);\n      this._addToParent(node);\n    }\n\n    this.errors.push(\n      TreeError.create(\n        token.parts[0],\n        token.sourceSpan,\n        `Incomplete @let declaration${nameString}. ` +\n          `@let declarations must be written as \\`@let <name> = <value>;\\``,\n      ),\n    );\n  }\n\n  private _getContainer(): NodeContainer | null {\n    return this._containerStack.length > 0\n      ? this._containerStack[this._containerStack.length - 1]\n      : null;\n  }\n\n  private _getClosestElementLikeParent(): html.Element | html.Component | null {\n    for (let i = this._containerStack.length - 1; i > -1; i--) {\n      const current = this._containerStack[i];\n      if (current instanceof html.Element || current instanceof html.Component) {\n        return current;\n      }\n    }\n\n    return null;\n  }\n\n  private _addToParent(node: html.Node) {\n    const parent = this._getContainer();\n\n    if (parent === null) {\n      this.rootNodes.push(node);\n    } else {\n      parent.children.push(node);\n    }\n  }\n\n  private _getElementFullName(\n    token: TagOpenStartToken | IncompleteTagOpenToken | TagCloseToken,\n    parent: html.Element | html.Component | null,\n  ): string {\n    const prefix = this._getPrefix(token, parent);\n    return mergeNsAndName(prefix, token.parts[1]);\n  }\n\n  private _getComponentFullName(\n    token: ComponentOpenStartToken | IncompleteComponentOpenToken | ComponentCloseToken,\n    parent: html.Element | html.Component | null,\n  ): string {\n    const componentName = token.parts[0];\n    const tagName = this._getComponentTagName(token, parent);\n\n    if (tagName === null) {\n      return componentName;\n    }\n\n    return tagName.startsWith(':') ? componentName + tagName : `${componentName}:${tagName}`;\n  }\n\n  private _getComponentTagName(\n    token: ComponentOpenStartToken | IncompleteComponentOpenToken | ComponentCloseToken,\n    parent: html.Element | html.Component | null,\n  ): string | null {\n    const prefix = this._getPrefix(token, parent);\n    const tagName = token.parts[2];\n\n    if (!prefix && !tagName) {\n      return null;\n    } else if (!prefix && tagName) {\n      return tagName;\n    } else {\n      // TODO(crisbeto): re-evaluate this fallback. Maybe base it off the class name?\n      return mergeNsAndName(prefix, tagName || 'ng-component');\n    }\n  }\n\n  private _getPrefix(\n    token:\n      | TagOpenStartToken\n      | IncompleteTagOpenToken\n      | ComponentOpenStartToken\n      | IncompleteComponentOpenToken\n      | TagCloseToken\n      | ComponentCloseToken,\n    parent: html.Element | html.Component | null,\n  ): string {\n    let prefix: string;\n    let tagName: string;\n\n    if (\n      token.type === TokenType.COMPONENT_OPEN_START ||\n      token.type === TokenType.INCOMPLETE_COMPONENT_OPEN ||\n      token.type === TokenType.COMPONENT_CLOSE\n    ) {\n      prefix = token.parts[1];\n      tagName = token.parts[2];\n    } else {\n      prefix = token.parts[0];\n      tagName = token.parts[1];\n    }\n\n    prefix = prefix || this._getTagDefinition(tagName)?.implicitNamespacePrefix || '';\n\n    if (!prefix && parent) {\n      const parentName = parent instanceof html.Element ? parent.name : parent.tagName;\n      if (parentName !== null) {\n        const parentTagName = splitNsName(parentName)[1];\n        const parentTagDefinition = this._getTagDefinition(parentTagName);\n        if (parentTagDefinition !== null && !parentTagDefinition.preventNamespaceInheritance) {\n          prefix = getNsPrefix(parentName);\n        }\n      }\n    }\n\n    return prefix;\n  }\n}\n\nfunction lastOnStack(stack: any[], element: any): boolean {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n\n/**\n * Decode the `entity` string, which we believe is the contents of an HTML entity.\n *\n * If the string is not actually a valid/known entity then just return the original `match` string.\n */\nfunction decodeEntity(match: string, entity: string): string {\n  if (NAMED_ENTITIES[entity] !== undefined) {\n    return NAMED_ENTITIES[entity] || match;\n  }\n  if (/^#x[a-f0-9]+$/i.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(2), 16));\n  }\n  if (/^#\\d+$/.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(1), 10));\n  }\n  return match;\n}\n"]}