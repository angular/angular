{"version":3,"file":"lexer.js","sourceRoot":"","sources":["lexer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './defaults';\nimport {NAMED_ENTITIES} from './entities';\nimport {TagContentType, TagDefinition} from './tags';\nimport {\n  ComponentOpenStartToken,\n  IncompleteComponentOpenToken,\n  IncompleteTagOpenToken,\n  TagOpenStartToken,\n  Token,\n  TokenType,\n} from './tokens';\n\nexport class TokenizeResult {\n  constructor(\n    public tokens: Token[],\n    public errors: ParseError[],\n    public nonNormalizedIcuExpressions: Token[],\n  ) {}\n}\n\nexport interface LexerRange {\n  startPos: number;\n  startLine: number;\n  startCol: number;\n  endPos: number;\n}\n\n/**\n * Options that modify how the text is tokenized.\n */\nexport interface TokenizeOptions {\n  /** Whether to tokenize ICU messages (considered as text nodes when false). */\n  tokenizeExpansionForms?: boolean;\n  /** How to tokenize interpolation markers. */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n  /**\n   * If true, do not convert CRLF to LF.\n   */\n  preserveLineEndings?: boolean;\n\n  /**\n   * Whether to tokenize @ block syntax. Otherwise considered text,\n   * or ICU tokens if `tokenizeExpansionForms` is enabled.\n   */\n  tokenizeBlocks?: boolean;\n\n  /**\n   * Whether to tokenize the `@let` syntax. Otherwise will be considered either\n   * text or an incomplete block, depending on whether `tokenizeBlocks` is enabled.\n   */\n  tokenizeLet?: boolean;\n\n  /** Whether the selectorless syntax is enabled. */\n  selectorlessEnabled?: boolean;\n}\n\nexport function tokenize(\n  source: string,\n  url: string,\n  getTagDefinition: (tagName: string) => TagDefinition,\n  options: TokenizeOptions = {},\n): TokenizeResult {\n  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(\n    mergeTextTokens(tokenizer.tokens),\n    tokenizer.errors,\n    tokenizer.nonNormalizedIcuExpressions,\n  );\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nfunction _unparsableEntityErrorMsg(type: CharacterReferenceType, entityStr: string): string {\n  return `Unable to parse entity \"${entityStr}\" - ${type} character reference entities must end with \";\"`;\n}\n\nenum CharacterReferenceType {\n  HEX = 'hexadecimal',\n  DEC = 'decimal',\n}\n\nconst SUPPORTED_BLOCKS = [\n  '@if',\n  '@else', // Covers `@else if` as well\n  '@for',\n  '@switch',\n  '@case',\n  '@default',\n  '@empty',\n  '@defer',\n  '@placeholder',\n  '@loading',\n  '@error',\n];\n\n// See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\nclass _Tokenizer {\n  private _cursor: CharacterCursor;\n  private _tokenizeIcu: boolean;\n  private _interpolationConfig: InterpolationConfig;\n  private _leadingTriviaCodePoints: number[] | undefined;\n  private _currentTokenStart: CharacterCursor | null = null;\n  private _currentTokenType: TokenType | null = null;\n  private _expansionCaseStack: TokenType[] = [];\n  private _openDirectiveCount = 0;\n  private _inInterpolation: boolean = false;\n  private readonly _preserveLineEndings: boolean;\n  private readonly _i18nNormalizeLineEndingsInICUs: boolean;\n  private readonly _tokenizeBlocks: boolean;\n  private readonly _tokenizeLet: boolean;\n  private readonly _selectorlessEnabled: boolean;\n  tokens: Token[] = [];\n  errors: ParseError[] = [];\n  nonNormalizedIcuExpressions: Token[] = [];\n\n  /**\n   * @param _file The html source file being tokenized.\n   * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n   * @param options Configuration of the tokenization.\n   */\n  constructor(\n    _file: ParseSourceFile,\n    private _getTagDefinition: (tagName: string) => TagDefinition,\n    options: TokenizeOptions,\n  ) {\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    this._leadingTriviaCodePoints =\n      options.leadingTriviaChars && options.leadingTriviaChars.map((c) => c.codePointAt(0) || 0);\n    const range = options.range || {\n      endPos: _file.content.length,\n      startPos: 0,\n      startLine: 0,\n      startCol: 0,\n    };\n    this._cursor = options.escapedString\n      ? new EscapedCharacterCursor(_file, range)\n      : new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n    this._tokenizeBlocks = options.tokenizeBlocks ?? true;\n    this._tokenizeLet = options.tokenizeLet ?? true;\n    this._selectorlessEnabled = options.selectorlessEnabled ?? false;\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n\n  private _processCarriageReturns(content: string): string {\n    if (this._preserveLineEndings) {\n      return content;\n    }\n    // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n\n  tokenize(): void {\n    while (this._cursor.peek() !== chars.$EOF) {\n      const start = this._cursor.clone();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (\n          this._tokenizeLet &&\n          // Use `peek` instead of `attempCharCode` since we\n          // don't want to advance in case it's not `@let`.\n          this._cursor.peek() === chars.$AT &&\n          !this._inInterpolation &&\n          this._isLetStart()\n        ) {\n          this._consumeLetDeclaration(start);\n        } else if (this._tokenizeBlocks && this._isBlockStart()) {\n          this._consumeBlockStart(start);\n        } else if (\n          this._tokenizeBlocks &&\n          !this._inInterpolation &&\n          !this._isInExpansionCase() &&\n          !this._isInExpansionForm() &&\n          this._attemptCharCode(chars.$RBRACE)\n        ) {\n          this._consumeBlockEnd(start);\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while\n          // the premature end of an interpolation is given by the start of a new HTML element.\n          this._consumeWithInterpolation(\n            TokenType.TEXT,\n            TokenType.INTERPOLATION,\n            () => this._isTextEnd(),\n            () => this._isTagStart(),\n          );\n        }\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n  }\n\n  private _getBlockName(): string {\n    // This allows us to capture up something like `@else if`, but not `@ if`.\n    let spacesInNameAllowed = false;\n    const nameCursor = this._cursor.clone();\n\n    this._attemptCharCodeUntilFn((code) => {\n      if (chars.isWhitespace(code)) {\n        return !spacesInNameAllowed;\n      }\n      if (isBlockNameChar(code)) {\n        spacesInNameAllowed = true;\n        return false;\n      }\n      return true;\n    });\n    return this._cursor.getChars(nameCursor).trim();\n  }\n\n  private _consumeBlockStart(start: CharacterCursor) {\n    this._requireCharCode(chars.$AT);\n    this._beginToken(TokenType.BLOCK_OPEN_START, start);\n    const startToken = this._endToken([this._getBlockName()]);\n\n    if (this._cursor.peek() === chars.$LPAREN) {\n      // Advance past the opening paren.\n      this._cursor.advance();\n      // Capture the parameters.\n      this._consumeBlockParameters();\n      // Allow spaces before the closing paren.\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      if (this._attemptCharCode(chars.$RPAREN)) {\n        // Allow spaces after the paren.\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        startToken.type = TokenType.INCOMPLETE_BLOCK_OPEN;\n        return;\n      }\n    }\n\n    if (this._attemptCharCode(chars.$LBRACE)) {\n      this._beginToken(TokenType.BLOCK_OPEN_END);\n      this._endToken([]);\n    } else {\n      startToken.type = TokenType.INCOMPLETE_BLOCK_OPEN;\n    }\n  }\n\n  private _consumeBlockEnd(start: CharacterCursor) {\n    this._beginToken(TokenType.BLOCK_CLOSE, start);\n    this._endToken([]);\n  }\n\n  private _consumeBlockParameters() {\n    // Trim the whitespace until the first parameter.\n    this._attemptCharCodeUntilFn(isBlockParameterChar);\n\n    while (this._cursor.peek() !== chars.$RPAREN && this._cursor.peek() !== chars.$EOF) {\n      this._beginToken(TokenType.BLOCK_PARAMETER);\n      const start = this._cursor.clone();\n      let inQuote: number | null = null;\n      let openParens = 0;\n\n      // Consume the parameter until the next semicolon or brace.\n      // Note that we skip over semicolons/braces inside of strings.\n      while (\n        (this._cursor.peek() !== chars.$SEMICOLON && this._cursor.peek() !== chars.$EOF) ||\n        inQuote !== null\n      ) {\n        const char = this._cursor.peek();\n\n        // Skip to the next character if it was escaped.\n        if (char === chars.$BACKSLASH) {\n          this._cursor.advance();\n        } else if (char === inQuote) {\n          inQuote = null;\n        } else if (inQuote === null && chars.isQuote(char)) {\n          inQuote = char;\n        } else if (char === chars.$LPAREN && inQuote === null) {\n          openParens++;\n        } else if (char === chars.$RPAREN && inQuote === null) {\n          if (openParens === 0) {\n            break;\n          } else if (openParens > 0) {\n            openParens--;\n          }\n        }\n\n        this._cursor.advance();\n      }\n\n      this._endToken([this._cursor.getChars(start)]);\n\n      // Skip to the next parameter.\n      this._attemptCharCodeUntilFn(isBlockParameterChar);\n    }\n  }\n\n  private _consumeLetDeclaration(start: CharacterCursor) {\n    this._requireStr('@let');\n    this._beginToken(TokenType.LET_START, start);\n\n    // Require at least one white space after the `@let`.\n    if (chars.isWhitespace(this._cursor.peek())) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n    } else {\n      const token = this._endToken([this._cursor.getChars(start)]);\n      token.type = TokenType.INCOMPLETE_LET;\n      return;\n    }\n\n    const startToken = this._endToken([this._getLetDeclarationName()]);\n\n    // Skip over white space before the equals character.\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    // Expect an equals sign.\n    if (!this._attemptCharCode(chars.$EQ)) {\n      startToken.type = TokenType.INCOMPLETE_LET;\n      return;\n    }\n\n    // Skip spaces after the equals.\n    this._attemptCharCodeUntilFn((code) => isNotWhitespace(code) && !chars.isNewLine(code));\n    this._consumeLetDeclarationValue();\n\n    // Terminate the `@let` with a semicolon.\n    const endChar = this._cursor.peek();\n    if (endChar === chars.$SEMICOLON) {\n      this._beginToken(TokenType.LET_END);\n      this._endToken([]);\n      this._cursor.advance();\n    } else {\n      startToken.type = TokenType.INCOMPLETE_LET;\n      startToken.sourceSpan = this._cursor.getSpan(start);\n    }\n  }\n\n  private _getLetDeclarationName(): string {\n    const nameCursor = this._cursor.clone();\n    let allowDigit = false;\n\n    this._attemptCharCodeUntilFn((code) => {\n      if (\n        chars.isAsciiLetter(code) ||\n        code === chars.$$ ||\n        code === chars.$_ ||\n        // `@let` names can't start with a digit, but digits are valid anywhere else in the name.\n        (allowDigit && chars.isDigit(code))\n      ) {\n        allowDigit = true;\n        return false;\n      }\n      return true;\n    });\n\n    return this._cursor.getChars(nameCursor).trim();\n  }\n\n  private _consumeLetDeclarationValue(): void {\n    const start = this._cursor.clone();\n    this._beginToken(TokenType.LET_VALUE, start);\n\n    while (this._cursor.peek() !== chars.$EOF) {\n      const char = this._cursor.peek();\n\n      // `@let` declarations terminate with a semicolon.\n      if (char === chars.$SEMICOLON) {\n        break;\n      }\n\n      // If we hit a quote, skip over its content since we don't care what's inside.\n      if (chars.isQuote(char)) {\n        this._cursor.advance();\n        this._attemptCharCodeUntilFn((inner) => {\n          if (inner === chars.$BACKSLASH) {\n            this._cursor.advance();\n            return false;\n          }\n          return inner === char;\n        });\n      }\n\n      this._cursor.advance();\n    }\n\n    this._endToken([this._cursor.getChars(start)]);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (this.isExpansionFormStart()) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._cursor.peek() === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _beginToken(type: TokenType, start = this._cursor.clone()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end?: CharacterCursor): Token {\n    if (this._currentTokenStart === null) {\n      throw new ParseError(\n        this._cursor.getSpan(end),\n        'Programming error - attempted to end a token when there was no start to the token',\n      );\n    }\n    if (this._currentTokenType === null) {\n      throw new ParseError(\n        this._cursor.getSpan(this._currentTokenStart),\n        'Programming error - attempted to end a token which has no token type',\n      );\n    }\n    const token = {\n      type: this._currentTokenType,\n      parts,\n      sourceSpan: (end ?? this._cursor).getSpan(\n        this._currentTokenStart,\n        this._leadingTriviaCodePoints,\n      ),\n    } as Token;\n    this.tokens.push(token);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): ParseError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new ParseError(span, msg);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return error;\n  }\n\n  private handleError(e: any) {\n    if (e instanceof CursorError) {\n      e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n    }\n    if (e instanceof ParseError) {\n      this.errors.push(e);\n    } else {\n      throw e;\n    }\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._cursor.peek() === charCode) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._cursor.clone();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(\n        _unexpectedCharacterErrorMsg(this._cursor.peek()),\n        this._cursor.getSpan(location),\n      );\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const initialPosition = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._cursor = initialPosition;\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._cursor.clone();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(\n        _unexpectedCharacterErrorMsg(this._cursor.peek()),\n        this._cursor.getSpan(location),\n      );\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._cursor.clone();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._cursor.diff(start) < len) {\n      throw this._createError(\n        _unexpectedCharacterErrorMsg(this._cursor.peek()),\n        this._cursor.getSpan(start),\n      );\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._cursor.peek() !== char) {\n      this._cursor.advance();\n    }\n  }\n\n  private _readChar(): string {\n    // Don't rely upon reading directly from `_input` as the actual char value\n    // may have been generated from an escape sequence.\n    const char = String.fromCodePoint(this._cursor.peek());\n    this._cursor.advance();\n    return char;\n  }\n\n  private _peekStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const cursor = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (cursor.peek() !== chars.charCodeAt(i)) {\n        return false;\n      }\n      cursor.advance();\n    }\n    return true;\n  }\n\n  private _isBlockStart(): boolean {\n    return (\n      this._cursor.peek() === chars.$AT &&\n      SUPPORTED_BLOCKS.some((blockName) => this._peekStr(blockName))\n    );\n  }\n\n  private _isLetStart(): boolean {\n    return this._cursor.peek() === chars.$AT && this._peekStr('@let');\n  }\n\n  private _consumeEntity(textTokenType: TokenType): void {\n    this._beginToken(TokenType.ENCODED_ENTITY);\n    const start = this._cursor.clone();\n    this._cursor.advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const codeStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        // Advance cursor to include the peeked character in the string provided to the error\n        // message.\n        this._cursor.advance();\n        const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n        throw this._createError(\n          _unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)),\n          this._cursor.getSpan(),\n        );\n      }\n      const strNum = this._cursor.getChars(codeStart);\n      this._cursor.advance();\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);\n      } catch {\n        throw this._createError(\n          _unknownEntityErrorMsg(this._cursor.getChars(start)),\n          this._cursor.getSpan(),\n        );\n      }\n    } else {\n      const nameStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        // No semicolon was found so abort the encoded entity token that was in progress, and treat\n        // this as a text token\n        this._beginToken(textTokenType, start);\n        this._cursor = nameStart;\n        this._endToken(['&']);\n      } else {\n        const name = this._cursor.getChars(nameStart);\n        this._cursor.advance();\n        const char = NAMED_ENTITIES.hasOwnProperty(name) && NAMED_ENTITIES[name];\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n        }\n        this._endToken([char, `&${name};`]);\n      }\n    }\n  }\n\n  private _consumeRawText(consumeEntities: boolean, endMarkerPredicate: () => boolean): void {\n    this._beginToken(consumeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n    const parts: string[] = [];\n    while (true) {\n      const tagCloseStart = this._cursor.clone();\n      const foundEndMarker = endMarkerPredicate();\n      this._cursor = tagCloseStart;\n      if (foundEndMarker) {\n        break;\n      }\n      if (consumeEntities && this._cursor.peek() === chars.$AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(TokenType.ESCAPABLE_RAW_TEXT);\n        this._beginToken(TokenType.ESCAPABLE_RAW_TEXT);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _consumeComment(start: CharacterCursor) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr('-->'));\n    this._beginToken(TokenType.COMMENT_END);\n    this._requireStr('-->');\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: CharacterCursor) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr(']]>'));\n    this._beginToken(TokenType.CDATA_END);\n    this._requireStr(']]>');\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: CharacterCursor) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    const contentStart = this._cursor.clone();\n    this._attemptUntilChar(chars.$GT);\n    const content = this._cursor.getChars(contentStart);\n    this._cursor.advance();\n    this._endToken([content]);\n  }\n\n  private _consumePrefixAndName(endPredicate: (code: number) => boolean): string[] {\n    const nameOrPrefixStart = this._cursor.clone();\n    let prefix: string = '';\n    while (this._cursor.peek() !== chars.$COLON && !isPrefixEnd(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    let nameStart: CharacterCursor;\n    if (this._cursor.peek() === chars.$COLON) {\n      prefix = this._cursor.getChars(nameOrPrefixStart);\n      this._cursor.advance();\n      nameStart = this._cursor.clone();\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(endPredicate, prefix === '' ? 0 : 1);\n    const name = this._cursor.getChars(nameStart);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: CharacterCursor) {\n    let tagName: string;\n    let prefix: string;\n    let closingTagName: string;\n    let openToken:\n      | TagOpenStartToken\n      | IncompleteTagOpenToken\n      | ComponentOpenStartToken\n      | IncompleteComponentOpenToken\n      | undefined;\n\n    try {\n      if (this._selectorlessEnabled && isSelectorlessNameStart(this._cursor.peek())) {\n        openToken = this._consumeComponentOpenStart(start);\n        [closingTagName, prefix, tagName] = openToken.parts;\n        if (prefix) {\n          closingTagName += `:${prefix}`;\n        }\n        if (tagName) {\n          closingTagName += `:${tagName}`;\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        if (!chars.isAsciiLetter(this._cursor.peek())) {\n          throw this._createError(\n            _unexpectedCharacterErrorMsg(this._cursor.peek()),\n            this._cursor.getSpan(start),\n          );\n        }\n\n        openToken = this._consumeTagOpenStart(start);\n        prefix = openToken.parts[0];\n        tagName = closingTagName = openToken.parts[1];\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n\n      while (!isAttributeTerminator(this._cursor.peek())) {\n        if (this._selectorlessEnabled && this._cursor.peek() === chars.$AT) {\n          const start = this._cursor.clone();\n          const nameStart = start.clone();\n          nameStart.advance();\n\n          if (isSelectorlessNameStart(nameStart.peek())) {\n            this._consumeDirective(start, nameStart);\n          }\n        } else {\n          this._consumeAttribute();\n        }\n      }\n\n      if (openToken.type === TokenType.COMPONENT_OPEN_START) {\n        this._consumeComponentOpenEnd();\n      } else {\n        this._consumeTagOpenEnd();\n      }\n    } catch (e) {\n      if (e instanceof ParseError) {\n        if (openToken) {\n          // We errored before we could close the opening tag, so it is incomplete.\n          openToken.type =\n            openToken.type === TokenType.COMPONENT_OPEN_START\n              ? TokenType.INCOMPLETE_COMPONENT_OPEN\n              : TokenType.INCOMPLETE_TAG_OPEN;\n        } else {\n          // When the start tag is invalid, assume we want a \"<\" as text.\n          // Back to back text tokens are merged at the end.\n          this._beginToken(TokenType.TEXT, start);\n          this._endToken(['<']);\n        }\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(\n    openToken: TagOpenStartToken | ComponentOpenStartToken,\n    tagName: string,\n    consumeEntities: boolean,\n  ) {\n    this._consumeRawText(consumeEntities, () => {\n      if (!this._attemptCharCode(chars.$LT)) return false;\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(tagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(\n      openToken.type === TokenType.COMPONENT_OPEN_START\n        ? TokenType.COMPONENT_CLOSE\n        : TokenType.TAG_CLOSE,\n    );\n    this._requireCharCodeUntilFn((code) => code === chars.$GT, 3);\n    this._cursor.advance(); // Consume the `>`\n    this._endToken(openToken.parts);\n  }\n\n  private _consumeTagOpenStart(start: CharacterCursor): TagOpenStartToken {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName(isNameEnd);\n    return this._endToken(parts) as TagOpenStartToken;\n  }\n\n  private _consumeComponentOpenStart(start: CharacterCursor): ComponentOpenStartToken {\n    this._beginToken(TokenType.COMPONENT_OPEN_START, start);\n    const parts = this._consumeComponentName();\n    return this._endToken(parts) as ComponentOpenStartToken;\n  }\n\n  private _consumeComponentName(): string[] {\n    const nameStart = this._cursor.clone();\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    const name = this._cursor.getChars(nameStart);\n    let prefix = '';\n    let tagName = '';\n    if (this._cursor.peek() === chars.$COLON) {\n      this._cursor.advance();\n      [prefix, tagName] = this._consumePrefixAndName(isNameEnd);\n    }\n    return [name, prefix, tagName];\n  }\n\n  private _consumeAttribute() {\n    this._consumeAttributeName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (this._attemptCharCode(chars.$EQ)) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      this._consumeAttributeValue();\n    }\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeAttributeName() {\n    const attrNameStart = this._cursor.peek();\n    if (attrNameStart === chars.$SQ || attrNameStart === chars.$DQ) {\n      throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n    }\n    this._beginToken(TokenType.ATTR_NAME);\n    let nameEndPredicate: (code: number) => boolean;\n\n    if (this._openDirectiveCount > 0) {\n      // If we're parsing attributes inside of directive syntax, we have to terminate the name\n      // on the first non-matching closing paren. For example, if we have `@Dir(someAttr)`,\n      // `@Dir` and `(` will have already been captured as `DIRECTIVE_NAME` and `DIRECTIVE_OPEN`\n      // respectively, but the `)` will get captured as a part of the name for `someAttr`\n      // because normally that would be an event binding.\n      let openParens = 0;\n      nameEndPredicate = (code: number) => {\n        if (this._openDirectiveCount > 0) {\n          if (code === chars.$LPAREN) {\n            openParens++;\n          } else if (code === chars.$RPAREN) {\n            if (openParens === 0) {\n              return true;\n            }\n            openParens--;\n          }\n        }\n        return isNameEnd(code);\n      };\n    } else if (attrNameStart === chars.$LBRACKET) {\n      let openBrackets = 0;\n\n      // Be more permissive for which characters are allowed inside square-bracketed attributes,\n      // because they usually end up being bound as attribute values. Some third-party packages\n      // like Tailwind take advantage of this.\n      nameEndPredicate = (code: number) => {\n        if (code === chars.$LBRACKET) {\n          openBrackets++;\n        } else if (code === chars.$RBRACKET) {\n          openBrackets--;\n        }\n        // Only check for name-ending characters if the brackets are balanced or mismatched.\n        // Also interrupt the matching on new lines.\n        return openBrackets <= 0 ? isNameEnd(code) : chars.isNewLine(code);\n      };\n    } else {\n      nameEndPredicate = isNameEnd;\n    }\n\n    const prefixAndName = this._consumePrefixAndName(nameEndPredicate);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    if (this._cursor.peek() === chars.$SQ || this._cursor.peek() === chars.$DQ) {\n      const quoteChar = this._cursor.peek();\n      this._consumeQuote(quoteChar);\n      // In an attribute then end of the attribute value and the premature end to an interpolation\n      // are both triggered by the `quoteChar`.\n      const endPredicate = () => this._cursor.peek() === quoteChar;\n      this._consumeWithInterpolation(\n        TokenType.ATTR_VALUE_TEXT,\n        TokenType.ATTR_VALUE_INTERPOLATION,\n        endPredicate,\n        endPredicate,\n      );\n      this._consumeQuote(quoteChar);\n    } else {\n      const endPredicate = () => isNameEnd(this._cursor.peek());\n      this._consumeWithInterpolation(\n        TokenType.ATTR_VALUE_TEXT,\n        TokenType.ATTR_VALUE_INTERPOLATION,\n        endPredicate,\n        endPredicate,\n      );\n    }\n  }\n\n  private _consumeQuote(quoteChar: number) {\n    this._beginToken(TokenType.ATTR_QUOTE);\n    this._requireCharCode(quoteChar);\n    this._endToken([String.fromCodePoint(quoteChar)]);\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType = this._attemptCharCode(chars.$SLASH)\n      ? TokenType.TAG_OPEN_END_VOID\n      : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeComponentOpenEnd() {\n    const tokenType = this._attemptCharCode(chars.$SLASH)\n      ? TokenType.COMPONENT_OPEN_END_VOID\n      : TokenType.COMPONENT_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: CharacterCursor) {\n    if (this._selectorlessEnabled) {\n      const clone = start.clone();\n      while (clone.peek() !== chars.$GT && !isSelectorlessNameStart(clone.peek())) {\n        clone.advance();\n      }\n      if (isSelectorlessNameStart(clone.peek())) {\n        this._beginToken(TokenType.COMPONENT_CLOSE, start);\n        const parts = this._consumeComponentName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode(chars.$GT);\n        this._endToken(parts);\n        return;\n      }\n    }\n\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName(isNameEnd);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const condition = this._readUntil(chars.$COMMA);\n    const normalizedCondition = this._processCarriageReturns(condition);\n    if (this._i18nNormalizeLineEndingsInICUs) {\n      // We explicitly want to normalize line endings for this text.\n      this._endToken([normalizedCondition]);\n    } else {\n      // We are not normalizing line endings.\n      const conditionToken = this._endToken([condition]);\n      if (normalizedCondition !== condition) {\n        this.nonNormalizedIcuExpressions.push(conditionToken);\n      }\n    }\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type]);\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  /**\n   * Consume a string that may contain interpolation expressions.\n   *\n   * The first token consumed will be of `tokenType` and then there will be alternating\n   * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.\n   *\n   * If an interpolation token ends prematurely it will have no end marker in its `parts` array.\n   *\n   * @param textTokenType the kind of tokens to interleave around interpolation tokens.\n   * @param interpolationTokenType the kind of tokens that contain interpolation.\n   * @param endPredicate a function that should return true when we should stop consuming.\n   * @param endInterpolation a function that should return true if there is a premature end to an\n   *     interpolation expression - i.e. before we get to the normal interpolation closing marker.\n   */\n  private _consumeWithInterpolation(\n    textTokenType: TokenType,\n    interpolationTokenType: TokenType,\n    endPredicate: () => boolean,\n    endInterpolation: () => boolean,\n  ) {\n    this._beginToken(textTokenType);\n    const parts: string[] = [];\n\n    while (!endPredicate()) {\n      const current = this._cursor.clone();\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        this._endToken([this._processCarriageReturns(parts.join(''))], current);\n        parts.length = 0;\n        this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n        this._beginToken(textTokenType);\n      } else if (this._cursor.peek() === chars.$AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(textTokenType);\n        this._beginToken(textTokenType);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n\n    // It is possible that an interpolation was started but not ended inside this text token.\n    // Make sure that we reset the state of the lexer correctly.\n    this._inInterpolation = false;\n\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  /**\n   * Consume a block of text that has been interpreted as an Angular interpolation.\n   *\n   * @param interpolationTokenType the type of the interpolation token to generate.\n   * @param interpolationStart a cursor that points to the start of this interpolation.\n   * @param prematureEndPredicate a function that should return true if the next characters indicate\n   *     an end to the interpolation before its normal closing marker.\n   */\n  private _consumeInterpolation(\n    interpolationTokenType: TokenType,\n    interpolationStart: CharacterCursor,\n    prematureEndPredicate: (() => boolean) | null,\n  ): void {\n    const parts: string[] = [];\n    this._beginToken(interpolationTokenType, interpolationStart);\n    parts.push(this._interpolationConfig.start);\n\n    // Find the end of the interpolation, ignoring content inside quotes.\n    const expressionStart = this._cursor.clone();\n    let inQuote: number | null = null;\n    let inComment = false;\n    while (\n      this._cursor.peek() !== chars.$EOF &&\n      (prematureEndPredicate === null || !prematureEndPredicate())\n    ) {\n      const current = this._cursor.clone();\n\n      if (this._isTagStart()) {\n        // We are starting what looks like an HTML element in the middle of this interpolation.\n        // Reset the cursor to before the `<` character and end the interpolation token.\n        // (This is actually wrong but here for backward compatibility).\n        this._cursor = current;\n        parts.push(this._getProcessedChars(expressionStart, current));\n        this._endToken(parts);\n        return;\n      }\n\n      if (inQuote === null) {\n        if (this._attemptStr(this._interpolationConfig.end)) {\n          // We are not in a string, and we hit the end interpolation marker\n          parts.push(this._getProcessedChars(expressionStart, current));\n          parts.push(this._interpolationConfig.end);\n          this._endToken(parts);\n          return;\n        } else if (this._attemptStr('//')) {\n          // Once we are in a comment we ignore any quotes\n          inComment = true;\n        }\n      }\n\n      const char = this._cursor.peek();\n      this._cursor.advance();\n      if (char === chars.$BACKSLASH) {\n        // Skip the next character because it was escaped.\n        this._cursor.advance();\n      } else if (char === inQuote) {\n        // Exiting the current quoted string\n        inQuote = null;\n      } else if (!inComment && inQuote === null && chars.isQuote(char)) {\n        // Entering a new quoted string\n        inQuote = char;\n      }\n    }\n\n    // We hit EOF without finding a closing interpolation marker\n    parts.push(this._getProcessedChars(expressionStart, this._cursor));\n    this._endToken(parts);\n  }\n\n  private _consumeDirective(start: CharacterCursor, nameStart: CharacterCursor) {\n    this._requireCharCode(chars.$AT);\n\n    // Skip over the @ since it's not part of the name.\n    this._cursor.advance();\n\n    // Capture the rest of the name.\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n\n    // Capture the opening token.\n    this._beginToken(TokenType.DIRECTIVE_NAME, start);\n    const name = this._cursor.getChars(nameStart);\n    this._endToken([name]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    // Optionally there might be attributes bound to the specific directive.\n    // Stop parsing if there's no opening character for them.\n    if (this._cursor.peek() !== chars.$LPAREN) {\n      return;\n    }\n\n    this._openDirectiveCount++;\n    this._beginToken(TokenType.DIRECTIVE_OPEN);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    // Capture all the attributes until we hit a closing paren.\n    while (!isAttributeTerminator(this._cursor.peek()) && this._cursor.peek() !== chars.$RPAREN) {\n      this._consumeAttribute();\n    }\n\n    // Trim any trailing whitespace.\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._openDirectiveCount--;\n\n    if (this._cursor.peek() !== chars.$RPAREN) {\n      // Stop parsing, instead of throwing, if we've hit the end of the tag.\n      // This can be handled better later when turning the tokens into AST.\n      if (this._cursor.peek() === chars.$GT || this._cursor.peek() === chars.$SLASH) {\n        return;\n      }\n\n      throw this._createError(\n        _unexpectedCharacterErrorMsg(this._cursor.peek()),\n        this._cursor.getSpan(start),\n      );\n    }\n\n    // Capture the closing token.\n    this._beginToken(TokenType.DIRECTIVE_CLOSE);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _getProcessedChars(start: CharacterCursor, end: CharacterCursor): string {\n    return this._processCarriageReturns(end.getChars(start));\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._isTagStart() || this._cursor.peek() === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (this.isExpansionFormStart()) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._cursor.peek() === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    if (\n      this._tokenizeBlocks &&\n      !this._inInterpolation &&\n      !this._isInExpansion() &&\n      (this._isBlockStart() || this._isLetStart() || this._cursor.peek() === chars.$RBRACE)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if the current cursor is pointing to the start of a tag\n   * (opening/closing/comments/cdata/etc).\n   */\n  private _isTagStart(): boolean {\n    if (this._cursor.peek() === chars.$LT) {\n      // We assume that `<` followed by whitespace is not the start of an HTML element.\n      const tmp = this._cursor.clone();\n      tmp.advance();\n      // If the next character is alphabetic, ! nor / then it is a tag start\n      const code = tmp.peek();\n      if (\n        (chars.$a <= code && code <= chars.$z) ||\n        (chars.$A <= code && code <= chars.$Z) ||\n        code === chars.$SLASH ||\n        code === chars.$BANG\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._cursor.clone();\n    this._attemptUntilChar(char);\n    return this._cursor.getChars(start);\n  }\n\n  private _isInExpansion(): boolean {\n    return this._isInExpansionCase() || this._isInExpansionForm();\n  }\n\n  private _isInExpansionCase(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_CASE_EXP_START\n    );\n  }\n\n  private _isInExpansionForm(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_FORM_START\n    );\n  }\n\n  private isExpansionFormStart(): boolean {\n    if (this._cursor.peek() !== chars.$LBRACE) {\n      return false;\n    }\n    if (this._interpolationConfig) {\n      const start = this._cursor.clone();\n      const isInterpolation = this._attemptStr(this._interpolationConfig.start);\n      this._cursor = start;\n      return !isInterpolation;\n    }\n    return true;\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return (\n    chars.isWhitespace(code) ||\n    code === chars.$GT ||\n    code === chars.$LT ||\n    code === chars.$SLASH ||\n    code === chars.$SQ ||\n    code === chars.$DQ ||\n    code === chars.$EQ ||\n    code === chars.$EOF\n  );\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (\n    (code < chars.$a || chars.$z < code) &&\n    (code < chars.$A || chars.$Z < code) &&\n    (code < chars.$0 || code > chars.$9)\n  );\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek !== chars.$RBRACE;\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction isBlockNameChar(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || code === chars.$_;\n}\n\nfunction isBlockParameterChar(code: number): boolean {\n  return code !== chars.$SEMICOLON && isNotWhitespace(code);\n}\n\nfunction isSelectorlessNameStart(code: number): boolean {\n  return code === chars.$_ || (code >= chars.$A && code <= chars.$Z);\n}\n\nfunction isSelectorlessNameChar(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || code === chars.$_;\n}\n\nfunction isAttributeTerminator(code: number): boolean {\n  return code === chars.$SLASH || code === chars.$GT || code === chars.$LT || code === chars.$EOF;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token | undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (\n      (lastDstToken && lastDstToken.type === TokenType.TEXT && token.type === TokenType.TEXT) ||\n      (lastDstToken &&\n        lastDstToken.type === TokenType.ATTR_VALUE_TEXT &&\n        token.type === TokenType.ATTR_VALUE_TEXT)\n    ) {\n      lastDstToken.parts[0]! += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n\n/**\n * The _Tokenizer uses objects of this type to move through the input text,\n * extracting \"parsed characters\". These could be more than one actual character\n * if the text contains escape sequences.\n */\ninterface CharacterCursor {\n  /** Initialize the cursor. */\n  init(): void;\n  /** The parsed character at the current cursor position. */\n  peek(): number;\n  /** Advance the cursor by one parsed character. */\n  advance(): void;\n  /** Get a span from the marked start point to the current point. */\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan;\n  /** Get the parsed characters from the marked start point to the current point. */\n  getChars(start: this): string;\n  /** The number of characters left before the end of the cursor. */\n  charsLeft(): number;\n  /** The number of characters between `this` cursor and `other` cursor. */\n  diff(other: this): number;\n  /** Make a copy of this cursor */\n  clone(): CharacterCursor;\n}\n\ninterface CursorState {\n  peek: number;\n  offset: number;\n  line: number;\n  column: number;\n}\n\nclass PlainCharacterCursor implements CharacterCursor {\n  protected state: CursorState;\n  protected file: ParseSourceFile;\n  protected input: string;\n  protected end: number;\n\n  constructor(fileOrCursor: PlainCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile | PlainCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n\n      const state = fileOrCursor.state;\n      // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n      // called in tight loops, this difference matters.\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column,\n      };\n    } else {\n      if (!range) {\n        throw new Error(\n          'Programming error: the range argument must be provided with a file argument.',\n        );\n      }\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol,\n      };\n    }\n  }\n\n  clone(): PlainCharacterCursor {\n    return new PlainCharacterCursor(this);\n  }\n\n  peek() {\n    return this.state.peek;\n  }\n  charsLeft() {\n    return this.end - this.state.offset;\n  }\n  diff(other: this) {\n    return this.state.offset - other.state.offset;\n  }\n\n  advance(): void {\n    this.advanceState(this.state);\n  }\n\n  init(): void {\n    this.updatePeek(this.state);\n  }\n\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan {\n    start = start || this;\n    let fullStart = start;\n    if (leadingTriviaCodePoints) {\n      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n        if (fullStart === start) {\n          start = start.clone() as this;\n        }\n        start.advance();\n      }\n    }\n    const startLocation = this.locationFromCursor(start);\n    const endLocation = this.locationFromCursor(this);\n    const fullStartLocation =\n      fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n    return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n  }\n\n  getChars(start: this): string {\n    return this.input.substring(start.state.offset, this.state.offset);\n  }\n\n  charAt(pos: number): number {\n    return this.input.charCodeAt(pos);\n  }\n\n  protected advanceState(state: CursorState) {\n    if (state.offset >= this.end) {\n      this.state = state;\n      throw new CursorError('Unexpected character \"EOF\"', this);\n    }\n    const currentChar = this.charAt(state.offset);\n    if (currentChar === chars.$LF) {\n      state.line++;\n      state.column = 0;\n    } else if (!chars.isNewLine(currentChar)) {\n      state.column++;\n    }\n    state.offset++;\n    this.updatePeek(state);\n  }\n\n  protected updatePeek(state: CursorState): void {\n    state.peek = state.offset >= this.end ? chars.$EOF : this.charAt(state.offset);\n  }\n\n  private locationFromCursor(cursor: this): ParseLocation {\n    return new ParseLocation(\n      cursor.file,\n      cursor.state.offset,\n      cursor.state.line,\n      cursor.state.column,\n    );\n  }\n}\n\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n  protected internalState: CursorState;\n\n  constructor(fileOrCursor: EscapedCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile | EscapedCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      super(fileOrCursor);\n      this.internalState = {...fileOrCursor.internalState};\n    } else {\n      super(fileOrCursor, range!);\n      this.internalState = this.state;\n    }\n  }\n\n  override advance(): void {\n    this.state = this.internalState;\n    super.advance();\n    this.processEscapeSequence();\n  }\n\n  override init(): void {\n    super.init();\n    this.processEscapeSequence();\n  }\n\n  override clone(): EscapedCharacterCursor {\n    return new EscapedCharacterCursor(this);\n  }\n\n  override getChars(start: this): string {\n    const cursor = start.clone();\n    let chars = '';\n    while (cursor.internalState.offset < this.internalState.offset) {\n      chars += String.fromCodePoint(cursor.peek());\n      cursor.advance();\n    }\n    return chars;\n  }\n\n  /**\n   * Process the escape sequence that starts at the current position in the text.\n   *\n   * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n   */\n  protected processEscapeSequence(): void {\n    const peek = () => this.internalState.peek;\n\n    if (peek() === chars.$BACKSLASH) {\n      // We have hit an escape sequence so we need the internal state to become independent\n      // of the external state.\n      this.internalState = {...this.state};\n\n      // Move past the backslash\n      this.advanceState(this.internalState);\n\n      // First check for standard control char sequences\n      if (peek() === chars.$n) {\n        this.state.peek = chars.$LF;\n      } else if (peek() === chars.$r) {\n        this.state.peek = chars.$CR;\n      } else if (peek() === chars.$v) {\n        this.state.peek = chars.$VTAB;\n      } else if (peek() === chars.$t) {\n        this.state.peek = chars.$TAB;\n      } else if (peek() === chars.$b) {\n        this.state.peek = chars.$BSPACE;\n      } else if (peek() === chars.$f) {\n        this.state.peek = chars.$FF;\n      }\n\n      // Now consider more complex sequences\n      else if (peek() === chars.$u) {\n        // Unicode code-point sequence\n        this.advanceState(this.internalState); // advance past the `u` char\n        if (peek() === chars.$LBRACE) {\n          // Variable length Unicode, e.g. `\\x{123}`\n          this.advanceState(this.internalState); // advance past the `{` char\n          // Advance past the variable number of hex digits until we hit a `}` char\n          const digitStart = this.clone();\n          let length = 0;\n          while (peek() !== chars.$RBRACE) {\n            this.advanceState(this.internalState);\n            length++;\n          }\n          this.state.peek = this.decodeHexDigits(digitStart, length);\n        } else {\n          // Fixed length Unicode, e.g. `\\u1234`\n          const digitStart = this.clone();\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.state.peek = this.decodeHexDigits(digitStart, 4);\n        }\n      } else if (peek() === chars.$x) {\n        // Hex char code, e.g. `\\x2F`\n        this.advanceState(this.internalState); // advance past the `x` char\n        const digitStart = this.clone();\n        this.advanceState(this.internalState);\n        this.state.peek = this.decodeHexDigits(digitStart, 2);\n      } else if (chars.isOctalDigit(peek())) {\n        // Octal char code, e.g. `\\012`,\n        let octal = '';\n        let length = 0;\n        let previous = this.clone();\n        while (chars.isOctalDigit(peek()) && length < 3) {\n          previous = this.clone();\n          octal += String.fromCodePoint(peek());\n          this.advanceState(this.internalState);\n          length++;\n        }\n        this.state.peek = parseInt(octal, 8);\n        // Backup one char\n        this.internalState = previous.internalState;\n      } else if (chars.isNewLine(this.internalState.peek)) {\n        // Line continuation `\\` followed by a new line\n        this.advanceState(this.internalState); // advance over the newline\n        this.state = this.internalState;\n      } else {\n        // If none of the `if` blocks were executed then we just have an escaped normal character.\n        // In that case we just, effectively, skip the backslash from the character.\n        this.state.peek = this.internalState.peek;\n      }\n    }\n  }\n\n  protected decodeHexDigits(start: EscapedCharacterCursor, length: number): number {\n    const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);\n    const charCode = parseInt(hex, 16);\n    if (!isNaN(charCode)) {\n      return charCode;\n    } else {\n      start.state = start.internalState;\n      throw new CursorError('Invalid hexadecimal escape sequence', start);\n    }\n  }\n}\n\nexport class CursorError extends Error {\n  constructor(\n    public msg: string,\n    public cursor: CharacterCursor,\n  ) {\n    super(msg);\n\n    // Extending `Error` does not always work when code is transpiled. See:\n    // https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n"]}