{"version":3,"file":"constant_pool.js","sourceRoot":"","sources":["constant_pool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from './output/output_ast';\n\nconst CONSTANT_PREFIX = '_c';\n\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = o.variable('<unknown>');\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  shared = false;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): FixupExpression {\n    throw new Error(`Not supported.`);\n  }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private sharedConstants = new Map<string, o.Expression>();\n\n  /**\n   * Constant pool also tracks claimed names from {@link uniqueName}.\n   * This is useful to avoid collisions if variables are intended to be\n   * named a certain way- but may conflict. We wouldn't want to always suffix\n   * them with unique numbers.\n   */\n  private _claimedNames = new Map<string, number>();\n\n  private nextNameIndex = 0;\n\n  constructor(private readonly isClosureCompilerEnabled: boolean = false) {}\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if (\n      (literal instanceof o.LiteralExpr && !isLongStringLiteral(literal)) ||\n      literal instanceof FixupExpression\n    ) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = GenericKeyFn.INSTANCE.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      let value: o.Expression;\n      let usage: o.Expression;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        // For string literals, Closure will **always** inline the string at\n        // **all** usages, duplicating it each time. For large strings, this\n        // unnecessarily bloats bundle size. To work around this restriction, we\n        // wrap the string in a function, and call that function for each usage.\n        // This tricks Closure into using inline logic for functions instead of\n        // string literals. Function calls are only inlined if the body is small\n        // enough to be worth it. By doing this, very large strings will be\n        // shared across multiple usages, rather than duplicating the string at\n        // each usage site.\n        //\n        // const myStr = function() { return \"very very very long string\"; };\n        // const usage1 = myStr();\n        // const usage2 = myStr();\n        value = new o.FunctionExpr(\n          [], // Params.\n          [\n            // Statements.\n            new o.ReturnStatement(literal),\n          ],\n        );\n        usage = o.variable(name).callFn([]);\n      } else {\n        // Just declare and use the variable directly, without a function call\n        // indirection. This saves a few bytes and avoids an unnecessary call.\n        value = literal;\n        usage = o.variable(name);\n      }\n\n      this.statements.push(\n        new o.DeclareVarStmt(name, value, o.INFERRED_TYPE, o.StmtModifier.Final),\n      );\n      fixup.fixup(usage);\n    }\n\n    return fixup;\n  }\n\n  getSharedConstant(def: SharedConstantDefinition, expr: o.Expression): o.Expression {\n    const key = def.keyOf(expr);\n    if (!this.sharedConstants.has(key)) {\n      const id = this.freshName();\n      this.sharedConstants.set(key, o.variable(id));\n      this.statements.push(def.toSharedConstantDeclaration(id, expr));\n    }\n    return this.sharedConstants.get(key)!;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr | o.LiteralMapExpr): {\n    literalFactory: o.Expression;\n    literalFactoryArguments: o.Expression[];\n  } {\n    // Create a pure function that builds an array of a mix of constant and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map((e) => (e.isConstant() ? e : UNKNOWN_VALUE_KEY));\n      const key = GenericKeyFn.INSTANCE.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, (entries) => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n        literal.entries.map((e) => ({\n          key: e.key,\n          value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n          quoted: e.quoted,\n        })),\n      );\n      const key = GenericKeyFn.INSTANCE.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n        key,\n        literal.entries.map((e) => e.value),\n        (entries) =>\n          o.literalMap(\n            entries.map((value, index) => ({\n              key: literal.entries[index].key,\n              value,\n              quoted: literal.entries[index].quoted,\n            })),\n          ),\n      );\n    }\n  }\n\n  // TODO: useUniqueName(false) is necessary for naming compatibility with\n  // TemplateDefinitionBuilder, but should be removed once Template Pipeline is the default.\n  getSharedFunctionReference(\n    fn: o.Expression,\n    prefix: string,\n    useUniqueName: boolean = true,\n  ): o.Expression {\n    const isArrow = fn instanceof o.ArrowFunctionExpr;\n\n    for (const current of this.statements) {\n      // Arrow functions are saved as variables so we check if the\n      // value of the variable is the same as the arrow function.\n      if (isArrow && current instanceof o.DeclareVarStmt && current.value?.isEquivalent(fn)) {\n        return o.variable(current.name);\n      }\n\n      // Function declarations are saved as function statements\n      // so we compare them directly to the passed-in function.\n      if (\n        !isArrow &&\n        current instanceof o.DeclareFunctionStmt &&\n        fn instanceof o.FunctionExpr &&\n        fn.isEquivalent(current)\n      ) {\n        return o.variable(current.name);\n      }\n    }\n\n    // Otherwise declare the function.\n    const name = useUniqueName ? this.uniqueName(prefix) : prefix;\n    this.statements.push(\n      fn instanceof o.FunctionExpr\n        ? fn.toDeclStmt(name, o.StmtModifier.Final)\n        : new o.DeclareVarStmt(name, fn, o.INFERRED_TYPE, o.StmtModifier.Final, fn.sourceSpan),\n    );\n    return o.variable(name);\n  }\n\n  private _getLiteralFactory(\n    key: string,\n    values: o.Expression[],\n    resultMap: (parameters: o.Expression[]) => o.Expression,\n  ): {literalFactory: o.Expression; literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e) => !e.isConstant());\n    if (!literalFactory) {\n      const resultExpressions = values.map((e, index) =>\n        e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`),\n      );\n      const parameters = resultExpressions\n        .filter(isVariable)\n        .map((e) => new o.FnParam(e.name!, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration = o.arrowFn(\n        parameters,\n        resultMap(resultExpressions),\n        o.INFERRED_TYPE,\n      );\n      const name = this.freshName();\n      this.statements.push(\n        new o.DeclareVarStmt(name, pureFunctionDeclaration, o.INFERRED_TYPE, o.StmtModifier.Final),\n      );\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name in the context of this pool.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(name: string, alwaysIncludeSuffix = true): string {\n    const count = this._claimedNames.get(name) ?? 0;\n    const result = count === 0 && !alwaysIncludeSuffix ? `${name}` : `${name}${count}`;\n\n    this._claimedNames.set(name, count + 1);\n    return result;\n  }\n\n  private freshName(): string {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n}\n\nexport interface ExpressionKeyFn {\n  keyOf(expr: o.Expression): string;\n}\n\nexport interface SharedConstantDefinition extends ExpressionKeyFn {\n  toSharedConstantDeclaration(declName: string, keyExpr: o.Expression): o.Statement;\n}\n\nexport class GenericKeyFn implements ExpressionKeyFn {\n  static readonly INSTANCE = new GenericKeyFn();\n\n  keyOf(expr: o.Expression): string {\n    if (expr instanceof o.LiteralExpr && typeof expr.value === 'string') {\n      return `\"${expr.value}\"`;\n    } else if (expr instanceof o.LiteralExpr) {\n      return String(expr.value);\n    } else if (expr instanceof o.RegularExpressionLiteral) {\n      return `/${expr.body}/${expr.flags ?? ''}`;\n    } else if (expr instanceof o.LiteralArrayExpr) {\n      const entries: string[] = [];\n      for (const entry of expr.entries) {\n        entries.push(this.keyOf(entry));\n      }\n      return `[${entries.join(',')}]`;\n    } else if (expr instanceof o.LiteralMapExpr) {\n      const entries: string[] = [];\n      for (const entry of expr.entries) {\n        let key = entry.key;\n        if (entry.quoted) {\n          key = `\"${key}\"`;\n        }\n        entries.push(key + ':' + this.keyOf(entry.value));\n      }\n      return `{${entries.join(',')}}`;\n    } else if (expr instanceof o.ExternalExpr) {\n      return `import(\"${expr.value.moduleName}\", ${expr.value.name})`;\n    } else if (expr instanceof o.ReadVarExpr) {\n      return `read(${expr.name})`;\n    } else if (expr instanceof o.TypeofExpr) {\n      return `typeof(${this.keyOf(expr.expr)})`;\n    } else {\n      throw new Error(\n        `${this.constructor.name} does not handle expressions of type ${expr.constructor.name}`,\n      );\n    }\n  }\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\nfunction isLongStringLiteral(expr: o.Expression): boolean {\n  return (\n    expr instanceof o.LiteralExpr &&\n    typeof expr.value === 'string' &&\n    expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS\n  );\n}\n"]}