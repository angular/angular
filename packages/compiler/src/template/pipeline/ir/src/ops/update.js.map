{"version":3,"file":"update.js","sourceRoot":"","sources":["update.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../../../../../core';\nimport * as i18n from '../../../../../i18n/i18n_ast';\nimport * as o from '../../../../../output/output_ast';\nimport {ParseSourceSpan} from '../../../../../parse_util';\nimport {\n  AnimationBindingKind,\n  AnimationKind,\n  BindingKind,\n  DeferOpModifierKind,\n  I18nExpressionFor,\n  I18nParamResolutionTime,\n  OpKind,\n  TemplateKind,\n} from '../enums';\nimport type {ConditionalCaseExpr} from '../expression';\nimport {SlotHandle} from '../handle';\nimport {Op, XrefId} from '../operations';\nimport {\n  ConsumesVarsTrait,\n  DependsOnSlotContextOpTrait,\n  TRAIT_CONSUMES_VARS,\n  TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n} from '../traits';\nimport type {DomPropertyOp} from './host';\nimport {ListEndOp, NEW_OP, StatementOp, VariableOp} from './shared';\n\n/**\n * An operation usable on the update side of the IR.\n */\nexport type UpdateOp =\n  | ListEndOp<UpdateOp>\n  | StatementOp<UpdateOp>\n  | PropertyOp\n  | TwoWayPropertyOp\n  | AttributeOp\n  | StylePropOp\n  | ClassPropOp\n  | StyleMapOp\n  | ClassMapOp\n  | InterpolateTextOp\n  | AdvanceOp\n  | VariableOp<UpdateOp>\n  | BindingOp\n  | DomPropertyOp\n  | ConditionalOp\n  | I18nExpressionOp\n  | I18nApplyOp\n  | RepeaterOp\n  | DeferWhenOp\n  | AnimationBindingOp\n  | StoreLetOp;\n\n/**\n * A logical operation to perform string interpolation on a text node.\n *\n * Interpolation inputs are stored as static `string`s and dynamic `o.Expression`s, in separate\n * arrays. Thus, the interpolation `A{{b}}C{{d}}E` is stored as 3 static strings `['A', 'C', 'E']`\n * and 2 dynamic expressions `[b, d]`.\n */\nexport interface InterpolateTextOp extends Op<UpdateOp>, ConsumesVarsTrait {\n  kind: OpKind.InterpolateText;\n\n  /**\n   * Reference to the text node to which the interpolation is bound.\n   */\n  target: XrefId;\n\n  /**\n   * The interpolated value.\n   */\n  interpolation: Interpolation;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `InterpolationTextOp`.\n */\nexport function createInterpolateTextOp(\n  xref: XrefId,\n  interpolation: Interpolation,\n  sourceSpan: ParseSourceSpan,\n): InterpolateTextOp {\n  return {\n    kind: OpKind.InterpolateText,\n    target: xref,\n    interpolation,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\nexport class Interpolation {\n  constructor(\n    readonly strings: string[],\n    readonly expressions: o.Expression[],\n    readonly i18nPlaceholders: string[],\n  ) {\n    if (i18nPlaceholders.length !== 0 && i18nPlaceholders.length !== expressions.length) {\n      throw new Error(\n        `Expected ${expressions.length} placeholders to match interpolation expression count, but got ${i18nPlaceholders.length}`,\n      );\n    }\n  }\n}\n\n/**\n * An intermediate binding op, that has not yet been processed into an individual property,\n * attribute, style, etc.\n */\nexport interface BindingOp extends Op<UpdateOp> {\n  kind: OpKind.Binding;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   *  The kind of binding represented by this op.\n   */\n  bindingKind: BindingKind;\n\n  /**\n   *  The name of this binding.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  /**\n   * The unit of the bound value.\n   */\n  unit: string | null;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * Whether the binding is a TextAttribute (e.g. `some-attr=\"some-value\"`).\n   *\n   * This needs to be tracked for compatibility with `TemplateDefinitionBuilder` which treats\n   * `style` and `class` TextAttributes differently from `[attr.style]` and `[attr.class]`.\n   */\n  isTextAttribute: boolean;\n\n  isStructuralTemplateAttribute: boolean;\n\n  /**\n   * Whether this binding is on a structural template.\n   */\n  templateKind: TemplateKind | null;\n\n  i18nContext: XrefId | null;\n  i18nMessage: i18n.Message | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `BindingOp`, not yet transformed into a particular type of binding.\n */\nexport function createBindingOp(\n  target: XrefId,\n  kind: BindingKind,\n  name: string,\n  expression: o.Expression | Interpolation,\n  unit: string | null,\n  securityContext: SecurityContext | SecurityContext[],\n  isTextAttribute: boolean,\n  isStructuralTemplateAttribute: boolean,\n  templateKind: TemplateKind | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): BindingOp {\n  return {\n    kind: OpKind.Binding,\n    bindingKind: kind,\n    target,\n    name,\n    expression,\n    unit,\n    securityContext,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a property in the update IR.\n */\nexport interface PropertyOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.Property;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  /**\n   * Whether this property is an animation trigger.\n   */\n  bindingKind: BindingKind;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this property.\n   */\n  sanitizer: o.Expression | null;\n\n  isStructuralTemplateAttribute: boolean;\n\n  /**\n   * The kind of template targeted by the binding, or null if this binding does not target a\n   * template.\n   */\n  templateKind: TemplateKind | null;\n\n  i18nContext: XrefId | null;\n  i18nMessage: i18n.Message | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `PropertyOp`.\n */\nexport function createPropertyOp(\n  target: XrefId,\n  name: string,\n  expression: o.Expression | Interpolation,\n  bindingKind: BindingKind,\n  securityContext: SecurityContext | SecurityContext[],\n  isStructuralTemplateAttribute: boolean,\n  templateKind: TemplateKind | null,\n  i18nContext: XrefId | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): PropertyOp {\n  return {\n    kind: OpKind.Property,\n    target,\n    name,\n    expression,\n    bindingKind,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing the property binding side of a two-way binding in the update IR.\n */\nexport interface TwoWayPropertyOp\n  extends Op<UpdateOp>,\n    ConsumesVarsTrait,\n    DependsOnSlotContextOpTrait {\n  kind: OpKind.TwoWayProperty;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this property.\n   */\n  sanitizer: o.Expression | null;\n\n  isStructuralTemplateAttribute: boolean;\n\n  /**\n   * The kind of template targeted by the binding, or null if this binding does not target a\n   * template.\n   */\n  templateKind: TemplateKind | null;\n\n  i18nContext: XrefId | null;\n  i18nMessage: i18n.Message | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `TwoWayPropertyOp`.\n */\nexport function createTwoWayPropertyOp(\n  target: XrefId,\n  name: string,\n  expression: o.Expression,\n  securityContext: SecurityContext | SecurityContext[],\n  isStructuralTemplateAttribute: boolean,\n  templateKind: TemplateKind | null,\n  i18nContext: XrefId | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): TwoWayPropertyOp {\n  return {\n    kind: OpKind.TwoWayProperty,\n    target,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a style property in the update IR.\n */\nexport interface StylePropOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.StyleProp;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  /**\n   * The unit of the bound value.\n   */\n  unit: string | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/** Create a `StylePropOp`. */\nexport function createStylePropOp(\n  xref: XrefId,\n  name: string,\n  expression: o.Expression | Interpolation,\n  unit: string | null,\n  sourceSpan: ParseSourceSpan,\n): StylePropOp {\n  return {\n    kind: OpKind.StyleProp,\n    target: xref,\n    name,\n    expression,\n    unit,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a class property in the update IR.\n */\nexport interface ClassPropOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.ClassProp;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `ClassPropOp`.\n */\nexport function createClassPropOp(\n  xref: XrefId,\n  name: string,\n  expression: o.Expression,\n  sourceSpan: ParseSourceSpan,\n): ClassPropOp {\n  return {\n    kind: OpKind.ClassProp,\n    target: xref,\n    name,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a style map in the update IR.\n */\nexport interface StyleMapOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.StyleMap;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/** Create a `StyleMapOp`. */\nexport function createStyleMapOp(\n  xref: XrefId,\n  expression: o.Expression | Interpolation,\n  sourceSpan: ParseSourceSpan,\n): StyleMapOp {\n  return {\n    kind: OpKind.StyleMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a style map in the update IR.\n */\nexport interface ClassMapOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.ClassMap;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `ClassMapOp`.\n */\nexport function createClassMapOp(\n  xref: XrefId,\n  expression: o.Expression | Interpolation,\n  sourceSpan: ParseSourceSpan,\n): ClassMapOp {\n  return {\n    kind: OpKind.ClassMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing setting an attribute on an element in the update IR.\n */\nexport interface AttributeOp extends Op<UpdateOp> {\n  kind: OpKind.Attribute;\n\n  /**\n   * The `XrefId` of the template-like element the attribute will belong to.\n   */\n  target: XrefId;\n\n  /**\n   * The namespace of the attribute (or null if none).\n   */\n  namespace: string | null;\n\n  /**\n   * The name of the attribute.\n   */\n  name: string;\n\n  /**\n   * The value of the attribute.\n   */\n  expression: o.Expression | Interpolation;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this attribute.\n   */\n  sanitizer: o.Expression | null;\n\n  /**\n   * Whether the binding is a TextAttribute (e.g. `some-attr=\"some-value\"`).\n   *\n   * This needs to be tracked for compatibility with `TemplateDefinitionBuilder` which treats\n   * `style` and `class` TextAttributes differently from `[attr.style]` and `[attr.class]`.\n   */\n  isTextAttribute: boolean;\n\n  isStructuralTemplateAttribute: boolean;\n\n  /**\n   * The kind of template targeted by the binding, or null if this binding does not target a\n   * template.\n   */\n  templateKind: TemplateKind | null;\n\n  /**\n   * The i18n context, if this is an i18n attribute.\n   */\n  i18nContext: XrefId | null;\n\n  i18nMessage: i18n.Message | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `AttributeOp`.\n */\nexport function createAttributeOp(\n  target: XrefId,\n  namespace: string | null,\n  name: string,\n  expression: o.Expression | Interpolation,\n  securityContext: SecurityContext | SecurityContext[],\n  isTextAttribute: boolean,\n  isStructuralTemplateAttribute: boolean,\n  templateKind: TemplateKind | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): AttributeOp {\n  return {\n    kind: OpKind.Attribute,\n    target,\n    namespace,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation to advance the runtime's internal slot pointer in the update IR.\n */\nexport interface AdvanceOp extends Op<UpdateOp> {\n  kind: OpKind.Advance;\n\n  /**\n   * Delta by which to advance the pointer.\n   */\n  delta: number;\n\n  // Source span of the binding that caused the advance\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `AdvanceOp`.\n */\nexport function createAdvanceOp(delta: number, sourceSpan: ParseSourceSpan): AdvanceOp {\n  return {\n    kind: OpKind.Advance,\n    delta,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing a conditional expression in the update IR.\n */\nexport interface ConditionalOp\n  extends Op<ConditionalOp>,\n    DependsOnSlotContextOpTrait,\n    ConsumesVarsTrait {\n  kind: OpKind.Conditional;\n\n  /**\n   * The insertion point, which is the first template in the creation block belonging to this\n   * condition.\n   */\n  target: XrefId;\n\n  /**\n   * The main test expression (for a switch), or `null` (for an if, which has no test\n   * expression).\n   */\n  test: o.Expression | null;\n\n  /**\n   * Each possible embedded view that could be displayed has a condition (or is default). This\n   * structure maps each view xref to its corresponding condition.\n   */\n  conditions: Array<ConditionalCaseExpr>;\n\n  /**\n   * After processing, this will be a single collapsed Joost-expression that evaluates the\n   * conditions, and yields the slot number of the template which should be displayed.\n   */\n  processed: o.Expression | null;\n\n  /**\n   * Control flow conditionals can accept a context value (this is a result of specifying an\n   * alias). This expression will be passed to the conditional instruction's context parameter.\n   */\n  contextValue: o.Expression | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a conditional op, which will display an embedded view according to a condtion.\n */\nexport function createConditionalOp(\n  target: XrefId,\n  test: o.Expression | null,\n  conditions: Array<ConditionalCaseExpr>,\n  sourceSpan: ParseSourceSpan,\n): ConditionalOp {\n  return {\n    kind: OpKind.Conditional,\n    target,\n    test,\n    conditions,\n    processed: null,\n    sourceSpan,\n    contextValue: null,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n  };\n}\n\nexport interface RepeaterOp extends Op<UpdateOp>, DependsOnSlotContextOpTrait {\n  kind: OpKind.Repeater;\n\n  /**\n   * The RepeaterCreate op associated with this repeater.\n   */\n  target: XrefId;\n\n  targetSlot: SlotHandle;\n\n  /**\n   * The collection provided to the for loop as its expression.\n   */\n  collection: o.Expression;\n\n  sourceSpan: ParseSourceSpan;\n}\n\nexport function createRepeaterOp(\n  repeaterCreate: XrefId,\n  targetSlot: SlotHandle,\n  collection: o.Expression,\n  sourceSpan: ParseSourceSpan,\n): RepeaterOp {\n  return {\n    kind: OpKind.Repeater,\n    target: repeaterCreate,\n    targetSlot,\n    collection,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n  };\n}\n\n/**\n * A logical operation representing binding to an animation in the update IR.\n */\nexport interface AnimationBindingOp extends Op<UpdateOp> {\n  kind: OpKind.AnimationBinding;\n\n  /**\n   * The name of the extracted attribute.\n   */\n  name: string;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  animationKind: AnimationKind;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  i18nMessage: XrefId | null;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this property.\n   */\n  sanitizer: o.Expression | null;\n\n  sourceSpan: ParseSourceSpan;\n\n  animationBindingKind: AnimationBindingKind;\n}\n\n/**\n * Create an `AnimationBindingOp`.\n */\nexport function createAnimationBindingOp(\n  name: string,\n  target: XrefId,\n  animationKind: AnimationKind,\n  expression: o.Expression | Interpolation,\n  securityContext: SecurityContext | SecurityContext[],\n  sourceSpan: ParseSourceSpan,\n  animationBindingKind: AnimationBindingKind,\n): AnimationBindingOp {\n  return {\n    kind: OpKind.AnimationBinding,\n    name,\n    target,\n    animationKind,\n    expression,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    animationBindingKind,\n    ...NEW_OP,\n  };\n}\n\nexport interface DeferWhenOp extends Op<UpdateOp>, DependsOnSlotContextOpTrait, ConsumesVarsTrait {\n  kind: OpKind.DeferWhen;\n\n  /**\n   * The `defer` create op associated with this when condition.\n   */\n  target: XrefId;\n\n  /**\n   * A user-provided expression that triggers the defer op.\n   */\n  expr: o.Expression;\n\n  /**\n   * Modifier set on the trigger by the user (e.g. `hydrate`, `prefetch` etc).\n   */\n  modifier: DeferOpModifierKind;\n\n  sourceSpan: ParseSourceSpan;\n}\n\nexport function createDeferWhenOp(\n  target: XrefId,\n  expr: o.Expression,\n  modifier: DeferOpModifierKind,\n  sourceSpan: ParseSourceSpan,\n): DeferWhenOp {\n  return {\n    kind: OpKind.DeferWhen,\n    target,\n    expr,\n    modifier,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n  };\n}\n\n/**\n * An op that represents an expression in an i18n message.\n *\n * TODO: This can represent expressions used in both i18n attributes and normal i18n content. We\n * may want to split these into two different op types, deriving from the same base class.\n */\nexport interface I18nExpressionOp\n  extends Op<UpdateOp>,\n    ConsumesVarsTrait,\n    DependsOnSlotContextOpTrait {\n  kind: OpKind.I18nExpression;\n\n  /**\n   * The i18n context that this expression belongs to.\n   */\n  context: XrefId;\n\n  /**\n   * The Xref of the op that we need to `advance` to.\n   *\n   * In an i18n block, this is initially the i18n start op, but will eventually correspond to\n   * the final slot consumer in the owning i18n block.\n   * TODO: We should make text i18nExpressions target the i18nEnd instruction, instead the last\n   * slot consumer in the i18n block. This makes them resilient to that last consumer being\n   * deleted. (Or new slot consumers being added!)\n   *\n   * In an i18n attribute, this is the xref of the corresponding elementStart/element.\n   */\n  target: XrefId;\n\n  /**\n   * In an i18n block, this should be the i18n start op.\n   *\n   * In an i18n attribute, this will be the xref of the attribute configuration instruction.\n   */\n  i18nOwner: XrefId;\n\n  /**\n   * A handle for the slot that this expression modifies.\n   * - In an i18n block, this is the handle of the block.\n   * - In an i18n attribute, this is the handle of the corresponding i18nAttributes instruction.\n   */\n  handle: SlotHandle;\n\n  /**\n   * The expression value.\n   */\n  expression: o.Expression;\n\n  icuPlaceholder: XrefId | null;\n\n  /**\n   * The i18n placeholder associated with this expression. This can be null if the expression is\n   * part of an ICU placeholder. In this case it gets combined with the string literal value and\n   * other expressions in the ICU placeholder and assigned to the translated message under the ICU\n   * placeholder name.\n   */\n  i18nPlaceholder: string | null;\n\n  /**\n   * The time that this expression is resolved.\n   */\n  resolutionTime: I18nParamResolutionTime;\n\n  /**\n   * Whether this i18n expression applies to a template or to a binding.\n   */\n  usage: I18nExpressionFor;\n\n  /**\n   * If this is an I18nExpressionContext.Binding, this expression is associated with a named\n   * attribute. That name is stored here.\n   */\n  name: string;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an i18n expression op.\n */\nexport function createI18nExpressionOp(\n  context: XrefId,\n  target: XrefId,\n  i18nOwner: XrefId,\n  handle: SlotHandle,\n  expression: o.Expression,\n  icuPlaceholder: XrefId | null,\n  i18nPlaceholder: string | null,\n  resolutionTime: I18nParamResolutionTime,\n  usage: I18nExpressionFor,\n  name: string,\n  sourceSpan: ParseSourceSpan,\n): I18nExpressionOp {\n  return {\n    kind: OpKind.I18nExpression,\n    context,\n    target,\n    i18nOwner,\n    handle,\n    expression,\n    icuPlaceholder,\n    i18nPlaceholder,\n    resolutionTime,\n    usage,\n    name,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_VARS,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n  };\n}\n\n/**\n * An op that represents applying a set of i18n expressions.\n */\nexport interface I18nApplyOp extends Op<UpdateOp> {\n  kind: OpKind.I18nApply;\n\n  /**\n   * In an i18n block, this should be the i18n start op.\n   *\n   * In an i18n attribute, this will be the xref of the attribute configuration instruction.\n   */\n  owner: XrefId;\n\n  /**\n   * A handle for the slot that i18n apply instruction should apply to. In an i18n block, this\n   * is the slot of the i18n block this expression belongs to. In an i18n attribute, this is the\n   * slot of the corresponding i18nAttributes instruction.\n   */\n  handle: SlotHandle;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Creates an op to apply i18n expression ops.\n */\nexport function createI18nApplyOp(\n  owner: XrefId,\n  handle: SlotHandle,\n  sourceSpan: ParseSourceSpan,\n): I18nApplyOp {\n  return {\n    kind: OpKind.I18nApply,\n    owner,\n    handle,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Op to store the current value of a `@let` declaration.\n */\nexport interface StoreLetOp extends Op<UpdateOp>, ConsumesVarsTrait {\n  kind: OpKind.StoreLet;\n  sourceSpan: ParseSourceSpan;\n\n  /** Name that the user set when declaring the `@let`. */\n  declaredName: string;\n\n  /** XrefId of the slot in which the call may write its value. */\n  target: XrefId;\n\n  /** Value of the `@let` declaration. */\n  value: o.Expression;\n}\n\n/**\n * Creates a `StoreLetOp`.\n */\nexport function createStoreLetOp(\n  target: XrefId,\n  declaredName: string,\n  value: o.Expression,\n  sourceSpan: ParseSourceSpan,\n): StoreLetOp {\n  return {\n    kind: OpKind.StoreLet,\n    target,\n    declaredName,\n    value,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n"]}