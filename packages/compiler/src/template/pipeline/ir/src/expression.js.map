{"version":3,"file":"expression.js","sourceRoot":"","sources":["expression.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport type {ParseSourceSpan} from '../../../../parse_util';\n\nimport * as t from '../../../../render3/r3_ast';\nimport {ExpressionKind, OpKind} from './enums';\nimport {SlotHandle} from './handle';\nimport type {XrefId} from './operations';\nimport type {CreateOp} from './ops/create';\nimport {Interpolation, type UpdateOp} from './ops/update';\nimport {\n  ConsumesVarsTrait,\n  DependsOnSlotContext,\n  DependsOnSlotContextOpTrait,\n  UsesVarOffset,\n  UsesVarOffsetTrait,\n} from './traits';\n\n/**\n * An `o.Expression` subtype representing a logical expression in the intermediate representation.\n */\nexport type Expression =\n  | LexicalReadExpr\n  | ReferenceExpr\n  | ContextExpr\n  | NextContextExpr\n  | GetCurrentViewExpr\n  | RestoreViewExpr\n  | ResetViewExpr\n  | ReadVariableExpr\n  | PureFunctionExpr\n  | PureFunctionParameterExpr\n  | PipeBindingExpr\n  | PipeBindingVariadicExpr\n  | SafePropertyReadExpr\n  | SafeKeyedReadExpr\n  | SafeInvokeFunctionExpr\n  | EmptyExpr\n  | AssignTemporaryExpr\n  | ReadTemporaryExpr\n  | SlotLiteralExpr\n  | ConditionalCaseExpr\n  | ConstCollectedExpr\n  | TwoWayBindingSetExpr\n  | ContextLetReferenceExpr\n  | StoreLetExpr\n  | TrackContextExpr;\n\n/**\n * Transformer type which converts expressions into general `o.Expression`s (which may be an\n * identity transformation).\n */\nexport type ExpressionTransform = (expr: o.Expression, flags: VisitorContextFlag) => o.Expression;\n\n/**\n * Check whether a given `o.Expression` is a logical IR expression type.\n */\nexport function isIrExpression(expr: o.Expression): expr is Expression {\n  return expr instanceof ExpressionBase;\n}\n\n/**\n * Base type used for all logical IR expressions.\n */\nexport abstract class ExpressionBase extends o.Expression {\n  abstract readonly kind: ExpressionKind;\n\n  constructor(sourceSpan: ParseSourceSpan | null = null) {\n    super(null, sourceSpan);\n  }\n\n  /**\n   * Run the transformer against any nested expressions which may be present in this IR expression\n   * subtype.\n   */\n  abstract transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void;\n}\n\n/**\n * Logical expression representing a lexical read of a variable name.\n */\nexport class LexicalReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.LexicalRead;\n\n  constructor(readonly name: string) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {}\n\n  override isEquivalent(other: LexicalReadExpr): boolean {\n    // We assume that the lexical reads are in the same context, which must be true for parent\n    // expressions to be equivalent.\n    // TODO: is this generally safe?\n    return this.name === other.name;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): LexicalReadExpr {\n    return new LexicalReadExpr(this.name);\n  }\n}\n\n/**\n * Runtime operation to retrieve the value of a local reference.\n */\nexport class ReferenceExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.Reference;\n\n  constructor(\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n    readonly offset: number,\n  ) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ReferenceExpr && e.target === this.target;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ReferenceExpr {\n    return new ReferenceExpr(this.target, this.targetSlot, this.offset);\n  }\n}\n\nexport class StoreLetExpr\n  extends ExpressionBase\n  implements ConsumesVarsTrait, DependsOnSlotContextOpTrait\n{\n  override readonly kind = ExpressionKind.StoreLet;\n  readonly [ConsumesVarsTrait] = true;\n  readonly [DependsOnSlotContext] = true;\n\n  constructor(\n    readonly target: XrefId,\n    public value: o.Expression,\n    override sourceSpan: ParseSourceSpan,\n  ) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return (\n      e instanceof StoreLetExpr && e.target === this.target && e.value.isEquivalent(this.value)\n    );\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n\n  override clone(): StoreLetExpr {\n    return new StoreLetExpr(this.target, this.value, this.sourceSpan);\n  }\n}\n\nexport class ContextLetReferenceExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ContextLetReference;\n\n  constructor(\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n  ) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ContextLetReferenceExpr && e.target === this.target;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ContextLetReferenceExpr {\n    return new ContextLetReferenceExpr(this.target, this.targetSlot);\n  }\n}\n\n/**\n * A reference to the current view context (usually the `ctx` variable in a template function).\n */\nexport class ContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.Context;\n\n  constructor(readonly view: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ContextExpr && e.view === this.view;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ContextExpr {\n    return new ContextExpr(this.view);\n  }\n}\n\n/**\n * A reference to the current view context inside a track function.\n */\nexport class TrackContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.TrackContext;\n\n  constructor(readonly view: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof TrackContextExpr && e.view === this.view;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): TrackContextExpr {\n    return new TrackContextExpr(this.view);\n  }\n}\n\n/**\n * Runtime operation to navigate to the next view context in the view hierarchy.\n */\nexport class NextContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.NextContext;\n\n  steps = 1;\n\n  constructor() {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof NextContextExpr && e.steps === this.steps;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): NextContextExpr {\n    const expr = new NextContextExpr();\n    expr.steps = this.steps;\n    return expr;\n  }\n}\n\n/**\n * Runtime operation to snapshot the current view context.\n *\n * The result of this operation can be stored in a variable and later used with the `RestoreView`\n * operation.\n */\nexport class GetCurrentViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.GetCurrentView;\n\n  constructor() {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof GetCurrentViewExpr;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): GetCurrentViewExpr {\n    return new GetCurrentViewExpr();\n  }\n}\n\n/**\n * Runtime operation to restore a snapshotted view.\n */\nexport class RestoreViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.RestoreView;\n\n  constructor(public view: XrefId | o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    if (typeof this.view !== 'number') {\n      this.view.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    if (!(e instanceof RestoreViewExpr) || typeof e.view !== typeof this.view) {\n      return false;\n    }\n\n    if (typeof this.view === 'number') {\n      return this.view === e.view;\n    } else {\n      return this.view.isEquivalent(e.view as o.Expression);\n    }\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    if (typeof this.view !== 'number') {\n      this.view = transformExpressionsInExpression(this.view, transform, flags);\n    }\n  }\n\n  override clone(): RestoreViewExpr {\n    return new RestoreViewExpr(this.view instanceof o.Expression ? this.view.clone() : this.view);\n  }\n}\n\n/**\n * Runtime operation to reset the current view context after `RestoreView`.\n */\nexport class ResetViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ResetView;\n\n  constructor(public expr: o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ResetViewExpr && this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n\n  override clone(): ResetViewExpr {\n    return new ResetViewExpr(this.expr.clone());\n  }\n}\n\nexport class TwoWayBindingSetExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.TwoWayBindingSet;\n\n  constructor(\n    public target: o.Expression,\n    public value: o.Expression,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    this.target.visitExpression(visitor, context);\n    this.value.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(other: TwoWayBindingSetExpr): boolean {\n    return this.target.isEquivalent(other.target) && this.value.isEquivalent(other.value);\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag) {\n    this.target = transformExpressionsInExpression(this.target, transform, flags);\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n\n  override clone(): TwoWayBindingSetExpr {\n    return new TwoWayBindingSetExpr(this.target, this.value);\n  }\n}\n\n/**\n * Read of a variable declared as an `ir.VariableOp` and referenced through its `ir.XrefId`.\n */\nexport class ReadVariableExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ReadVariable;\n  name: string | null = null;\n  constructor(readonly xref: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(other: o.Expression): boolean {\n    return other instanceof ReadVariableExpr && other.xref === this.xref;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ReadVariableExpr {\n    const expr = new ReadVariableExpr(this.xref);\n    expr.name = this.name;\n    return expr;\n  }\n}\n\nexport class PureFunctionExpr\n  extends ExpressionBase\n  implements ConsumesVarsTrait, UsesVarOffsetTrait\n{\n  override readonly kind = ExpressionKind.PureFunctionExpr;\n  readonly [ConsumesVarsTrait] = true;\n  readonly [UsesVarOffset] = true;\n\n  varOffset: number | null = null;\n\n  /**\n   * The expression which should be memoized as a pure computation.\n   *\n   * This expression contains internal `PureFunctionParameterExpr`s, which are placeholders for the\n   * positional argument expressions in `args.\n   */\n  body: o.Expression | null;\n\n  /**\n   * Positional arguments to the pure function which will memoize the `body` expression, which act\n   * as memoization keys.\n   */\n  args: o.Expression[];\n\n  /**\n   * Once extracted to the `ConstantPool`, a reference to the function which defines the computation\n   * of `body`.\n   */\n  fn: o.Expression | null = null;\n\n  constructor(expression: o.Expression | null, args: o.Expression[]) {\n    super();\n    this.body = expression;\n    this.args = args;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any) {\n    this.body?.visitExpression(visitor, context);\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(other: o.Expression): boolean {\n    if (!(other instanceof PureFunctionExpr) || other.args.length !== this.args.length) {\n      return false;\n    }\n\n    return (\n      other.body !== null &&\n      this.body !== null &&\n      other.body.isEquivalent(this.body) &&\n      other.args.every((arg, idx) => arg.isEquivalent(this.args[idx]))\n    );\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    if (this.body !== null) {\n      // TODO: figure out if this is the right flag to pass here.\n      this.body = transformExpressionsInExpression(\n        this.body,\n        transform,\n        flags | VisitorContextFlag.InChildOperation,\n      );\n    } else if (this.fn !== null) {\n      this.fn = transformExpressionsInExpression(this.fn, transform, flags);\n    }\n\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n\n  override clone(): PureFunctionExpr {\n    const expr = new PureFunctionExpr(\n      this.body?.clone() ?? null,\n      this.args.map((arg) => arg.clone()),\n    );\n    expr.fn = this.fn?.clone() ?? null;\n    expr.varOffset = this.varOffset;\n    return expr;\n  }\n}\n\nexport class PureFunctionParameterExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.PureFunctionParameterExpr;\n\n  constructor(public index: number) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(other: o.Expression): boolean {\n    return other instanceof PureFunctionParameterExpr && other.index === this.index;\n  }\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): PureFunctionParameterExpr {\n    return new PureFunctionParameterExpr(this.index);\n  }\n}\n\nexport class PipeBindingExpr\n  extends ExpressionBase\n  implements ConsumesVarsTrait, UsesVarOffsetTrait\n{\n  override readonly kind = ExpressionKind.PipeBinding;\n  readonly [ConsumesVarsTrait] = true;\n  readonly [UsesVarOffset] = true;\n\n  varOffset: number | null = null;\n\n  constructor(\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n    readonly name: string,\n    readonly args: o.Expression[],\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    for (let idx = 0; idx < this.args.length; idx++) {\n      this.args[idx] = transformExpressionsInExpression(this.args[idx], transform, flags);\n    }\n  }\n\n  override clone() {\n    const r = new PipeBindingExpr(\n      this.target,\n      this.targetSlot,\n      this.name,\n      this.args.map((a) => a.clone()),\n    );\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\n\nexport class PipeBindingVariadicExpr\n  extends ExpressionBase\n  implements ConsumesVarsTrait, UsesVarOffsetTrait\n{\n  override readonly kind = ExpressionKind.PipeBindingVariadic;\n  readonly [ConsumesVarsTrait] = true;\n  readonly [UsesVarOffset] = true;\n\n  varOffset: number | null = null;\n\n  constructor(\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n    readonly name: string,\n    public args: o.Expression,\n    public numArgs: number,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    this.args.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.args = transformExpressionsInExpression(this.args, transform, flags);\n  }\n\n  override clone(): PipeBindingVariadicExpr {\n    const r = new PipeBindingVariadicExpr(\n      this.target,\n      this.targetSlot,\n      this.name,\n      this.args.clone(),\n      this.numArgs,\n    );\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\n\nexport class SafePropertyReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafePropertyRead;\n\n  constructor(\n    public receiver: o.Expression,\n    public name: string,\n  ) {\n    super();\n  }\n\n  // An alias for name, which allows other logic to handle property reads and keyed reads together.\n  get index() {\n    return this.name;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.receiver.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n  }\n\n  override clone(): SafePropertyReadExpr {\n    return new SafePropertyReadExpr(this.receiver.clone(), this.name);\n  }\n}\n\nexport class SafeKeyedReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafeKeyedRead;\n\n  constructor(\n    public receiver: o.Expression,\n    public index: o.Expression,\n    sourceSpan: ParseSourceSpan | null,\n  ) {\n    super(sourceSpan);\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.receiver.visitExpression(visitor, context);\n    this.index.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    this.index = transformExpressionsInExpression(this.index, transform, flags);\n  }\n\n  override clone(): SafeKeyedReadExpr {\n    return new SafeKeyedReadExpr(this.receiver.clone(), this.index.clone(), this.sourceSpan);\n  }\n}\n\nexport class SafeInvokeFunctionExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafeInvokeFunction;\n\n  constructor(\n    public receiver: o.Expression,\n    public args: o.Expression[],\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.receiver.visitExpression(visitor, context);\n    for (const a of this.args) {\n      a.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n\n  override clone(): SafeInvokeFunctionExpr {\n    return new SafeInvokeFunctionExpr(\n      this.receiver.clone(),\n      this.args.map((a) => a.clone()),\n    );\n  }\n}\n\nexport class SafeTernaryExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafeTernaryExpr;\n\n  constructor(\n    public guard: o.Expression,\n    public expr: o.Expression,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.guard.visitExpression(visitor, context);\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.guard = transformExpressionsInExpression(this.guard, transform, flags);\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n\n  override clone(): SafeTernaryExpr {\n    return new SafeTernaryExpr(this.guard.clone(), this.expr.clone());\n  }\n}\n\nexport class EmptyExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.EmptyExpr;\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {}\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof EmptyExpr;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): EmptyExpr {\n    return new EmptyExpr();\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\nexport class AssignTemporaryExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.AssignTemporaryExpr;\n\n  public name: string | null = null;\n\n  constructor(\n    public expr: o.Expression,\n    public xref: XrefId,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n\n  override clone(): AssignTemporaryExpr {\n    const a = new AssignTemporaryExpr(this.expr.clone(), this.xref);\n    a.name = this.name;\n    return a;\n  }\n}\n\nexport class ReadTemporaryExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ReadTemporaryExpr;\n\n  public name: string | null = null;\n\n  constructor(public xref: XrefId) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {}\n\n  override isEquivalent(): boolean {\n    return this.xref === this.xref;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {}\n\n  override clone(): ReadTemporaryExpr {\n    const r = new ReadTemporaryExpr(this.xref);\n    r.name = this.name;\n    return r;\n  }\n}\n\nexport class SlotLiteralExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SlotLiteralExpr;\n\n  constructor(readonly slot: SlotHandle) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {}\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof SlotLiteralExpr && e.slot === this.slot;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): SlotLiteralExpr {\n    return new SlotLiteralExpr(this.slot);\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\nexport class ConditionalCaseExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ConditionalCase;\n\n  /**\n   * Create an expression for one branch of a conditional.\n   * @param expr The expression to be tested for this case. Might be null, as in an `else` case.\n   * @param target The Xref of the view to be displayed if this condition is true.\n   */\n  constructor(\n    public expr: o.Expression | null,\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n    readonly alias: t.Variable | null = null,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (this.expr !== null) {\n      this.expr.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ConditionalCaseExpr && e.expr === this.expr;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): ConditionalCaseExpr {\n    return new ConditionalCaseExpr(this.expr, this.target, this.targetSlot);\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    if (this.expr !== null) {\n      this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n    }\n  }\n}\n\nexport class ConstCollectedExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ConstCollected;\n\n  constructor(public expr: o.Expression) {\n    super();\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.expr = transform(this.expr, flags);\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any) {\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    if (!(e instanceof ConstCollectedExpr)) {\n      return false;\n    }\n    return this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): ConstCollectedExpr {\n    return new ConstCollectedExpr(this.expr);\n  }\n}\n\n/**\n * Visits all `Expression`s in the AST of `op` with the `visitor` function.\n */\nexport function visitExpressionsInOp(\n  op: CreateOp | UpdateOp,\n  visitor: (expr: o.Expression, flags: VisitorContextFlag) => void,\n): void {\n  transformExpressionsInOp(\n    op,\n    (expr, flags) => {\n      visitor(expr, flags);\n      return expr;\n    },\n    VisitorContextFlag.None,\n  );\n}\n\nexport enum VisitorContextFlag {\n  None = 0b0000,\n  InChildOperation = 0b0001,\n}\n\nfunction transformExpressionsInInterpolation(\n  interpolation: Interpolation,\n  transform: ExpressionTransform,\n  flags: VisitorContextFlag,\n) {\n  for (let i = 0; i < interpolation.expressions.length; i++) {\n    interpolation.expressions[i] = transformExpressionsInExpression(\n      interpolation.expressions[i],\n      transform,\n      flags,\n    );\n  }\n}\n\n/**\n * Transform all `Expression`s in the AST of `op` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInOp(\n  op: CreateOp | UpdateOp,\n  transform: ExpressionTransform,\n  flags: VisitorContextFlag,\n): void {\n  switch (op.kind) {\n    case OpKind.StyleProp:\n    case OpKind.StyleMap:\n    case OpKind.ClassProp:\n    case OpKind.ClassMap:\n    case OpKind.AnimationString:\n    case OpKind.AnimationBinding:\n    case OpKind.Binding:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      break;\n    case OpKind.Property:\n    case OpKind.DomProperty:\n    case OpKind.Attribute:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      op.sanitizer =\n        op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.TwoWayProperty:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      op.sanitizer =\n        op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.I18nExpression:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      break;\n    case OpKind.InterpolateText:\n      transformExpressionsInInterpolation(op.interpolation, transform, flags);\n      break;\n    case OpKind.Statement:\n      transformExpressionsInStatement(op.statement, transform, flags);\n      break;\n    case OpKind.Variable:\n      op.initializer = transformExpressionsInExpression(op.initializer, transform, flags);\n      break;\n    case OpKind.Conditional:\n      for (const condition of op.conditions) {\n        if (condition.expr === null) {\n          // This is a default case.\n          continue;\n        }\n        condition.expr = transformExpressionsInExpression(condition.expr, transform, flags);\n      }\n      if (op.processed !== null) {\n        op.processed = transformExpressionsInExpression(op.processed, transform, flags);\n      }\n      if (op.contextValue !== null) {\n        op.contextValue = transformExpressionsInExpression(op.contextValue, transform, flags);\n      }\n      break;\n    case OpKind.Animation:\n    case OpKind.AnimationListener:\n    case OpKind.Listener:\n    case OpKind.TwoWayListener:\n      for (const innerOp of op.handlerOps) {\n        transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n      }\n      break;\n    case OpKind.ExtractedAttribute:\n      op.expression =\n        op.expression && transformExpressionsInExpression(op.expression, transform, flags);\n      op.trustedValueFn =\n        op.trustedValueFn && transformExpressionsInExpression(op.trustedValueFn, transform, flags);\n      break;\n    case OpKind.RepeaterCreate:\n      if (op.trackByOps === null) {\n        op.track = transformExpressionsInExpression(op.track, transform, flags);\n      } else {\n        for (const innerOp of op.trackByOps) {\n          transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n        }\n      }\n      if (op.trackByFn !== null) {\n        op.trackByFn = transformExpressionsInExpression(op.trackByFn, transform, flags);\n      }\n      break;\n    case OpKind.Repeater:\n      op.collection = transformExpressionsInExpression(op.collection, transform, flags);\n      break;\n    case OpKind.Defer:\n      if (op.loadingConfig !== null) {\n        op.loadingConfig = transformExpressionsInExpression(op.loadingConfig, transform, flags);\n      }\n      if (op.placeholderConfig !== null) {\n        op.placeholderConfig = transformExpressionsInExpression(\n          op.placeholderConfig,\n          transform,\n          flags,\n        );\n      }\n      if (op.resolverFn !== null) {\n        op.resolverFn = transformExpressionsInExpression(op.resolverFn, transform, flags);\n      }\n      break;\n    case OpKind.I18nMessage:\n      for (const [placeholder, expr] of op.params) {\n        op.params.set(placeholder, transformExpressionsInExpression(expr, transform, flags));\n      }\n      for (const [placeholder, expr] of op.postprocessingParams) {\n        op.postprocessingParams.set(\n          placeholder,\n          transformExpressionsInExpression(expr, transform, flags),\n        );\n      }\n      break;\n    case OpKind.DeferWhen:\n      op.expr = transformExpressionsInExpression(op.expr, transform, flags);\n      break;\n    case OpKind.StoreLet:\n      op.value = transformExpressionsInExpression(op.value, transform, flags);\n      break;\n    case OpKind.Advance:\n    case OpKind.Container:\n    case OpKind.ContainerEnd:\n    case OpKind.ContainerStart:\n    case OpKind.DeferOn:\n    case OpKind.DisableBindings:\n    case OpKind.Element:\n    case OpKind.ElementEnd:\n    case OpKind.ElementStart:\n    case OpKind.EnableBindings:\n    case OpKind.I18n:\n    case OpKind.I18nApply:\n    case OpKind.I18nContext:\n    case OpKind.I18nEnd:\n    case OpKind.I18nStart:\n    case OpKind.IcuEnd:\n    case OpKind.IcuStart:\n    case OpKind.Namespace:\n    case OpKind.Pipe:\n    case OpKind.Projection:\n    case OpKind.ProjectionDef:\n    case OpKind.Template:\n    case OpKind.Text:\n    case OpKind.I18nAttributes:\n    case OpKind.IcuPlaceholder:\n    case OpKind.DeclareLet:\n    case OpKind.SourceLocation:\n    case OpKind.ConditionalCreate:\n    case OpKind.ConditionalBranchCreate:\n      // These operations contain no expressions.\n      break;\n    default:\n      throw new Error(`AssertionError: transformExpressionsInOp doesn't handle ${OpKind[op.kind]}`);\n  }\n}\n\n/**\n * Transform all `Expression`s in the AST of `expr` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInExpression(\n  expr: o.Expression,\n  transform: ExpressionTransform,\n  flags: VisitorContextFlag,\n): o.Expression {\n  if (expr instanceof ExpressionBase) {\n    expr.transformInternalExpressions(transform, flags);\n  } else if (expr instanceof o.BinaryOperatorExpr) {\n    expr.lhs = transformExpressionsInExpression(expr.lhs, transform, flags);\n    expr.rhs = transformExpressionsInExpression(expr.rhs, transform, flags);\n  } else if (expr instanceof o.UnaryOperatorExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof o.ReadPropExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n  } else if (expr instanceof o.ReadKeyExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n    expr.index = transformExpressionsInExpression(expr.index, transform, flags);\n  } else if (expr instanceof o.InvokeFunctionExpr) {\n    expr.fn = transformExpressionsInExpression(expr.fn, transform, flags);\n    for (let i = 0; i < expr.args.length; i++) {\n      expr.args[i] = transformExpressionsInExpression(expr.args[i], transform, flags);\n    }\n  } else if (expr instanceof o.LiteralArrayExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i] = transformExpressionsInExpression(expr.entries[i], transform, flags);\n    }\n  } else if (expr instanceof o.LiteralMapExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i].value = transformExpressionsInExpression(\n        expr.entries[i].value,\n        transform,\n        flags,\n      );\n    }\n  } else if (expr instanceof o.ConditionalExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n    expr.trueCase = transformExpressionsInExpression(expr.trueCase, transform, flags);\n    if (expr.falseCase !== null) {\n      expr.falseCase = transformExpressionsInExpression(expr.falseCase, transform, flags);\n    }\n  } else if (expr instanceof o.TypeofExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof o.VoidExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof o.LocalizedString) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof o.NotExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n  } else if (expr instanceof o.TaggedTemplateLiteralExpr) {\n    expr.tag = transformExpressionsInExpression(expr.tag, transform, flags);\n    expr.template.expressions = expr.template.expressions.map((e) =>\n      transformExpressionsInExpression(e, transform, flags),\n    );\n  } else if (expr instanceof o.ArrowFunctionExpr) {\n    if (Array.isArray(expr.body)) {\n      for (let i = 0; i < expr.body.length; i++) {\n        transformExpressionsInStatement(expr.body[i], transform, flags);\n      }\n    } else {\n      expr.body = transformExpressionsInExpression(expr.body, transform, flags);\n    }\n  } else if (expr instanceof o.WrappedNodeExpr) {\n    // TODO: Do we need to transform any TS nodes nested inside of this expression?\n  } else if (expr instanceof o.TemplateLiteralExpr) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof o.ParenthesizedExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (\n    expr instanceof o.ReadVarExpr ||\n    expr instanceof o.ExternalExpr ||\n    expr instanceof o.LiteralExpr ||\n    expr instanceof o.RegularExpressionLiteral\n  ) {\n    // No action for these types.\n  } else {\n    throw new Error(`Unhandled expression kind: ${expr.constructor.name}`);\n  }\n  return transform(expr, flags);\n}\n\n/**\n * Transform all `Expression`s in the AST of `stmt` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInStatement(\n  stmt: o.Statement,\n  transform: ExpressionTransform,\n  flags: VisitorContextFlag,\n): void {\n  if (stmt instanceof o.ExpressionStatement) {\n    stmt.expr = transformExpressionsInExpression(stmt.expr, transform, flags);\n  } else if (stmt instanceof o.ReturnStatement) {\n    stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n  } else if (stmt instanceof o.DeclareVarStmt) {\n    if (stmt.value !== undefined) {\n      stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n    }\n  } else if (stmt instanceof o.IfStmt) {\n    stmt.condition = transformExpressionsInExpression(stmt.condition, transform, flags);\n    for (const caseStatement of stmt.trueCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n    for (const caseStatement of stmt.falseCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n  } else {\n    throw new Error(`Unhandled statement kind: ${stmt.constructor.name}`);\n  }\n}\n\n/**\n * Checks whether the given expression is a string literal.\n */\nexport function isStringLiteral(expr: o.Expression): expr is o.LiteralExpr & {value: string} {\n  return expr instanceof o.LiteralExpr && typeof expr.value === 'string';\n}\n"]}