{"version":3,"file":"operations.js","sourceRoot":"","sources":["operations.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OpKind} from './enums';\n\n/**\n * Branded type for a cross-reference ID. During ingest, `XrefId`s are generated to link together\n * different IR operations which need to reference each other.\n */\nexport type XrefId = number & {__brand: 'XrefId'};\n\n/**\n * Base interface for semantic operations being performed within a template.\n *\n * @param OpT a specific narrower type of `Op` (for example, creation operations) which this\n *     specific subtype of `Op` can be linked with in a linked list.\n */\nexport interface Op<OpT extends Op<OpT>> {\n  /**\n   * All operations have a distinct kind.\n   */\n  kind: OpKind;\n\n  /**\n   * The previous operation in the linked list, if any.\n   *\n   * This is `null` for operation nodes not currently in a list, or for the special head/tail nodes.\n   */\n  prev: OpT | null;\n\n  /**\n   * The next operation in the linked list, if any.\n   *\n   * This is `null` for operation nodes not currently in a list, or for the special head/tail nodes.\n   */\n  next: OpT | null;\n\n  /**\n   * Debug id of the list to which this node currently belongs, or `null` if this node is not part\n   * of a list.\n   */\n  debugListId: number | null;\n}\n\n/**\n * A linked list of `Op` nodes of a given subtype.\n *\n * @param OpT specific subtype of `Op` nodes which this list contains.\n */\nexport class OpList<OpT extends Op<OpT>> {\n  static nextListId = 0;\n\n  /**\n   * Debug ID of this `OpList` instance.\n   */\n  readonly debugListId = OpList.nextListId++;\n\n  // OpList uses static head/tail nodes of a special `ListEnd` type.\n  // This avoids the need for special casing of the first and last list\n  // elements in all list operations.\n  readonly head: OpT = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId,\n  } as OpT;\n\n  readonly tail = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId,\n  } as OpT;\n\n  constructor() {\n    // Link `head` and `tail` together at the start (list is empty).\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n\n  /**\n   * Push a new operation to the tail of the list.\n   */\n  push(op: OpT | Array<OpT>): void {\n    if (Array.isArray(op)) {\n      for (const o of op) {\n        this.push(o);\n      }\n      return;\n    }\n\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = this.debugListId;\n\n    // The old \"previous\" node (which might be the head, if the list is empty).\n    const oldLast = this.tail.prev!;\n\n    // Insert `op` following the old last node.\n    op.prev = oldLast;\n    oldLast.next = op;\n\n    // Connect `op` with the list tail.\n    op.next = this.tail;\n    this.tail.prev = op;\n  }\n\n  /**\n   * Prepend one or more nodes to the start of the list.\n   */\n  prepend(ops: OpT[]): void {\n    if (ops.length === 0) {\n      return;\n    }\n\n    for (const op of ops) {\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsUnowned(op);\n\n      op.debugListId = this.debugListId;\n    }\n\n    const first = this.head.next!;\n\n    let prev = this.head;\n    for (const op of ops) {\n      prev.next = op;\n      op.prev = prev;\n\n      prev = op;\n    }\n\n    prev.next = first;\n    first.prev = prev;\n  }\n\n  /**\n   * `OpList` is iterable via the iteration protocol.\n   *\n   * It's safe to mutate the part of the list that has already been returned by the iterator, up to\n   * and including the last operation returned. Mutations beyond that point _may_ be safe, but may\n   * also corrupt the iteration position and should be avoided.\n   */\n  *[Symbol.iterator](): Generator<OpT> {\n    let current = this.head.next!;\n    while (current !== this.tail) {\n      // Guards against corruption of the iterator state by mutations to the tail of the list during\n      // iteration.\n      OpList.assertIsOwned(current, this.debugListId);\n\n      const next = current.next!;\n      yield current;\n      current = next;\n    }\n  }\n\n  *reversed(): Generator<OpT> {\n    let current = this.tail.prev!;\n    while (current !== this.head) {\n      OpList.assertIsOwned(current, this.debugListId);\n\n      const prev = current.prev!;\n      yield current;\n      current = prev;\n    }\n  }\n\n  /**\n   * Replace `oldOp` with `newOp` in the list.\n   */\n  static replace<OpT extends Op<OpT>>(oldOp: OpT, newOp: OpT): void {\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsNotEnd(newOp);\n\n    OpList.assertIsOwned(oldOp);\n    OpList.assertIsUnowned(newOp);\n\n    newOp.debugListId = oldOp.debugListId;\n    if (oldOp.prev !== null) {\n      oldOp.prev.next = newOp;\n      newOp.prev = oldOp.prev;\n    }\n    if (oldOp.next !== null) {\n      oldOp.next.prev = newOp;\n      newOp.next = oldOp.next;\n    }\n    oldOp.debugListId = null;\n    oldOp.prev = null;\n    oldOp.next = null;\n  }\n\n  /**\n   * Replace `oldOp` with some number of new operations in the list (which may include `oldOp`).\n   */\n  static replaceWithMany<OpT extends Op<OpT>>(oldOp: OpT, newOps: OpT[]): void {\n    if (newOps.length === 0) {\n      // Replacing with an empty list -> pure removal.\n      OpList.remove(oldOp);\n      return;\n    }\n\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsOwned(oldOp);\n\n    const listId = oldOp.debugListId;\n    oldOp.debugListId = null;\n\n    for (const newOp of newOps) {\n      OpList.assertIsNotEnd(newOp);\n\n      // `newOp` might be `oldOp`, but at this point it's been marked as unowned.\n      OpList.assertIsUnowned(newOp);\n    }\n\n    // It should be safe to reuse `oldOp` in the `newOps` list - maybe you want to sandwich an\n    // operation between two new ops.\n    const {prev: oldPrev, next: oldNext} = oldOp;\n    oldOp.prev = null;\n    oldOp.next = null;\n\n    let prev: OpT = oldPrev!;\n    for (const newOp of newOps) {\n      OpList.assertIsUnowned(newOp);\n      newOp.debugListId = listId;\n\n      prev!.next = newOp;\n      newOp.prev = prev;\n\n      // This _should_ be the case, but set it just in case.\n      newOp.next = null;\n\n      prev = newOp;\n    }\n    // At the end of iteration, `prev` holds the last node in the list.\n    const first = newOps[0]!;\n    const last = prev!;\n\n    // Replace `oldOp` with the chain `first` -> `last`.\n    if (oldPrev !== null) {\n      oldPrev.next = first;\n      first.prev = oldPrev;\n    }\n\n    if (oldNext !== null) {\n      oldNext.prev = last;\n      last.next = oldNext;\n    }\n  }\n\n  /**\n   * Remove the given node from the list which contains it.\n   */\n  static remove<OpT extends Op<OpT>>(op: OpT): void {\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsOwned(op);\n\n    op.prev!.next = op.next;\n    op.next!.prev = op.prev;\n\n    // Break any link between the node and this list to safeguard against its usage in future\n    // operations.\n    op.debugListId = null;\n    op.prev = null;\n    op.next = null;\n  }\n\n  /**\n   * Insert `op` before `target`.\n   */\n  static insertBefore<OpT extends Op<OpT>>(op: OpT | OpT[], target: OpT): void {\n    if (Array.isArray(op)) {\n      for (const o of op) {\n        OpList.insertBefore(o, target);\n      }\n      return;\n    }\n\n    OpList.assertIsOwned(target);\n    if (target.prev === null) {\n      throw new Error(`AssertionError: illegal operation on list start`);\n    }\n\n    OpList.assertIsNotEnd(op);\n\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = target.debugListId;\n\n    // Just in case.\n    op.prev = null;\n\n    target.prev!.next = op;\n    op.prev = target.prev;\n\n    op.next = target;\n    target.prev = op;\n  }\n\n  /**\n   * Insert `op` after `target`.\n   */\n  static insertAfter<OpT extends Op<OpT>>(op: OpT, target: OpT): void {\n    OpList.assertIsOwned(target);\n    if (target.next === null) {\n      throw new Error(`AssertionError: illegal operation on list end`);\n    }\n\n    OpList.assertIsNotEnd(op);\n\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = target.debugListId;\n\n    target.next.prev = op;\n    op.next = target.next;\n\n    op.prev = target;\n    target.next = op;\n  }\n\n  /**\n   * Asserts that `op` does not currently belong to a list.\n   */\n  static assertIsUnowned<OpT extends Op<OpT>>(op: OpT): void {\n    if (op.debugListId !== null) {\n      throw new Error(`AssertionError: illegal operation on owned node: ${OpKind[op.kind]}`);\n    }\n  }\n\n  /**\n   * Asserts that `op` currently belongs to a list. If `byList` is passed, `op` is asserted to\n   * specifically belong to that list.\n   */\n  static assertIsOwned<OpT extends Op<OpT>>(op: OpT, byList?: number): void {\n    if (op.debugListId === null) {\n      throw new Error(`AssertionError: illegal operation on unowned node: ${OpKind[op.kind]}`);\n    } else if (byList !== undefined && op.debugListId !== byList) {\n      throw new Error(\n        `AssertionError: node belongs to the wrong list (expected ${byList}, actual ${op.debugListId})`,\n      );\n    }\n  }\n\n  /**\n   * Asserts that `op` is not a special `ListEnd` node.\n   */\n  static assertIsNotEnd<OpT extends Op<OpT>>(op: OpT): void {\n    if (op.kind === OpKind.ListEnd) {\n      throw new Error(`AssertionError: illegal operation on list head or tail`);\n    }\n  }\n}\n"]}