{"version":3,"file":"variable_optimization.js","sourceRoot":"","sources":["variable_optimization.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Optimize variables declared and used in the IR.\n *\n * Variables are eagerly generated by pipeline stages for all possible values that could be\n * referenced. This stage processes the list of declared variables and all variable usages,\n * and optimizes where possible. It performs 3 main optimizations:\n *\n *   * It transforms variable declarations to side effectful expressions when the\n *     variable is not used, but its initializer has global effects which other\n *     operations rely upon.\n *   * It removes variable declarations if those variables are not referenced and\n *     either they do not have global effects, or nothing relies on them.\n *   * It inlines variable declarations when those variables are only used once\n *     and the inlining is semantically safe.\n *\n * To guarantee correctness, analysis of \"fences\" in the instruction lists is used to determine\n * which optimizations are safe to perform.\n */\nexport function optimizeVariables(job: CompilationJob): void {\n  for (const unit of job.units) {\n    inlineAlwaysInlineVariables(unit.create);\n    inlineAlwaysInlineVariables(unit.update);\n\n    for (const op of unit.create) {\n      if (\n        op.kind === ir.OpKind.Listener ||\n        op.kind === ir.OpKind.Animation ||\n        op.kind === ir.OpKind.AnimationListener ||\n        op.kind === ir.OpKind.TwoWayListener\n      ) {\n        inlineAlwaysInlineVariables(op.handlerOps);\n      } else if (op.kind === ir.OpKind.RepeaterCreate && op.trackByOps !== null) {\n        inlineAlwaysInlineVariables(op.trackByOps);\n      }\n    }\n\n    optimizeVariablesInOpList(unit.create, job.compatibility);\n    optimizeVariablesInOpList(unit.update, job.compatibility);\n\n    for (const op of unit.create) {\n      if (\n        op.kind === ir.OpKind.Listener ||\n        op.kind === ir.OpKind.Animation ||\n        op.kind === ir.OpKind.AnimationListener ||\n        op.kind === ir.OpKind.TwoWayListener\n      ) {\n        optimizeVariablesInOpList(op.handlerOps, job.compatibility);\n      } else if (op.kind === ir.OpKind.RepeaterCreate && op.trackByOps !== null) {\n        optimizeVariablesInOpList(op.trackByOps, job.compatibility);\n      }\n    }\n  }\n}\n\n/**\n * A [fence](https://en.wikipedia.org/wiki/Memory_barrier) flag for an expression which indicates\n * how that expression can be optimized in relation to other expressions or instructions.\n *\n * `Fence`s are a bitfield, so multiple flags may be set on a single expression.\n */\nenum Fence {\n  /**\n   * Empty flag (no fence exists).\n   */\n  None = 0b000,\n\n  /**\n   * A context read fence, meaning that the expression in question reads from the \"current view\"\n   * context of the runtime.\n   */\n  ViewContextRead = 0b001,\n\n  /**\n   * A context write fence, meaning that the expression in question writes to the \"current view\"\n   * context of the runtime.\n   *\n   * Note that all `ContextWrite` fences are implicitly `ContextRead` fences as operations which\n   * change the view context do so based on the current one.\n   */\n  ViewContextWrite = 0b010,\n\n  /**\n   * Indicates that a call is required for its side-effects, even if nothing reads its result.\n   *\n   * This is also true of `ViewContextWrite` operations **if** they are followed by a\n   * `ViewContextRead`.\n   */\n  SideEffectful = 0b100,\n}\n\n/**\n * Summary data collected for each `Op` in a list.\n *\n * Tracking this data per operation allows the optimizer to process operations at a higher level\n * than always scanning expressions.\n */\ninterface OpInfo {\n  /**\n   * A `Set` of variables referenced by expressions in this operation.\n   */\n  variablesUsed: Set<ir.XrefId>;\n\n  /**\n   * Flags indicating any `Fence`s present for this operation.\n   */\n  fences: Fence;\n}\n\nfunction inlineAlwaysInlineVariables(ops: ir.OpList<ir.CreateOp | ir.UpdateOp>): void {\n  const vars = new Map<ir.XrefId, ir.VariableOp<ir.CreateOp | ir.UpdateOp>>();\n  for (const op of ops) {\n    if (op.kind === ir.OpKind.Variable && op.flags & ir.VariableFlags.AlwaysInline) {\n      ir.visitExpressionsInOp(op, (expr) => {\n        if (ir.isIrExpression(expr) && fencesForIrExpression(expr) !== Fence.None) {\n          throw new Error(`AssertionError: A context-sensitive variable was marked AlwaysInline`);\n        }\n      });\n      vars.set(op.xref, op);\n    }\n\n    ir.transformExpressionsInOp(\n      op,\n      (expr) => {\n        if (expr instanceof ir.ReadVariableExpr && vars.has(expr.xref)) {\n          const varOp = vars.get(expr.xref)!;\n          // Inline by cloning, because we might inline into multiple places.\n          return varOp.initializer.clone();\n        }\n        return expr;\n      },\n      ir.VisitorContextFlag.None,\n    );\n  }\n\n  for (const op of vars.values()) {\n    ir.OpList.remove(op as ir.CreateOp | ir.UpdateOp);\n  }\n}\n\n/**\n * Process a list of operations and optimize variables within that list.\n */\nfunction optimizeVariablesInOpList(\n  ops: ir.OpList<ir.CreateOp | ir.UpdateOp>,\n  compatibility: ir.CompatibilityMode,\n): void {\n  const varDecls = new Map<ir.XrefId, ir.VariableOp<ir.CreateOp | ir.UpdateOp>>();\n  const varUsages = new Map<ir.XrefId, number>();\n\n  // Track variables that are used outside of the immediate operation list. For example, within\n  // `ListenerOp` handler operations of listeners in the current operation list.\n  const varRemoteUsages = new Set<ir.XrefId>();\n  const opMap = new Map<ir.CreateOp | ir.UpdateOp, OpInfo>();\n\n  // First, extract information about variables declared or used within the whole list.\n  for (const op of ops) {\n    if (op.kind === ir.OpKind.Variable) {\n      if (varDecls.has(op.xref) || varUsages.has(op.xref)) {\n        throw new Error(`Should not see two declarations of the same variable: ${op.xref}`);\n      }\n      varDecls.set(op.xref, op);\n      varUsages.set(op.xref, 0);\n    }\n\n    opMap.set(op, collectOpInfo(op));\n    countVariableUsages(op, varUsages, varRemoteUsages);\n  }\n\n  // The next step is to remove any variable declarations for variables that aren't used. The\n  // variable initializer expressions may be side-effectful, so they may need to be retained as\n  // expression statements.\n\n  // Track whether we've seen an operation which reads from the view context yet. This is used to\n  // determine whether a write to the view context in a variable initializer can be observed.\n  let contextIsUsed = false;\n\n  // Note that iteration through the list happens in reverse, which guarantees that we'll process\n  // all reads of a variable prior to processing its declaration.\n  for (const op of ops.reversed()) {\n    const opInfo = opMap.get(op)!;\n\n    if (op.kind === ir.OpKind.Variable && varUsages.get(op.xref)! === 0) {\n      // This variable is unused and can be removed. We might need to keep the initializer around,\n      // though, if something depends on it running.\n      if (\n        (contextIsUsed && opInfo.fences & Fence.ViewContextWrite) ||\n        opInfo.fences & Fence.SideEffectful\n      ) {\n        // This variable initializer has a side effect which must be retained. Either:\n        //  * it writes to the view context, and we know there is a future operation which depends\n        //    on that write, or\n        //  * it's an operation which is inherently side-effectful.\n        // We can't remove the initializer, but we can remove the variable declaration itself and\n        // replace it with a side-effectful statement.\n        const stmtOp = ir.createStatementOp(op.initializer.toStmt()) as ir.UpdateOp;\n        opMap.set(stmtOp, opInfo);\n        ir.OpList.replace(op as ir.UpdateOp, stmtOp);\n      } else {\n        // It's safe to delete this entire variable declaration as nothing depends on it, even\n        // side-effectfully. Note that doing this might make other variables unused. Since we're\n        // iterating in reverse order, we should always be processing usages before declarations\n        // and therefore by the time we get to a declaration, all removable usages will have been\n        // removed.\n        uncountVariableUsages(op, varUsages);\n        ir.OpList.remove(op as ir.UpdateOp);\n      }\n\n      opMap.delete(op);\n      varDecls.delete(op.xref);\n      varUsages.delete(op.xref);\n      continue;\n    }\n\n    // Does this operation depend on the view context?\n    if (opInfo.fences & Fence.ViewContextRead) {\n      contextIsUsed = true;\n    }\n  }\n\n  // Next, inline any remaining variables with exactly one usage.\n  const toInline: ir.XrefId[] = [];\n  for (const [id, count] of varUsages) {\n    const decl = varDecls.get(id)!;\n    // We can inline variables that:\n    //  - are used exactly once, and\n    //  - are not used remotely\n    // OR\n    //  - are marked for always inlining\n    const isAlwaysInline = !!(decl.flags & ir.VariableFlags.AlwaysInline);\n    if (count !== 1 || isAlwaysInline) {\n      // We can't inline this variable as it's used more than once.\n      continue;\n    }\n\n    if (varRemoteUsages.has(id)) {\n      // This variable is used once, but across an operation boundary, so it can't be inlined.\n      continue;\n    }\n\n    toInline.push(id);\n  }\n\n  let candidate: ir.XrefId | undefined;\n  while ((candidate = toInline.pop())) {\n    // We will attempt to inline this variable. If inlining fails (due to fences for example),\n    // no future operation will make inlining legal.\n    const decl = varDecls.get(candidate)!;\n    const varInfo = opMap.get(decl as ir.CreateOp | ir.UpdateOp)!;\n    const isAlwaysInline = !!(decl.flags & ir.VariableFlags.AlwaysInline);\n\n    if (isAlwaysInline) {\n      throw new Error(\n        `AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.`,\n      );\n    }\n\n    // Scan operations following the variable declaration and look for the point where that variable\n    // is used. There should only be one usage given the precondition above.\n    for (\n      let targetOp = decl.next!;\n      targetOp.kind !== ir.OpKind.ListEnd;\n      targetOp = targetOp.next!\n    ) {\n      const opInfo = opMap.get(targetOp)!;\n\n      // Is the variable used in this operation?\n      if (opInfo.variablesUsed.has(candidate)) {\n        if (\n          compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder &&\n          !allowConservativeInlining(decl, targetOp)\n        ) {\n          // We're in conservative mode, and this variable is not eligible for inlining into the\n          // target operation in this mode.\n          break;\n        }\n\n        // Yes, try to inline it. Inlining may not be successful if fences in this operation before\n        // the variable's usage cannot be safely crossed.\n        if (tryInlineVariableInitializer(candidate, decl.initializer, targetOp, varInfo.fences)) {\n          // Inlining was successful! Update the tracking structures to reflect the inlined\n          // variable.\n          opInfo.variablesUsed.delete(candidate);\n\n          // Add all variables used in the variable's initializer to its new usage site.\n          for (const id of varInfo.variablesUsed) {\n            opInfo.variablesUsed.add(id);\n          }\n\n          // Merge fences in the variable's initializer into its new usage site.\n          opInfo.fences |= varInfo.fences;\n\n          // Delete tracking info related to the declaration.\n          varDecls.delete(candidate);\n          varUsages.delete(candidate);\n          opMap.delete(decl as ir.CreateOp | ir.UpdateOp);\n\n          // And finally, delete the original declaration from the operation list.\n          ir.OpList.remove(decl as ir.UpdateOp);\n        }\n\n        // Whether inlining succeeded or failed, we're done processing this variable.\n        break;\n      }\n\n      // If the variable is not used in this operation, then we'd need to inline across it. Check if\n      // that's safe to do.\n      if (!safeToInlinePastFences(opInfo.fences, varInfo.fences)) {\n        // We can't safely inline this variable beyond this operation, so don't proceed with\n        // inlining this variable.\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Given an `ir.Expression`, returns the `Fence` flags for that expression type.\n */\nfunction fencesForIrExpression(expr: ir.Expression): Fence {\n  switch (expr.kind) {\n    case ir.ExpressionKind.NextContext:\n      return Fence.ViewContextRead | Fence.ViewContextWrite;\n    case ir.ExpressionKind.RestoreView:\n      return Fence.ViewContextRead | Fence.ViewContextWrite | Fence.SideEffectful;\n    case ir.ExpressionKind.StoreLet:\n      return Fence.SideEffectful;\n    case ir.ExpressionKind.Reference:\n    case ir.ExpressionKind.ContextLetReference:\n      return Fence.ViewContextRead;\n    default:\n      return Fence.None;\n  }\n}\n\n/**\n * Build the `OpInfo` structure for the given `op`. This performs two operations:\n *\n *  * It tracks which variables are used in the operation's expressions.\n *  * It rolls up fence flags for expressions within the operation.\n */\nfunction collectOpInfo(op: ir.CreateOp | ir.UpdateOp): OpInfo {\n  let fences = Fence.None;\n  const variablesUsed = new Set<ir.XrefId>();\n  ir.visitExpressionsInOp(op, (expr) => {\n    if (!ir.isIrExpression(expr)) {\n      return;\n    }\n\n    switch (expr.kind) {\n      case ir.ExpressionKind.ReadVariable:\n        variablesUsed.add(expr.xref);\n        break;\n      default:\n        fences |= fencesForIrExpression(expr);\n    }\n  });\n  return {fences, variablesUsed};\n}\n\n/**\n * Count the number of usages of each variable, being careful to track whether those usages are\n * local or remote.\n */\nfunction countVariableUsages(\n  op: ir.CreateOp | ir.UpdateOp,\n  varUsages: Map<ir.XrefId, number>,\n  varRemoteUsage: Set<ir.XrefId>,\n): void {\n  ir.visitExpressionsInOp(op, (expr, flags) => {\n    if (!ir.isIrExpression(expr)) {\n      return;\n    }\n\n    if (expr.kind !== ir.ExpressionKind.ReadVariable) {\n      return;\n    }\n\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      // This variable is declared outside the current scope of optimization.\n      return;\n    }\n    varUsages.set(expr.xref, count + 1);\n\n    if (flags & ir.VisitorContextFlag.InChildOperation) {\n      varRemoteUsage.add(expr.xref);\n    }\n  });\n}\n\n/**\n * Remove usages of a variable in `op` from the `varUsages` tracking.\n */\nfunction uncountVariableUsages(\n  op: ir.CreateOp | ir.UpdateOp,\n  varUsages: Map<ir.XrefId, number>,\n): void {\n  ir.visitExpressionsInOp(op, (expr) => {\n    if (!ir.isIrExpression(expr)) {\n      return;\n    }\n\n    if (expr.kind !== ir.ExpressionKind.ReadVariable) {\n      return;\n    }\n\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      // This variable is declared outside the current scope of optimization.\n      return;\n    } else if (count === 0) {\n      throw new Error(\n        `Inaccurate variable count: ${expr.xref} - found another read but count is already 0`,\n      );\n    }\n    varUsages.set(expr.xref, count - 1);\n  });\n}\n\n/**\n * Checks whether it's safe to inline a variable across a particular operation.\n *\n * @param fences the fences of the operation which the inlining will cross\n * @param declFences the fences of the variable being inlined.\n */\nfunction safeToInlinePastFences(fences: Fence, declFences: Fence): boolean {\n  if (fences & Fence.ViewContextWrite) {\n    // It's not safe to inline context reads across context writes.\n    if (declFences & Fence.ViewContextRead) {\n      return false;\n    }\n  } else if (fences & Fence.ViewContextRead) {\n    // It's not safe to inline context writes across context reads.\n    if (declFences & Fence.ViewContextWrite) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Attempt to inline the initializer of a variable into a target operation's expressions.\n *\n * This may or may not be safe to do. For example, the variable could be read following the\n * execution of an expression with fences that don't permit the variable to be inlined across them.\n */\nfunction tryInlineVariableInitializer(\n  id: ir.XrefId,\n  initializer: o.Expression,\n  target: ir.CreateOp | ir.UpdateOp,\n  declFences: Fence,\n): boolean {\n  // We use `ir.transformExpressionsInOp` to walk the expressions and inline the variable if\n  // possible. Since this operation is callback-based, once inlining succeeds or fails we can't\n  // \"stop\" the expression processing, and have to keep track of whether inlining has succeeded or\n  // is no longer allowed.\n  let inlined = false;\n  let inliningAllowed = true;\n\n  ir.transformExpressionsInOp(\n    target,\n    (expr, flags) => {\n      if (!ir.isIrExpression(expr)) {\n        return expr;\n      }\n\n      if (inlined || !inliningAllowed) {\n        // Either the inlining has already succeeded, or we've passed a fence that disallows inlining\n        // at this point, so don't try.\n        return expr;\n      } else if (\n        flags & ir.VisitorContextFlag.InChildOperation &&\n        declFences & Fence.ViewContextRead\n      ) {\n        // We cannot inline variables that are sensitive to the current context across operation\n        // boundaries.\n        return expr;\n      }\n\n      switch (expr.kind) {\n        case ir.ExpressionKind.ReadVariable:\n          if (expr.xref === id) {\n            // This is the usage site of the variable. Since nothing has disallowed inlining, it's\n            // safe to inline the initializer here.\n            inlined = true;\n            return initializer;\n          }\n          break;\n        default:\n          // For other types of `ir.Expression`s, whether inlining is allowed depends on their fences.\n          const exprFences = fencesForIrExpression(expr);\n          inliningAllowed = inliningAllowed && safeToInlinePastFences(exprFences, declFences);\n          break;\n      }\n      return expr;\n    },\n    ir.VisitorContextFlag.None,\n  );\n  return inlined;\n}\n\n/**\n * Determines whether inlining of `decl` should be allowed in \"conservative\" mode.\n *\n * In conservative mode, inlining behavior is limited to those operations which the\n * `TemplateDefinitionBuilder` supported, with the goal of producing equivalent output.\n */\nfunction allowConservativeInlining(\n  decl: ir.VariableOp<ir.CreateOp | ir.UpdateOp>,\n  target: ir.Op<ir.CreateOp | ir.UpdateOp>,\n): boolean {\n  // TODO(alxhub): understand exactly how TemplateDefinitionBuilder approaches inlining, and record\n  // that behavior here.\n  switch (decl.variable.kind) {\n    case ir.SemanticVariableKind.Identifier:\n      if (decl.initializer instanceof o.ReadVarExpr && decl.initializer.name === 'ctx') {\n        // Although TemplateDefinitionBuilder is cautious about inlining, we still want to do so\n        // when the variable is the context, to imitate its behavior with aliases in control flow\n        // blocks. This quirky behavior will become dead code once compatibility mode is no longer\n        // supported.\n        return true;\n      }\n      return false;\n    case ir.SemanticVariableKind.Context:\n      // Context can only be inlined into other variables.\n      return target.kind === ir.OpKind.Variable;\n    default:\n      return true;\n  }\n}\n"]}