{"version":3,"file":"resolve_sanitizers.js","sourceRoot":"","sources":["resolve_sanitizers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../../../../core';\nimport * as o from '../../../../output/output_ast';\nimport {Identifiers} from '../../../../render3/r3_identifiers';\nimport {isIframeSecuritySensitiveAttr} from '../../../../schema/dom_security_schema';\nimport * as ir from '../../ir';\nimport {CompilationJob, CompilationJobKind} from '../compilation';\nimport {createOpXrefMap} from '../util/elements';\n\n/**\n * Map of security contexts to their sanitizer function.\n */\nconst sanitizerFns = new Map<SecurityContext, o.ExternalReference>([\n  [SecurityContext.HTML, Identifiers.sanitizeHtml],\n  [SecurityContext.RESOURCE_URL, Identifiers.sanitizeResourceUrl],\n  [SecurityContext.SCRIPT, Identifiers.sanitizeScript],\n  [SecurityContext.STYLE, Identifiers.sanitizeStyle],\n  [SecurityContext.URL, Identifiers.sanitizeUrl],\n]);\n\n/**\n * Map of security contexts to their trusted value function.\n */\nconst trustedValueFns = new Map<SecurityContext, o.ExternalReference>([\n  [SecurityContext.HTML, Identifiers.trustConstantHtml],\n  [SecurityContext.RESOURCE_URL, Identifiers.trustConstantResourceUrl],\n]);\n\n/**\n * Resolves sanitization functions for ops that need them.\n */\nexport function resolveSanitizers(job: CompilationJob): void {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n\n    // For normal element bindings we create trusted values for security sensitive constant\n    // attributes. However, for host bindings we skip this step (this matches what\n    // TemplateDefinitionBuilder does).\n    // TODO: Is the TDB behavior correct here?\n    if (job.kind !== CompilationJobKind.Host) {\n      for (const op of unit.create) {\n        if (op.kind === ir.OpKind.ExtractedAttribute) {\n          const trustedValueFn =\n            trustedValueFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          op.trustedValueFn = trustedValueFn !== null ? o.importExpr(trustedValueFn) : null;\n        }\n      }\n    }\n\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case ir.OpKind.Property:\n        case ir.OpKind.Attribute:\n        case ir.OpKind.DomProperty:\n          let sanitizerFn: o.ExternalReference | null = null;\n          if (\n            Array.isArray(op.securityContext) &&\n            op.securityContext.length === 2 &&\n            op.securityContext.indexOf(SecurityContext.URL) > -1 &&\n            op.securityContext.indexOf(SecurityContext.RESOURCE_URL) > -1\n          ) {\n            // When the host element isn't known, some URL attributes (such as \"src\" and \"href\") may\n            // be part of multiple different security contexts. In this case we use special\n            // sanitization function and select the actual sanitizer at runtime based on a tag name\n            // that is provided while invoking sanitization function.\n            sanitizerFn = Identifiers.sanitizeUrlOrResourceUrl;\n          } else {\n            sanitizerFn = sanitizerFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          }\n          op.sanitizer = sanitizerFn !== null ? o.importExpr(sanitizerFn) : null;\n\n          // If there was no sanitization function found based on the security context of an\n          // attribute/property, check whether this attribute/property is one of the\n          // security-sensitive <iframe> attributes (and that the current element is actually an\n          // <iframe>).\n          if (op.sanitizer === null) {\n            let isIframe = false;\n            if (job.kind === CompilationJobKind.Host || op.kind === ir.OpKind.DomProperty) {\n              // Note: for host bindings defined on a directive, we do not try to find all\n              // possible places where it can be matched, so we can not determine whether\n              // the host element is an <iframe>. In this case, we just assume it is and append a\n              // validation function, which is invoked at runtime and would have access to the\n              // underlying DOM element to check if it's an <iframe> and if so - run extra checks.\n              isIframe = true;\n            } else {\n              // For a normal binding we can just check if the element its on is an iframe.\n              const ownerOp = elements.get(op.target);\n              if (ownerOp === undefined || !ir.isElementOrContainerOp(ownerOp)) {\n                throw Error('Property should have an element-like owner');\n              }\n              isIframe = isIframeElement(ownerOp);\n            }\n            if (isIframe && isIframeSecuritySensitiveAttr(op.name)) {\n              op.sanitizer = o.importExpr(Identifiers.validateIframeAttribute);\n            }\n          }\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Checks whether the given op represents an iframe element.\n */\nfunction isIframeElement(op: ir.ElementOrContainerOps): boolean {\n  return op.kind === ir.OpKind.ElementStart && op.tag?.toLowerCase() === 'iframe';\n}\n\n/**\n * Asserts that there is only a single security context and returns it.\n */\nfunction getOnlySecurityContext(\n  securityContext: SecurityContext | SecurityContext[],\n): SecurityContext {\n  if (Array.isArray(securityContext)) {\n    if (securityContext.length > 1) {\n      // TODO: What should we do here? TDB just took the first one, but this feels like something we\n      // would want to know about and create a special case for like we did for Url/ResourceUrl. My\n      // guess is that, outside of the Url/ResourceUrl case, this never actually happens. If there\n      // do turn out to be other cases, throwing an error until we can address it feels safer.\n      throw Error(`AssertionError: Ambiguous security context`);\n    }\n    return securityContext[0] || SecurityContext.NONE;\n  }\n  return securityContext;\n}\n"]}