{"version":3,"file":"attribute_extraction.js","sourceRoot":"","sources":["attribute_extraction.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../../../../core';\nimport * as ir from '../../ir';\nimport {CompilationJobKind, type CompilationJob, type CompilationUnit} from '../compilation';\nimport {createOpXrefMap} from '../util/elements';\n\n/**\n * Find all extractable attribute and binding ops, and create ExtractedAttributeOps for them.\n * In cases where no instruction needs to be generated for the attribute or binding, it is removed.\n */\nexport function extractAttributes(job: CompilationJob): void {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case ir.OpKind.Attribute:\n          extractAttributeOp(unit, op, elements);\n          break;\n        case ir.OpKind.Property:\n          if (\n            op.bindingKind !== ir.BindingKind.LegacyAnimation &&\n            op.bindingKind !== ir.BindingKind.Animation\n          ) {\n            let bindingKind: ir.BindingKind;\n            if (op.i18nMessage !== null && op.templateKind === null) {\n              // If the binding has an i18n context, it is an i18n attribute, and should have that\n              // kind in the consts array.\n              bindingKind = ir.BindingKind.I18n;\n            } else if (op.isStructuralTemplateAttribute) {\n              bindingKind = ir.BindingKind.Template;\n            } else {\n              bindingKind = ir.BindingKind.Property;\n            }\n\n            ir.OpList.insertBefore<ir.CreateOp>(\n              // Deliberately null i18nMessage value\n              ir.createExtractedAttributeOp(\n                op.target,\n                bindingKind,\n                null,\n                op.name,\n                /* expression */ null,\n                /* i18nContext */ null,\n                /* i18nMessage */ null,\n                op.securityContext,\n              ),\n              lookupElement(elements, op.target),\n            );\n          }\n          break;\n        case ir.OpKind.TwoWayProperty:\n          ir.OpList.insertBefore<ir.CreateOp>(\n            ir.createExtractedAttributeOp(\n              op.target,\n              ir.BindingKind.TwoWayProperty,\n              null,\n              op.name,\n              /* expression */ null,\n              /* i18nContext */ null,\n              /* i18nMessage */ null,\n              op.securityContext,\n            ),\n            lookupElement(elements, op.target),\n          );\n          break;\n        case ir.OpKind.StyleProp:\n        case ir.OpKind.ClassProp:\n          // TODO: Can style or class bindings be i18n attributes?\n\n          // The old compiler treated empty style bindings as regular bindings for the purpose of\n          // directive matching. That behavior is incorrect, but we emulate it in compatibility\n          // mode.\n          if (\n            unit.job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder &&\n            op.expression instanceof ir.EmptyExpr\n          ) {\n            ir.OpList.insertBefore<ir.CreateOp>(\n              ir.createExtractedAttributeOp(\n                op.target,\n                ir.BindingKind.Property,\n                null,\n                op.name,\n                /* expression */ null,\n                /* i18nContext */ null,\n                /* i18nMessage */ null,\n                SecurityContext.STYLE,\n              ),\n              lookupElement(elements, op.target),\n            );\n          }\n          break;\n        case ir.OpKind.Listener:\n          if (!op.isLegacyAnimationListener) {\n            const extractedAttributeOp = ir.createExtractedAttributeOp(\n              op.target,\n              ir.BindingKind.Property,\n              null,\n              op.name,\n              /* expression */ null,\n              /* i18nContext */ null,\n              /* i18nMessage */ null,\n              SecurityContext.NONE,\n            );\n            if (job.kind === CompilationJobKind.Host) {\n              if (job.compatibility) {\n                // TemplateDefinitionBuilder does not extract listener bindings to the const array\n                // (which is honestly pretty inconsistent).\n                break;\n              }\n              // This attribute will apply to the enclosing host binding compilation unit, so order\n              // doesn't matter.\n              unit.create.push(extractedAttributeOp);\n            } else {\n              ir.OpList.insertBefore<ir.CreateOp>(\n                extractedAttributeOp,\n                lookupElement(elements, op.target),\n              );\n            }\n          }\n          break;\n        case ir.OpKind.TwoWayListener:\n          // Two-way listeners aren't supported in host bindings.\n          if (job.kind !== CompilationJobKind.Host) {\n            const extractedAttributeOp = ir.createExtractedAttributeOp(\n              op.target,\n              ir.BindingKind.Property,\n              null,\n              op.name,\n              /* expression */ null,\n              /* i18nContext */ null,\n              /* i18nMessage */ null,\n              SecurityContext.NONE,\n            );\n            ir.OpList.insertBefore<ir.CreateOp>(\n              extractedAttributeOp,\n              lookupElement(elements, op.target),\n            );\n          }\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Looks up an element in the given map by xref ID.\n */\nfunction lookupElement(\n  elements: Map<ir.XrefId, ir.ConsumesSlotOpTrait & ir.CreateOp>,\n  xref: ir.XrefId,\n): ir.ConsumesSlotOpTrait & ir.CreateOp {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\n\n/**\n * Extracts an attribute binding.\n */\nfunction extractAttributeOp(\n  unit: CompilationUnit,\n  op: ir.AttributeOp,\n  elements: Map<ir.XrefId, ir.ConsumesSlotOpTrait & ir.CreateOp>,\n) {\n  if (op.expression instanceof ir.Interpolation) {\n    return;\n  }\n\n  let extractable = op.isTextAttribute || op.expression.isConstant();\n  if (unit.job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder) {\n    // TemplateDefinitionBuilder only extracts text attributes. It does not extract attriibute\n    // bindings, even if they are constants.\n    extractable &&= op.isTextAttribute;\n  }\n\n  if (extractable) {\n    const extractedAttributeOp = ir.createExtractedAttributeOp(\n      op.target,\n      op.isStructuralTemplateAttribute ? ir.BindingKind.Template : ir.BindingKind.Attribute,\n      op.namespace,\n      op.name,\n      op.expression,\n      op.i18nContext,\n      op.i18nMessage,\n      op.securityContext,\n    );\n    if (unit.job.kind === CompilationJobKind.Host) {\n      // This attribute will apply to the enclosing host binding compilation unit, so order doesn't\n      // matter.\n      unit.create.push(extractedAttributeOp);\n    } else {\n      const ownerOp = lookupElement(elements, op.target);\n      ir.OpList.insertBefore<ir.CreateOp>(extractedAttributeOp, ownerOp);\n    }\n    ir.OpList.remove<ir.UpdateOp>(op);\n  }\n}\n"]}