{"version":3,"file":"resolve_i18n_element_placeholders.js","sourceRoot":"","sources":["resolve_i18n_element_placeholders.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as i18n from '../../../../i18n/i18n_ast';\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob, ViewCompilationUnit} from '../compilation';\n\n/**\n * Resolve the element placeholders in i18n messages.\n */\nexport function resolveI18nElementPlaceholders(job: ComponentCompilationJob) {\n  // Record all of the element and i18n context ops for use later.\n  const i18nContexts = new Map<ir.XrefId, ir.I18nContextOp>();\n  const elements = new Map<ir.XrefId, ir.ElementStartOp>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nContext:\n          i18nContexts.set(op.xref, op);\n          break;\n        case ir.OpKind.ElementStart:\n          elements.set(op.xref, op);\n          break;\n      }\n    }\n  }\n\n  resolvePlaceholdersForView(job, job.root, i18nContexts, elements);\n}\n\n/**\n * Recursively resolves element and template tag placeholders in the given view.\n */\nfunction resolvePlaceholdersForView(\n  job: ComponentCompilationJob,\n  unit: ViewCompilationUnit,\n  i18nContexts: Map<ir.XrefId, ir.I18nContextOp>,\n  elements: Map<ir.XrefId, ir.ElementStartOp>,\n  pendingStructuralDirective?:\n    | ir.TemplateOp\n    | ir.ConditionalCreateOp\n    | ir.ConditionalBranchCreateOp,\n) {\n  // Track the current i18n op and corresponding i18n context op as we step through the creation\n  // IR.\n  let currentOps: {i18nBlock: ir.I18nStartOp; i18nContext: ir.I18nContextOp} | null = null;\n  let pendingStructuralDirectiveCloses = new Map<\n    ir.XrefId,\n    ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp\n  >();\n  for (const op of unit.create) {\n    switch (op.kind) {\n      case ir.OpKind.I18nStart:\n        if (!op.context) {\n          throw Error('Could not find i18n context for i18n op');\n        }\n        currentOps = {i18nBlock: op, i18nContext: i18nContexts.get(op.context)!};\n        break;\n      case ir.OpKind.I18nEnd:\n        currentOps = null;\n        break;\n      case ir.OpKind.ElementStart:\n        // For elements with i18n placeholders, record its slot value in the params map under the\n        // corresponding tag start placeholder.\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(\n            op,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirective,\n          );\n          // If there is a separate close tag placeholder for this element, save the pending\n          // structural directive so we can pass it to the closing tag as well.\n          if (pendingStructuralDirective && op.i18nPlaceholder.closeName) {\n            pendingStructuralDirectiveCloses.set(op.xref, pendingStructuralDirective);\n          }\n          // Clear out the pending structural directive now that its been accounted for.\n          pendingStructuralDirective = undefined;\n        }\n        break;\n      case ir.OpKind.ElementEnd:\n        // For elements with i18n placeholders, record its slot value in the params map under the\n        // corresponding tag close placeholder.\n        const startOp = elements.get(op.xref);\n        if (startOp && startOp.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error(\n              'AssertionError: i18n tag placeholder should only occur inside an i18n block',\n            );\n          }\n          recordElementClose(\n            startOp,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirectiveCloses.get(op.xref),\n          );\n          // Clear out the pending structural directive close that was accounted for.\n          pendingStructuralDirectiveCloses.delete(op.xref);\n        }\n        break;\n      case ir.OpKind.Projection:\n        // For content projections with i18n placeholders, record its slot value in the params map\n        // under the corresponding tag start and close placeholders.\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(\n            op,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirective,\n          );\n          recordElementClose(\n            op,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirective,\n          );\n          // Clear out the pending structural directive now that its been accounted for.\n          pendingStructuralDirective = undefined;\n        }\n\n        if (op.fallbackView !== null) {\n          const view = job.views.get(op.fallbackView)!;\n          if (op.fallbackViewI18nPlaceholder === undefined) {\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(\n              job,\n              view,\n              op.handle.slot!,\n              op.fallbackViewI18nPlaceholder,\n              currentOps.i18nContext,\n              currentOps.i18nBlock,\n              pendingStructuralDirective,\n            );\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(\n              job,\n              view,\n              op.handle.slot!,\n              op.fallbackViewI18nPlaceholder,\n              currentOps.i18nContext,\n              currentOps.i18nBlock,\n              pendingStructuralDirective,\n            );\n            pendingStructuralDirective = undefined;\n          }\n        }\n\n        break;\n      case ir.OpKind.ConditionalCreate:\n      case ir.OpKind.ConditionalBranchCreate:\n      case ir.OpKind.Template:\n        const view = job.views.get(op.xref)!;\n        if (op.i18nPlaceholder === undefined) {\n          // If there is no i18n placeholder, just recurse into the view in case it contains i18n\n          // blocks.\n          resolvePlaceholdersForView(job, view, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          if (op.templateKind === ir.TemplateKind.Structural) {\n            // If this is a structural directive template, don't record anything yet. Instead pass\n            // the current template as a pending structural directive to be recorded when we find\n            // the element, content, or template it belongs to. This allows us to create combined\n            // values that represent, e.g. the start of a template and element at the same time.\n            resolvePlaceholdersForView(job, view, i18nContexts, elements, op);\n          } else {\n            // If this is some other kind of template, we can record its start, recurse into its\n            // view, and then record its end.\n            recordTemplateStart(\n              job,\n              view,\n              op.handle.slot!,\n              op.i18nPlaceholder,\n              currentOps.i18nContext,\n              currentOps.i18nBlock,\n              pendingStructuralDirective,\n            );\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(\n              job,\n              view,\n              op.handle.slot!,\n              op.i18nPlaceholder,\n              currentOps!.i18nContext,\n              currentOps!.i18nBlock,\n              pendingStructuralDirective,\n            );\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n      case ir.OpKind.RepeaterCreate:\n        if (pendingStructuralDirective !== undefined) {\n          throw Error('AssertionError: Unexpected structural directive associated with @for block');\n        }\n        // RepeaterCreate has 3 slots: the first is for the op itself, the second is for the @for\n        // template and the (optional) third is for the @empty template.\n        const forSlot = op.handle.slot! + 1;\n        const forView = job.views.get(op.xref)!;\n        // First record all of the placeholders for the @for template.\n        if (op.i18nPlaceholder === undefined) {\n          // If there is no i18n placeholder, just recurse into the view in case it contains i18n\n          // blocks.\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordTemplateStart(\n            job,\n            forView,\n            forSlot,\n            op.i18nPlaceholder,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirective,\n          );\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n          recordTemplateClose(\n            job,\n            forView,\n            forSlot,\n            op.i18nPlaceholder,\n            currentOps!.i18nContext,\n            currentOps!.i18nBlock,\n            pendingStructuralDirective,\n          );\n          pendingStructuralDirective = undefined;\n        }\n        // Then if there's an @empty template, add its placeholders as well.\n        if (op.emptyView !== null) {\n          // RepeaterCreate has 3 slots: the first is for the op itself, the second is for the @for\n          // template and the (optional) third is for the @empty template.\n          const emptySlot = op.handle.slot! + 2;\n          const emptyView = job.views.get(op.emptyView!)!;\n          if (op.emptyI18nPlaceholder === undefined) {\n            // If there is no i18n placeholder, just recurse into the view in case it contains i18n\n            // blocks.\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(\n              job,\n              emptyView,\n              emptySlot,\n              op.emptyI18nPlaceholder,\n              currentOps.i18nContext,\n              currentOps.i18nBlock,\n              pendingStructuralDirective,\n            );\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n            recordTemplateClose(\n              job,\n              emptyView,\n              emptySlot,\n              op.emptyI18nPlaceholder,\n              currentOps!.i18nContext,\n              currentOps!.i18nBlock,\n              pendingStructuralDirective,\n            );\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n    }\n  }\n}\n\n/**\n * Records an i18n param value for the start of an element.\n */\nfunction recordElementStart(\n  op: ir.ElementStartOp | ir.ProjectionOp,\n  i18nContext: ir.I18nContextOp,\n  i18nBlock: ir.I18nStartOp,\n  structuralDirective?: ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp,\n) {\n  const {startName, closeName} = op.i18nPlaceholder!;\n  let flags = ir.I18nParamValueFlags.ElementTag | ir.I18nParamValueFlags.OpenTag;\n  let value: ir.I18nParamValue['value'] = op.handle.slot!;\n  // If the element is associated with a structural directive, start it as well.\n  if (structuralDirective !== undefined) {\n    flags |= ir.I18nParamValueFlags.TemplateTag;\n    value = {element: value, template: structuralDirective.handle.slot!};\n  }\n  // For self-closing tags, there is no close tag placeholder. Instead, the start tag\n  // placeholder accounts for the start and close of the element.\n  if (!closeName) {\n    flags |= ir.I18nParamValueFlags.CloseTag;\n  }\n  addParam(i18nContext.params, startName, value, i18nBlock.subTemplateIndex, flags);\n}\n\n/**\n * Records an i18n param value for the closing of an element.\n */\nfunction recordElementClose(\n  op: ir.ElementStartOp | ir.ProjectionOp,\n  i18nContext: ir.I18nContextOp,\n  i18nBlock: ir.I18nStartOp,\n  structuralDirective?: ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp,\n) {\n  const {closeName} = op.i18nPlaceholder!;\n  // Self-closing tags don't have a closing tag placeholder, instead the element closing is\n  // recorded via an additional flag on the element start value.\n  if (closeName) {\n    let flags = ir.I18nParamValueFlags.ElementTag | ir.I18nParamValueFlags.CloseTag;\n    let value: ir.I18nParamValue['value'] = op.handle.slot!;\n    // If the element is associated with a structural directive, close it as well.\n    if (structuralDirective !== undefined) {\n      flags |= ir.I18nParamValueFlags.TemplateTag;\n      value = {element: value, template: structuralDirective.handle.slot!};\n    }\n    addParam(i18nContext.params, closeName, value, i18nBlock.subTemplateIndex, flags);\n  }\n}\n\n/**\n * Records an i18n param value for the start of a template.\n */\nfunction recordTemplateStart(\n  job: ComponentCompilationJob,\n  view: ViewCompilationUnit,\n  slot: number,\n  i18nPlaceholder: i18n.TagPlaceholder | i18n.BlockPlaceholder,\n  i18nContext: ir.I18nContextOp,\n  i18nBlock: ir.I18nStartOp,\n  structuralDirective?: ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp,\n) {\n  let {startName, closeName} = i18nPlaceholder;\n  let flags = ir.I18nParamValueFlags.TemplateTag | ir.I18nParamValueFlags.OpenTag;\n  // For self-closing tags, there is no close tag placeholder. Instead, the start tag\n  // placeholder accounts for the start and close of the element.\n  if (!closeName) {\n    flags |= ir.I18nParamValueFlags.CloseTag;\n  }\n  // If the template is associated with a structural directive, record the structural directive's\n  // start first. Since this template must be in the structural directive's view, we can just\n  // directly use the current i18n block's sub-template index.\n  if (structuralDirective !== undefined) {\n    addParam(\n      i18nContext.params,\n      startName,\n      structuralDirective.handle.slot!,\n      i18nBlock.subTemplateIndex,\n      flags,\n    );\n  }\n  // Record the start of the template. For the sub-template index, pass the index for the template's\n  // view, rather than the current i18n block's index.\n  addParam(\n    i18nContext.params,\n    startName,\n    slot,\n    getSubTemplateIndexForTemplateTag(job, i18nBlock, view),\n    flags,\n  );\n}\n\n/**\n * Records an i18n param value for the closing of a template.\n */\nfunction recordTemplateClose(\n  job: ComponentCompilationJob,\n  view: ViewCompilationUnit,\n  slot: number,\n  i18nPlaceholder: i18n.TagPlaceholder | i18n.BlockPlaceholder,\n  i18nContext: ir.I18nContextOp,\n  i18nBlock: ir.I18nStartOp,\n  structuralDirective?: ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp,\n) {\n  const {closeName} = i18nPlaceholder;\n  const flags = ir.I18nParamValueFlags.TemplateTag | ir.I18nParamValueFlags.CloseTag;\n  // Self-closing tags don't have a closing tag placeholder, instead the template's closing is\n  // recorded via an additional flag on the template start value.\n  if (closeName) {\n    // Record the closing of the template. For the sub-template index, pass the index for the\n    // template's view, rather than the current i18n block's index.\n    addParam(\n      i18nContext.params,\n      closeName,\n      slot,\n      getSubTemplateIndexForTemplateTag(job, i18nBlock, view),\n      flags,\n    );\n    // If the template is associated with a structural directive, record the structural directive's\n    // closing after. Since this template must be in the structural directive's view, we can just\n    // directly use the current i18n block's sub-template index.\n    if (structuralDirective !== undefined) {\n      addParam(\n        i18nContext.params,\n        closeName,\n        structuralDirective.handle.slot!,\n        i18nBlock.subTemplateIndex,\n        flags,\n      );\n    }\n  }\n}\n\n/**\n * Get the subTemplateIndex for the given template op. For template ops, use the subTemplateIndex of\n * the child i18n block inside the template.\n */\nfunction getSubTemplateIndexForTemplateTag(\n  job: ComponentCompilationJob,\n  i18nOp: ir.I18nStartOp,\n  view: ViewCompilationUnit,\n): number | null {\n  for (const childOp of view.create) {\n    if (childOp.kind === ir.OpKind.I18nStart) {\n      return childOp.subTemplateIndex;\n    }\n  }\n  return i18nOp.subTemplateIndex;\n}\n\n/**\n * Add a param value to the given params map.\n */\nfunction addParam(\n  params: Map<string, ir.I18nParamValue[]>,\n  placeholder: string,\n  value: string | number | {element: number; template: number},\n  subTemplateIndex: number | null,\n  flags: ir.I18nParamValueFlags,\n) {\n  const values = params.get(placeholder) ?? [];\n  values.push({value, subTemplateIndex, flags});\n  params.set(placeholder, values);\n}\n"]}