{"version":3,"file":"remove_illegal_let_references.js","sourceRoot":"","sources":["remove_illegal_let_references.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,KAAK,CAAC,MAAM,+BAA+B,CAAC;AACnD,OAAO,KAAK,EAAE,MAAM,UAAU,CAAC;AAG/B;;;;;;;;GAQG;AACH,MAAM,UAAU,0BAA0B,CAAC,GAAmB;IAC5D,KAAK,MAAM,IAAI,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC;QAC7B,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAC7B,IACE,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,QAAQ;gBAC9B,EAAE,CAAC,QAAQ,CAAC,IAAI,KAAK,EAAE,CAAC,oBAAoB,CAAC,UAAU;gBACvD,CAAC,CAAC,EAAE,CAAC,WAAW,YAAY,EAAE,CAAC,YAAY,CAAC,EAC5C,CAAC;gBACD,SAAS;YACX,CAAC;YAED,MAAM,IAAI,GAAG,EAAE,CAAC,QAAQ,CAAC,UAAU,CAAC;YACpC,IAAI,OAAO,GAAuB,EAAE,CAAC;YACrC,OAAO,OAAO,IAAI,OAAO,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;gBACrD,EAAE,CAAC,wBAAwB,CACzB,OAAO,EACP,CAAC,IAAI,EAAE,EAAE,CACP,IAAI,YAAY,EAAE,CAAC,eAAe,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,EACxF,EAAE,CAAC,kBAAkB,CAAC,IAAI,CAC3B,CAAC;gBACF,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC;YACzB,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * It's not allowed to access a `@let` declaration before it has been defined. This is enforced\n * already via template type checking, however it can trip some of the assertions in the pipeline.\n * E.g. the naming phase can fail because we resolved the variable here, but the variable doesn't\n * exist anymore because the optimization phase removed it since it's invalid. To avoid surfacing\n * confusing errors to users in the case where template type checking isn't running (e.g. in JIT\n * mode) this phase detects illegal forward references and replaces them with `undefined`.\n * Eventually users will see the proper error from the template type checker.\n */\nexport function removeIllegalLetReferences(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (\n        op.kind !== ir.OpKind.Variable ||\n        op.variable.kind !== ir.SemanticVariableKind.Identifier ||\n        !(op.initializer instanceof ir.StoreLetExpr)\n      ) {\n        continue;\n      }\n\n      const name = op.variable.identifier;\n      let current: ir.UpdateOp | null = op;\n      while (current && current.kind !== ir.OpKind.ListEnd) {\n        ir.transformExpressionsInOp(\n          current,\n          (expr) =>\n            expr instanceof ir.LexicalReadExpr && expr.name === name ? o.literal(undefined) : expr,\n          ir.VisitorContextFlag.None,\n        );\n        current = current.prev;\n      }\n    }\n  }\n}\n"]}