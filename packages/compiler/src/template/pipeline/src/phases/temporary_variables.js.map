{"version":3,"file":"temporary_variables.js","sourceRoot":"","sources":["temporary_variables.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Find all assignments and usages of temporary variables, which are linked to each other with cross\n * references. Generate names for each cross-reference, and add a `DeclareVarStmt` to initialize\n * them at the beginning of the update block.\n *\n * TODO: Sometimes, it will be possible to reuse names across different subexpressions. For example,\n * in the double keyed read `a?.[f()]?.[f()]`, the two function calls have non-overlapping scopes.\n * Implement an algorithm for reuse.\n */\nexport function generateTemporaryVariables(job: CompilationJob): void {\n  for (const unit of job.units) {\n    unit.create.prepend(generateTemporaries(unit.create) as Array<ir.StatementOp<ir.CreateOp>>);\n    unit.update.prepend(generateTemporaries(unit.update) as Array<ir.StatementOp<ir.UpdateOp>>);\n  }\n}\n\nfunction generateTemporaries(\n  ops: ir.OpList<ir.CreateOp | ir.UpdateOp>,\n): Array<ir.StatementOp<ir.CreateOp | ir.UpdateOp>> {\n  let opCount = 0;\n  let generatedStatements: Array<ir.StatementOp<ir.UpdateOp>> = [];\n\n  // For each op, search for any variables that are assigned or read. For each variable, generate a\n  // name and produce a `DeclareVarStmt` to the beginning of the block.\n  for (const op of ops) {\n    // Identify the final time each temp var is read.\n    const finalReads = new Map<ir.XrefId, ir.ReadTemporaryExpr>();\n    ir.visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & ir.VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof ir.ReadTemporaryExpr) {\n        finalReads.set(expr.xref, expr);\n      }\n    });\n\n    // Name the temp vars, accounting for the fact that a name can be reused after it has been\n    // read for the final time.\n    let count = 0;\n    const assigned = new Set<ir.XrefId>();\n    const released = new Set<ir.XrefId>();\n    const defs = new Map<ir.XrefId, string>();\n    ir.visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & ir.VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof ir.AssignTemporaryExpr) {\n        if (!assigned.has(expr.xref)) {\n          assigned.add(expr.xref);\n          // TODO: Exactly replicate the naming scheme used by `TemplateDefinitionBuilder`.\n          // It seems to rely on an expression index instead of an op index.\n          defs.set(expr.xref, `tmp_${opCount}_${count++}`);\n        }\n        assignName(defs, expr);\n      } else if (expr instanceof ir.ReadTemporaryExpr) {\n        if (finalReads.get(expr.xref) === expr) {\n          released.add(expr.xref);\n          count--;\n        }\n        assignName(defs, expr);\n      }\n    });\n\n    // Add declarations for the temp vars.\n    generatedStatements.push(\n      ...Array.from(new Set(defs.values())).map((name) =>\n        ir.createStatementOp<ir.UpdateOp>(new o.DeclareVarStmt(name)),\n      ),\n    );\n    opCount++;\n\n    if (\n      op.kind === ir.OpKind.Listener ||\n      op.kind === ir.OpKind.Animation ||\n      op.kind === ir.OpKind.AnimationListener ||\n      op.kind === ir.OpKind.TwoWayListener\n    ) {\n      op.handlerOps.prepend(generateTemporaries(op.handlerOps) as ir.UpdateOp[]);\n    } else if (op.kind === ir.OpKind.RepeaterCreate && op.trackByOps !== null) {\n      op.trackByOps.prepend(generateTemporaries(op.trackByOps) as ir.UpdateOp[]);\n    }\n  }\n\n  return generatedStatements;\n}\n\n/**\n * Assigns a name to the temporary variable in the given temporary variable expression.\n */\nfunction assignName(\n  names: Map<ir.XrefId, string>,\n  expr: ir.AssignTemporaryExpr | ir.ReadTemporaryExpr,\n) {\n  const name = names.get(expr.xref);\n  if (name === undefined) {\n    throw new Error(`Found xref with unassigned name: ${expr.xref}`);\n  }\n  expr.name = name;\n}\n"]}