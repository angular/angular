{"version":3,"file":"ordering.js","sourceRoot":"","sources":["ordering.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJobKind, type CompilationJob} from '../compilation';\n\nfunction kindTest(kind: ir.OpKind): (op: ir.UpdateOp) => boolean {\n  return (op: ir.UpdateOp) => op.kind === kind;\n}\n\nfunction kindWithInterpolationTest(\n  kind: ir.OpKind.Attribute | ir.OpKind.Property | ir.OpKind.DomProperty,\n  interpolation: boolean,\n): (op: ir.UpdateOp) => boolean {\n  return (op: ir.UpdateOp) => {\n    return op.kind === kind && interpolation === op.expression instanceof ir.Interpolation;\n  };\n}\n\nfunction basicListenerKindTest(op: ir.CreateOp): boolean {\n  return (\n    (op.kind === ir.OpKind.Listener && !(op.hostListener && op.isLegacyAnimationListener)) ||\n    op.kind === ir.OpKind.TwoWayListener ||\n    op.kind === ir.OpKind.Animation ||\n    op.kind === ir.OpKind.AnimationListener\n  );\n}\n\nfunction nonInterpolationPropertyKindTest(op: ir.UpdateOp): boolean {\n  return (\n    (op.kind === ir.OpKind.Property || op.kind === ir.OpKind.TwoWayProperty) &&\n    !(op.expression instanceof ir.Interpolation)\n  );\n}\n\ninterface Rule<T extends ir.CreateOp | ir.UpdateOp> {\n  test: (op: T) => boolean;\n  transform?: (ops: Array<T>) => Array<T>;\n}\n\n/**\n * Defines the groups based on `OpKind` that ops will be divided into, for the various create\n * op kinds. Ops will be collected into groups, then optionally transformed, before recombining\n * the groups in the order defined here.\n */\nconst CREATE_ORDERING: Array<Rule<ir.CreateOp>> = [\n  {test: (op) => op.kind === ir.OpKind.Listener && op.hostListener && op.isLegacyAnimationListener},\n  {test: basicListenerKindTest},\n];\n\n/**\n * Defines the groups based on `OpKind` that ops will be divided into, for the various update\n * op kinds.\n */\nconst UPDATE_ORDERING: Array<Rule<ir.UpdateOp>> = [\n  {test: kindTest(ir.OpKind.StyleMap), transform: keepLast},\n  {test: kindTest(ir.OpKind.ClassMap), transform: keepLast},\n  {test: kindTest(ir.OpKind.StyleProp)},\n  {test: kindTest(ir.OpKind.ClassProp)},\n  {test: kindWithInterpolationTest(ir.OpKind.Attribute, true)},\n  {test: kindWithInterpolationTest(ir.OpKind.Property, true)},\n  {test: nonInterpolationPropertyKindTest},\n  {test: kindWithInterpolationTest(ir.OpKind.Attribute, false)},\n];\n\n/**\n * Host bindings have their own update ordering.\n */\nconst UPDATE_HOST_ORDERING: Array<Rule<ir.UpdateOp>> = [\n  {test: kindWithInterpolationTest(ir.OpKind.DomProperty, true)},\n  {test: kindWithInterpolationTest(ir.OpKind.DomProperty, false)},\n  {test: kindTest(ir.OpKind.Attribute)},\n  {test: kindTest(ir.OpKind.StyleMap), transform: keepLast},\n  {test: kindTest(ir.OpKind.ClassMap), transform: keepLast},\n  {test: kindTest(ir.OpKind.StyleProp)},\n  {test: kindTest(ir.OpKind.ClassProp)},\n];\n\n/**\n * The set of all op kinds we handle in the reordering phase.\n */\nconst handledOpKinds = new Set([\n  ir.OpKind.Listener,\n  ir.OpKind.TwoWayListener,\n  ir.OpKind.AnimationListener,\n  ir.OpKind.StyleMap,\n  ir.OpKind.ClassMap,\n  ir.OpKind.StyleProp,\n  ir.OpKind.ClassProp,\n  ir.OpKind.Property,\n  ir.OpKind.TwoWayProperty,\n  ir.OpKind.DomProperty,\n  ir.OpKind.Attribute,\n  ir.OpKind.Animation,\n]);\n\n/**\n * Many type of operations have ordering constraints that must be respected. For example, a\n * `ClassMap` instruction must be ordered after a `StyleMap` instruction, in order to have\n * predictable semantics that match TemplateDefinitionBuilder and don't break applications.\n */\nexport function orderOps(job: CompilationJob) {\n  for (const unit of job.units) {\n    // First, we pull out ops that need to be ordered. Then, when we encounter an op that shouldn't\n    // be reordered, put the ones we've pulled so far back in the correct order. Finally, if we\n    // still have ops pulled at the end, put them back in the correct order.\n\n    // Create mode:\n    orderWithin(unit.create, CREATE_ORDERING as Array<Rule<ir.CreateOp | ir.UpdateOp>>);\n\n    // Update mode:\n    const ordering =\n      unit.job.kind === CompilationJobKind.Host ? UPDATE_HOST_ORDERING : UPDATE_ORDERING;\n    orderWithin(unit.update, ordering as Array<Rule<ir.CreateOp | ir.UpdateOp>>);\n  }\n}\n\n/**\n * Order all the ops within the specified group.\n */\nfunction orderWithin(\n  opList: ir.OpList<ir.CreateOp | ir.UpdateOp>,\n  ordering: Array<Rule<ir.CreateOp | ir.UpdateOp>>,\n) {\n  let opsToOrder: Array<ir.CreateOp | ir.UpdateOp> = [];\n  // Only reorder ops that target the same xref; do not mix ops that target different xrefs.\n  let firstTargetInGroup: ir.XrefId | null = null;\n  for (const op of opList) {\n    const currentTarget = ir.hasDependsOnSlotContextTrait(op) ? op.target : null;\n    if (\n      !handledOpKinds.has(op.kind) ||\n      (currentTarget !== firstTargetInGroup &&\n        firstTargetInGroup !== null &&\n        currentTarget !== null)\n    ) {\n      ir.OpList.insertBefore(reorder(opsToOrder, ordering), op);\n      opsToOrder = [];\n      firstTargetInGroup = null;\n    }\n    if (handledOpKinds.has(op.kind)) {\n      opsToOrder.push(op);\n      ir.OpList.remove(op);\n      firstTargetInGroup = currentTarget ?? firstTargetInGroup;\n    }\n  }\n  opList.push(reorder(opsToOrder, ordering));\n}\n\n/**\n * Reorders the given list of ops according to the ordering defined by `ORDERING`.\n */\nfunction reorder<T extends ir.CreateOp | ir.UpdateOp>(\n  ops: Array<T>,\n  ordering: Array<Rule<T>>,\n): Array<T> {\n  // Break the ops list into groups based on OpKind.\n  const groups = Array.from(ordering, () => new Array<T>());\n  for (const op of ops) {\n    const groupIndex = ordering.findIndex((o) => o.test(op));\n    groups[groupIndex].push(op);\n  }\n  // Reassemble the groups into a single list, in the correct order.\n  return groups.flatMap((group, i) => {\n    const transform = ordering[i].transform;\n    return transform ? transform(group) : group;\n  });\n}\n\n/**\n * Keeps only the last op in a list of ops.\n */\nfunction keepLast<T>(ops: Array<T>) {\n  return ops.slice(ops.length - 1);\n}\n"]}