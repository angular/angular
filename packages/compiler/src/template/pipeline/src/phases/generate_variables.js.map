{"version":3,"file":"generate_variables.js","sourceRoot":"","sources":["generate_variables.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,KAAK,CAAC,MAAM,+BAA+B,CAAC;AACnD,OAAO,KAAK,EAAE,MAAM,UAAU,CAAC;AAI/B;;;;;;;;;;;;;GAaG;AACH,MAAM,UAAU,iBAAiB,CAAC,GAA4B;IAC5D,sBAAsB,CAAC,GAAG,CAAC,IAAI,EAAE,gDAAgD,CAAC,IAAI,CAAC,CAAC;AAC1F,CAAC;AAED;;;;;;GAMG;AACH,SAAS,sBAAsB,CAAC,IAAyB,EAAE,WAAyB;IAClF,oCAAoC;IACpC,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;IAEjD,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;QAC7B,QAAQ,EAAE,CAAC,IAAI,EAAE,CAAC;YAChB,KAAK,EAAE,CAAC,MAAM,CAAC,iBAAiB,CAAC;YACjC,KAAK,EAAE,CAAC,MAAM,CAAC,uBAAuB,CAAC;YACvC,KAAK,EAAE,CAAC,MAAM,CAAC,QAAQ;gBACrB,qCAAqC;gBACrC,sBAAsB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAE,EAAE,KAAK,CAAC,CAAC;gBAC5D,MAAM;YACR,KAAK,EAAE,CAAC,MAAM,CAAC,UAAU;gBACvB,IAAI,EAAE,CAAC,YAAY,KAAK,IAAI,EAAE,CAAC;oBAC7B,sBAAsB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,YAAY,CAAE,EAAE,KAAK,CAAC,CAAC;gBACtE,CAAC;gBACD,MAAM;YACR,KAAK,EAAE,CAAC,MAAM,CAAC,cAAc;gBAC3B,qCAAqC;gBACrC,sBAAsB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAE,EAAE,KAAK,CAAC,CAAC;gBAC5D,IAAI,EAAE,CAAC,SAAS,EAAE,CAAC;oBACjB,sBAAsB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,SAAS,CAAE,EAAE,KAAK,CAAC,CAAC;gBACnE,CAAC;gBACD,IAAI,EAAE,CAAC,UAAU,KAAK,IAAI,EAAE,CAAC;oBAC3B,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,+BAA+B,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;gBAC7E,CAAC;gBACD,MAAM;YACR,KAAK,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC;YACzB,KAAK,EAAE,CAAC,MAAM,CAAC,iBAAiB,CAAC;YACjC,KAAK,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC;YACxB,KAAK,EAAE,CAAC,MAAM,CAAC,cAAc;gBAC3B,mDAAmD;gBACnD,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,+BAA+B,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;gBAC1E,MAAM;QACV,CAAC;IACH,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,+BAA+B,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;AAC3E,CAAC;AA4ED;;;GAGG;AACH,SAAS,eAAe,CAAC,IAAyB,EAAE,MAAoB;IACtE,MAAM,KAAK,GAAU;QACnB,IAAI,EAAE,IAAI,CAAC,IAAI;QACf,mBAAmB,EAAE;YACnB,IAAI,EAAE,EAAE,CAAC,oBAAoB,CAAC,OAAO;YACrC,IAAI,EAAE,IAAI;YACV,IAAI,EAAE,IAAI,CAAC,IAAI;SAChB;QACD,gBAAgB,EAAE,IAAI,GAAG,EAA+B;QACxD,OAAO,EAAE,IAAI,CAAC,OAAO;QACrB,UAAU,EAAE,EAAE;QACd,eAAe,EAAE,EAAE;QACnB,MAAM;KACP,CAAC;IAEF,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,EAAE,CAAC;QACtD,KAAK,CAAC,gBAAgB,CAAC,GAAG,CAAC,UAAU,EAAE;YACrC,IAAI,EAAE,EAAE,CAAC,oBAAoB,CAAC,UAAU;YACxC,IAAI,EAAE,IAAI;YACV,UAAU;YACV,KAAK,EAAE,KAAK;SACb,CAAC,CAAC;IACL,CAAC;IAED,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;QAC7B,QAAQ,EAAE,CAAC,IAAI,EAAE,CAAC;YAChB,KAAK,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC;YAC5B,KAAK,EAAE,CAAC,MAAM,CAAC,iBAAiB,CAAC;YACjC,KAAK,EAAE,CAAC,MAAM,CAAC,uBAAuB,CAAC;YACvC,KAAK,EAAE,CAAC,MAAM,CAAC,QAAQ;gBACrB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,SAAS,CAAC,EAAE,CAAC;oBACjC,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;gBACvE,CAAC;gBAED,uDAAuD;gBACvD,KAAK,IAAI,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,CAAC;oBAC5D,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC;wBACpB,IAAI,EAAE,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,IAAI;wBAC/B,QAAQ,EAAE,EAAE,CAAC,IAAI;wBACjB,UAAU,EAAE,EAAE,CAAC,MAAM;wBACrB,MAAM;wBACN,QAAQ,EAAE;4BACR,IAAI,EAAE,EAAE,CAAC,oBAAoB,CAAC,UAAU;4BACxC,IAAI,EAAE,IAAI;4BACV,UAAU,EAAE,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,IAAI;4BACrC,KAAK,EAAE,KAAK;yBACb;qBACF,CAAC,CAAC;gBACL,CAAC;gBACD,MAAM;YAER,KAAK,EAAE,CAAC,MAAM,CAAC,UAAU;gBACvB,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC;oBACzB,QAAQ,EAAE,EAAE,CAAC,IAAI;oBACjB,UAAU,EAAE,EAAE,CAAC,MAAM;oBACrB,QAAQ,EAAE;wBACR,IAAI,EAAE,EAAE,CAAC,oBAAoB,CAAC,UAAU;wBACxC,IAAI,EAAE,IAAI;wBACV,UAAU,EAAE,EAAE,CAAC,YAAY;wBAC3B,KAAK,EAAE,KAAK;qBACb;iBACF,CAAC,CAAC;gBACH,MAAM;QACV,CAAC;IACH,CAAC;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;;GAKG;AACH,SAAS,+BAA+B,CACtC,IAAyB,EACzB,KAAY,EACZ,UAAmB;IAEnB,MAAM,MAAM,GAAiC,EAAE,CAAC;IAEhD,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,EAAE,CAAC;QAC7B,gGAAgG;QAChG,2FAA2F;QAC3F,wEAAwE;QACxE,MAAM,CAAC,IAAI,CACT,EAAE,CAAC,gBAAgB,CACjB,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,EACzB,KAAK,CAAC,mBAAmB,EACzB,IAAI,EAAE,CAAC,eAAe,EAAE,EACxB,EAAE,CAAC,aAAa,CAAC,IAAI,CACtB,CACF,CAAC;IACJ,CAAC;IAED,0EAA0E;IAC1E,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAE,CAAC;IAClD,KAAK,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,SAAS,CAAC,gBAAgB,EAAE,CAAC;QACvD,MAAM,OAAO,GAAG,IAAI,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC/C,wFAAwF;QACxF,MAAM,QAAQ,GAAG,KAAK,KAAK,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,YAAY,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACrF,gCAAgC;QAChC,MAAM,CAAC,IAAI,CACT,EAAE,CAAC,gBAAgB,CACjB,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,EACzB,KAAK,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAE,EACjC,QAAQ,EACR,EAAE,CAAC,aAAa,CAAC,IAAI,CACtB,CACF,CAAC;IACJ,CAAC;IAED,KAAK,MAAM,KAAK,IAAI,SAAS,CAAC,OAAO,EAAE,CAAC;QACtC,MAAM,CAAC,IAAI,CACT,EAAE,CAAC,gBAAgB,CACjB,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,EACzB,KAAK,EACL,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,EACxB,EAAE,CAAC,aAAa,CAAC,YAAY,CAC9B,CACF,CAAC;IACJ,CAAC;IAED,8EAA8E;IAC9E,KAAK,MAAM,GAAG,IAAI,KAAK,CAAC,UAAU,EAAE,CAAC;QACnC,MAAM,CAAC,IAAI,CACT,EAAE,CAAC,gBAAgB,CACjB,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,EACzB,GAAG,CAAC,QAAQ,EACZ,IAAI,EAAE,CAAC,aAAa,CAAC,GAAG,CAAC,QAAQ,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,MAAM,CAAC,EAC9D,EAAE,CAAC,aAAa,CAAC,IAAI,CACtB,CACF,CAAC;IACJ,CAAC;IAED,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,IAAI,UAAU,EAAE,CAAC;QAC3C,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC,eAAe,EAAE,CAAC;YACzC,MAAM,CAAC,IAAI,CACT,EAAE,CAAC,gBAAgB,CACjB,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,EACzB,IAAI,CAAC,QAAQ,EACb,IAAI,EAAE,CAAC,uBAAuB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,EAC9D,EAAE,CAAC,aAAa,CAAC,IAAI,CACtB,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAED,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,EAAE,CAAC;QAC1B,mDAAmD;QACnD,MAAM,CAAC,IAAI,CAAC,GAAG,+BAA+B,CAAC,IAAI,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;IAC7E,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilationJob, ViewCompilationUnit} from '../compilation';\n\n/**\n * Generate a preamble sequence for each view creation block and listener function which declares\n * any variables that be referenced in other operations in the block.\n *\n * Variables generated include:\n *   * a saved view context to be used to restore the current view in event listeners.\n *   * the context of the restored view within event listener handlers.\n *   * context variables from the current view as well as all parent views (including the root\n *     context if needed).\n *   * local references from elements within the current view and any lexical parents.\n *\n * Variables are generated here unconditionally, and may optimized away in future operations if it\n * turns out their values (and any side effects) are unused.\n */\nexport function generateVariables(job: ComponentCompilationJob): void {\n  recursivelyProcessView(job.root, /* there is no parent scope for the root view */ null);\n}\n\n/**\n * Process the given `ViewCompilation` and generate preambles for it and any listeners that it\n * declares.\n *\n * @param `parentScope` a scope extracted from the parent view which captures any variables which\n *     should be inherited by this view. `null` if the current view is the root view.\n */\nfunction recursivelyProcessView(view: ViewCompilationUnit, parentScope: Scope | null): void {\n  // Extract a `Scope` from this view.\n  const scope = getScopeForView(view, parentScope);\n\n  for (const op of view.create) {\n    switch (op.kind) {\n      case ir.OpKind.ConditionalCreate:\n      case ir.OpKind.ConditionalBranchCreate:\n      case ir.OpKind.Template:\n        // Descend into child embedded views.\n        recursivelyProcessView(view.job.views.get(op.xref)!, scope);\n        break;\n      case ir.OpKind.Projection:\n        if (op.fallbackView !== null) {\n          recursivelyProcessView(view.job.views.get(op.fallbackView)!, scope);\n        }\n        break;\n      case ir.OpKind.RepeaterCreate:\n        // Descend into child embedded views.\n        recursivelyProcessView(view.job.views.get(op.xref)!, scope);\n        if (op.emptyView) {\n          recursivelyProcessView(view.job.views.get(op.emptyView)!, scope);\n        }\n        if (op.trackByOps !== null) {\n          op.trackByOps.prepend(generateVariablesInScopeForView(view, scope, false));\n        }\n        break;\n      case ir.OpKind.Animation:\n      case ir.OpKind.AnimationListener:\n      case ir.OpKind.Listener:\n      case ir.OpKind.TwoWayListener:\n        // Prepend variables to listener handler functions.\n        op.handlerOps.prepend(generateVariablesInScopeForView(view, scope, true));\n        break;\n    }\n  }\n\n  view.update.prepend(generateVariablesInScopeForView(view, scope, false));\n}\n\n/**\n * Lexical scope of a view, including a reference to its parent view's scope, if any.\n */\ninterface Scope {\n  /**\n   * `XrefId` of the view to which this scope corresponds.\n   */\n  view: ir.XrefId;\n\n  viewContextVariable: ir.SemanticVariable;\n\n  contextVariables: Map<string, ir.SemanticVariable>;\n\n  aliases: Set<ir.AliasVariable>;\n\n  /**\n   * Local references collected from elements within the view.\n   */\n  references: Reference[];\n\n  /**\n   * `@let` declarations collected from the view.\n   */\n  letDeclarations: LetDeclaration[];\n\n  /**\n   * `Scope` of the parent view, if any.\n   */\n  parent: Scope | null;\n}\n\n/**\n * Information needed about a local reference collected from an element within a view.\n */\ninterface Reference {\n  /**\n   * Name given to the local reference variable within the template.\n   *\n   * This is not the name which will be used for the variable declaration in the generated\n   * template code.\n   */\n  name: string;\n\n  /**\n   * `XrefId` of the element-like node which this reference targets.\n   *\n   * The reference may be either to the element (or template) itself, or to a directive on it.\n   */\n  targetId: ir.XrefId;\n\n  targetSlot: ir.SlotHandle;\n\n  /**\n   * A generated offset of this reference among all the references on a specific element.\n   */\n  offset: number;\n\n  variable: ir.SemanticVariable;\n}\n\n/**\n * Information about `@let` declaration collected from a view.\n */\ninterface LetDeclaration {\n  /** `XrefId` of the `@let` declaration that the reference is pointing to. */\n  targetId: ir.XrefId;\n\n  /** Slot in which the declaration is stored. */\n  targetSlot: ir.SlotHandle;\n\n  /** Variable referring to the declaration. */\n  variable: ir.IdentifierVariable;\n}\n\n/**\n * Process a view and generate a `Scope` representing the variables available for reference within\n * that view.\n */\nfunction getScopeForView(view: ViewCompilationUnit, parent: Scope | null): Scope {\n  const scope: Scope = {\n    view: view.xref,\n    viewContextVariable: {\n      kind: ir.SemanticVariableKind.Context,\n      name: null,\n      view: view.xref,\n    },\n    contextVariables: new Map<string, ir.SemanticVariable>(),\n    aliases: view.aliases,\n    references: [],\n    letDeclarations: [],\n    parent,\n  };\n\n  for (const identifier of view.contextVariables.keys()) {\n    scope.contextVariables.set(identifier, {\n      kind: ir.SemanticVariableKind.Identifier,\n      name: null,\n      identifier,\n      local: false,\n    });\n  }\n\n  for (const op of view.create) {\n    switch (op.kind) {\n      case ir.OpKind.ElementStart:\n      case ir.OpKind.ConditionalCreate:\n      case ir.OpKind.ConditionalBranchCreate:\n      case ir.OpKind.Template:\n        if (!Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: expected localRefs to be an array`);\n        }\n\n        // Record available local references from this element.\n        for (let offset = 0; offset < op.localRefs.length; offset++) {\n          scope.references.push({\n            name: op.localRefs[offset].name,\n            targetId: op.xref,\n            targetSlot: op.handle,\n            offset,\n            variable: {\n              kind: ir.SemanticVariableKind.Identifier,\n              name: null,\n              identifier: op.localRefs[offset].name,\n              local: false,\n            },\n          });\n        }\n        break;\n\n      case ir.OpKind.DeclareLet:\n        scope.letDeclarations.push({\n          targetId: op.xref,\n          targetSlot: op.handle,\n          variable: {\n            kind: ir.SemanticVariableKind.Identifier,\n            name: null,\n            identifier: op.declaredName,\n            local: false,\n          },\n        });\n        break;\n    }\n  }\n\n  return scope;\n}\n\n/**\n * Generate declarations for all variables that are in scope for a given view.\n *\n * This is a recursive process, as views inherit variables available from their parent view, which\n * itself may have inherited variables, etc.\n */\nfunction generateVariablesInScopeForView(\n  view: ViewCompilationUnit,\n  scope: Scope,\n  isCallback: boolean,\n): ir.VariableOp<ir.UpdateOp>[] {\n  const newOps: ir.VariableOp<ir.UpdateOp>[] = [];\n\n  if (scope.view !== view.xref) {\n    // Before generating variables for a parent view, we need to switch to the context of the parent\n    // view with a `nextContext` expression. This context switching operation itself declares a\n    // variable, because the context of the view may be referenced directly.\n    newOps.push(\n      ir.createVariableOp(\n        view.job.allocateXrefId(),\n        scope.viewContextVariable,\n        new ir.NextContextExpr(),\n        ir.VariableFlags.None,\n      ),\n    );\n  }\n\n  // Add variables for all context variables available in this scope's view.\n  const scopeView = view.job.views.get(scope.view)!;\n  for (const [name, value] of scopeView.contextVariables) {\n    const context = new ir.ContextExpr(scope.view);\n    // We either read the context, or, if the variable is CTX_REF, use the context directly.\n    const variable = value === ir.CTX_REF ? context : new o.ReadPropExpr(context, value);\n    // Add the variable declaration.\n    newOps.push(\n      ir.createVariableOp(\n        view.job.allocateXrefId(),\n        scope.contextVariables.get(name)!,\n        variable,\n        ir.VariableFlags.None,\n      ),\n    );\n  }\n\n  for (const alias of scopeView.aliases) {\n    newOps.push(\n      ir.createVariableOp(\n        view.job.allocateXrefId(),\n        alias,\n        alias.expression.clone(),\n        ir.VariableFlags.AlwaysInline,\n      ),\n    );\n  }\n\n  // Add variables for all local references declared for elements in this scope.\n  for (const ref of scope.references) {\n    newOps.push(\n      ir.createVariableOp(\n        view.job.allocateXrefId(),\n        ref.variable,\n        new ir.ReferenceExpr(ref.targetId, ref.targetSlot, ref.offset),\n        ir.VariableFlags.None,\n      ),\n    );\n  }\n\n  if (scope.view !== view.xref || isCallback) {\n    for (const decl of scope.letDeclarations) {\n      newOps.push(\n        ir.createVariableOp<ir.UpdateOp>(\n          view.job.allocateXrefId(),\n          decl.variable,\n          new ir.ContextLetReferenceExpr(decl.targetId, decl.targetSlot),\n          ir.VariableFlags.None,\n        ),\n      );\n    }\n  }\n\n  if (scope.parent !== null) {\n    // Recursively add variables from the parent scope.\n    newOps.push(...generateVariablesInScopeForView(view, scope.parent, false));\n  }\n  return newOps;\n}\n"]}