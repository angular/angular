{"version":3,"file":"local_refs.js","sourceRoot":"","sources":["local_refs.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,KAAK,CAAC,MAAM,+BAA+B,CAAC;AACnD,OAAO,KAAK,EAAE,MAAM,UAAU,CAAC;AAI/B;;;GAGG;AACH,MAAM,UAAU,aAAa,CAAC,GAA4B;IACxD,KAAK,MAAM,IAAI,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC;QAC7B,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAC7B,QAAQ,EAAE,CAAC,IAAI,EAAE,CAAC;gBAChB,KAAK,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC;gBAC5B,KAAK,EAAE,CAAC,MAAM,CAAC,iBAAiB,CAAC;gBACjC,KAAK,EAAE,CAAC,MAAM,CAAC,uBAAuB,CAAC;gBACvC,KAAK,EAAE,CAAC,MAAM,CAAC,QAAQ;oBACrB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,SAAS,CAAC,EAAE,CAAC;wBACjC,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;oBAC7E,CAAC;oBACD,EAAE,CAAC,YAAY,IAAI,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC;oBAEvC,IAAI,EAAE,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBAC5B,MAAM,SAAS,GAAG,kBAAkB,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC;wBACnD,EAAE,CAAC,SAAS,GAAG,GAAG,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;oBACzC,CAAC;yBAAM,CAAC;wBACN,EAAE,CAAC,SAAS,GAAG,IAAI,CAAC;oBACtB,CAAC;oBACD,MAAM;YACV,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC;AAED,SAAS,kBAAkB,CAAC,IAAmB;IAC7C,MAAM,SAAS,GAAmB,EAAE,CAAC;IACrC,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC;QACvB,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;IAC7D,CAAC;IACD,OAAO,CAAC,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;AACjC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilationJob} from '../compilation';\n\n/**\n * Lifts local reference declarations on element-like structures within each view into an entry in\n * the `consts` array for the whole component.\n */\nexport function liftLocalRefs(job: ComponentCompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.ElementStart:\n        case ir.OpKind.ConditionalCreate:\n        case ir.OpKind.ConditionalBranchCreate:\n        case ir.OpKind.Template:\n          if (!Array.isArray(op.localRefs)) {\n            throw new Error(`AssertionError: expected localRefs to be an array still`);\n          }\n          op.numSlotsUsed += op.localRefs.length;\n\n          if (op.localRefs.length > 0) {\n            const localRefs = serializeLocalRefs(op.localRefs);\n            op.localRefs = job.addConst(localRefs);\n          } else {\n            op.localRefs = null;\n          }\n          break;\n      }\n    }\n  }\n}\n\nfunction serializeLocalRefs(refs: ir.LocalRef[]): o.Expression {\n  const constRefs: o.Expression[] = [];\n  for (const ref of refs) {\n    constRefs.push(o.literal(ref.name), o.literal(ref.target));\n  }\n  return o.literalArr(constRefs);\n}\n"]}