{"version":3,"file":"conditionals.js","sourceRoot":"","sources":["conditionals.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob} from '../compilation';\n\n/**\n * Collapse the various conditions of conditional ops (if, switch) into a single test expression.\n */\nexport function generateConditionalExpressions(job: ComponentCompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== ir.OpKind.Conditional) {\n        continue;\n      }\n\n      let test: o.Expression;\n\n      // Any case with a `null` condition is `default`. If one exists, default to it instead.\n      const defaultCase = op.conditions.findIndex((cond) => cond.expr === null);\n      if (defaultCase >= 0) {\n        const slot = op.conditions.splice(defaultCase, 1)[0].targetSlot;\n        test = new ir.SlotLiteralExpr(slot);\n      } else {\n        // By default, a switch evaluates to `-1`, causing no template to be displayed.\n        test = o.literal(-1);\n      }\n\n      // Switch expressions assign their main test to a temporary, to avoid re-executing it.\n      let tmp = op.test == null ? null : new ir.AssignTemporaryExpr(op.test, job.allocateXrefId());\n      let caseExpressionTemporaryXref: ir.XrefId | null = null;\n\n      // For each remaining condition, test whether the temporary satifies the check. (If no temp is\n      // present, just check each expression directly.)\n      for (let i = op.conditions.length - 1; i >= 0; i--) {\n        let conditionalCase = op.conditions[i];\n        if (conditionalCase.expr === null) {\n          continue;\n        }\n        if (tmp !== null) {\n          const useTmp = i === 0 ? tmp : new ir.ReadTemporaryExpr(tmp.xref);\n          conditionalCase.expr = new o.BinaryOperatorExpr(\n            o.BinaryOperator.Identical,\n            useTmp,\n            conditionalCase.expr,\n          );\n        } else if (conditionalCase.alias !== null) {\n          // Since we can only pass one variable into the conditional instruction,\n          // reuse the same variable to store the result of the expressions.\n          caseExpressionTemporaryXref ??= job.allocateXrefId();\n          conditionalCase.expr = new ir.AssignTemporaryExpr(\n            conditionalCase.expr,\n            caseExpressionTemporaryXref,\n          );\n          op.contextValue = new ir.ReadTemporaryExpr(caseExpressionTemporaryXref);\n        }\n        test = new o.ConditionalExpr(\n          conditionalCase.expr,\n          new ir.SlotLiteralExpr(conditionalCase.targetSlot),\n          test,\n        );\n      }\n\n      // Save the resulting aggregate Joost-expression.\n      op.processed = test;\n\n      // Clear the original conditions array, since we no longer need it, and don't want it to\n      // affect subsequent phases (e.g. pipe creation).\n      op.conditions = [];\n    }\n  }\n}\n"]}