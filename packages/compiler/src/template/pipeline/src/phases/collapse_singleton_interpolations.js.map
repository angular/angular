{"version":3,"file":"collapse_singleton_interpolations.js","sourceRoot":"","sources":["collapse_singleton_interpolations.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,KAAK,EAAE,MAAM,UAAU,CAAC;AAG/B;;;;;;;;;GASG;AACH,MAAM,UAAU,+BAA+B,CAAC,GAAmB;IACjE,KAAK,MAAM,IAAI,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC;QAC7B,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAC7B,MAAM,cAAc,GAClB,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,SAAS;gBAC/B,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,SAAS;gBAC/B,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ;gBAC7B,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC;YACjC,IACE,cAAc;gBACd,EAAE,CAAC,UAAU,YAAY,EAAE,CAAC,aAAa;gBACzC,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC;gBAClC,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,EAC5C,CAAC;gBACD,EAAE,CAAC,UAAU,GAAG,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YAC/C,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Attribute or style interpolations of the form `[attr.foo]=\"{{foo}}\"\"` should be \"collapsed\"\n * into a plain instruction, instead of an interpolated one.\n *\n * (We cannot do this for singleton property interpolations,\n * because they need to stringify their expressions)\n *\n * The reification step is also capable of performing this transformation, but doing it early in the\n * pipeline allows other phases to accurately know what instruction will be emitted.\n */\nexport function collapseSingletonInterpolations(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      const eligibleOpKind =\n        op.kind === ir.OpKind.Attribute ||\n        op.kind === ir.OpKind.StyleProp ||\n        op.kind == ir.OpKind.StyleMap ||\n        op.kind === ir.OpKind.ClassMap;\n      if (\n        eligibleOpKind &&\n        op.expression instanceof ir.Interpolation &&\n        op.expression.strings.length === 2 &&\n        op.expression.strings.every((s) => s === '')\n      ) {\n        op.expression = op.expression.expressions[0];\n      }\n    }\n  }\n}\n"]}