{"version":3,"file":"resolve_names.js","sourceRoot":"","sources":["resolve_names.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob, CompilationUnit} from '../compilation';\n\n/**\n * Resolves lexical references in views (`ir.LexicalReadExpr`) to either a target variable or to\n * property reads on the top-level component context.\n *\n * Also matches `ir.RestoreViewExpr` expressions with the variables of their corresponding saved\n * views.\n */\nexport function resolveNames(job: CompilationJob): void {\n  for (const unit of job.units) {\n    processLexicalScope(unit, unit.create, null);\n    processLexicalScope(unit, unit.update, null);\n  }\n}\n\nfunction processLexicalScope(\n  unit: CompilationUnit,\n  ops: ir.OpList<ir.CreateOp> | ir.OpList<ir.UpdateOp>,\n  savedView: SavedView | null,\n): void {\n  // Maps names defined in the lexical scope of this template to the `ir.XrefId`s of the variable\n  // declarations which represent those values.\n  //\n  // Since variables are generated in each view for the entire lexical scope (including any\n  // identifiers from parent templates) only local variables need be considered here.\n  const scope = new Map<string, ir.XrefId>();\n\n  // Symbols defined within the current scope. They take precedence over ones defined outside.\n  const localDefinitions = new Map<string, ir.XrefId>();\n\n  // First, step through the operations list and:\n  // 1) build up the `scope` mapping\n  // 2) recurse into any listener functions\n  for (const op of ops) {\n    switch (op.kind) {\n      case ir.OpKind.Variable:\n        switch (op.variable.kind) {\n          case ir.SemanticVariableKind.Identifier:\n            if (op.variable.local) {\n              if (localDefinitions.has(op.variable.identifier)) {\n                continue;\n              }\n              localDefinitions.set(op.variable.identifier, op.xref);\n            } else if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case ir.SemanticVariableKind.Alias:\n            // This variable represents some kind of identifier which can be used in the template.\n            if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case ir.SemanticVariableKind.SavedView:\n            // This variable represents a snapshot of the current view context, and can be used to\n            // restore that context within listener functions.\n            savedView = {\n              view: op.variable.view,\n              variable: op.xref,\n            };\n            break;\n        }\n        break;\n      case ir.OpKind.Animation:\n      case ir.OpKind.AnimationListener:\n      case ir.OpKind.Listener:\n      case ir.OpKind.TwoWayListener:\n        // Listener functions have separate variable declarations, so process them as a separate\n        // lexical scope.\n        processLexicalScope(unit, op.handlerOps, savedView);\n        break;\n      case ir.OpKind.RepeaterCreate:\n        if (op.trackByOps !== null) {\n          processLexicalScope(unit, op.trackByOps, savedView);\n        }\n        break;\n    }\n  }\n\n  // Next, use the `scope` mapping to match `ir.LexicalReadExpr` with defined names in the lexical\n  // scope. Also, look for `ir.RestoreViewExpr`s and match them with the snapshotted view context\n  // variable.\n  for (const op of ops) {\n    if (\n      op.kind == ir.OpKind.Listener ||\n      op.kind === ir.OpKind.TwoWayListener ||\n      op.kind === ir.OpKind.Animation ||\n      op.kind === ir.OpKind.AnimationListener\n    ) {\n      // Listeners were already processed above with their own scopes.\n      continue;\n    }\n    ir.transformExpressionsInOp(\n      op,\n      (expr) => {\n        if (expr instanceof ir.LexicalReadExpr) {\n          // `expr` is a read of a name within the lexical scope of this view.\n          // Either that name is defined within the current view, or it represents a property from the\n          // main component context.\n          if (localDefinitions.has(expr.name)) {\n            return new ir.ReadVariableExpr(localDefinitions.get(expr.name)!);\n          } else if (scope.has(expr.name)) {\n            // This was a defined variable in the current scope.\n            return new ir.ReadVariableExpr(scope.get(expr.name)!);\n          } else {\n            // Reading from the component context.\n            return new o.ReadPropExpr(new ir.ContextExpr(unit.job.root.xref), expr.name);\n          }\n        } else if (expr instanceof ir.RestoreViewExpr && typeof expr.view === 'number') {\n          // `ir.RestoreViewExpr` happens in listener functions and restores a saved view from the\n          // parent creation list. We expect to find that we captured the `savedView` previously, and\n          // that it matches the expected view to be restored.\n          if (savedView === null || savedView.view !== expr.view) {\n            throw new Error(`AssertionError: no saved view ${expr.view} from view ${unit.xref}`);\n          }\n          expr.view = new ir.ReadVariableExpr(savedView.variable);\n          return expr;\n        } else {\n          return expr;\n        }\n      },\n      ir.VisitorContextFlag.None,\n    );\n  }\n\n  for (const op of ops) {\n    ir.visitExpressionsInOp(op, (expr) => {\n      if (expr instanceof ir.LexicalReadExpr) {\n        throw new Error(\n          `AssertionError: no lexical reads should remain, but found read of ${expr.name}`,\n        );\n      }\n    });\n  }\n}\n\n/**\n * Information about a `SavedView` variable.\n */\ninterface SavedView {\n  /**\n   * The view `ir.XrefId` which was saved into this variable.\n   */\n  view: ir.XrefId;\n\n  /**\n   * The `ir.XrefId` of the variable into which the view was saved.\n   */\n  variable: ir.XrefId;\n}\n"]}