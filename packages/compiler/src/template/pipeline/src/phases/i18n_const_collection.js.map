{"version":3,"file":"i18n_const_collection.js","sourceRoot":"","sources":["i18n_const_collection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {type ConstantPool} from '../../../../constant_pool';\nimport * as i18n from '../../../../i18n/i18n_ast';\nimport {mapLiteral} from '../../../../output/map_util';\nimport * as o from '../../../../output/output_ast';\nimport {sanitizeIdentifier} from '../../../../parse_util';\nimport {Identifiers} from '../../../../render3/r3_identifiers';\nimport {createGoogleGetMsgStatements} from '../../../../render3/view/i18n/get_msg_utils';\nimport {createLocalizeStatements} from '../../../../render3/view/i18n/localize_utils';\nimport {formatI18nPlaceholderNamesInMap} from '../../../../render3/view/i18n/util';\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob} from '../compilation';\n\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nconst TRANSLATION_VAR_PREFIX = 'i18n_';\n\n/** Prefix of ICU expressions for post processing */\nexport const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n\n/**\n * The escape sequence used for message param values.\n */\nconst ESCAPE = '\\uFFFD';\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nexport function getTranslationConstPrefix(extra: string): string {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nexport function declareI18nVariable(variable: o.ReadVarExpr): o.Statement {\n  return new o.DeclareVarStmt(\n    variable.name!,\n    undefined,\n    o.INFERRED_TYPE,\n    undefined,\n    variable.sourceSpan,\n  );\n}\n\n/**\n * Lifts i18n properties into the consts array.\n * TODO: Can we use `ConstCollectedExpr`?\n * TODO: The way the various attributes are linked together is very complex. Perhaps we could\n * simplify the process, maybe by combining the context and message ops?\n */\nexport function collectI18nConsts(job: ComponentCompilationJob): void {\n  const fileBasedI18nSuffix =\n    job.relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_').toUpperCase() + '_';\n  // Step One: Build up various lookup maps we need to collect all the consts.\n\n  // Context Xref -> Extracted Attribute Ops\n  const extractedAttributesByI18nContext = new Map<ir.XrefId, ir.ExtractedAttributeOp[]>();\n  // Element/ElementStart Xref -> I18n Attributes config op\n  const i18nAttributesByElement = new Map<ir.XrefId, ir.I18nAttributesOp>();\n  // Element/ElementStart Xref -> All I18n Expression ops for attrs on that target\n  const i18nExpressionsByElement = new Map<ir.XrefId, ir.I18nExpressionOp[]>();\n  // I18n Message Xref -> I18n Message Op (TODO: use a central op map)\n  const messages = new Map<ir.XrefId, ir.I18nMessageOp>();\n\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === ir.OpKind.ExtractedAttribute && op.i18nContext !== null) {\n        const attributes = extractedAttributesByI18nContext.get(op.i18nContext) ?? [];\n        attributes.push(op);\n        extractedAttributesByI18nContext.set(op.i18nContext, attributes);\n      } else if (op.kind === ir.OpKind.I18nAttributes) {\n        i18nAttributesByElement.set(op.target, op);\n      } else if (\n        op.kind === ir.OpKind.I18nExpression &&\n        op.usage === ir.I18nExpressionFor.I18nAttribute\n      ) {\n        const expressions = i18nExpressionsByElement.get(op.target) ?? [];\n        expressions.push(op);\n        i18nExpressionsByElement.set(op.target, expressions);\n      } else if (op.kind === ir.OpKind.I18nMessage) {\n        messages.set(op.xref, op);\n      }\n    }\n  }\n\n  // Step Two: Serialize the extracted i18n messages for root i18n blocks and i18n attributes into\n  // the const array.\n  //\n  // Also, each i18n message will have a variable expression that can refer to its\n  // value. Store these expressions in the appropriate place:\n  // 1. For normal i18n content, it also goes in the const array. We save the const index to use\n  // later.\n  // 2. For extracted attributes, it becomes the value of the extracted attribute instruction.\n  // 3. For i18n bindings, it will go in a separate const array instruction below; for now, we just\n  // save it.\n\n  const i18nValuesByContext = new Map<ir.XrefId, o.Expression>();\n  const messageConstIndices = new Map<ir.XrefId, ir.ConstIndex>();\n\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.I18nMessage) {\n        if (op.messagePlaceholder === null) {\n          const {mainVar, statements} = collectMessage(job, fileBasedI18nSuffix, messages, op);\n          if (op.i18nBlock !== null) {\n            // This is a regular i18n message with a corresponding i18n block. Collect it into the\n            // const array.\n            const i18nConst = job.addConst(mainVar, statements);\n            messageConstIndices.set(op.i18nBlock, i18nConst);\n          } else {\n            // This is an i18n attribute. Extract the initializers into the const pool.\n            job.constsInitializers.push(...statements);\n\n            // Save the i18n variable value for later.\n            i18nValuesByContext.set(op.i18nContext, mainVar);\n\n            // This i18n message may correspond to an individual extracted attribute. If so, The\n            // value of that attribute is updated to read the extracted i18n variable.\n            const attributesForMessage = extractedAttributesByI18nContext.get(op.i18nContext);\n            if (attributesForMessage !== undefined) {\n              for (const attr of attributesForMessage) {\n                attr.expression = mainVar.clone();\n              }\n            }\n          }\n        }\n        ir.OpList.remove<ir.CreateOp>(op);\n      }\n    }\n  }\n\n  // Step Three: Serialize I18nAttributes configurations into the const array. Each I18nAttributes\n  // instruction has a config array, which contains k-v pairs describing each binding name, and the\n  // i18n variable that provides the value.\n\n  for (const unit of job.units) {\n    for (const elem of unit.create) {\n      if (ir.isElementOrContainerOp(elem)) {\n        const i18nAttributes = i18nAttributesByElement.get(elem.xref);\n        if (i18nAttributes === undefined) {\n          // This element is not associated with an i18n attributes configuration instruction.\n          continue;\n        }\n\n        let i18nExpressions = i18nExpressionsByElement.get(elem.xref);\n        if (i18nExpressions === undefined) {\n          // Unused i18nAttributes should have already been removed.\n          // TODO: Should the removal of those dead instructions be merged with this phase?\n          throw new Error(\n            'AssertionError: Could not find any i18n expressions associated with an I18nAttributes instruction',\n          );\n        }\n\n        // Find expressions for all the unique property names, removing duplicates.\n        const seenPropertyNames = new Set<string>();\n        i18nExpressions = i18nExpressions.filter((i18nExpr) => {\n          const seen = seenPropertyNames.has(i18nExpr.name);\n          seenPropertyNames.add(i18nExpr.name);\n          return !seen;\n        });\n\n        const i18nAttributeConfig = i18nExpressions.flatMap((i18nExpr) => {\n          const i18nExprValue = i18nValuesByContext.get(i18nExpr.context);\n          if (i18nExprValue === undefined) {\n            throw new Error(\"AssertionError: Could not find i18n expression's value\");\n          }\n          return [o.literal(i18nExpr.name), i18nExprValue];\n        });\n\n        i18nAttributes.i18nAttributesConfig = job.addConst(\n          new o.LiteralArrayExpr(i18nAttributeConfig),\n        );\n      }\n    }\n  }\n\n  // Step Four: Propagate the extracted const index into i18n ops that messages were extracted from.\n\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.I18nStart) {\n        const msgIndex = messageConstIndices.get(op.root);\n        if (msgIndex === undefined) {\n          throw new Error(\n            'AssertionError: Could not find corresponding i18n block index for an i18n message op; was an i18n message incorrectly assumed to correspond to an attribute?',\n          );\n        }\n        op.messageIndex = msgIndex;\n      }\n    }\n  }\n}\n\n/**\n * Collects the given message into a set of statements that can be added to the const array.\n * This will recursively collect any sub-messages referenced from the parent message as well.\n */\nfunction collectMessage(\n  job: ComponentCompilationJob,\n  fileBasedI18nSuffix: string,\n  messages: Map<ir.XrefId, ir.I18nMessageOp>,\n  messageOp: ir.I18nMessageOp,\n): {mainVar: o.ReadVarExpr; statements: o.Statement[]} {\n  // Recursively collect any sub-messages, record each sub-message's main variable under its\n  // placeholder so that we can add them to the params for the parent message. It is possible\n  // that multiple sub-messages will share the same placeholder, so we need to track an array of\n  // variables for each placeholder.\n  const statements: o.Statement[] = [];\n  const subMessagePlaceholders = new Map<string, o.Expression[]>();\n  for (const subMessageId of messageOp.subMessages) {\n    const subMessage = messages.get(subMessageId)!;\n    const {mainVar: subMessageVar, statements: subMessageStatements} = collectMessage(\n      job,\n      fileBasedI18nSuffix,\n      messages,\n      subMessage,\n    );\n    statements.push(...subMessageStatements);\n    const subMessages = subMessagePlaceholders.get(subMessage.messagePlaceholder!) ?? [];\n    subMessages.push(subMessageVar);\n    subMessagePlaceholders.set(subMessage.messagePlaceholder!, subMessages);\n  }\n  addSubMessageParams(messageOp, subMessagePlaceholders);\n\n  // Sort the params for consistency with TemaplateDefinitionBuilder output.\n  messageOp.params = new Map([...messageOp.params.entries()].sort());\n\n  const mainVar = o.variable(job.pool.uniqueName(TRANSLATION_VAR_PREFIX));\n  // Closure Compiler requires const names to start with `MSG_` but disallows any other\n  // const to start with `MSG_`. We define a variable starting with `MSG_` just for the\n  // `goog.getMsg` call\n  const closureVar = i18nGenerateClosureVar(\n    job.pool,\n    messageOp.message.id,\n    fileBasedI18nSuffix,\n    job.i18nUseExternalIds,\n  );\n  let transformFn = undefined;\n\n  // If nescessary, add a post-processing step and resolve any placeholder params that are\n  // set in post-processing.\n  if (messageOp.needsPostprocessing || messageOp.postprocessingParams.size > 0) {\n    // Sort the post-processing params for consistency with TemaplateDefinitionBuilder output.\n    const postprocessingParams = Object.fromEntries(\n      [...messageOp.postprocessingParams.entries()].sort(),\n    );\n    const formattedPostprocessingParams = formatI18nPlaceholderNamesInMap(\n      postprocessingParams,\n      /* useCamelCase */ false,\n    );\n    const extraTransformFnParams: o.Expression[] = [];\n    if (messageOp.postprocessingParams.size > 0) {\n      extraTransformFnParams.push(mapLiteral(formattedPostprocessingParams, /* quoted */ true));\n    }\n    transformFn = (expr: o.ReadVarExpr) =>\n      o.importExpr(Identifiers.i18nPostprocess).callFn([expr, ...extraTransformFnParams]);\n  }\n\n  // Add the message's statements\n  statements.push(\n    ...getTranslationDeclStmts(\n      messageOp.message,\n      mainVar,\n      closureVar,\n      messageOp.params,\n      transformFn,\n    ),\n  );\n\n  return {mainVar, statements};\n}\n\n/**\n * Adds the given subMessage placeholders to the given message op.\n *\n * If a placeholder only corresponds to a single sub-message variable, we just set that variable\n * as the param value. However, if the placeholder corresponds to multiple sub-message\n * variables, we need to add a special placeholder value that is handled by the post-processing\n * step. We then add the array of variables as a post-processing param.\n */\nfunction addSubMessageParams(\n  messageOp: ir.I18nMessageOp,\n  subMessagePlaceholders: Map<string, o.Expression[]>,\n) {\n  for (const [placeholder, subMessages] of subMessagePlaceholders) {\n    if (subMessages.length === 1) {\n      messageOp.params.set(placeholder, subMessages[0]);\n    } else {\n      messageOp.params.set(\n        placeholder,\n        o.literal(`${ESCAPE}${I18N_ICU_MAPPING_PREFIX}${placeholder}${ESCAPE}`),\n      );\n      messageOp.postprocessingParams.set(placeholder, o.literalArr(subMessages));\n    }\n  }\n}\n\n/**\n * Generate statements that define a given translation message.\n *\n * ```ts\n * var I18N_1;\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\n *          \"Some message with {$interpolation}!\",\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n *     );\n *     I18N_1 = MSG_EXTERNAL_XXX;\n * }\n * else {\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n * }\n * ```\n *\n * @param message The original i18n AST message node\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n * @param params Object mapping placeholder names to their values (e.g.\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n * @param transformFn Optional transformation function that will be applied to the translation\n *     (e.g.\n * post-processing).\n * @returns An array of statements that defined a given translation.\n */\nfunction getTranslationDeclStmts(\n  message: i18n.Message,\n  variable: o.ReadVarExpr,\n  closureVar: o.ReadVarExpr,\n  params: Map<string, o.Expression>,\n  transformFn?: (raw: o.ReadVarExpr) => o.Expression,\n): o.Statement[] {\n  const paramsObject = Object.fromEntries(params);\n  const statements: o.Statement[] = [\n    declareI18nVariable(variable),\n    o.ifStmt(\n      createClosureModeGuard(),\n      createGoogleGetMsgStatements(variable, message, closureVar, paramsObject),\n      createLocalizeStatements(\n        variable,\n        message,\n        formatI18nPlaceholderNamesInMap(paramsObject, /* useCamelCase */ false),\n      ),\n    ),\n  ];\n\n  if (transformFn) {\n    statements.push(new o.ExpressionStatement(variable.set(transformFn(variable))));\n  }\n\n  return statements;\n}\n\n/**\n * Create the expression that will be used to guard the closure mode block\n * It is equivalent to:\n *\n * ```ts\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n * ```\n */\nfunction createClosureModeGuard(): o.BinaryOperatorExpr {\n  return o\n    .typeofExpr(o.variable(NG_I18N_CLOSURE_MODE))\n    .notIdentical(o.literal('undefined', o.STRING_TYPE))\n    .and(o.variable(NG_I18N_CLOSURE_MODE));\n}\n\n/**\n * Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n */\nfunction i18nGenerateClosureVar(\n  pool: ConstantPool,\n  messageId: string,\n  fileBasedI18nSuffix: string,\n  useExternalIds: boolean,\n): o.ReadVarExpr {\n  let name: string;\n  const suffix = fileBasedI18nSuffix;\n  if (useExternalIds) {\n    const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n    const uniqueSuffix = pool.uniqueName(suffix);\n    name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n  } else {\n    const prefix = getTranslationConstPrefix(suffix);\n    name = pool.uniqueName(prefix);\n  }\n  return o.variable(name);\n}\n"]}