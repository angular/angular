{"version":3,"file":"i18n_text_extraction.js","sourceRoot":"","sources":["i18n_text_extraction.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Removes text nodes within i18n blocks since they are already hardcoded into the i18n message.\n * Also, replaces interpolations on these text nodes with i18n expressions of the non-text portions,\n * which will be applied later.\n */\nexport function convertI18nText(job: CompilationJob): void {\n  for (const unit of job.units) {\n    // Remove all text nodes within i18n blocks, their content is already captured in the i18n\n    // message.\n    let currentI18n: ir.I18nStartOp | null = null;\n    let currentIcu: ir.IcuStartOp | null = null;\n    const textNodeI18nBlocks = new Map<ir.XrefId, ir.I18nStartOp>();\n    const textNodeIcus = new Map<ir.XrefId, ir.IcuStartOp | null>();\n    const icuPlaceholderByText = new Map<ir.XrefId, ir.IcuPlaceholderOp>();\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nStart:\n          if (op.context === null) {\n            throw Error('I18n op should have its context set.');\n          }\n          currentI18n = op;\n          break;\n        case ir.OpKind.I18nEnd:\n          currentI18n = null;\n          break;\n        case ir.OpKind.IcuStart:\n          if (op.context === null) {\n            throw Error('Icu op should have its context set.');\n          }\n          currentIcu = op;\n          break;\n        case ir.OpKind.IcuEnd:\n          currentIcu = null;\n          break;\n        case ir.OpKind.Text:\n          if (currentI18n !== null) {\n            textNodeI18nBlocks.set(op.xref, currentI18n);\n            textNodeIcus.set(op.xref, currentIcu);\n            if (op.icuPlaceholder !== null) {\n              // Create an op to represent the ICU placeholder. Initially set its static text to the\n              // value of the text op, though this may be overwritten later if this text op is a\n              // placeholder for an interpolation.\n              const icuPlaceholderOp = ir.createIcuPlaceholderOp(\n                job.allocateXrefId(),\n                op.icuPlaceholder,\n                [op.initialValue],\n              );\n              ir.OpList.replace<ir.CreateOp>(op, icuPlaceholderOp);\n              icuPlaceholderByText.set(op.xref, icuPlaceholderOp);\n            } else {\n              // Otherwise just remove the text op, since its value is already accounted for in the\n              // translated message.\n              ir.OpList.remove<ir.CreateOp>(op);\n            }\n          }\n          break;\n      }\n    }\n\n    // Update any interpolations to the removed text, and instead represent them as a series of i18n\n    // expressions that we then apply.\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case ir.OpKind.InterpolateText:\n          if (!textNodeI18nBlocks.has(op.target)) {\n            continue;\n          }\n\n          const i18nOp = textNodeI18nBlocks.get(op.target)!;\n          const icuOp = textNodeIcus.get(op.target);\n          const icuPlaceholder = icuPlaceholderByText.get(op.target);\n          const contextId = icuOp ? icuOp.context : i18nOp.context;\n          const resolutionTime = icuOp\n            ? ir.I18nParamResolutionTime.Postproccessing\n            : ir.I18nParamResolutionTime.Creation;\n          const ops: ir.I18nExpressionOp[] = [];\n          for (let i = 0; i < op.interpolation.expressions.length; i++) {\n            const expr = op.interpolation.expressions[i];\n            // For now, this i18nExpression depends on the slot context of the enclosing i18n block.\n            // Later, we will modify this, and advance to a different point.\n            ops.push(\n              ir.createI18nExpressionOp(\n                contextId!,\n                i18nOp.xref,\n                i18nOp.xref,\n                i18nOp.handle,\n                expr,\n                icuPlaceholder?.xref ?? null,\n                op.interpolation.i18nPlaceholders[i] ?? null,\n                resolutionTime,\n                ir.I18nExpressionFor.I18nText,\n                '',\n                expr.sourceSpan ?? op.sourceSpan,\n              ),\n            );\n          }\n          ir.OpList.replaceWithMany(op as ir.UpdateOp, ops);\n          // If this interpolation is part of an ICU placeholder, add the strings and expressions to\n          // the placeholder.\n          if (icuPlaceholder !== undefined) {\n            icuPlaceholder.strings = op.interpolation.strings;\n          }\n          break;\n      }\n    }\n  }\n}\n"]}