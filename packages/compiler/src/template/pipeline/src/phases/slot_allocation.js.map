{"version":3,"file":"slot_allocation.js","sourceRoot":"","sources":["slot_allocation.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,KAAK,EAAE,MAAM,UAAU,CAAC;AAG/B;;;;;;;GAOG;AACH,MAAM,UAAU,aAAa,CAAC,GAA4B;IACxD,kGAAkG;IAClG,6FAA6F;IAC7F,+FAA+F;IAC/F,aAAa;IACb,MAAM,OAAO,GAAG,IAAI,GAAG,EAAqB,CAAC;IAE7C,8DAA8D;IAC9D,KAAK,MAAM,IAAI,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC;QAC7B,4EAA4E;QAC5E,IAAI,SAAS,GAAG,CAAC,CAAC;QAElB,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAC7B,uDAAuD;YACvD,IAAI,CAAC,EAAE,CAAC,oBAAoB,CAAC,EAAE,CAAC,EAAE,CAAC;gBACjC,SAAS;YACX,CAAC;YAED,wEAAwE;YACxE,EAAE,CAAC,MAAM,CAAC,IAAI,GAAG,SAAS,CAAC;YAE3B,gDAAgD;YAChD,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAErC,4FAA4F;YAC5F,qBAAqB;YACrB,SAAS,IAAI,EAAE,CAAC,YAAY,CAAC;QAC/B,CAAC;QAED,+FAA+F;QAC/F,yEAAyE;QACzE,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;IACzB,CAAC;IAED,8FAA8F;IAC9F,+EAA+E;IAC/E,8EAA8E;IAC9E,4FAA4F;IAC5F,yFAAyF;IACzF,KAAK,MAAM,IAAI,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC;QAC7B,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;YAC5B,IACE,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,QAAQ;gBAC9B,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,iBAAiB;gBACvC,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,uBAAuB;gBAC7C,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,cAAc,EACpC,CAAC;gBACD,mFAAmF;gBACnF,gDAAgD;gBAChD,MAAM,SAAS,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAE,CAAC;gBAC1C,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;gBAE3B,yFAAyF;gBACzF,6CAA6C;YAC/C,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {ComponentCompilationJob} from '../compilation';\n\n/**\n * Assign data slots for all operations which implement `ConsumesSlotOpTrait`, and propagate the\n * assigned data slots of those operations to any expressions which reference them via\n * `UsesSlotIndexTrait`.\n *\n * This phase is also responsible for counting the number of slots used for each view (its `decls`)\n * and propagating that number into the `Template` operations which declare embedded views.\n */\nexport function allocateSlots(job: ComponentCompilationJob): void {\n  // Map of all declarations in all views within the component which require an assigned slot index.\n  // This map needs to be global (across all views within the component) since it's possible to\n  // reference a slot from one view from an expression within another (e.g. local references work\n  // this way).\n  const slotMap = new Map<ir.XrefId, number>();\n\n  // Process all views in the component and assign slot indexes.\n  for (const unit of job.units) {\n    // Slot indices start at 0 for each view (and are not unique between views).\n    let slotCount = 0;\n\n    for (const op of unit.create) {\n      // Only consider declarations which consume data slots.\n      if (!ir.hasConsumesSlotTrait(op)) {\n        continue;\n      }\n\n      // Assign slots to this declaration starting at the current `slotCount`.\n      op.handle.slot = slotCount;\n\n      // And track its assigned slot in the `slotMap`.\n      slotMap.set(op.xref, op.handle.slot);\n\n      // Each declaration may use more than 1 slot, so increment `slotCount` to reserve the number\n      // of slots required.\n      slotCount += op.numSlotsUsed;\n    }\n\n    // Record the total number of slots used on the view itself. This will later be propagated into\n    // `ir.TemplateOp`s which declare those views (except for the root view).\n    unit.decls = slotCount;\n  }\n\n  // After slot assignment, `slotMap` now contains slot assignments for every declaration in the\n  // whole template, across all views. Next, look for expressions which implement\n  // `UsesSlotIndexExprTrait` and propagate the assigned slot indexes into them.\n  // Additionally, this second scan allows us to find `ir.TemplateOp`s which declare views and\n  // propagate the number of slots used for each view into the operation which declares it.\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (\n        op.kind === ir.OpKind.Template ||\n        op.kind === ir.OpKind.ConditionalCreate ||\n        op.kind === ir.OpKind.ConditionalBranchCreate ||\n        op.kind === ir.OpKind.RepeaterCreate\n      ) {\n        // Record the number of slots used by the view this `ir.TemplateOp` declares in the\n        // operation itself, so it can be emitted later.\n        const childView = job.views.get(op.xref)!;\n        op.decls = childView.decls;\n\n        // TODO: currently we handle the decls for the RepeaterCreate empty template in the reify\n        // phase. We should handle that here instead.\n      }\n    }\n  }\n}\n"]}