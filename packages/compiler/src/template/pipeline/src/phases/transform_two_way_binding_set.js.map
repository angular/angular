{"version":3,"file":"transform_two_way_binding_set.js","sourceRoot":"","sources":["transform_two_way_binding_set.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,KAAK,CAAC,MAAM,+BAA+B,CAAC;AACnD,OAAO,KAAK,EAAE,MAAM,UAAU,CAAC;AAC/B,OAAO,KAAK,EAAE,MAAM,gBAAgB,CAAC;AAGrC;;;;;GAKG;AACH,MAAM,UAAU,yBAAyB,CAAC,GAAmB;IAC3D,KAAK,MAAM,IAAI,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC;QAC7B,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAC7B,IAAI,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC;gBACzC,EAAE,CAAC,wBAAwB,CACzB,EAAE,EACF,CAAC,IAAI,EAAE,EAAE;oBACP,IAAI,CAAC,CAAC,IAAI,YAAY,EAAE,CAAC,oBAAoB,CAAC,EAAE,CAAC;wBAC/C,OAAO,IAAI,CAAC;oBACd,CAAC;oBAED,MAAM,EAAC,MAAM,EAAE,KAAK,EAAC,GAAG,IAAI,CAAC;oBAE7B,IAAI,MAAM,YAAY,CAAC,CAAC,YAAY,IAAI,MAAM,YAAY,CAAC,CAAC,WAAW,EAAE,CAAC;wBACxE,OAAO,EAAE,CAAC,gBAAgB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;oBAClE,CAAC;oBAED,8EAA8E;oBAC9E,oFAAoF;oBACpF,sFAAsF;oBACtF,0FAA0F;oBAC1F,yCAAyC;oBACzC,IAAI,MAAM,YAAY,EAAE,CAAC,gBAAgB,EAAE,CAAC;wBAC1C,OAAO,EAAE,CAAC,gBAAgB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;oBAC5C,CAAC;oBAED,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;gBACvE,CAAC,EACD,EAAE,CAAC,kBAAkB,CAAC,gBAAgB,CACvC,CAAC;YACJ,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport * as ng from '../instruction';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Transforms a `TwoWayBindingSet` expression into an expression that either\n * sets a value through the `twoWayBindingSet` instruction or falls back to setting\n * the value directly. E.g. the expression `TwoWayBindingSet(target, value)` becomes:\n * `ng.twoWayBindingSet(target, value) || (target = value)`.\n */\nexport function transformTwoWayBindingSet(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.TwoWayListener) {\n        ir.transformExpressionsInOp(\n          op,\n          (expr) => {\n            if (!(expr instanceof ir.TwoWayBindingSetExpr)) {\n              return expr;\n            }\n\n            const {target, value} = expr;\n\n            if (target instanceof o.ReadPropExpr || target instanceof o.ReadKeyExpr) {\n              return ng.twoWayBindingSet(target, value).or(target.set(value));\n            }\n\n            // ASSUMPTION: here we're assuming that `ReadVariableExpr` will be a reference\n            // to a local template variable. This appears to be the case at the time of writing.\n            // If the expression is targeting a variable read, we only emit the `twoWayBindingSet`\n            // since the fallback would be attempting to write into a constant. Invalid usages will be\n            // flagged during template type checking.\n            if (target instanceof ir.ReadVariableExpr) {\n              return ng.twoWayBindingSet(target, value);\n            }\n\n            throw new Error(`Unsupported expression in two-way action binding.`);\n          },\n          ir.VisitorContextFlag.InChildOperation,\n        );\n      }\n    }\n  }\n}\n"]}