{"version":3,"file":"strip_nonrequired_parentheses.js","sourceRoot":"","sources":["strip_nonrequired_parentheses.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * In most cases we can drop user added parentheses from expressions. However, in some cases\n * parentheses are needed for the expression to be considered valid JavaScript or for Typescript to\n * generate the correct output. This phases strips all parentheses except in the following\n * siturations where they are required:\n *\n * 1. Unary operators in the base of an exponentiation expression. For example, `-2 ** 3` is not\n *    valid JavaScript, but `(-2) ** 3` is.\n *\n * 2. When mixing nullish coalescing (`??`) and logical and/or operators (`&&`, `||`), we need\n *    parentheses. For example, `a ?? b && c` is not valid JavaScript, but `a ?? (b && c)` is.\n *    Note: Because of the outcome of https://github.com/microsoft/TypeScript/issues/62307\n *    We need (for now) to keep parentheses around the `??` operator when it is used with and/or operators.\n *    For example, `a ?? b && c` is not valid JavaScript, but `(a ?? b) && c` is.\n *\n * 3. Ternary expression used as an operand for nullish coalescing. Typescript generates incorrect\n *    code if the parentheses are missing. For example when `(a ? b : c) ?? d` is translated to\n *    typescript AST, the parentheses node is removed, and then the remaining AST is printed, it\n *    incorrectly prints `a ? b : c ?? d`. This is different from how it handles the same situation\n *    with `||` and `&&` where it prints the parentheses even if they are not present in the AST.\n *    Note: We may be able to remove this case if Typescript resolves the following issue:\n *    https://github.com/microsoft/TypeScript/issues/61369\n */\nexport function stripNonrequiredParentheses(job: CompilationJob): void {\n  // Check which parentheses are required.\n  const requiredParens = new Set<o.ParenthesizedExpr>();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      ir.visitExpressionsInOp(op, (expr) => {\n        if (expr instanceof o.BinaryOperatorExpr) {\n          switch (expr.operator) {\n            case o.BinaryOperator.Exponentiation:\n              checkExponentiationParens(expr, requiredParens);\n              break;\n            case o.BinaryOperator.NullishCoalesce:\n              checkNullishCoalescingParens(expr, requiredParens);\n              break;\n            // these 2 cases can be dropped if the regression introduced in 5.9.2 is fixed\n            // see https://github.com/microsoft/TypeScript/issues/62307\n            case o.BinaryOperator.And:\n            case o.BinaryOperator.Or:\n              checkAndOrParens(expr, requiredParens);\n          }\n        }\n      });\n    }\n  }\n\n  // Remove any non-required parentheses.\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      ir.transformExpressionsInOp(\n        op,\n        (expr) => {\n          if (expr instanceof o.ParenthesizedExpr) {\n            return requiredParens.has(expr) ? expr : expr.expr;\n          }\n          return expr;\n        },\n        ir.VisitorContextFlag.None,\n      );\n    }\n  }\n}\n\nfunction checkExponentiationParens(\n  expr: o.BinaryOperatorExpr,\n  requiredParens: Set<o.ParenthesizedExpr>,\n) {\n  if (expr.lhs instanceof o.ParenthesizedExpr && expr.lhs.expr instanceof o.UnaryOperatorExpr) {\n    requiredParens.add(expr.lhs);\n  }\n}\n\nfunction checkNullishCoalescingParens(\n  expr: o.BinaryOperatorExpr,\n  requiredParens: Set<o.ParenthesizedExpr>,\n) {\n  if (\n    expr.lhs instanceof o.ParenthesizedExpr &&\n    (isLogicalAndOr(expr.lhs.expr) || expr.lhs.expr instanceof o.ConditionalExpr)\n  ) {\n    requiredParens.add(expr.lhs);\n  }\n  if (\n    expr.rhs instanceof o.ParenthesizedExpr &&\n    (isLogicalAndOr(expr.rhs.expr) || expr.rhs.expr instanceof o.ConditionalExpr)\n  ) {\n    requiredParens.add(expr.rhs);\n  }\n}\n\nfunction checkAndOrParens(expr: o.BinaryOperatorExpr, requiredParens: Set<o.ParenthesizedExpr>) {\n  if (\n    expr.lhs instanceof o.ParenthesizedExpr &&\n    expr.lhs.expr instanceof o.BinaryOperatorExpr &&\n    expr.lhs.expr.operator === o.BinaryOperator.NullishCoalesce\n  ) {\n    requiredParens.add(expr.lhs);\n  }\n}\n\nfunction isLogicalAndOr(expr: o.Expression) {\n  return (\n    expr instanceof o.BinaryOperatorExpr &&\n    (expr.operator === o.BinaryOperator.And || expr.operator === o.BinaryOperator.Or)\n  );\n}\n"]}