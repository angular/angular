{"version":3,"file":"ingest.js","sourceRoot":"","sources":["ingest.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ConstantPool} from '../../../constant_pool';\nimport {SecurityContext} from '../../../core';\nimport * as e from '../../../expression_parser/ast';\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {splitNsName} from '../../../ml_parser/tags';\nimport * as o from '../../../output/output_ast';\nimport {ParseSourceSpan} from '../../../parse_util';\nimport * as t from '../../../render3/r3_ast';\nimport {DeferBlockDepsEmitMode, R3ComponentDeferMetadata} from '../../../render3/view/api';\nimport {icuFromI18nMessage} from '../../../render3/view/i18n/util';\nimport {DomElementSchemaRegistry} from '../../../schema/dom_element_schema_registry';\nimport {BindingParser} from '../../../template_parser/binding_parser';\nimport * as ir from '../ir';\n\nimport {\n  TemplateCompilationMode,\n  CompilationUnit,\n  ComponentCompilationJob,\n  HostBindingCompilationJob,\n  type CompilationJob,\n  type ViewCompilationUnit,\n} from './compilation';\nimport {BINARY_OPERATORS, namespaceForKey, prefixWithNamespace} from './conversion';\n\nconst compatibilityMode = ir.CompatibilityMode.TemplateDefinitionBuilder;\n\n// Schema containing DOM elements and their properties.\nconst domSchema = new DomElementSchemaRegistry();\n\n// Tag name of the `ng-template` element.\nconst NG_TEMPLATE_TAG_NAME = 'ng-template';\n\n// prefix for any animation binding\nconst ANIMATE_PREFIX = 'animate.';\n\nexport function isI18nRootNode(meta?: i18n.I18nMeta): meta is i18n.Message {\n  return meta instanceof i18n.Message;\n}\n\nexport function isSingleI18nIcu(meta?: i18n.I18nMeta): meta is i18n.I18nMeta & {nodes: [i18n.Icu]} {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n}\n\n/**\n * Process a template AST and convert it into a `ComponentCompilation` in the intermediate\n * representation.\n * TODO: Refactor more of the ingestion code into phases.\n */\nexport function ingestComponent(\n  componentName: string,\n  template: t.Node[],\n  constantPool: ConstantPool,\n  compilationMode: TemplateCompilationMode,\n  relativeContextFilePath: string,\n  i18nUseExternalIds: boolean,\n  deferMeta: R3ComponentDeferMetadata,\n  allDeferrableDepsFn: o.ReadVarExpr | null,\n  relativeTemplatePath: string | null,\n  enableDebugLocations: boolean,\n): ComponentCompilationJob {\n  const job = new ComponentCompilationJob(\n    componentName,\n    constantPool,\n    compatibilityMode,\n    compilationMode,\n    relativeContextFilePath,\n    i18nUseExternalIds,\n    deferMeta,\n    allDeferrableDepsFn,\n    relativeTemplatePath,\n    enableDebugLocations,\n  );\n  ingestNodes(job.root, template);\n  return job;\n}\n\nexport interface HostBindingInput {\n  componentName: string;\n  componentSelector: string;\n  properties: e.ParsedProperty[] | null;\n  attributes: {[key: string]: o.Expression};\n  events: e.ParsedEvent[] | null;\n}\n\n/**\n * Process a host binding AST and convert it into a `HostBindingCompilationJob` in the intermediate\n * representation.\n */\nexport function ingestHostBinding(\n  input: HostBindingInput,\n  bindingParser: BindingParser,\n  constantPool: ConstantPool,\n): HostBindingCompilationJob {\n  const job = new HostBindingCompilationJob(\n    input.componentName,\n    constantPool,\n    compatibilityMode,\n    TemplateCompilationMode.DomOnly,\n  );\n  for (const property of input.properties ?? []) {\n    let bindingKind = ir.BindingKind.Property;\n    // TODO: this should really be handled in the parser.\n    if (property.name.startsWith('attr.')) {\n      property.name = property.name.substring('attr.'.length);\n      bindingKind = ir.BindingKind.Attribute;\n    }\n    if (property.isLegacyAnimation) {\n      bindingKind = ir.BindingKind.LegacyAnimation;\n    }\n    if (property.isAnimation) {\n      bindingKind = ir.BindingKind.Animation;\n    }\n    const securityContexts = bindingParser\n      .calcPossibleSecurityContexts(\n        input.componentSelector,\n        property.name,\n        bindingKind === ir.BindingKind.Attribute,\n      )\n      .filter((context) => context !== SecurityContext.NONE);\n    ingestDomProperty(job, property, bindingKind, securityContexts);\n  }\n  for (const [name, expr] of Object.entries(input.attributes) ?? []) {\n    const securityContexts = bindingParser\n      .calcPossibleSecurityContexts(input.componentSelector, name, true)\n      .filter((context) => context !== SecurityContext.NONE);\n    ingestHostAttribute(job, name, expr, securityContexts);\n  }\n  for (const event of input.events ?? []) {\n    ingestHostEvent(job, event);\n  }\n  return job;\n}\n\n// TODO: We should refactor the parser to use the same types and structures for host bindings as\n// with ordinary components. This would allow us to share a lot more ingestion code.\nexport function ingestDomProperty(\n  job: HostBindingCompilationJob,\n  property: e.ParsedProperty,\n  bindingKind: ir.BindingKind,\n  securityContexts: SecurityContext[],\n): void {\n  let expression: o.Expression | ir.Interpolation;\n  const ast = property.expression.ast;\n  if (ast instanceof e.Interpolation) {\n    expression = new ir.Interpolation(\n      ast.strings,\n      ast.expressions.map((expr) => convertAst(expr, job, property.sourceSpan)),\n      [],\n    );\n  } else {\n    expression = convertAst(ast, job, property.sourceSpan);\n  }\n  job.root.update.push(\n    ir.createBindingOp(\n      job.root.xref,\n      bindingKind,\n      property.name,\n      expression,\n      null,\n      securityContexts,\n      false,\n      false,\n      null,\n      /* TODO: How do Host bindings handle i18n attrs? */ null,\n      property.sourceSpan,\n    ),\n  );\n}\n\nexport function ingestHostAttribute(\n  job: HostBindingCompilationJob,\n  name: string,\n  value: o.Expression,\n  securityContexts: SecurityContext[],\n): void {\n  const attrBinding = ir.createBindingOp(\n    job.root.xref,\n    ir.BindingKind.Attribute,\n    name,\n    value,\n    null,\n    securityContexts,\n    /* Host attributes should always be extracted to const hostAttrs, even if they are not\n     *strictly* text literals */\n    true,\n    false,\n    null,\n    /* TODO */ null,\n    /** TODO: May be null? */ value.sourceSpan!,\n  );\n  job.root.update.push(attrBinding);\n}\n\nexport function ingestHostEvent(job: HostBindingCompilationJob, event: e.ParsedEvent) {\n  let eventBinding: ir.CreateOp;\n  if (event.type === e.ParsedEventType.Animation) {\n    eventBinding = ir.createAnimationListenerOp(\n      job.root.xref,\n      new ir.SlotHandle(),\n      event.name,\n      null,\n      makeListenerHandlerOps(job.root, event.handler, event.handlerSpan),\n      event.name.endsWith('enter') ? ir.AnimationKind.ENTER : ir.AnimationKind.LEAVE,\n      event.targetOrPhase,\n      true,\n      event.sourceSpan,\n    );\n  } else {\n    const [phase, target] =\n      event.type !== e.ParsedEventType.LegacyAnimation\n        ? [null, event.targetOrPhase]\n        : [event.targetOrPhase, null];\n\n    eventBinding = ir.createListenerOp(\n      job.root.xref,\n      new ir.SlotHandle(),\n      event.name,\n      null,\n      makeListenerHandlerOps(job.root, event.handler, event.handlerSpan),\n      phase,\n      target,\n      true,\n      event.sourceSpan,\n    );\n  }\n  job.root.create.push(eventBinding);\n}\n\n/**\n * Ingest the nodes of a template AST into the given `ViewCompilation`.\n */\nfunction ingestNodes(unit: ViewCompilationUnit, template: t.Node[]): void {\n  for (const node of template) {\n    if (node instanceof t.Element) {\n      ingestElement(unit, node);\n    } else if (node instanceof t.Template) {\n      ingestTemplate(unit, node);\n    } else if (node instanceof t.Content) {\n      ingestContent(unit, node);\n    } else if (node instanceof t.Text) {\n      ingestText(unit, node, null);\n    } else if (node instanceof t.BoundText) {\n      ingestBoundText(unit, node, null);\n    } else if (node instanceof t.IfBlock) {\n      ingestIfBlock(unit, node);\n    } else if (node instanceof t.SwitchBlock) {\n      ingestSwitchBlock(unit, node);\n    } else if (node instanceof t.DeferredBlock) {\n      ingestDeferBlock(unit, node);\n    } else if (node instanceof t.Icu) {\n      ingestIcu(unit, node);\n    } else if (node instanceof t.ForLoopBlock) {\n      ingestForBlock(unit, node);\n    } else if (node instanceof t.LetDeclaration) {\n      ingestLetDeclaration(unit, node);\n    } else if (node instanceof t.Component) {\n      // TODO(crisbeto): account for selectorless nodes.\n    } else {\n      throw new Error(`Unsupported template node: ${node.constructor.name}`);\n    }\n  }\n}\n\n/**\n * Ingest an element AST from the template into the given `ViewCompilation`.\n */\nfunction ingestElement(unit: ViewCompilationUnit, element: t.Element): void {\n  if (\n    element.i18n !== undefined &&\n    !(element.i18n instanceof i18n.Message || element.i18n instanceof i18n.TagPlaceholder)\n  ) {\n    throw Error(`Unhandled i18n metadata type for element: ${element.i18n.constructor.name}`);\n  }\n\n  const id = unit.job.allocateXrefId();\n\n  const [namespaceKey, elementName] = splitNsName(element.name);\n\n  const startOp = ir.createElementStartOp(\n    elementName,\n    id,\n    namespaceForKey(namespaceKey),\n    element.i18n instanceof i18n.TagPlaceholder ? element.i18n : undefined,\n    element.startSourceSpan,\n    element.sourceSpan,\n  );\n  unit.create.push(startOp);\n\n  ingestElementBindings(unit, startOp, element);\n  ingestReferences(startOp, element);\n\n  // Start i18n, if needed, goes after the element create and bindings, but before the nodes\n  let i18nBlockId: ir.XrefId | null = null;\n  if (element.i18n instanceof i18n.Message) {\n    i18nBlockId = unit.job.allocateXrefId();\n    unit.create.push(\n      ir.createI18nStartOp(i18nBlockId, element.i18n, undefined, element.startSourceSpan),\n    );\n  }\n\n  ingestNodes(unit, element.children);\n\n  // The source span for the end op is typically the element closing tag. However, if no closing tag\n  // exists, such as in `<input>`, we use the start source span instead. Usually the start and end\n  // instructions will be collapsed into one `element` instruction, negating the purpose of this\n  // fallback, but in cases when it is not collapsed (such as an input with a binding), we still\n  // want to map the end instruction to the main element.\n  const endOp = ir.createElementEndOp(id, element.endSourceSpan ?? element.startSourceSpan);\n  unit.create.push(endOp);\n\n  // If there is an i18n message associated with this element, insert i18n start and end ops.\n  if (i18nBlockId !== null) {\n    ir.OpList.insertBefore<ir.CreateOp>(\n      ir.createI18nEndOp(i18nBlockId, element.endSourceSpan ?? element.startSourceSpan),\n      endOp,\n    );\n  }\n}\n\n/**\n * Ingest an `ng-template` node from the AST into the given `ViewCompilation`.\n */\nfunction ingestTemplate(unit: ViewCompilationUnit, tmpl: t.Template): void {\n  if (\n    tmpl.i18n !== undefined &&\n    !(tmpl.i18n instanceof i18n.Message || tmpl.i18n instanceof i18n.TagPlaceholder)\n  ) {\n    throw Error(`Unhandled i18n metadata type for template: ${tmpl.i18n.constructor.name}`);\n  }\n\n  const childView = unit.job.allocateView(unit.xref);\n\n  let tagNameWithoutNamespace = tmpl.tagName;\n  let namespacePrefix: string | null = '';\n  if (tmpl.tagName) {\n    [namespacePrefix, tagNameWithoutNamespace] = splitNsName(tmpl.tagName);\n  }\n\n  const i18nPlaceholder = tmpl.i18n instanceof i18n.TagPlaceholder ? tmpl.i18n : undefined;\n  const namespace = namespaceForKey(namespacePrefix);\n  const functionNameSuffix =\n    tagNameWithoutNamespace === null ? '' : prefixWithNamespace(tagNameWithoutNamespace, namespace);\n  const templateKind = isPlainTemplate(tmpl)\n    ? ir.TemplateKind.NgTemplate\n    : ir.TemplateKind.Structural;\n  const templateOp = ir.createTemplateOp(\n    childView.xref,\n    templateKind,\n    tagNameWithoutNamespace,\n    functionNameSuffix,\n    namespace,\n    i18nPlaceholder,\n    tmpl.startSourceSpan,\n    tmpl.sourceSpan,\n  );\n  unit.create.push(templateOp);\n\n  ingestTemplateBindings(unit, templateOp, tmpl, templateKind);\n  ingestReferences(templateOp, tmpl);\n  ingestNodes(childView, tmpl.children);\n\n  for (const {name, value} of tmpl.variables) {\n    childView.contextVariables.set(name, value !== '' ? value : '$implicit');\n  }\n\n  // If this is a plain template and there is an i18n message associated with it, insert i18n start\n  // and end ops. For structural directive templates, the i18n ops will be added when ingesting the\n  // element/template the directive is placed on.\n  if (templateKind === ir.TemplateKind.NgTemplate && tmpl.i18n instanceof i18n.Message) {\n    const id = unit.job.allocateXrefId();\n    ir.OpList.insertAfter(\n      ir.createI18nStartOp(id, tmpl.i18n, undefined, tmpl.startSourceSpan),\n      childView.create.head,\n    );\n    ir.OpList.insertBefore(\n      ir.createI18nEndOp(id, tmpl.endSourceSpan ?? tmpl.startSourceSpan),\n      childView.create.tail,\n    );\n  }\n}\n\n/**\n * Ingest a content node from the AST into the given `ViewCompilation`.\n */\nfunction ingestContent(unit: ViewCompilationUnit, content: t.Content): void {\n  if (content.i18n !== undefined && !(content.i18n instanceof i18n.TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for element: ${content.i18n.constructor.name}`);\n  }\n\n  let fallbackView: ViewCompilationUnit | null = null;\n\n  // Don't capture default content that's only made up of empty text nodes and comments.\n  // Note that we process the default content before the projection in order to match the\n  // insertion order at runtime.\n  if (\n    content.children.some(\n      (child) =>\n        !(child instanceof t.Comment) &&\n        (!(child instanceof t.Text) || child.value.trim().length > 0),\n    )\n  ) {\n    fallbackView = unit.job.allocateView(unit.xref);\n    ingestNodes(fallbackView, content.children);\n  }\n\n  const id = unit.job.allocateXrefId();\n  const op = ir.createProjectionOp(\n    id,\n    content.selector,\n    content.i18n,\n    fallbackView?.xref ?? null,\n    content.sourceSpan,\n  );\n  for (const attr of content.attributes) {\n    const securityContext = domSchema.securityContext(content.name, attr.name, true);\n    unit.update.push(\n      ir.createBindingOp(\n        op.xref,\n        ir.BindingKind.Attribute,\n        attr.name,\n        o.literal(attr.value),\n        null,\n        securityContext,\n        true,\n        false,\n        null,\n        asMessage(attr.i18n),\n        attr.sourceSpan,\n      ),\n    );\n  }\n  unit.create.push(op);\n}\n\n/**\n * Ingest a literal text node from the AST into the given `ViewCompilation`.\n */\nfunction ingestText(unit: ViewCompilationUnit, text: t.Text, icuPlaceholder: string | null): void {\n  unit.create.push(\n    ir.createTextOp(unit.job.allocateXrefId(), text.value, icuPlaceholder, text.sourceSpan),\n  );\n}\n\n/**\n * Ingest an interpolated text node from the AST into the given `ViewCompilation`.\n */\nfunction ingestBoundText(\n  unit: ViewCompilationUnit,\n  text: t.BoundText,\n  icuPlaceholder: string | null,\n): void {\n  let value = text.value;\n  if (value instanceof e.ASTWithSource) {\n    value = value.ast;\n  }\n  if (!(value instanceof e.Interpolation)) {\n    throw new Error(\n      `AssertionError: expected Interpolation for BoundText node, got ${value.constructor.name}`,\n    );\n  }\n  if (text.i18n !== undefined && !(text.i18n instanceof i18n.Container)) {\n    throw Error(\n      `Unhandled i18n metadata type for text interpolation: ${text.i18n?.constructor.name}`,\n    );\n  }\n\n  const i18nPlaceholders =\n    text.i18n instanceof i18n.Container\n      ? text.i18n.children\n          .filter((node): node is i18n.Placeholder => node instanceof i18n.Placeholder)\n          .map((placeholder) => placeholder.name)\n      : [];\n  if (i18nPlaceholders.length > 0 && i18nPlaceholders.length !== value.expressions.length) {\n    throw Error(\n      `Unexpected number of i18n placeholders (${value.expressions.length}) for BoundText with ${value.expressions.length} expressions`,\n    );\n  }\n\n  const textXref = unit.job.allocateXrefId();\n  unit.create.push(ir.createTextOp(textXref, '', icuPlaceholder, text.sourceSpan));\n  // TemplateDefinitionBuilder does not generate source maps for sub-expressions inside an\n  // interpolation. We copy that behavior in compatibility mode.\n  // TODO: is it actually correct to generate these extra maps in modern mode?\n  const baseSourceSpan = unit.job.compatibility ? null : text.sourceSpan;\n  unit.update.push(\n    ir.createInterpolateTextOp(\n      textXref,\n      new ir.Interpolation(\n        value.strings,\n        value.expressions.map((expr) => convertAst(expr, unit.job, baseSourceSpan)),\n        i18nPlaceholders,\n      ),\n      text.sourceSpan,\n    ),\n  );\n}\n\n/**\n * Ingest an `@if` block into the given `ViewCompilation`.\n */\nfunction ingestIfBlock(unit: ViewCompilationUnit, ifBlock: t.IfBlock): void {\n  let firstXref: ir.XrefId | null = null;\n  let conditions: Array<ir.ConditionalCaseExpr> = [];\n  for (let i = 0; i < ifBlock.branches.length; i++) {\n    const ifCase = ifBlock.branches[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, ifCase);\n\n    if (ifCase.expressionAlias !== null) {\n      cView.contextVariables.set(ifCase.expressionAlias.name, ir.CTX_REF);\n    }\n\n    let ifCaseI18nMeta: i18n.BlockPlaceholder | undefined = undefined;\n    if (ifCase.i18n !== undefined) {\n      if (!(ifCase.i18n instanceof i18n.BlockPlaceholder)) {\n        throw Error(`Unhandled i18n metadata type for if block: ${ifCase.i18n?.constructor.name}`);\n      }\n      ifCaseI18nMeta = ifCase.i18n;\n    }\n\n    const createOp = i === 0 ? ir.createConditionalCreateOp : ir.createConditionalBranchCreateOp;\n\n    const conditionalCreateOp = createOp(\n      cView.xref,\n      ir.TemplateKind.Block,\n      tagName,\n      'Conditional',\n      ir.Namespace.HTML,\n      ifCaseI18nMeta,\n      ifCase.startSourceSpan,\n      ifCase.sourceSpan,\n    );\n    unit.create.push(conditionalCreateOp);\n\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n\n    const caseExpr = ifCase.expression ? convertAst(ifCase.expression, unit.job, null) : null;\n    const conditionalCaseExpr = new ir.ConditionalCaseExpr(\n      caseExpr,\n      conditionalCreateOp.xref,\n      conditionalCreateOp.handle,\n      ifCase.expressionAlias,\n    );\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, ifCase.children);\n  }\n  unit.update.push(ir.createConditionalOp(firstXref!, null, conditions, ifBlock.sourceSpan));\n}\n\n/**\n * Ingest an `@switch` block into the given `ViewCompilation`.\n */\nfunction ingestSwitchBlock(unit: ViewCompilationUnit, switchBlock: t.SwitchBlock): void {\n  // Don't ingest empty switches since they won't render anything.\n  if (switchBlock.cases.length === 0) {\n    return;\n  }\n\n  let firstXref: ir.XrefId | null = null;\n  let conditions: Array<ir.ConditionalCaseExpr> = [];\n  for (let i = 0; i < switchBlock.cases.length; i++) {\n    const switchCase = switchBlock.cases[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, switchCase);\n    let switchCaseI18nMeta: i18n.BlockPlaceholder | undefined = undefined;\n    if (switchCase.i18n !== undefined) {\n      if (!(switchCase.i18n instanceof i18n.BlockPlaceholder)) {\n        throw Error(\n          `Unhandled i18n metadata type for switch block: ${switchCase.i18n?.constructor.name}`,\n        );\n      }\n      switchCaseI18nMeta = switchCase.i18n;\n    }\n\n    const createOp = i === 0 ? ir.createConditionalCreateOp : ir.createConditionalBranchCreateOp;\n\n    const conditionalCreateOp = createOp(\n      cView.xref,\n      ir.TemplateKind.Block,\n      tagName,\n      'Case',\n      ir.Namespace.HTML,\n      switchCaseI18nMeta,\n      switchCase.startSourceSpan,\n      switchCase.sourceSpan,\n    );\n    unit.create.push(conditionalCreateOp);\n\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n    const caseExpr = switchCase.expression\n      ? convertAst(switchCase.expression, unit.job, switchBlock.startSourceSpan)\n      : null;\n    const conditionalCaseExpr = new ir.ConditionalCaseExpr(\n      caseExpr,\n      conditionalCreateOp.xref,\n      conditionalCreateOp.handle,\n    );\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, switchCase.children);\n  }\n  unit.update.push(\n    ir.createConditionalOp(\n      firstXref!,\n      convertAst(switchBlock.expression, unit.job, null),\n      conditions,\n      switchBlock.sourceSpan,\n    ),\n  );\n}\n\nfunction ingestDeferView(\n  unit: ViewCompilationUnit,\n  suffix: string,\n  i18nMeta: i18n.I18nMeta | undefined,\n  children?: t.Node[],\n  sourceSpan?: ParseSourceSpan,\n): ir.TemplateOp | null {\n  if (i18nMeta !== undefined && !(i18nMeta instanceof i18n.BlockPlaceholder)) {\n    throw Error('Unhandled i18n metadata type for defer block');\n  }\n  if (children === undefined) {\n    return null;\n  }\n  const secondaryView = unit.job.allocateView(unit.xref);\n  ingestNodes(secondaryView, children);\n  const templateOp = ir.createTemplateOp(\n    secondaryView.xref,\n    ir.TemplateKind.Block,\n    null,\n    `Defer${suffix}`,\n    ir.Namespace.HTML,\n    i18nMeta,\n    sourceSpan!,\n    sourceSpan!,\n  );\n  unit.create.push(templateOp);\n  return templateOp;\n}\n\nfunction ingestDeferBlock(unit: ViewCompilationUnit, deferBlock: t.DeferredBlock): void {\n  let ownResolverFn: o.Expression | null = null;\n\n  if (unit.job.deferMeta.mode === DeferBlockDepsEmitMode.PerBlock) {\n    if (!unit.job.deferMeta.blocks.has(deferBlock)) {\n      throw new Error(\n        `AssertionError: unable to find a dependency function for this deferred block`,\n      );\n    }\n    ownResolverFn = unit.job.deferMeta.blocks.get(deferBlock) ?? null;\n  }\n\n  // Generate the defer main view and all secondary views.\n  const main = ingestDeferView(\n    unit,\n    '',\n    deferBlock.i18n,\n    deferBlock.children,\n    deferBlock.sourceSpan,\n  )!;\n  const loading = ingestDeferView(\n    unit,\n    'Loading',\n    deferBlock.loading?.i18n,\n    deferBlock.loading?.children,\n    deferBlock.loading?.sourceSpan,\n  );\n  const placeholder = ingestDeferView(\n    unit,\n    'Placeholder',\n    deferBlock.placeholder?.i18n,\n    deferBlock.placeholder?.children,\n    deferBlock.placeholder?.sourceSpan,\n  );\n  const error = ingestDeferView(\n    unit,\n    'Error',\n    deferBlock.error?.i18n,\n    deferBlock.error?.children,\n    deferBlock.error?.sourceSpan,\n  );\n\n  // Create the main defer op, and ops for all secondary views.\n  const deferXref = unit.job.allocateXrefId();\n  const deferOp = ir.createDeferOp(\n    deferXref,\n    main.xref,\n    main.handle,\n    ownResolverFn,\n    unit.job.allDeferrableDepsFn,\n    deferBlock.sourceSpan,\n  );\n  deferOp.placeholderView = placeholder?.xref ?? null;\n  deferOp.placeholderSlot = placeholder?.handle ?? null;\n  deferOp.loadingSlot = loading?.handle ?? null;\n  deferOp.errorSlot = error?.handle ?? null;\n  deferOp.placeholderMinimumTime = deferBlock.placeholder?.minimumTime ?? null;\n  deferOp.loadingMinimumTime = deferBlock.loading?.minimumTime ?? null;\n  deferOp.loadingAfterTime = deferBlock.loading?.afterTime ?? null;\n  deferOp.flags = calcDeferBlockFlags(deferBlock);\n  unit.create.push(deferOp);\n\n  // Configure all defer `on` conditions.\n  // TODO: refactor prefetch triggers to use a separate op type, with a shared superclass. This will\n  // make it easier to refactor prefetch behavior in the future.\n  const deferOnOps: ir.DeferOnOp[] = [];\n  const deferWhenOps: ir.DeferWhenOp[] = [];\n\n  // Ingest the hydrate triggers first since they set up all the other triggers during SSR.\n  ingestDeferTriggers(\n    ir.DeferOpModifierKind.HYDRATE,\n    deferBlock.hydrateTriggers,\n    deferOnOps,\n    deferWhenOps,\n    unit,\n    deferXref,\n  );\n\n  ingestDeferTriggers(\n    ir.DeferOpModifierKind.NONE,\n    deferBlock.triggers,\n    deferOnOps,\n    deferWhenOps,\n    unit,\n    deferXref,\n  );\n\n  ingestDeferTriggers(\n    ir.DeferOpModifierKind.PREFETCH,\n    deferBlock.prefetchTriggers,\n    deferOnOps,\n    deferWhenOps,\n    unit,\n    deferXref,\n  );\n\n  // If no (non-prefetching or hydrating) defer triggers were provided, default to `idle`.\n  const hasConcreteTrigger =\n    deferOnOps.some((op) => op.modifier === ir.DeferOpModifierKind.NONE) ||\n    deferWhenOps.some((op) => op.modifier === ir.DeferOpModifierKind.NONE);\n\n  if (!hasConcreteTrigger) {\n    deferOnOps.push(\n      ir.createDeferOnOp(\n        deferXref,\n        {kind: ir.DeferTriggerKind.Idle},\n        ir.DeferOpModifierKind.NONE,\n        null!,\n      ),\n    );\n  }\n\n  unit.create.push(deferOnOps);\n  unit.update.push(deferWhenOps);\n}\n\nfunction calcDeferBlockFlags(deferBlockDetails: t.DeferredBlock): ir.TDeferDetailsFlags | null {\n  if (Object.keys(deferBlockDetails.hydrateTriggers).length > 0) {\n    return ir.TDeferDetailsFlags.HasHydrateTriggers;\n  }\n  return null;\n}\n\nfunction ingestDeferTriggers(\n  modifier: ir.DeferOpModifierKind,\n  triggers: Readonly<t.DeferredBlockTriggers>,\n  onOps: ir.DeferOnOp[],\n  whenOps: ir.DeferWhenOp[],\n  unit: ViewCompilationUnit,\n  deferXref: ir.XrefId,\n) {\n  if (triggers.idle !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {kind: ir.DeferTriggerKind.Idle},\n      modifier,\n      triggers.idle.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.immediate !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {kind: ir.DeferTriggerKind.Immediate},\n      modifier,\n      triggers.immediate.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.timer !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {kind: ir.DeferTriggerKind.Timer, delay: triggers.timer.delay},\n      modifier,\n      triggers.timer.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.hover !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {\n        kind: ir.DeferTriggerKind.Hover,\n        targetName: triggers.hover.reference,\n        targetXref: null,\n        targetSlot: null,\n        targetView: null,\n        targetSlotViewSteps: null,\n      },\n      modifier,\n      triggers.hover.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.interaction !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {\n        kind: ir.DeferTriggerKind.Interaction,\n        targetName: triggers.interaction.reference,\n        targetXref: null,\n        targetSlot: null,\n        targetView: null,\n        targetSlotViewSteps: null,\n      },\n      modifier,\n      triggers.interaction.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.viewport !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {\n        kind: ir.DeferTriggerKind.Viewport,\n        targetName: triggers.viewport.reference,\n        targetXref: null,\n        targetSlot: null,\n        targetView: null,\n        targetSlotViewSteps: null,\n      },\n      modifier,\n      triggers.viewport.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.never !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {kind: ir.DeferTriggerKind.Never},\n      modifier,\n      triggers.never.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.when !== undefined) {\n    if (triggers.when.value instanceof e.Interpolation) {\n      // TemplateDefinitionBuilder supports this case, but it's very strange to me. What would it\n      // even mean?\n      throw new Error(`Unexpected interpolation in defer block when trigger`);\n    }\n    const deferOnOp = ir.createDeferWhenOp(\n      deferXref,\n      convertAst(triggers.when.value, unit.job, triggers.when.sourceSpan),\n      modifier,\n      triggers.when.sourceSpan,\n    );\n    whenOps.push(deferOnOp);\n  }\n}\n\nfunction ingestIcu(unit: ViewCompilationUnit, icu: t.Icu) {\n  if (icu.i18n instanceof i18n.Message && isSingleI18nIcu(icu.i18n)) {\n    const xref = unit.job.allocateXrefId();\n    unit.create.push(ir.createIcuStartOp(xref, icu.i18n, icuFromI18nMessage(icu.i18n).name, null!));\n    for (const [placeholder, text] of Object.entries({...icu.vars, ...icu.placeholders})) {\n      if (text instanceof t.BoundText) {\n        ingestBoundText(unit, text, placeholder);\n      } else {\n        ingestText(unit, text, placeholder);\n      }\n    }\n    unit.create.push(ir.createIcuEndOp(xref));\n  } else {\n    throw Error(`Unhandled i18n metadata type for ICU: ${icu.i18n?.constructor.name}`);\n  }\n}\n\n/**\n * Ingest an `@for` block into the given `ViewCompilation`.\n */\nfunction ingestForBlock(unit: ViewCompilationUnit, forBlock: t.ForLoopBlock): void {\n  const repeaterView = unit.job.allocateView(unit.xref);\n\n  // We copy TemplateDefinitionBuilder's scheme of creating names for `$count` and `$index`\n  // that are suffixed with special information, to disambiguate which level of nested loop\n  // the below aliases refer to.\n  // TODO: We should refactor Template Pipeline's variable phases to gracefully handle\n  // shadowing, and arbitrarily many levels of variables depending on each other.\n  const indexName = `ɵ$index_${repeaterView.xref}`;\n  const countName = `ɵ$count_${repeaterView.xref}`;\n  const indexVarNames = new Set<string>();\n\n  // Set all the context variables and aliases available in the repeater.\n  repeaterView.contextVariables.set(forBlock.item.name, forBlock.item.value);\n\n  for (const variable of forBlock.contextVariables) {\n    if (variable.value === '$index') {\n      indexVarNames.add(variable.name);\n    }\n    if (variable.name === '$index') {\n      repeaterView.contextVariables.set('$index', variable.value).set(indexName, variable.value);\n    } else if (variable.name === '$count') {\n      repeaterView.contextVariables.set('$count', variable.value).set(countName, variable.value);\n    } else {\n      repeaterView.aliases.add({\n        kind: ir.SemanticVariableKind.Alias,\n        name: null,\n        identifier: variable.name,\n        expression: getComputedForLoopVariableExpression(variable, indexName, countName),\n      });\n    }\n  }\n\n  const sourceSpan = convertSourceSpan(forBlock.trackBy.span, forBlock.sourceSpan);\n  const track = convertAst(forBlock.trackBy, unit.job, sourceSpan);\n\n  ingestNodes(repeaterView, forBlock.children);\n\n  let emptyView: ViewCompilationUnit | null = null;\n  let emptyTagName: string | null = null;\n  if (forBlock.empty !== null) {\n    emptyView = unit.job.allocateView(unit.xref);\n    ingestNodes(emptyView, forBlock.empty.children);\n    emptyTagName = ingestControlFlowInsertionPoint(unit, emptyView.xref, forBlock.empty);\n  }\n\n  const varNames: ir.RepeaterVarNames = {\n    $index: indexVarNames,\n    $implicit: forBlock.item.name,\n  };\n\n  if (forBlock.i18n !== undefined && !(forBlock.i18n instanceof i18n.BlockPlaceholder)) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @for');\n  }\n  if (\n    forBlock.empty?.i18n !== undefined &&\n    !(forBlock.empty.i18n instanceof i18n.BlockPlaceholder)\n  ) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @empty');\n  }\n  const i18nPlaceholder = forBlock.i18n;\n  const emptyI18nPlaceholder = forBlock.empty?.i18n;\n\n  const tagName = ingestControlFlowInsertionPoint(unit, repeaterView.xref, forBlock);\n  const repeaterCreate = ir.createRepeaterCreateOp(\n    repeaterView.xref,\n    emptyView?.xref ?? null,\n    tagName,\n    track,\n    varNames,\n    emptyTagName,\n    i18nPlaceholder,\n    emptyI18nPlaceholder,\n    forBlock.startSourceSpan,\n    forBlock.sourceSpan,\n  );\n  unit.create.push(repeaterCreate);\n\n  const expression = convertAst(\n    forBlock.expression,\n    unit.job,\n    convertSourceSpan(forBlock.expression.span, forBlock.sourceSpan),\n  );\n  const repeater = ir.createRepeaterOp(\n    repeaterCreate.xref,\n    repeaterCreate.handle,\n    expression,\n    forBlock.sourceSpan,\n  );\n  unit.update.push(repeater);\n}\n\n/**\n * Gets an expression that represents a variable in an `@for` loop.\n * @param variable AST representing the variable.\n * @param indexName Loop-specific name for `$index`.\n * @param countName Loop-specific name for `$count`.\n */\nfunction getComputedForLoopVariableExpression(\n  variable: t.Variable,\n  indexName: string,\n  countName: string,\n): o.Expression {\n  switch (variable.value) {\n    case '$index':\n      return new ir.LexicalReadExpr(indexName);\n\n    case '$count':\n      return new ir.LexicalReadExpr(countName);\n\n    case '$first':\n      return new ir.LexicalReadExpr(indexName).identical(o.literal(0));\n\n    case '$last':\n      return new ir.LexicalReadExpr(indexName).identical(\n        new ir.LexicalReadExpr(countName).minus(o.literal(1)),\n      );\n\n    case '$even':\n      return new ir.LexicalReadExpr(indexName).modulo(o.literal(2)).identical(o.literal(0));\n\n    case '$odd':\n      return new ir.LexicalReadExpr(indexName).modulo(o.literal(2)).notIdentical(o.literal(0));\n\n    default:\n      throw new Error(`AssertionError: unknown @for loop variable ${variable.value}`);\n  }\n}\n\nfunction ingestLetDeclaration(unit: ViewCompilationUnit, node: t.LetDeclaration) {\n  const target = unit.job.allocateXrefId();\n\n  unit.create.push(ir.createDeclareLetOp(target, node.name, node.sourceSpan));\n  unit.update.push(\n    ir.createStoreLetOp(\n      target,\n      node.name,\n      convertAst(node.value, unit.job, node.valueSpan),\n      node.sourceSpan,\n    ),\n  );\n}\n\n/**\n * Convert a template AST expression into an output AST expression.\n */\nfunction convertAst(\n  ast: e.AST,\n  job: CompilationJob,\n  baseSourceSpan: ParseSourceSpan | null,\n): o.Expression {\n  if (ast instanceof e.ASTWithSource) {\n    return convertAst(ast.ast, job, baseSourceSpan);\n  } else if (ast instanceof e.PropertyRead) {\n    // Whether this is an implicit receiver, *excluding* explicit reads of `this`.\n    const isImplicitReceiver =\n      ast.receiver instanceof e.ImplicitReceiver && !(ast.receiver instanceof e.ThisReceiver);\n    if (isImplicitReceiver) {\n      return new ir.LexicalReadExpr(ast.name);\n    } else {\n      return new o.ReadPropExpr(\n        convertAst(ast.receiver, job, baseSourceSpan),\n        ast.name,\n        null,\n        convertSourceSpan(ast.span, baseSourceSpan),\n      );\n    }\n  } else if (ast instanceof e.Call) {\n    if (ast.receiver instanceof e.ImplicitReceiver) {\n      throw new Error(`Unexpected ImplicitReceiver`);\n    } else {\n      return new o.InvokeFunctionExpr(\n        convertAst(ast.receiver, job, baseSourceSpan),\n        ast.args.map((arg) => convertAst(arg, job, baseSourceSpan)),\n        undefined,\n        convertSourceSpan(ast.span, baseSourceSpan),\n      );\n    }\n  } else if (ast instanceof e.LiteralPrimitive) {\n    return o.literal(ast.value, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof e.Unary) {\n    switch (ast.operator) {\n      case '+':\n        return new o.UnaryOperatorExpr(\n          o.UnaryOperator.Plus,\n          convertAst(ast.expr, job, baseSourceSpan),\n          undefined,\n          convertSourceSpan(ast.span, baseSourceSpan),\n        );\n      case '-':\n        return new o.UnaryOperatorExpr(\n          o.UnaryOperator.Minus,\n          convertAst(ast.expr, job, baseSourceSpan),\n          undefined,\n          convertSourceSpan(ast.span, baseSourceSpan),\n        );\n      default:\n        throw new Error(`AssertionError: unknown unary operator ${ast.operator}`);\n    }\n  } else if (ast instanceof e.Binary) {\n    const operator = BINARY_OPERATORS.get(ast.operation);\n    if (operator === undefined) {\n      throw new Error(`AssertionError: unknown binary operator ${ast.operation}`);\n    }\n    return new o.BinaryOperatorExpr(\n      operator,\n      convertAst(ast.left, job, baseSourceSpan),\n      convertAst(ast.right, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.ThisReceiver) {\n    // TODO: should context expressions have source maps?\n    return new ir.ContextExpr(job.root.xref);\n  } else if (ast instanceof e.KeyedRead) {\n    return new o.ReadKeyExpr(\n      convertAst(ast.receiver, job, baseSourceSpan),\n      convertAst(ast.key, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.Chain) {\n    throw new Error(`AssertionError: Chain in unknown context`);\n  } else if (ast instanceof e.LiteralMap) {\n    const entries = ast.keys.map((key, idx) => {\n      const value = ast.values[idx];\n      // TODO: should literals have source maps, or do we just map the whole surrounding\n      // expression?\n      return new o.LiteralMapEntry(key.key, convertAst(value, job, baseSourceSpan), key.quoted);\n    });\n    return new o.LiteralMapExpr(entries, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof e.LiteralArray) {\n    // TODO: should literals have source maps, or do we just map the whole surrounding expression?\n    return new o.LiteralArrayExpr(\n      ast.expressions.map((expr) => convertAst(expr, job, baseSourceSpan)),\n    );\n  } else if (ast instanceof e.Conditional) {\n    return new o.ConditionalExpr(\n      convertAst(ast.condition, job, baseSourceSpan),\n      convertAst(ast.trueExp, job, baseSourceSpan),\n      convertAst(ast.falseExp, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.NonNullAssert) {\n    // A non-null assertion shouldn't impact generated instructions, so we can just drop it.\n    return convertAst(ast.expression, job, baseSourceSpan);\n  } else if (ast instanceof e.BindingPipe) {\n    // TODO: pipes should probably have source maps; figure out details.\n    return new ir.PipeBindingExpr(job.allocateXrefId(), new ir.SlotHandle(), ast.name, [\n      convertAst(ast.exp, job, baseSourceSpan),\n      ...ast.args.map((arg) => convertAst(arg, job, baseSourceSpan)),\n    ]);\n  } else if (ast instanceof e.SafeKeyedRead) {\n    return new ir.SafeKeyedReadExpr(\n      convertAst(ast.receiver, job, baseSourceSpan),\n      convertAst(ast.key, job, baseSourceSpan),\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.SafePropertyRead) {\n    // TODO: source span\n    return new ir.SafePropertyReadExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.name);\n  } else if (ast instanceof e.SafeCall) {\n    // TODO: source span\n    return new ir.SafeInvokeFunctionExpr(\n      convertAst(ast.receiver, job, baseSourceSpan),\n      ast.args.map((a) => convertAst(a, job, baseSourceSpan)),\n    );\n  } else if (ast instanceof e.EmptyExpr) {\n    return new ir.EmptyExpr(convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof e.PrefixNot) {\n    return o.not(\n      convertAst(ast.expression, job, baseSourceSpan),\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.TypeofExpression) {\n    return o.typeofExpr(convertAst(ast.expression, job, baseSourceSpan));\n  } else if (ast instanceof e.VoidExpression) {\n    return new o.VoidExpr(\n      convertAst(ast.expression, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.TemplateLiteral) {\n    return convertTemplateLiteral(ast, job, baseSourceSpan);\n  } else if (ast instanceof e.TaggedTemplateLiteral) {\n    return new o.TaggedTemplateLiteralExpr(\n      convertAst(ast.tag, job, baseSourceSpan),\n      convertTemplateLiteral(ast.template, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.ParenthesizedExpression) {\n    return new o.ParenthesizedExpr(\n      convertAst(ast.expression, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.RegularExpressionLiteral) {\n    return new o.RegularExpressionLiteral(ast.body, ast.flags, baseSourceSpan);\n  } else {\n    throw new Error(\n      `Unhandled expression type \"${ast.constructor.name}\" in file \"${baseSourceSpan?.start.file.url}\"`,\n    );\n  }\n}\n\nfunction convertTemplateLiteral(\n  ast: e.TemplateLiteral,\n  job: CompilationJob,\n  baseSourceSpan: ParseSourceSpan | null,\n) {\n  return new o.TemplateLiteralExpr(\n    ast.elements.map((el) => {\n      return new o.TemplateLiteralElementExpr(el.text, convertSourceSpan(el.span, baseSourceSpan));\n    }),\n    ast.expressions.map((expr) => convertAst(expr, job, baseSourceSpan)),\n    convertSourceSpan(ast.span, baseSourceSpan),\n  );\n}\n\nfunction convertAstWithInterpolation(\n  job: CompilationJob,\n  value: e.AST | string,\n  i18nMeta: i18n.I18nMeta | null | undefined,\n  sourceSpan?: ParseSourceSpan,\n): o.Expression | ir.Interpolation {\n  let expression: o.Expression | ir.Interpolation;\n  if (value instanceof e.Interpolation) {\n    expression = new ir.Interpolation(\n      value.strings,\n      value.expressions.map((e) => convertAst(e, job, sourceSpan ?? null)),\n      Object.keys(asMessage(i18nMeta)?.placeholders ?? {}),\n    );\n  } else if (value instanceof e.AST) {\n    expression = convertAst(value, job, sourceSpan ?? null);\n  } else {\n    expression = o.literal(value);\n  }\n  return expression;\n}\n\n// TODO: Can we populate Template binding kinds in ingest?\nconst BINDING_KINDS = new Map<e.BindingType, ir.BindingKind>([\n  [e.BindingType.Property, ir.BindingKind.Property],\n  [e.BindingType.TwoWay, ir.BindingKind.TwoWayProperty],\n  [e.BindingType.Attribute, ir.BindingKind.Attribute],\n  [e.BindingType.Class, ir.BindingKind.ClassName],\n  [e.BindingType.Style, ir.BindingKind.StyleProperty],\n  [e.BindingType.LegacyAnimation, ir.BindingKind.LegacyAnimation],\n  [e.BindingType.Animation, ir.BindingKind.Animation],\n]);\n\n/**\n * Checks whether the given template is a plain ng-template (as opposed to another kind of template\n * such as a structural directive template or control flow template). This is checked based on the\n * tagName. We can expect that only plain ng-templates will come through with a tagName of\n * 'ng-template'.\n *\n * Here are some of the cases we expect:\n *\n * | Angular HTML                       | Template tagName   |\n * | ---------------------------------- | ------------------ |\n * | `<ng-template>`                    | 'ng-template'      |\n * | `<div *ngIf=\"true\">`               | 'div'              |\n * | `<svg><ng-template>`               | 'svg:ng-template'  |\n * | `@if (true) {`                     | 'Conditional'      |\n * | `<ng-template *ngIf>` (plain)      | 'ng-template'      |\n * | `<ng-template *ngIf>` (structural) | null               |\n */\nfunction isPlainTemplate(tmpl: t.Template) {\n  return splitNsName(tmpl.tagName ?? '')[1] === NG_TEMPLATE_TAG_NAME;\n}\n\n/**\n * Ensures that the i18nMeta, if provided, is an i18n.Message.\n */\nfunction asMessage(i18nMeta: i18n.I18nMeta | null | undefined): i18n.Message | null {\n  if (i18nMeta == null) {\n    return null;\n  }\n  if (!(i18nMeta instanceof i18n.Message)) {\n    throw Error(`Expected i18n meta to be a Message, but got: ${i18nMeta.constructor.name}`);\n  }\n  return i18nMeta;\n}\n\n/**\n * Process all of the bindings on an element in the template AST and convert them to their IR\n * representation.\n */\nfunction ingestElementBindings(\n  unit: ViewCompilationUnit,\n  op: ir.ElementOpBase,\n  element: t.Element,\n): void {\n  let bindings = new Array<ir.BindingOp | ir.ExtractedAttributeOp | null>();\n  let i18nAttributeBindingNames = new Set<string>();\n\n  for (const attr of element.attributes) {\n    // Attribute literal bindings, such as `attr.foo=\"bar\"`.\n    const securityContext = domSchema.securityContext(element.name, attr.name, true);\n    bindings.push(\n      ir.createBindingOp(\n        op.xref,\n        ir.BindingKind.Attribute,\n        attr.name,\n        convertAstWithInterpolation(unit.job, attr.value, attr.i18n),\n        null,\n        securityContext,\n        true,\n        false,\n        null,\n        asMessage(attr.i18n),\n        attr.sourceSpan,\n      ),\n    );\n    if (attr.i18n) {\n      i18nAttributeBindingNames.add(attr.name);\n    }\n  }\n\n  for (const input of element.inputs) {\n    if (i18nAttributeBindingNames.has(input.name)) {\n      console.error(\n        `On component ${unit.job.componentName}, the binding ${input.name} is both an i18n attribute and a property. You may want to remove the property binding. This will become a compilation error in future versions of Angular.`,\n      );\n    }\n    // All dynamic bindings (both attribute and property bindings).\n    bindings.push(\n      ir.createBindingOp(\n        op.xref,\n        BINDING_KINDS.get(input.type)!,\n        input.name,\n        convertAstWithInterpolation(unit.job, astOf(input.value), input.i18n),\n        input.unit,\n        input.securityContext,\n        false,\n        false,\n        null,\n        asMessage(input.i18n) ?? null,\n        input.sourceSpan,\n      ),\n    );\n  }\n\n  unit.create.push(\n    bindings.filter((b): b is ir.ExtractedAttributeOp => b?.kind === ir.OpKind.ExtractedAttribute),\n  );\n  unit.update.push(bindings.filter((b): b is ir.BindingOp => b?.kind === ir.OpKind.Binding));\n\n  for (const output of element.outputs) {\n    if (output.type === e.ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n\n    if (output.type === e.ParsedEventType.TwoWay) {\n      unit.create.push(\n        ir.createTwoWayListenerOp(\n          op.xref,\n          op.handle,\n          output.name,\n          op.tag,\n          makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan),\n          output.sourceSpan,\n        ),\n      );\n    } else if (output.type === e.ParsedEventType.Animation) {\n      unit.create.push(\n        ir.createAnimationListenerOp(\n          op.xref,\n          op.handle,\n          output.name,\n          op.tag,\n          makeListenerHandlerOps(unit, output.handler, output.handlerSpan),\n          output.name.endsWith('enter') ? ir.AnimationKind.ENTER : ir.AnimationKind.LEAVE,\n          output.target,\n          false,\n          output.sourceSpan,\n        ),\n      );\n    } else {\n      unit.create.push(\n        ir.createListenerOp(\n          op.xref,\n          op.handle,\n          output.name,\n          op.tag,\n          makeListenerHandlerOps(unit, output.handler, output.handlerSpan),\n          output.phase,\n          output.target,\n          false,\n          output.sourceSpan,\n        ),\n      );\n    }\n  }\n\n  // If any of the bindings on this element have an i18n message, then an i18n attrs configuration\n  // op is also required.\n  if (bindings.some((b) => b?.i18nMessage) !== null) {\n    unit.create.push(\n      ir.createI18nAttributesOp(unit.job.allocateXrefId(), new ir.SlotHandle(), op.xref),\n    );\n  }\n}\n\n/**\n * Process all of the bindings on a template in the template AST and convert them to their IR\n * representation.\n */\nfunction ingestTemplateBindings(\n  unit: ViewCompilationUnit,\n  op: ir.ElementOpBase,\n  template: t.Template,\n  templateKind: ir.TemplateKind | null,\n): void {\n  let bindings = new Array<ir.BindingOp | ir.ExtractedAttributeOp | null>();\n  for (const attr of template.templateAttrs) {\n    if (attr instanceof t.TextAttribute) {\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n      bindings.push(\n        createTemplateBinding(\n          unit,\n          op.xref,\n          e.BindingType.Attribute,\n          attr.name,\n          attr.value,\n          null,\n          securityContext,\n          true,\n          templateKind,\n          asMessage(attr.i18n),\n          attr.sourceSpan,\n        ),\n      );\n    } else {\n      bindings.push(\n        createTemplateBinding(\n          unit,\n          op.xref,\n          attr.type,\n          attr.name,\n          astOf(attr.value),\n          attr.unit,\n          attr.securityContext,\n          true,\n          templateKind,\n          asMessage(attr.i18n),\n          attr.sourceSpan,\n        ),\n      );\n    }\n  }\n\n  for (const attr of template.attributes) {\n    // Attribute literal bindings, such as `attr.foo=\"bar\"`.\n    const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n    bindings.push(\n      createTemplateBinding(\n        unit,\n        op.xref,\n        e.BindingType.Attribute,\n        attr.name,\n        attr.value,\n        null,\n        securityContext,\n        false,\n        templateKind,\n        asMessage(attr.i18n),\n        attr.sourceSpan,\n      ),\n    );\n  }\n\n  for (const input of template.inputs) {\n    // Dynamic bindings (both attribute and property bindings).\n    bindings.push(\n      createTemplateBinding(\n        unit,\n        op.xref,\n        input.type,\n        input.name,\n        astOf(input.value),\n        input.unit,\n        input.securityContext,\n        false,\n        templateKind,\n        asMessage(input.i18n),\n        input.sourceSpan,\n      ),\n    );\n  }\n\n  unit.create.push(\n    bindings.filter((b): b is ir.ExtractedAttributeOp => b?.kind === ir.OpKind.ExtractedAttribute),\n  );\n  unit.update.push(bindings.filter((b): b is ir.BindingOp => b?.kind === ir.OpKind.Binding));\n\n  for (const output of template.outputs) {\n    if (output.type === e.ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n\n    if (templateKind === ir.TemplateKind.NgTemplate) {\n      if (output.type === e.ParsedEventType.TwoWay) {\n        unit.create.push(\n          ir.createTwoWayListenerOp(\n            op.xref,\n            op.handle,\n            output.name,\n            op.tag,\n            makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan),\n            output.sourceSpan,\n          ),\n        );\n      } else {\n        unit.create.push(\n          ir.createListenerOp(\n            op.xref,\n            op.handle,\n            output.name,\n            op.tag,\n            makeListenerHandlerOps(unit, output.handler, output.handlerSpan),\n            output.phase,\n            output.target,\n            false,\n            output.sourceSpan,\n          ),\n        );\n      }\n    }\n    if (\n      templateKind === ir.TemplateKind.Structural &&\n      output.type !== e.ParsedEventType.LegacyAnimation\n    ) {\n      // Animation bindings are excluded from the structural template's const array.\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, output.name, false);\n      unit.create.push(\n        ir.createExtractedAttributeOp(\n          op.xref,\n          ir.BindingKind.Property,\n          null,\n          output.name,\n          null,\n          null,\n          null,\n          securityContext,\n        ),\n      );\n    }\n  }\n\n  // TODO: Perhaps we could do this in a phase? (It likely wouldn't change the slot indices.)\n  if (bindings.some((b) => b?.i18nMessage) !== null) {\n    unit.create.push(\n      ir.createI18nAttributesOp(unit.job.allocateXrefId(), new ir.SlotHandle(), op.xref),\n    );\n  }\n}\n\n/**\n * Helper to ingest an individual binding on a template, either an explicit `ng-template`, or an\n * implicit template created via structural directive.\n *\n * Bindings on templates are *extremely* tricky. I have tried to isolate all of the confusing edge\n * cases into this function, and to comment it well to document the behavior.\n *\n * Some of this behavior is intuitively incorrect, and we should consider changing it in the future.\n *\n * @param view The compilation unit for the view containing the template.\n * @param xref The xref of the template op.\n * @param type The binding type, according to the parser. This is fairly reasonable, e.g. both\n *     dynamic and static attributes have e.BindingType.Attribute.\n * @param name The binding's name.\n * @param value The bindings's value, which will either be an input AST expression, or a string\n *     literal. Note that the input AST expression may or may not be const -- it will only be a\n *     string literal if the parser considered it a text binding.\n * @param unit If the binding has a unit (e.g. `px` for style bindings), then this is the unit.\n * @param securityContext The security context of the binding.\n * @param isStructuralTemplateAttribute Whether this binding actually applies to the structural\n *     ng-template. For example, an `ngFor` would actually apply to the structural template. (Most\n *     bindings on structural elements target the inner element, not the template.)\n * @param templateKind Whether this is an explicit `ng-template` or an implicit template created by\n *     a structural directive. This should never be a block template.\n * @param i18nMessage The i18n metadata for the binding, if any.\n * @param sourceSpan The source span of the binding.\n * @returns An IR binding op, or null if the binding should be skipped.\n */\nfunction createTemplateBinding(\n  view: ViewCompilationUnit,\n  xref: ir.XrefId,\n  type: e.BindingType,\n  name: string,\n  value: e.AST | string,\n  unit: string | null,\n  securityContext: SecurityContext,\n  isStructuralTemplateAttribute: boolean,\n  templateKind: ir.TemplateKind | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): ir.BindingOp | ir.ExtractedAttributeOp | null {\n  const isTextBinding = typeof value === 'string';\n  // If this is a structural template, then several kinds of bindings should not result in an\n  // update instruction.\n  if (templateKind === ir.TemplateKind.Structural) {\n    if (!isStructuralTemplateAttribute) {\n      switch (type) {\n        case e.BindingType.Property:\n        case e.BindingType.Class:\n        case e.BindingType.Style:\n          // Because this binding doesn't really target the ng-template, it must be a binding on an\n          // inner node of a structural template. We can't skip it entirely, because we still need\n          // it on the ng-template's consts (e.g. for the purposes of directive matching). However,\n          // we should not generate an update instruction for it.\n          return ir.createExtractedAttributeOp(\n            xref,\n            ir.BindingKind.Property,\n            null,\n            name,\n            null,\n            null,\n            i18nMessage,\n            securityContext,\n          );\n        case e.BindingType.TwoWay:\n          return ir.createExtractedAttributeOp(\n            xref,\n            ir.BindingKind.TwoWayProperty,\n            null,\n            name,\n            null,\n            null,\n            i18nMessage,\n            securityContext,\n          );\n      }\n    }\n\n    if (\n      !isTextBinding &&\n      (type === e.BindingType.Attribute ||\n        type === e.BindingType.LegacyAnimation ||\n        type === e.BindingType.Animation)\n    ) {\n      // Again, this binding doesn't really target the ng-template; it actually targets the element\n      // inside the structural template. In the case of non-text attribute or animation bindings,\n      // the binding doesn't even show up on the ng-template const array, so we just skip it\n      // entirely.\n      return null;\n    }\n  }\n\n  let bindingType = BINDING_KINDS.get(type)!;\n\n  if (templateKind === ir.TemplateKind.NgTemplate) {\n    // We know we are dealing with bindings directly on an explicit ng-template.\n    // Static attribute bindings should be collected into the const array as k/v pairs. Property\n    // bindings should result in a `property` instruction, and `AttributeMarker.Bindings` const\n    // entries.\n    //\n    // The difficulty is with dynamic attribute, style, and class bindings. These don't really make\n    // sense on an `ng-template` and should probably be parser errors. However,\n    // TemplateDefinitionBuilder generates `property` instructions for them, and so we do that as\n    // well.\n    //\n    // Note that we do have a slight behavior difference with TemplateDefinitionBuilder: although\n    // TDB emits `property` instructions for dynamic attributes, styles, and classes, only styles\n    // and classes also get const collected into the `AttributeMarker.Bindings` field. Dynamic\n    // attribute bindings are missing from the consts entirely. We choose to emit them into the\n    // consts field anyway, to avoid creating special cases for something so arcane and nonsensical.\n    if (\n      type === e.BindingType.Class ||\n      type === e.BindingType.Style ||\n      (type === e.BindingType.Attribute && !isTextBinding)\n    ) {\n      // TODO: These cases should be parse errors.\n      bindingType = ir.BindingKind.Property;\n    }\n  }\n\n  return ir.createBindingOp(\n    xref,\n    bindingType,\n    name,\n    convertAstWithInterpolation(view.job, value, i18nMessage),\n    unit,\n    securityContext,\n    isTextBinding,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nMessage,\n    sourceSpan,\n  );\n}\n\nfunction makeListenerHandlerOps(\n  unit: CompilationUnit,\n  handler: e.AST,\n  handlerSpan: ParseSourceSpan,\n): ir.UpdateOp[] {\n  handler = astOf(handler);\n  const handlerOps = new Array<ir.UpdateOp>();\n  let handlerExprs: e.AST[] = handler instanceof e.Chain ? handler.expressions : [handler];\n  if (handlerExprs.length === 0) {\n    throw new Error('Expected listener to have non-empty expression list.');\n  }\n  const expressions = handlerExprs.map((expr) => convertAst(expr, unit.job, handlerSpan));\n  const returnExpr = expressions.pop()!;\n  handlerOps.push(\n    ...expressions.map((e) =>\n      ir.createStatementOp<ir.UpdateOp>(new o.ExpressionStatement(e, e.sourceSpan)),\n    ),\n  );\n  handlerOps.push(ir.createStatementOp(new o.ReturnStatement(returnExpr, returnExpr.sourceSpan)));\n  return handlerOps;\n}\n\nfunction makeTwoWayListenerHandlerOps(\n  unit: CompilationUnit,\n  handler: e.AST,\n  handlerSpan: ParseSourceSpan,\n): ir.UpdateOp[] {\n  handler = astOf(handler);\n  const handlerOps = new Array<ir.UpdateOp>();\n\n  if (handler instanceof e.Chain) {\n    if (handler.expressions.length === 1) {\n      handler = handler.expressions[0];\n    } else {\n      // This is validated during parsing already, but we do it here just in case.\n      throw new Error('Expected two-way listener to have a single expression.');\n    }\n  }\n\n  const handlerExpr = convertAst(handler, unit.job, handlerSpan);\n  const eventReference = new ir.LexicalReadExpr('$event');\n  const twoWaySetExpr = new ir.TwoWayBindingSetExpr(handlerExpr, eventReference);\n\n  handlerOps.push(ir.createStatementOp<ir.UpdateOp>(new o.ExpressionStatement(twoWaySetExpr)));\n  handlerOps.push(ir.createStatementOp(new o.ReturnStatement(eventReference)));\n  return handlerOps;\n}\n\nfunction astOf(ast: e.AST | e.ASTWithSource): e.AST {\n  return ast instanceof e.ASTWithSource ? ast.ast : ast;\n}\n\n/**\n * Process all of the local references on an element-like structure in the template AST and\n * convert them to their IR representation.\n */\nfunction ingestReferences(op: ir.ElementOpBase, element: t.Element | t.Template): void {\n  assertIsArray<ir.LocalRef>(op.localRefs);\n  for (const {name, value} of element.references) {\n    op.localRefs.push({\n      name,\n      target: value,\n    });\n  }\n}\n\n/**\n * Assert that the given value is an array.\n */\nfunction assertIsArray<T>(value: any): asserts value is Array<T> {\n  if (!Array.isArray(value)) {\n    throw new Error(`AssertionError: expected an array`);\n  }\n}\n\n/**\n * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n *\n * `ParseSpan` objects are relative to the start of the expression.\n * This method converts these to full `ParseSourceSpan` objects that\n * show where the span is within the overall source file.\n *\n * @param span the relative span to convert.\n * @param baseSourceSpan a span corresponding to the base of the expression tree.\n * @returns a `ParseSourceSpan` for the given span or null if no `baseSourceSpan` was provided.\n */\nfunction convertSourceSpan(\n  span: e.ParseSpan,\n  baseSourceSpan: ParseSourceSpan | null,\n): ParseSourceSpan | null {\n  if (baseSourceSpan === null) {\n    return null;\n  }\n  const start = baseSourceSpan.start.moveBy(span.start);\n  const end = baseSourceSpan.start.moveBy(span.end);\n  const fullStart = baseSourceSpan.fullStart.moveBy(span.start);\n  return new ParseSourceSpan(start, end, fullStart);\n}\n\n/**\n * With the directive-based control flow users were able to conditionally project content using\n * the `*` syntax. E.g. `<div *ngIf=\"expr\" projectMe></div>` will be projected into\n * `<ng-content select=\"[projectMe]\"/>`, because the attributes and tag name from the `div` are\n * copied to the template via the template creation instruction. With `@if` and `@for` that is\n * not the case, because the conditional is placed *around* elements, rather than *on* them.\n * The result is that content projection won't work in the same way if a user converts from\n * `*ngIf` to `@if`.\n *\n * This function aims to cover the most common case by doing the same copying when a control flow\n * node has *one and only one* root element or template node.\n *\n * This approach comes with some caveats:\n * 1. As soon as any other node is added to the root, the copying behavior won't work anymore.\n *    A diagnostic will be added to flag cases like this and to explain how to work around it.\n * 2. If `preserveWhitespaces` is enabled, it's very likely that indentation will break this\n *    workaround, because it'll include an additional text node as the first child. We can work\n *    around it here, but in a discussion it was decided not to, because the user explicitly opted\n *    into preserving the whitespace and we would have to drop it from the generated code.\n *    The diagnostic mentioned point in #1 will flag such cases to users.\n *\n * @returns Tag name to be used for the control flow template.\n */\nfunction ingestControlFlowInsertionPoint(\n  unit: ViewCompilationUnit,\n  xref: ir.XrefId,\n  node: t.IfBlockBranch | t.SwitchBlockCase | t.ForLoopBlock | t.ForLoopBlockEmpty,\n): string | null {\n  let root: t.Element | t.Template | null = null;\n\n  for (const child of node.children) {\n    // Skip over comment nodes and @let declarations since\n    // it doesn't matter where they end up in the DOM.\n    if (child instanceof t.Comment || child instanceof t.LetDeclaration) {\n      continue;\n    }\n\n    // We can only infer the tag name/attributes if there's a single root node.\n    if (root !== null) {\n      return null;\n    }\n\n    // Root nodes can only elements or templates with a tag name (e.g. `<div *foo></div>`).\n    if (child instanceof t.Element || (child instanceof t.Template && child.tagName !== null)) {\n      root = child;\n    } else {\n      return null;\n    }\n  }\n\n  // If we've found a single root node, its tag name and attributes can be\n  // copied to the surrounding template to be used for content projection.\n  if (root !== null) {\n    // Collect the static attributes for content projection purposes.\n    for (const attr of root.attributes) {\n      if (!attr.name.startsWith(ANIMATE_PREFIX)) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.update.push(\n          ir.createBindingOp(\n            xref,\n            ir.BindingKind.Attribute,\n            attr.name,\n            o.literal(attr.value),\n            null,\n            securityContext,\n            true,\n            false,\n            null,\n            asMessage(attr.i18n),\n            attr.sourceSpan,\n          ),\n        );\n      }\n    }\n\n    // Also collect the inputs since they participate in content projection as well.\n    // Note that TDB used to collect the outputs as well, but it wasn't passing them into\n    // the template instruction. Here we just don't collect them.\n    for (const attr of root.inputs) {\n      if (\n        attr.type !== e.BindingType.LegacyAnimation &&\n        attr.type !== e.BindingType.Animation &&\n        attr.type !== e.BindingType.Attribute\n      ) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.create.push(\n          ir.createExtractedAttributeOp(\n            xref,\n            ir.BindingKind.Property,\n            null,\n            attr.name,\n            null,\n            null,\n            null,\n            securityContext,\n          ),\n        );\n      }\n    }\n\n    const tagName = root instanceof t.Element ? root.name : root.tagName;\n\n    // Don't pass along `ng-template` tag name since it enables directive matching.\n    return tagName === NG_TEMPLATE_TAG_NAME ? null : tagName;\n  }\n\n  return null;\n}\n"]}