{"version":3,"file":"i18n_parser.js","sourceRoot":"","sources":["i18n_parser.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,KAAK,IAAI,eAAe,EAAC,MAAM,4BAA4B,CAAC;AACpE,OAAO,EAAC,MAAM,IAAI,gBAAgB,EAAC,MAAM,6BAA6B,CAAC;AACvE,OAAO,EAAC,SAAS,IAAI,mBAAmB,EAAC,MAAM,iCAAiC,CAAC;AACjF,OAAO,KAAK,IAAI,MAAM,kBAAkB,CAAC;AAEzC,OAAO,EAAC,oBAAoB,EAAC,MAAM,wBAAwB,CAAC;AAQ5D,OAAO,EAAC,eAAe,EAAC,MAAM,eAAe,CAAC;AAE9C,OAAO,KAAK,IAAI,MAAM,YAAY,CAAC;AACnC,OAAO,EAAC,mBAAmB,EAAC,MAAM,2BAA2B,CAAC;AAE9D,MAAM,UAAU,GAAG,IAAI,gBAAgB,CAAC,IAAI,eAAe,EAAE,CAAC,CAAC;AAc/D;;GAEG;AACH,MAAM,UAAU,wBAAwB,CACtC,mBAAwC,EACxC,eAA4B,EAC5B,iBAA0B,EAC1B,4BAAqC;IAErC,MAAM,OAAO,GAAG,IAAI,YAAY,CAC9B,UAAU,EACV,mBAAmB,EACnB,eAAe,EACf,iBAAiB,EACjB,4BAA4B,CAC7B,CAAC;IACF,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,WAAW,EAAE,QAAQ,EAAE,WAAW,EAAE,EAAE,CAC5D,OAAO,CAAC,aAAa,CAAC,KAAK,EAAE,OAAO,EAAE,WAAW,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;AAC9E,CAAC;AAWD,SAAS,eAAe,CAAC,KAAgB,EAAE,IAAe;IACxD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,YAAY;IAChB,YACU,iBAAmC,EACnC,oBAAyC,EACzC,gBAA6B,EACpB,kBAA2B,EAC3B,6BAAsC;QAJ/C,sBAAiB,GAAjB,iBAAiB,CAAkB;QACnC,yBAAoB,GAApB,oBAAoB,CAAqB;QACzC,qBAAgB,GAAhB,gBAAgB,CAAa;QACpB,uBAAkB,GAAlB,kBAAkB,CAAS;QAC3B,kCAA6B,GAA7B,6BAA6B,CAAS;IACtD,CAAC;IAEG,aAAa,CAClB,KAAkB,EAClB,OAAO,GAAG,EAAE,EACZ,WAAW,GAAG,EAAE,EAChB,QAAQ,GAAG,EAAE,EACb,WAAoC;QAEpC,MAAM,OAAO,GAA8B;YACzC,KAAK,EAAE,KAAK,CAAC,MAAM,IAAI,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC,SAAS;YAC9D,QAAQ,EAAE,CAAC;YACX,mBAAmB,EAAE,IAAI,mBAAmB,EAAE;YAC9C,oBAAoB,EAAE,EAAE;YACxB,oBAAoB,EAAE,EAAE;YACxB,WAAW,EAAE,WAAW,IAAI,eAAe;SAC5C,CAAC;QAEF,MAAM,QAAQ,GAAgB,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;QAElE,OAAO,IAAI,IAAI,CAAC,OAAO,CACrB,QAAQ,EACR,OAAO,CAAC,oBAAoB,EAC5B,OAAO,CAAC,oBAAoB,EAC5B,OAAO,EACP,WAAW,EACX,QAAQ,CACT,CAAC;IACJ,CAAC;IAED,YAAY,CAAC,EAAgB,EAAE,OAAkC;QAC/D,OAAO,IAAI,CAAC,iBAAiB,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;IAC7C,CAAC;IAED,cAAc,CAAC,SAAyB,EAAE,OAAkC;QAC1E,OAAO,IAAI,CAAC,iBAAiB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;IACpD,CAAC;IAED,cAAc,CAAC,SAAyB,EAAE,OAAY;QACpD,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;IACtC,CAAC;IAED,cAAc,CAAC,SAAyB,EAAE,OAAkC;QAC1E,MAAM,IAAI,GACR,SAAS,CAAC,WAAW,KAAK,SAAS,IAAI,SAAS,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC;YACvE,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,SAAS,IAAI,SAAS,CAAC,UAAU,CAAC;YAC7E,CAAC,CAAC,IAAI,CAAC,2BAA2B,CAC9B,SAAS,CAAC,WAAW,EACrB,SAAS,CAAC,SAAS,IAAI,SAAS,CAAC,UAAU,EAC3C,OAAO,EACP,SAAS,CAAC,IAAI,CACf,CAAC;QACR,OAAO,OAAO,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC9C,CAAC;IAED,SAAS,CAAC,IAAe,EAAE,OAAkC;QAC3D,MAAM,IAAI,GACR,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC;YACtB,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC;YAC5C,CAAC,CAAC,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QACzF,OAAO,OAAO,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACzC,CAAC;IAED,YAAY,CAAC,OAAqB,EAAE,OAAkC;QACpE,OAAO,IAAI,CAAC;IACd,CAAC;IAED,cAAc,CAAC,GAAmB,EAAE,OAAkC;QACpE,OAAO,CAAC,QAAQ,EAAE,CAAC;QACnB,MAAM,YAAY,GAA6B,EAAE,CAAC;QAClD,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,GAAG,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC;QACtF,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAQ,EAAE;YAC/B,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,SAAS,CAC3C,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,EACxD,IAAI,CAAC,aAAa,CACnB,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,OAAO,CAAC,QAAQ,EAAE,CAAC;QAEnB,IAAI,OAAO,CAAC,KAAK,IAAI,OAAO,CAAC,QAAQ,GAAG,CAAC,EAAE,CAAC;YAC1C,4BAA4B;YAC5B,iEAAiE;YACjE,+BAA+B;YAC/B,MAAM,KAAK,GAAG,OAAO,CAAC,mBAAmB,CAAC,oBAAoB,CAAC,OAAO,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YAClF,OAAO,CAAC,qBAAqB,GAAG,KAAK,CAAC;YACtC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,GAAG;gBACpC,IAAI,EAAE,GAAG,CAAC,WAAW;gBACrB,UAAU,EAAE,GAAG,CAAC,qBAAqB;aACtC,CAAC;YACF,OAAO,OAAO,CAAC,WAAW,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QAC3C,CAAC;QAED,6BAA6B;QAC7B,yFAAyF;QACzF,gBAAgB;QAChB,yFAAyF;QACzF,MAAM,MAAM,GAAG,OAAO,CAAC,mBAAmB,CAAC,kBAAkB,CAAC,KAAK,EAAE,GAAG,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC;QAChG,OAAO,CAAC,oBAAoB,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,SAAS,CAAC,CAAC;QACxF,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC;QACtE,OAAO,OAAO,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;IACxC,CAAC;IAED,kBAAkB,CAAC,QAA4B,EAAE,QAAmC;QAClF,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;IACtC,CAAC;IAED,UAAU,CAAC,KAAiB,EAAE,OAAkC;QAC9D,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAE9D,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC;YAC1C,OAAO,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;QACxD,CAAC;QAED,MAAM,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QACrE,MAAM,WAAW,GAAG,OAAO,CAAC,mBAAmB,CAAC,4BAA4B,CAC1E,KAAK,CAAC,IAAI,EACV,UAAU,CACX,CAAC;QACF,MAAM,WAAW,GAAG,OAAO,CAAC,mBAAmB,CAAC,4BAA4B,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAEzF,OAAO,CAAC,oBAAoB,CAAC,WAAW,CAAC,GAAG;YAC1C,IAAI,EAAE,KAAK,CAAC,eAAe,CAAC,QAAQ,EAAE;YACtC,UAAU,EAAE,KAAK,CAAC,eAAe;SAClC,CAAC;QAEF,OAAO,CAAC,oBAAoB,CAAC,WAAW,CAAC,GAAG;YAC1C,IAAI,EAAE,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,GAAG;YAChE,UAAU,EAAE,KAAK,CAAC,aAAa,IAAI,KAAK,CAAC,UAAU;SACpD,CAAC;QAEF,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,gBAAgB,CACpC,KAAK,CAAC,IAAI,EACV,UAAU,EACV,WAAW,EACX,WAAW,EACX,QAAQ,EACR,KAAK,CAAC,UAAU,EAChB,KAAK,CAAC,eAAe,EACrB,KAAK,CAAC,aAAa,CACpB,CAAC;QACF,OAAO,OAAO,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IAC1C,CAAC;IAED,mBAAmB,CAAC,UAA+B,EAAE,QAAmC;QACtF,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;IACtC,CAAC;IAED,mBAAmB,CAAC,IAAyB,EAAE,OAAY;QACzD,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,iBAAiB,CACvB,IAAmC,EACnC,OAAkC;QAElC,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAC7D,MAAM,KAAK,GAA0B,EAAE,CAAC;QACxC,MAAM,cAAc,GAAG,CAAC,IAAoB,EAAE,EAAE;YAC9C,oEAAoE;YACpE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;QAChC,CAAC,CAAC;QAEF,IAAI,QAAgB,CAAC;QACrB,IAAI,MAAe,CAAC;QAEpB,IAAI,IAAI,YAAY,IAAI,CAAC,OAAO,EAAE,CAAC;YACjC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;YACrB,MAAM,GAAG,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;QAClD,CAAC;aAAM,CAAC;YACN,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YACzB,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC;QAC5E,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;QACnC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC;QAEpE,MAAM,WAAW,GAAG,OAAO,CAAC,mBAAmB,CAAC,0BAA0B,CACxE,QAAQ,EACR,KAAK,EACL,MAAM,CACP,CAAC;QACF,OAAO,CAAC,oBAAoB,CAAC,WAAW,CAAC,GAAG;YAC1C,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE;YACrC,UAAU,EAAE,IAAI,CAAC,eAAe;SACjC,CAAC;QAEF,IAAI,WAAW,GAAG,EAAE,CAAC;QAErB,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,WAAW,GAAG,OAAO,CAAC,mBAAmB,CAAC,0BAA0B,CAAC,QAAQ,CAAC,CAAC;YAC/E,OAAO,CAAC,oBAAoB,CAAC,WAAW,CAAC,GAAG;gBAC1C,IAAI,EAAE,KAAK,QAAQ,GAAG;gBACtB,UAAU,EAAE,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,UAAU;aAClD,CAAC;QACJ,CAAC;QAED,MAAM,QAAQ,GAAG,IAAI,IAAI,CAAC,cAAc,CACtC,QAAQ,EACR,KAAK,EACL,WAAW,EACX,WAAW,EACX,QAAQ,EACR,MAAM,EACN,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,aAAa,CACnB,CAAC;QACF,OAAO,OAAO,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC7C,CAAC;IAED;;;;;;;OAOG;IACK,2BAA2B,CACjC,MAA8D,EAC9D,UAA2B,EAC3B,OAAkC,EAClC,YAAuC;QAEvC,gFAAgF;QAChF,MAAM,KAAK,GAAgB,EAAE,CAAC;QAC9B,wEAAwE;QACxE,4BAA4B;QAC5B,IAAI,gBAAgB,GAAG,KAAK,CAAC;QAC7B,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;YAC3B,QAAQ,KAAK,CAAC,IAAI,EAAE,CAAC;gBACnB,qCAA6B;gBAC7B;oBACE,gBAAgB,GAAG,IAAI,CAAC;oBACxB,MAAM,CAAC,WAAW,EAAE,UAAU,EAAE,SAAS,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC;oBACzD,MAAM,QAAQ,GAAG,sBAAsB,CAAC,UAAU,CAAC,IAAI,eAAe,CAAC;oBACvE,MAAM,MAAM,GAAG,OAAO,CAAC,mBAAmB,CAAC,kBAAkB,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;oBAEpF,IAAI,IAAI,CAAC,6BAA6B,EAAE,CAAC;wBACvC,OAAO,CAAC,oBAAoB,CAAC,MAAM,CAAC,GAAG;4BACrC,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC;4BAC1B,UAAU,EAAE,KAAK,CAAC,UAAU;yBAC7B,CAAC;wBACF,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;oBACzE,CAAC;yBAAM,CAAC;wBACN,MAAM,UAAU,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;wBACnD,OAAO,CAAC,oBAAoB,CAAC,MAAM,CAAC,GAAG;4BACrC,IAAI,EAAE,GAAG,WAAW,GAAG,UAAU,GAAG,SAAS,EAAE;4BAC/C,UAAU,EAAE,KAAK,CAAC,UAAU;yBAC7B,CAAC;wBACF,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;oBACzE,CAAC;oBACD,MAAM;gBACR;oBACE,gFAAgF;oBAChF,+EAA+E;oBAC/E,gFAAgF;oBAChF,iEAAiE;oBACjE,gFAAgF;oBAChF,mFAAmF;oBACnF,kFAAkF;oBAClF,gFAAgF;oBAChF,6BAA6B;oBAC7B,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;wBACzD,2CAA2C;wBAC3C,+EAA+E;wBAC/E,uEAAuE;wBACvE,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;wBACzC,IAAI,QAAQ,YAAY,IAAI,CAAC,IAAI,EAAE,CAAC;4BAClC,QAAQ,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;4BACjC,QAAQ,CAAC,UAAU,GAAG,IAAI,eAAe,CACvC,QAAQ,CAAC,UAAU,CAAC,KAAK,EACzB,KAAK,CAAC,UAAU,CAAC,GAAG,EACpB,QAAQ,CAAC,UAAU,CAAC,SAAS,EAC7B,QAAQ,CAAC,UAAU,CAAC,OAAO,CAC5B,CAAC;wBACJ,CAAC;6BAAM,CAAC;4BACN,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;wBAC9D,CAAC;oBACH,CAAC;yBAAM,CAAC;wBACN,+EAA+E;wBAC/E,iFAAiF;wBACjF,4EAA4E;wBAC5E,gFAAgF;wBAChF,6CAA6C;wBAC7C,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;4BAC5B,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;wBAC9D,CAAC;oBACH,CAAC;oBAED,MAAM;YACV,CAAC;QACH,CAAC;QAED,IAAI,gBAAgB,EAAE,CAAC;YACrB,0EAA0E;YAC1E,wBAAwB,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;YAC9C,OAAO,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;QAC/C,CAAC;aAAM,CAAC;YACN,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC;IACH,CAAC;IAED,+EAA+E;IAC/E,gEAAgE;IAChE,mBAAmB,CAAC,KAA4D;QAC9E,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAClC,MAAM,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAC9C,UAAU;QACV,cAAc,CAAC,KAAK,CAAC,UAAU;QAC/B,oBAAoB,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,EAClD,IAAI,CAAC,oBAAoB,CAC1B,CAAC;QACF,OAAO,mBAAmB,CAAC,IAAI,CAAC,CAAC;IACnC,CAAC;CACF;AAED;;;;;;;;GAQG;AACH,SAAS,wBAAwB,CAC/B,KAAkB,EAClB,YAAuC;IAEvC,IAAI,YAAY,YAAY,IAAI,CAAC,OAAO,EAAE,CAAC;QACzC,yFAAyF;QACzF,wFAAwF;QACxF,+CAA+C;QAC/C,4BAA4B,CAAC,YAAY,CAAC,CAAC;QAC3C,YAAY,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACvC,CAAC;IAED,IAAI,YAAY,YAAY,IAAI,CAAC,SAAS,EAAE,CAAC;QAC3C,8FAA8F;QAC9F,wDAAwD;QACxD,qBAAqB,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QAEpD,8CAA8C;QAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACtC,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;QAC5D,CAAC;IACH,CAAC;AACH,CAAC;AAED;;GAEG;AACH,SAAS,4BAA4B,CAAC,OAAqB;IACzD,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;IAC5B,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;QAChE,MAAM,IAAI,KAAK,CACb,8FAA8F,CAC/F,CAAC;IACJ,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,SAAS,qBAAqB,CAAC,aAA0B,EAAE,KAAkB;IAC3E,IAAI,aAAa,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE,CAAC;QAC1C,MAAM,IAAI,KAAK,CACb;;;cAGQ,aAAa,CAAC,MAAM;EAChC,aAAa,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;;eAE5D,KAAK,CAAC,MAAM;EACzB,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;KAC9D,CAAC,IAAI,EAAE,CACP,CAAC;IACJ,CAAC;IACD,IAAI,aAAa,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,KAAK,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC;QAC/E,MAAM,IAAI,KAAK,CACb,+EAA+E,CAChF,CAAC;IACJ,CAAC;AACH,CAAC;AAED,MAAM,cAAc,GAClB,6EAA6E,CAAC;AAEhF,SAAS,sBAAsB,CAAC,KAAa;IAC3C,OAAO,KAAK,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Lexer as ExpressionLexer} from '../expression_parser/lexer';\nimport {Parser as ExpressionParser} from '../expression_parser/parser';\nimport {serialize as serializeExpression} from '../expression_parser/serializer';\nimport * as html from '../ml_parser/ast';\nimport {InterpolationConfig} from '../ml_parser/defaults';\nimport {getHtmlTagDefinition} from '../ml_parser/html_tags';\nimport {\n  AttributeValueInterpolationToken,\n  InterpolatedAttributeToken,\n  InterpolatedTextToken,\n  InterpolationToken,\n  TokenType,\n} from '../ml_parser/tokens';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as i18n from './i18n_ast';\nimport {PlaceholderRegistry} from './serializers/placeholder';\n\nconst _expParser = new ExpressionParser(new ExpressionLexer());\n\nexport type VisitNodeFn = (html: html.Node, i18n: i18n.Node) => i18n.Node;\n\nexport interface I18nMessageFactory {\n  (\n    nodes: html.Node[],\n    meaning: string | undefined,\n    description: string | undefined,\n    customId: string | undefined,\n    visitNodeFn?: VisitNodeFn,\n  ): i18n.Message;\n}\n\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nexport function createI18nMessageFactory(\n  interpolationConfig: InterpolationConfig,\n  containerBlocks: Set<string>,\n  retainEmptyTokens: boolean,\n  preserveExpressionWhitespace: boolean,\n): I18nMessageFactory {\n  const visitor = new _I18nVisitor(\n    _expParser,\n    interpolationConfig,\n    containerBlocks,\n    retainEmptyTokens,\n    preserveExpressionWhitespace,\n  );\n  return (nodes, meaning, description, customId, visitNodeFn) =>\n    visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\n\ninterface I18nMessageVisitorContext {\n  isIcu: boolean;\n  icuDepth: number;\n  placeholderRegistry: PlaceholderRegistry;\n  placeholderToContent: {[phName: string]: i18n.MessagePlaceholder};\n  placeholderToMessage: {[phName: string]: i18n.Message};\n  visitNodeFn: VisitNodeFn;\n}\n\nfunction noopVisitNodeFn(_html: html.Node, i18n: i18n.Node): i18n.Node {\n  return i18n;\n}\n\nclass _I18nVisitor implements html.Visitor {\n  constructor(\n    private _expressionParser: ExpressionParser,\n    private _interpolationConfig: InterpolationConfig,\n    private _containerBlocks: Set<string>,\n    private readonly _retainEmptyTokens: boolean,\n    private readonly _preserveExpressionWhitespace: boolean,\n  ) {}\n\n  public toI18nMessage(\n    nodes: html.Node[],\n    meaning = '',\n    description = '',\n    customId = '',\n    visitNodeFn: VisitNodeFn | undefined,\n  ): i18n.Message {\n    const context: I18nMessageVisitorContext = {\n      isIcu: nodes.length == 1 && nodes[0] instanceof html.Expansion,\n      icuDepth: 0,\n      placeholderRegistry: new PlaceholderRegistry(),\n      placeholderToContent: {},\n      placeholderToMessage: {},\n      visitNodeFn: visitNodeFn || noopVisitNodeFn,\n    };\n\n    const i18nodes: i18n.Node[] = html.visitAll(this, nodes, context);\n\n    return new i18n.Message(\n      i18nodes,\n      context.placeholderToContent,\n      context.placeholderToMessage,\n      meaning,\n      description,\n      customId,\n    );\n  }\n\n  visitElement(el: html.Element, context: I18nMessageVisitorContext): i18n.Node {\n    return this._visitElementLike(el, context);\n  }\n\n  visitComponent(component: html.Component, context: I18nMessageVisitorContext) {\n    return this._visitElementLike(component, context);\n  }\n\n  visitDirective(directive: html.Directive, context: any) {\n    throw new Error('Unreachable code');\n  }\n\n  visitAttribute(attribute: html.Attribute, context: I18nMessageVisitorContext): i18n.Node {\n    const node =\n      attribute.valueTokens === undefined || attribute.valueTokens.length === 1\n        ? new i18n.Text(attribute.value, attribute.valueSpan || attribute.sourceSpan)\n        : this._visitTextWithInterpolation(\n            attribute.valueTokens,\n            attribute.valueSpan || attribute.sourceSpan,\n            context,\n            attribute.i18n,\n          );\n    return context.visitNodeFn(attribute, node);\n  }\n\n  visitText(text: html.Text, context: I18nMessageVisitorContext): i18n.Node {\n    const node =\n      text.tokens.length === 1\n        ? new i18n.Text(text.value, text.sourceSpan)\n        : this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n    return context.visitNodeFn(text, node);\n  }\n\n  visitComment(comment: html.Comment, context: I18nMessageVisitorContext): i18n.Node | null {\n    return null;\n  }\n\n  visitExpansion(icu: html.Expansion, context: I18nMessageVisitorContext): i18n.Node {\n    context.icuDepth++;\n    const i18nIcuCases: {[k: string]: i18n.Node} = {};\n    const i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach((caze): void => {\n      i18nIcuCases[caze.value] = new i18n.Container(\n        caze.expression.map((node) => node.visit(this, context)),\n        caze.expSourceSpan,\n      );\n    });\n    context.icuDepth--;\n\n    if (context.isIcu || context.icuDepth > 0) {\n      // Returns an ICU node when:\n      // - the message (vs a part of the message) is an ICU message, or\n      // - the ICU message is nested.\n      const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      context.placeholderToContent[expPh] = {\n        text: icu.switchValue,\n        sourceSpan: icu.switchValueSourceSpan,\n      };\n      return context.visitNodeFn(icu, i18nIcu);\n    }\n\n    // Else returns a placeholder\n    // ICU placeholders should not be replaced with their original content but with the their\n    // translations.\n    // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n    const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n    context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n    const node = new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    return context.visitNodeFn(icu, node);\n  }\n\n  visitExpansionCase(_icuCase: html.ExpansionCase, _context: I18nMessageVisitorContext): i18n.Node {\n    throw new Error('Unreachable code');\n  }\n\n  visitBlock(block: html.Block, context: I18nMessageVisitorContext) {\n    const children = html.visitAll(this, block.children, context);\n\n    if (this._containerBlocks.has(block.name)) {\n      return new i18n.Container(children, block.sourceSpan);\n    }\n\n    const parameters = block.parameters.map((param) => param.expression);\n    const startPhName = context.placeholderRegistry.getStartBlockPlaceholderName(\n      block.name,\n      parameters,\n    );\n    const closePhName = context.placeholderRegistry.getCloseBlockPlaceholderName(block.name);\n\n    context.placeholderToContent[startPhName] = {\n      text: block.startSourceSpan.toString(),\n      sourceSpan: block.startSourceSpan,\n    };\n\n    context.placeholderToContent[closePhName] = {\n      text: block.endSourceSpan ? block.endSourceSpan.toString() : '}',\n      sourceSpan: block.endSourceSpan ?? block.sourceSpan,\n    };\n\n    const node = new i18n.BlockPlaceholder(\n      block.name,\n      parameters,\n      startPhName,\n      closePhName,\n      children,\n      block.sourceSpan,\n      block.startSourceSpan,\n      block.endSourceSpan,\n    );\n    return context.visitNodeFn(block, node);\n  }\n\n  visitBlockParameter(_parameter: html.BlockParameter, _context: I18nMessageVisitorContext) {\n    throw new Error('Unreachable code');\n  }\n\n  visitLetDeclaration(decl: html.LetDeclaration, context: any) {\n    return null;\n  }\n\n  private _visitElementLike(\n    node: html.Element | html.Component,\n    context: I18nMessageVisitorContext,\n  ): i18n.Node {\n    const children = html.visitAll(this, node.children, context);\n    const attrs: {[k: string]: string} = {};\n    const visitAttribute = (attr: html.Attribute) => {\n      // Do not visit the attributes, translatable ones are top-level ASTs\n      attrs[attr.name] = attr.value;\n    };\n\n    let nodeName: string;\n    let isVoid: boolean;\n\n    if (node instanceof html.Element) {\n      nodeName = node.name;\n      isVoid = getHtmlTagDefinition(node.name).isVoid;\n    } else {\n      nodeName = node.fullName;\n      isVoid = node.tagName ? getHtmlTagDefinition(node.tagName).isVoid : false;\n    }\n\n    node.attrs.forEach(visitAttribute);\n    node.directives.forEach((dir) => dir.attrs.forEach(visitAttribute));\n\n    const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(\n      nodeName,\n      attrs,\n      isVoid,\n    );\n    context.placeholderToContent[startPhName] = {\n      text: node.startSourceSpan.toString(),\n      sourceSpan: node.startSourceSpan,\n    };\n\n    let closePhName = '';\n\n    if (!isVoid) {\n      closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(nodeName);\n      context.placeholderToContent[closePhName] = {\n        text: `</${nodeName}>`,\n        sourceSpan: node.endSourceSpan ?? node.sourceSpan,\n      };\n    }\n\n    const i18nNode = new i18n.TagPlaceholder(\n      nodeName,\n      attrs,\n      startPhName,\n      closePhName,\n      children,\n      isVoid,\n      node.sourceSpan,\n      node.startSourceSpan,\n      node.endSourceSpan,\n    );\n    return context.visitNodeFn(node, i18nNode);\n  }\n\n  /**\n   * Convert, text and interpolated tokens up into text and placeholder pieces.\n   *\n   * @param tokens The text and interpolated tokens.\n   * @param sourceSpan The span of the whole of the `text` string.\n   * @param context The current context of the visitor, used to compute and store placeholders.\n   * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n   */\n  private _visitTextWithInterpolation(\n    tokens: (InterpolatedTextToken | InterpolatedAttributeToken)[],\n    sourceSpan: ParseSourceSpan,\n    context: I18nMessageVisitorContext,\n    previousI18n: i18n.I18nMeta | undefined,\n  ): i18n.Node {\n    // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n    const nodes: i18n.Node[] = [];\n    // We will only create a container if there are actually interpolations,\n    // so this flag tracks that.\n    let hasInterpolation = false;\n    for (const token of tokens) {\n      switch (token.type) {\n        case TokenType.INTERPOLATION:\n        case TokenType.ATTR_VALUE_INTERPOLATION:\n          hasInterpolation = true;\n          const [startMarker, expression, endMarker] = token.parts;\n          const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n          const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n\n          if (this._preserveExpressionWhitespace) {\n            context.placeholderToContent[phName] = {\n              text: token.parts.join(''),\n              sourceSpan: token.sourceSpan,\n            };\n            nodes.push(new i18n.Placeholder(expression, phName, token.sourceSpan));\n          } else {\n            const normalized = this.normalizeExpression(token);\n            context.placeholderToContent[phName] = {\n              text: `${startMarker}${normalized}${endMarker}`,\n              sourceSpan: token.sourceSpan,\n            };\n            nodes.push(new i18n.Placeholder(normalized, phName, token.sourceSpan));\n          }\n          break;\n        default:\n          // Try to merge text tokens with previous tokens. We do this even for all tokens\n          // when `retainEmptyTokens == true` because whitespace tokens may have non-zero\n          // length, but will be trimmed by `WhitespaceVisitor` in one extraction pass and\n          // be considered \"empty\" there. Therefore a whitespace token with\n          // `retainEmptyTokens === true` should be treated like an empty token and either\n          // retained or merged into the previous node. Since extraction does two passes with\n          // different trimming behavior, the second pass needs to have identical node count\n          // to reuse source spans, so we need this check to get the same answer when both\n          // trimming and not trimming.\n          if (token.parts[0].length > 0 || this._retainEmptyTokens) {\n            // This token is text or an encoded entity.\n            // If it is following on from a previous text node then merge it into that node\n            // Otherwise, if it is following an interpolation, then add a new node.\n            const previous = nodes[nodes.length - 1];\n            if (previous instanceof i18n.Text) {\n              previous.value += token.parts[0];\n              previous.sourceSpan = new ParseSourceSpan(\n                previous.sourceSpan.start,\n                token.sourceSpan.end,\n                previous.sourceSpan.fullStart,\n                previous.sourceSpan.details,\n              );\n            } else {\n              nodes.push(new i18n.Text(token.parts[0], token.sourceSpan));\n            }\n          } else {\n            // Retain empty tokens to avoid breaking dropping entire nodes such that source\n            // spans should not be reusable across multiple parses of a template. We *should*\n            // do this all the time, however we need to maintain backwards compatibility\n            // with existing message IDs so we can't do it by default and should only enable\n            // this when removing significant whitespace.\n            if (this._retainEmptyTokens) {\n              nodes.push(new i18n.Text(token.parts[0], token.sourceSpan));\n            }\n          }\n\n          break;\n      }\n    }\n\n    if (hasInterpolation) {\n      // Whitespace removal may have invalidated the interpolation source-spans.\n      reusePreviousSourceSpans(nodes, previousI18n);\n      return new i18n.Container(nodes, sourceSpan);\n    } else {\n      return nodes[0];\n    }\n  }\n\n  // Normalize expression whitespace by parsing and re-serializing it. This makes\n  // message IDs more durable to insignificant whitespace changes.\n  normalizeExpression(token: InterpolationToken | AttributeValueInterpolationToken): string {\n    const expression = token.parts[1];\n    const expr = this._expressionParser.parseBinding(\n      expression,\n      /* location */ token.sourceSpan,\n      /* absoluteOffset */ token.sourceSpan.start.offset,\n      this._interpolationConfig,\n    );\n    return serializeExpression(expr);\n  }\n}\n\n/**\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n *\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n * reuse the source-span stored from a previous pass before the whitespace was removed.\n *\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n */\nfunction reusePreviousSourceSpans(\n  nodes: i18n.Node[],\n  previousI18n: i18n.I18nMeta | undefined,\n): void {\n  if (previousI18n instanceof i18n.Message) {\n    // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n    // metadata. The `Message` should consist only of a single `Container` that contains the\n    // parts (`Text` and `Placeholder`) to process.\n    assertSingleContainerMessage(previousI18n);\n    previousI18n = previousI18n.nodes[0];\n  }\n\n  if (previousI18n instanceof i18n.Container) {\n    // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n    // after whitespace has been removed from the AST nodes.\n    assertEquivalentNodes(previousI18n.children, nodes);\n\n    // Reuse the source-spans from the first pass.\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n    }\n  }\n}\n\n/**\n * Asserts that the `message` contains exactly one `Container` node.\n */\nfunction assertSingleContainerMessage(message: i18n.Message): void {\n  const nodes = message.nodes;\n  if (nodes.length !== 1 || !(nodes[0] instanceof i18n.Container)) {\n    throw new Error(\n      'Unexpected previous i18n message - expected it to consist of only a single `Container` node.',\n    );\n  }\n}\n\n/**\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n * corresponding elements have the same node type.\n */\nfunction assertEquivalentNodes(previousNodes: i18n.Node[], nodes: i18n.Node[]): void {\n  if (previousNodes.length !== nodes.length) {\n    throw new Error(\n      `\nThe number of i18n message children changed between first and second pass.\n\nFirst pass (${previousNodes.length} tokens):\n${previousNodes.map((node) => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n\nSecond pass (${nodes.length} tokens):\n${nodes.map((node) => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n    `.trim(),\n    );\n  }\n  if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n    throw new Error(\n      'The types of the i18n message children changed between first and second pass.',\n    );\n  }\n}\n\nconst _CUSTOM_PH_EXP =\n  /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction extractPlaceholderName(input: string): string {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n"]}