{"version":3,"file":"r3_deferred_blocks.js","sourceRoot":"","sources":["r3_deferred_blocks.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\nimport {BindingParser} from '../template_parser/binding_parser';\n\nimport * as t from './r3_ast';\nimport {\n  getTriggerParametersStart,\n  parseDeferredTime,\n  parseNeverTrigger,\n  parseOnTrigger,\n  parseWhenTrigger,\n} from './r3_deferred_triggers';\n\n/** Pattern to identify a `prefetch when` trigger. */\nconst PREFETCH_WHEN_PATTERN = /^prefetch\\s+when\\s/;\n\n/** Pattern to identify a `prefetch on` trigger. */\nconst PREFETCH_ON_PATTERN = /^prefetch\\s+on\\s/;\n\n/** Pattern to identify a `hydrate when` trigger. */\nconst HYDRATE_WHEN_PATTERN = /^hydrate\\s+when\\s/;\n\n/** Pattern to identify a `hydrate on` trigger. */\nconst HYDRATE_ON_PATTERN = /^hydrate\\s+on\\s/;\n\n/** Pattern to identify a `hydrate never` trigger. */\nconst HYDRATE_NEVER_PATTERN = /^hydrate\\s+never(\\s*)$/;\n\n/** Pattern to identify a `minimum` parameter in a block. */\nconst MINIMUM_PARAMETER_PATTERN = /^minimum\\s/;\n\n/** Pattern to identify a `after` parameter in a block. */\nconst AFTER_PARAMETER_PATTERN = /^after\\s/;\n\n/** Pattern to identify a `when` parameter in a block. */\nconst WHEN_PARAMETER_PATTERN = /^when\\s/;\n\n/** Pattern to identify a `on` parameter in a block. */\nconst ON_PARAMETER_PATTERN = /^on\\s/;\n\n/**\n * Predicate function that determines if a block with\n * a specific name cam be connected to a `defer` block.\n */\nexport function isConnectedDeferLoopBlock(name: string): boolean {\n  return name === 'placeholder' || name === 'loading' || name === 'error';\n}\n\n/** Creates a deferred block from an HTML AST node. */\nexport function createDeferredBlock(\n  ast: html.Block,\n  connectedBlocks: html.Block[],\n  visitor: html.Visitor,\n  bindingParser: BindingParser,\n): {node: t.DeferredBlock; errors: ParseError[]} {\n  const errors: ParseError[] = [];\n  const {placeholder, loading, error} = parseConnectedBlocks(connectedBlocks, errors, visitor);\n  const {triggers, prefetchTriggers, hydrateTriggers} = parsePrimaryTriggers(\n    ast,\n    bindingParser,\n    errors,\n    placeholder,\n  );\n\n  // The `defer` block has a main span encompassing all of the connected branches as well.\n  let lastEndSourceSpan = ast.endSourceSpan;\n  let endOfLastSourceSpan = ast.sourceSpan.end;\n  if (connectedBlocks.length > 0) {\n    const lastConnectedBlock = connectedBlocks[connectedBlocks.length - 1];\n    lastEndSourceSpan = lastConnectedBlock.endSourceSpan;\n    endOfLastSourceSpan = lastConnectedBlock.sourceSpan.end;\n  }\n\n  const sourceSpanWithConnectedBlocks = new ParseSourceSpan(\n    ast.sourceSpan.start,\n    endOfLastSourceSpan,\n  );\n\n  const node = new t.DeferredBlock(\n    html.visitAll(visitor, ast.children, ast.children),\n    triggers,\n    prefetchTriggers,\n    hydrateTriggers,\n    placeholder,\n    loading,\n    error,\n    ast.nameSpan,\n    sourceSpanWithConnectedBlocks,\n    ast.sourceSpan,\n    ast.startSourceSpan,\n    lastEndSourceSpan,\n    ast.i18n,\n  );\n\n  return {node, errors};\n}\n\nfunction parseConnectedBlocks(\n  connectedBlocks: html.Block[],\n  errors: ParseError[],\n  visitor: html.Visitor,\n) {\n  let placeholder: t.DeferredBlockPlaceholder | null = null;\n  let loading: t.DeferredBlockLoading | null = null;\n  let error: t.DeferredBlockError | null = null;\n\n  for (const block of connectedBlocks) {\n    try {\n      if (!isConnectedDeferLoopBlock(block.name)) {\n        errors.push(new ParseError(block.startSourceSpan, `Unrecognized block \"@${block.name}\"`));\n        break;\n      }\n\n      switch (block.name) {\n        case 'placeholder':\n          if (placeholder !== null) {\n            errors.push(\n              new ParseError(\n                block.startSourceSpan,\n                `@defer block can only have one @placeholder block`,\n              ),\n            );\n          } else {\n            placeholder = parsePlaceholderBlock(block, visitor);\n          }\n          break;\n\n        case 'loading':\n          if (loading !== null) {\n            errors.push(\n              new ParseError(\n                block.startSourceSpan,\n                `@defer block can only have one @loading block`,\n              ),\n            );\n          } else {\n            loading = parseLoadingBlock(block, visitor);\n          }\n          break;\n\n        case 'error':\n          if (error !== null) {\n            errors.push(\n              new ParseError(block.startSourceSpan, `@defer block can only have one @error block`),\n            );\n          } else {\n            error = parseErrorBlock(block, visitor);\n          }\n          break;\n      }\n    } catch (e) {\n      errors.push(new ParseError(block.startSourceSpan, (e as Error).message));\n    }\n  }\n\n  return {placeholder, loading, error};\n}\n\nfunction parsePlaceholderBlock(ast: html.Block, visitor: html.Visitor): t.DeferredBlockPlaceholder {\n  let minimumTime: number | null = null;\n\n  for (const param of ast.parameters) {\n    if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@placeholder block can only have one \"minimum\" parameter`);\n      }\n\n      const parsedTime = parseDeferredTime(\n        param.expression.slice(getTriggerParametersStart(param.expression)),\n      );\n\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @placeholder block: \"${param.expression}\"`);\n    }\n  }\n\n  return new t.DeferredBlockPlaceholder(\n    html.visitAll(visitor, ast.children, ast.children),\n    minimumTime,\n    ast.nameSpan,\n    ast.sourceSpan,\n    ast.startSourceSpan,\n    ast.endSourceSpan,\n    ast.i18n,\n  );\n}\n\nfunction parseLoadingBlock(ast: html.Block, visitor: html.Visitor): t.DeferredBlockLoading {\n  let afterTime: number | null = null;\n  let minimumTime: number | null = null;\n\n  for (const param of ast.parameters) {\n    if (AFTER_PARAMETER_PATTERN.test(param.expression)) {\n      if (afterTime != null) {\n        throw new Error(`@loading block can only have one \"after\" parameter`);\n      }\n\n      const parsedTime = parseDeferredTime(\n        param.expression.slice(getTriggerParametersStart(param.expression)),\n      );\n\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"after\"`);\n      }\n\n      afterTime = parsedTime;\n    } else if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@loading block can only have one \"minimum\" parameter`);\n      }\n\n      const parsedTime = parseDeferredTime(\n        param.expression.slice(getTriggerParametersStart(param.expression)),\n      );\n\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @loading block: \"${param.expression}\"`);\n    }\n  }\n\n  return new t.DeferredBlockLoading(\n    html.visitAll(visitor, ast.children, ast.children),\n    afterTime,\n    minimumTime,\n    ast.nameSpan,\n    ast.sourceSpan,\n    ast.startSourceSpan,\n    ast.endSourceSpan,\n    ast.i18n,\n  );\n}\n\nfunction parseErrorBlock(ast: html.Block, visitor: html.Visitor): t.DeferredBlockError {\n  if (ast.parameters.length > 0) {\n    throw new Error(`@error block cannot have parameters`);\n  }\n\n  return new t.DeferredBlockError(\n    html.visitAll(visitor, ast.children, ast.children),\n    ast.nameSpan,\n    ast.sourceSpan,\n    ast.startSourceSpan,\n    ast.endSourceSpan,\n    ast.i18n,\n  );\n}\n\nfunction parsePrimaryTriggers(\n  ast: html.Block,\n  bindingParser: BindingParser,\n  errors: ParseError[],\n  placeholder: t.DeferredBlockPlaceholder | null,\n) {\n  const triggers: t.DeferredBlockTriggers = {};\n  const prefetchTriggers: t.DeferredBlockTriggers = {};\n  const hydrateTriggers: t.DeferredBlockTriggers = {};\n\n  for (const param of ast.parameters) {\n    // The lexer ignores the leading spaces so we can assume\n    // that the expression starts with a keyword.\n    if (WHEN_PARAMETER_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, triggers, errors);\n    } else if (ON_PARAMETER_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, triggers, errors, placeholder);\n    } else if (PREFETCH_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, prefetchTriggers, errors);\n    } else if (PREFETCH_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, prefetchTriggers, errors, placeholder);\n    } else if (HYDRATE_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, hydrateTriggers, errors);\n    } else if (HYDRATE_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, hydrateTriggers, errors, placeholder);\n    } else if (HYDRATE_NEVER_PATTERN.test(param.expression)) {\n      parseNeverTrigger(param, hydrateTriggers, errors);\n    } else {\n      errors.push(new ParseError(param.sourceSpan, 'Unrecognized trigger'));\n    }\n  }\n\n  if (hydrateTriggers.never && Object.keys(hydrateTriggers).length > 1) {\n    errors.push(\n      new ParseError(\n        ast.startSourceSpan,\n        'Cannot specify additional `hydrate` triggers if `hydrate never` is present',\n      ),\n    );\n  }\n\n  return {triggers, prefetchTriggers, hydrateTriggers};\n}\n"]}