{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {escapeIdentifier} from '../output/abstract_emitter';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers} from './r3_identifiers';\n\nexport function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n  if (numParams === 0) {\n    return o.expressionType(type);\n  }\n  const params: o.Type[] = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(o.DYNAMIC_TYPE);\n  }\n  return o.expressionType(type, undefined, params);\n}\n\nexport interface R3Reference {\n  value: o.Expression;\n  type: o.Expression;\n}\n\n/**\n * Result of compilation of a render3 code unit, e.g. component, directive, pipe, etc.\n */\nexport interface R3CompiledExpression {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nconst LEGACY_ANIMATE_SYMBOL_PREFIX = '@';\nexport function prepareSyntheticPropertyName(name: string) {\n  return `${LEGACY_ANIMATE_SYMBOL_PREFIX}${name}`;\n}\n\nexport function prepareSyntheticListenerName(name: string, phase: string) {\n  return `${LEGACY_ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\n\nexport function getSafePropertyAccessString(accessor: string, name: string): string {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\n\nexport function prepareSyntheticListenerFunctionName(name: string, phase: string) {\n  return `animation_${name}_${phase}`;\n}\n\nexport function jitOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngJitMode', expr);\n}\n\nexport function devOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngDevMode', expr);\n}\n\nexport function guardedExpression(guard: string, expr: o.Expression): o.Expression {\n  const guardExpr = new o.ExternalExpr({name: guard, moduleName: null});\n  const guardNotDefined = new o.BinaryOperatorExpr(\n    o.BinaryOperator.Identical,\n    new o.TypeofExpr(guardExpr),\n    o.literal('undefined'),\n  );\n  const guardUndefinedOrTrue = new o.BinaryOperatorExpr(\n    o.BinaryOperator.Or,\n    guardNotDefined,\n    guardExpr,\n    /* type */ undefined,\n    /* sourceSpan */ undefined,\n  );\n  return new o.BinaryOperatorExpr(o.BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\n\nexport function wrapReference(value: any): R3Reference {\n  const wrapped = new o.WrappedNodeExpr(value);\n  return {value: wrapped, type: wrapped};\n}\n\nexport function refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean): o.Expression {\n  const values = o.literalArr(refs.map((ref) => ref.value));\n  return shouldForwardDeclare ? o.arrowFn([], values) : values;\n}\n\n/**\n * Describes an expression that may have been wrapped in a `forwardRef()` guard.\n *\n * This is used when describing expressions that can refer to types that may eagerly reference types\n * that have not yet been defined.\n */\nexport interface MaybeForwardRefExpression<T extends o.Expression = o.Expression> {\n  /**\n   * The unwrapped expression.\n   */\n  expression: T;\n  /**\n   * Specified whether the `expression` contains a reference to something that has not yet been\n   * defined, and whether the expression is still wrapped in a `forwardRef()` call.\n   *\n   * If this value is `ForwardRefHandling.None` then the `expression` is safe to use as-is.\n   *\n   * Otherwise the `expression` was wrapped in a call to `forwardRef()` and must not be eagerly\n   * evaluated. Instead it must be wrapped in a function closure that will be evaluated lazily to\n   * allow the definition of the expression to be evaluated first.\n   *\n   * In full AOT compilation it can be safe to unwrap the `forwardRef()` call up front if the\n   * expression will actually be evaluated lazily inside a function call after the value of\n   * `expression` has been defined.\n   *\n   * But in other cases, such as partial AOT compilation or JIT compilation the expression will be\n   * evaluated eagerly in top level code so will need to continue to be wrapped in a `forwardRef()`\n   * call.\n   *\n   */\n  forwardRef: ForwardRefHandling;\n}\n\nexport function createMayBeForwardRefExpression<T extends o.Expression>(\n  expression: T,\n  forwardRef: ForwardRefHandling,\n): MaybeForwardRefExpression<T> {\n  return {expression, forwardRef};\n}\n\n/**\n * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n * `forwardRef()` call.\n *\n * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression\n * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated\n * in the code.\n *\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n */\nexport function convertFromMaybeForwardRefExpression({\n  expression,\n  forwardRef,\n}: MaybeForwardRefExpression): o.Expression {\n  switch (forwardRef) {\n    case ForwardRefHandling.None:\n    case ForwardRefHandling.Wrapped:\n      return expression;\n    case ForwardRefHandling.Unwrapped:\n      return generateForwardRef(expression);\n  }\n}\n\n/**\n * Generate an expression that has the given `expr` wrapped in the following form:\n *\n * ```ts\n * forwardRef(() => expr)\n * ```\n */\nexport function generateForwardRef(expr: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.forwardRef).callFn([o.arrowFn([], expr)]);\n}\n\n/**\n * Specifies how a forward ref has been handled in a MaybeForwardRefExpression\n */\nexport const enum ForwardRefHandling {\n  /** The expression was not wrapped in a `forwardRef()` call in the first place. */\n  None,\n  /** The expression is still wrapped in a `forwardRef()` call. */\n  Wrapped,\n  /** The expression was wrapped in a `forwardRef()` call but has since been unwrapped. */\n  Unwrapped,\n}\n"]}