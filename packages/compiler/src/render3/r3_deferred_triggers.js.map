{"version":3,"file":"r3_deferred_triggers.js","sourceRoot":"","sources":["r3_deferred_triggers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as chars from '../chars';\nimport {Lexer, Token, TokenType} from '../expression_parser/lexer';\nimport * as html from '../ml_parser/ast';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\nimport {BindingParser} from '../template_parser/binding_parser';\n\nimport * as t from './r3_ast';\n\n/** Pattern for a timing value in a trigger. */\nconst TIME_PATTERN = /^\\d+\\.?\\d*(ms|s)?$/;\n\n/** Pattern for a separator between keywords in a trigger expression. */\nconst SEPARATOR_PATTERN = /^\\s$/;\n\n/** Pairs of characters that form syntax that is comma-delimited. */\nconst COMMA_DELIMITED_SYNTAX = new Map([\n  [chars.$LBRACE, chars.$RBRACE], // Object literals\n  [chars.$LBRACKET, chars.$RBRACKET], // Array literals\n  [chars.$LPAREN, chars.$RPAREN], // Function calls\n]);\n\n/** Possible types of `on` triggers. */\nenum OnTriggerType {\n  IDLE = 'idle',\n  TIMER = 'timer',\n  INTERACTION = 'interaction',\n  IMMEDIATE = 'immediate',\n  HOVER = 'hover',\n  VIEWPORT = 'viewport',\n  NEVER = 'never',\n}\n\n/** Function that validates the structure of a reference-based trigger. */\ntype ReferenceTriggerValidator = (type: OnTriggerType, parameters: string[]) => void;\n\n/** Parses a `when` deferred trigger. */\nexport function parseNeverTrigger(\n  {expression, sourceSpan}: html.BlockParameter,\n  triggers: t.DeferredBlockTriggers,\n  errors: ParseError[],\n): void {\n  const neverIndex = expression.indexOf('never');\n  const neverSourceSpan = new ParseSourceSpan(\n    sourceSpan.start.moveBy(neverIndex),\n    sourceSpan.start.moveBy(neverIndex + 'never'.length),\n  );\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n\n  // This is here just to be safe, we shouldn't enter this function\n  // in the first place if a block doesn't have the \"on\" keyword.\n  if (neverIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"never\" keyword in expression`));\n  } else {\n    trackTrigger(\n      'never',\n      triggers,\n      errors,\n      new t.NeverDeferredTrigger(neverSourceSpan, sourceSpan, prefetchSpan, null, hydrateSpan),\n    );\n  }\n}\n\n/** Parses a `when` deferred trigger. */\nexport function parseWhenTrigger(\n  {expression, sourceSpan}: html.BlockParameter,\n  bindingParser: BindingParser,\n  triggers: t.DeferredBlockTriggers,\n  errors: ParseError[],\n): void {\n  const whenIndex = expression.indexOf('when');\n  const whenSourceSpan = new ParseSourceSpan(\n    sourceSpan.start.moveBy(whenIndex),\n    sourceSpan.start.moveBy(whenIndex + 'when'.length),\n  );\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n\n  // This is here just to be safe, we shouldn't enter this function\n  // in the first place if a block doesn't have the \"when\" keyword.\n  if (whenIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"when\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, whenIndex + 1);\n    const parsed = bindingParser.parseBinding(\n      expression.slice(start),\n      false,\n      sourceSpan,\n      sourceSpan.start.offset + start,\n    );\n    trackTrigger(\n      'when',\n      triggers,\n      errors,\n      new t.BoundDeferredTrigger(parsed, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan),\n    );\n  }\n}\n\n/** Parses an `on` trigger */\nexport function parseOnTrigger(\n  {expression, sourceSpan}: html.BlockParameter,\n  triggers: t.DeferredBlockTriggers,\n  errors: ParseError[],\n  placeholder: t.DeferredBlockPlaceholder | null,\n): void {\n  const onIndex = expression.indexOf('on');\n  const onSourceSpan = new ParseSourceSpan(\n    sourceSpan.start.moveBy(onIndex),\n    sourceSpan.start.moveBy(onIndex + 'on'.length),\n  );\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n\n  // This is here just to be safe, we shouldn't enter this function\n  // in the first place if a block doesn't have the \"on\" keyword.\n  if (onIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"on\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, onIndex + 1);\n    const parser = new OnTriggerParser(\n      expression,\n      start,\n      sourceSpan,\n      triggers,\n      errors,\n      expression.startsWith('hydrate')\n        ? validateHydrateReferenceBasedTrigger\n        : validatePlainReferenceBasedTrigger,\n      placeholder,\n      prefetchSpan,\n      onSourceSpan,\n      hydrateSpan,\n    );\n    parser.parse();\n  }\n}\n\nfunction getPrefetchSpan(expression: string, sourceSpan: ParseSourceSpan) {\n  if (!expression.startsWith('prefetch')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('prefetch'.length));\n}\n\nfunction getHydrateSpan(expression: string, sourceSpan: ParseSourceSpan) {\n  if (!expression.startsWith('hydrate')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('hydrate'.length));\n}\n\nclass OnTriggerParser {\n  private index = 0;\n  private tokens: Token[];\n\n  constructor(\n    private expression: string,\n    private start: number,\n    private span: ParseSourceSpan,\n    private triggers: t.DeferredBlockTriggers,\n    private errors: ParseError[],\n    private validator: ReferenceTriggerValidator,\n    private placeholder: t.DeferredBlockPlaceholder | null,\n    private prefetchSpan: ParseSourceSpan | null,\n    private onSourceSpan: ParseSourceSpan,\n    private hydrateSpan: ParseSourceSpan | null,\n  ) {\n    this.tokens = new Lexer().tokenize(expression.slice(start));\n  }\n\n  parse(): void {\n    while (this.tokens.length > 0 && this.index < this.tokens.length) {\n      const token = this.token();\n\n      if (!token.isIdentifier()) {\n        this.unexpectedToken(token);\n        break;\n      }\n\n      // An identifier immediately followed by a comma or the end of\n      // the expression cannot have parameters so we can exit early.\n      if (this.isFollowedByOrLast(chars.$COMMA)) {\n        this.consumeTrigger(token, []);\n        this.advance();\n      } else if (this.isFollowedByOrLast(chars.$LPAREN)) {\n        this.advance(); // Advance to the opening paren.\n        const prevErrors = this.errors.length;\n        const parameters = this.consumeParameters();\n        if (this.errors.length !== prevErrors) {\n          break;\n        }\n        this.consumeTrigger(token, parameters);\n        this.advance(); // Advance past the closing paren.\n      } else if (this.index < this.tokens.length - 1) {\n        this.unexpectedToken(this.tokens[this.index + 1]);\n      }\n\n      this.advance();\n    }\n  }\n\n  private advance() {\n    this.index++;\n  }\n\n  private isFollowedByOrLast(char: number): boolean {\n    if (this.index === this.tokens.length - 1) {\n      return true;\n    }\n\n    return this.tokens[this.index + 1].isCharacter(char);\n  }\n\n  private token(): Token {\n    return this.tokens[Math.min(this.index, this.tokens.length - 1)];\n  }\n\n  private consumeTrigger(identifier: Token, parameters: string[]) {\n    const triggerNameStartSpan = this.span.start.moveBy(\n      this.start + identifier.index - this.tokens[0].index,\n    );\n    const nameSpan = new ParseSourceSpan(\n      triggerNameStartSpan,\n      triggerNameStartSpan.moveBy(identifier.strValue.length),\n    );\n    const endSpan = triggerNameStartSpan.moveBy(this.token().end - identifier.index);\n\n    // Put the prefetch and on spans with the first trigger\n    // This should maybe be refactored to have something like an outer OnGroup AST\n    // Since triggers can be grouped with commas \"on hover(x), interaction(y)\"\n    const isFirstTrigger = identifier.index === 0;\n    const onSourceSpan = isFirstTrigger ? this.onSourceSpan : null;\n    const prefetchSourceSpan = isFirstTrigger ? this.prefetchSpan : null;\n    const hydrateSourceSpan = isFirstTrigger ? this.hydrateSpan : null;\n    const sourceSpan = new ParseSourceSpan(\n      isFirstTrigger ? this.span.start : triggerNameStartSpan,\n      endSpan,\n    );\n\n    try {\n      switch (identifier.toString()) {\n        case OnTriggerType.IDLE:\n          this.trackTrigger(\n            'idle',\n            createIdleTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              prefetchSourceSpan,\n              onSourceSpan,\n              hydrateSourceSpan,\n            ),\n          );\n          break;\n\n        case OnTriggerType.TIMER:\n          this.trackTrigger(\n            'timer',\n            createTimerTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n            ),\n          );\n          break;\n\n        case OnTriggerType.INTERACTION:\n          this.trackTrigger(\n            'interaction',\n            createInteractionTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n              this.validator,\n            ),\n          );\n          break;\n\n        case OnTriggerType.IMMEDIATE:\n          this.trackTrigger(\n            'immediate',\n            createImmediateTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n            ),\n          );\n          break;\n\n        case OnTriggerType.HOVER:\n          this.trackTrigger(\n            'hover',\n            createHoverTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n              this.placeholder,\n              this.validator,\n            ),\n          );\n          break;\n\n        case OnTriggerType.VIEWPORT:\n          this.trackTrigger(\n            'viewport',\n            createViewportTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n              this.validator,\n            ),\n          );\n          break;\n\n        default:\n          throw new Error(`Unrecognized trigger type \"${identifier}\"`);\n      }\n    } catch (e) {\n      this.error(identifier, (e as Error).message);\n    }\n  }\n\n  private consumeParameters(): string[] {\n    const parameters: string[] = [];\n\n    if (!this.token().isCharacter(chars.$LPAREN)) {\n      this.unexpectedToken(this.token());\n      return parameters;\n    }\n\n    this.advance();\n\n    const commaDelimStack: number[] = [];\n    let current = '';\n\n    while (this.index < this.tokens.length) {\n      const token = this.token();\n\n      // Stop parsing if we've hit the end character and we're outside of a comma-delimited syntax.\n      // Note that we don't need to account for strings here since the lexer already parsed them\n      // into string tokens.\n      if (token.isCharacter(chars.$RPAREN) && commaDelimStack.length === 0) {\n        if (current.length) {\n          parameters.push(current);\n        }\n        break;\n      }\n\n      // In the `on` microsyntax \"top-level\" commas (e.g. ones outside of an parameters) separate\n      // the different triggers (e.g. `on idle,timer(500)`). This is problematic, because the\n      // function-like syntax also implies that multiple parameters can be passed into the\n      // individual trigger (e.g. `on foo(a, b)`). To avoid tripping up the parser with commas that\n      // are part of other sorts of syntax (object literals, arrays), we treat anything inside\n      // a comma-delimited syntax block as plain text.\n      if (token.type === TokenType.Character && COMMA_DELIMITED_SYNTAX.has(token.numValue)) {\n        commaDelimStack.push(COMMA_DELIMITED_SYNTAX.get(token.numValue)!);\n      }\n\n      if (\n        commaDelimStack.length > 0 &&\n        token.isCharacter(commaDelimStack[commaDelimStack.length - 1])\n      ) {\n        commaDelimStack.pop();\n      }\n\n      // If we hit a comma outside of a comma-delimited syntax, it means\n      // that we're at the top level and we're starting a new parameter.\n      if (commaDelimStack.length === 0 && token.isCharacter(chars.$COMMA) && current.length > 0) {\n        parameters.push(current);\n        current = '';\n        this.advance();\n        continue;\n      }\n\n      // Otherwise treat the token as a plain text character in the current parameter.\n      current += this.tokenText();\n      this.advance();\n    }\n\n    if (!this.token().isCharacter(chars.$RPAREN) || commaDelimStack.length > 0) {\n      this.error(this.token(), 'Unexpected end of expression');\n    }\n\n    if (\n      this.index < this.tokens.length - 1 &&\n      !this.tokens[this.index + 1].isCharacter(chars.$COMMA)\n    ) {\n      this.unexpectedToken(this.tokens[this.index + 1]);\n    }\n\n    return parameters;\n  }\n\n  private tokenText(): string {\n    // Tokens have a toString already which we could use, but for string tokens it omits the quotes.\n    // Eventually we could expose this information on the token directly.\n    return this.expression.slice(this.start + this.token().index, this.start + this.token().end);\n  }\n\n  private trackTrigger(name: keyof t.DeferredBlockTriggers, trigger: t.DeferredTrigger): void {\n    trackTrigger(name, this.triggers, this.errors, trigger);\n  }\n\n  private error(token: Token, message: string): void {\n    const newStart = this.span.start.moveBy(this.start + token.index);\n    const newEnd = newStart.moveBy(token.end - token.index);\n    this.errors.push(new ParseError(new ParseSourceSpan(newStart, newEnd), message));\n  }\n\n  private unexpectedToken(token: Token) {\n    this.error(token, `Unexpected token \"${token}\"`);\n  }\n}\n\n/** Adds a trigger to a map of triggers. */\nfunction trackTrigger(\n  name: keyof t.DeferredBlockTriggers,\n  allTriggers: t.DeferredBlockTriggers,\n  errors: ParseError[],\n  trigger: t.DeferredTrigger,\n) {\n  if (allTriggers[name]) {\n    errors.push(new ParseError(trigger.sourceSpan, `Duplicate \"${name}\" trigger is not allowed`));\n  } else {\n    allTriggers[name] = trigger as any;\n  }\n}\n\nfunction createIdleTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n): t.IdleDeferredTrigger {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IDLE}\" trigger cannot have parameters`);\n  }\n\n  return new t.IdleDeferredTrigger(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\n\nfunction createTimerTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n) {\n  if (parameters.length !== 1) {\n    throw new Error(`\"${OnTriggerType.TIMER}\" trigger must have exactly one parameter`);\n  }\n\n  const delay = parseDeferredTime(parameters[0]);\n\n  if (delay === null) {\n    throw new Error(`Could not parse time value of trigger \"${OnTriggerType.TIMER}\"`);\n  }\n\n  return new t.TimerDeferredTrigger(\n    delay,\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\nfunction createImmediateTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n): t.ImmediateDeferredTrigger {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IMMEDIATE}\" trigger cannot have parameters`);\n  }\n\n  return new t.ImmediateDeferredTrigger(\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\nfunction createHoverTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n  placeholder: t.DeferredBlockPlaceholder | null,\n  validator: ReferenceTriggerValidator,\n): t.HoverDeferredTrigger {\n  validator(OnTriggerType.HOVER, parameters);\n  return new t.HoverDeferredTrigger(\n    parameters[0] ?? null,\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\nfunction createInteractionTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n  validator: ReferenceTriggerValidator,\n): t.InteractionDeferredTrigger {\n  validator(OnTriggerType.INTERACTION, parameters);\n  return new t.InteractionDeferredTrigger(\n    parameters[0] ?? null,\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\nfunction createViewportTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n  validator: ReferenceTriggerValidator,\n): t.ViewportDeferredTrigger {\n  validator(OnTriggerType.VIEWPORT, parameters);\n  return new t.ViewportDeferredTrigger(\n    parameters[0] ?? null,\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\n/**\n * Checks whether the structure of a non-hydrate reference-based trigger is valid.\n * @param type Type of the trigger being validated.\n * @param parameters Parameters of the trigger.\n */\nfunction validatePlainReferenceBasedTrigger(type: OnTriggerType, parameters: string[]) {\n  if (parameters.length > 1) {\n    throw new Error(`\"${type}\" trigger can only have zero or one parameters`);\n  }\n}\n\n/**\n * Checks whether the structure of a hydrate trigger is valid.\n * @param type Type of the trigger being validated.\n * @param parameters Parameters of the trigger.\n */\nfunction validateHydrateReferenceBasedTrigger(type: OnTriggerType, parameters: string[]) {\n  if (parameters.length > 0) {\n    throw new Error(`Hydration trigger \"${type}\" cannot have parameters`);\n  }\n}\n\n/** Gets the index within an expression at which the trigger parameters start. */\nexport function getTriggerParametersStart(value: string, startPosition = 0): number {\n  let hasFoundSeparator = false;\n\n  for (let i = startPosition; i < value.length; i++) {\n    if (SEPARATOR_PATTERN.test(value[i])) {\n      hasFoundSeparator = true;\n    } else if (hasFoundSeparator) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Parses a time expression from a deferred trigger to\n * milliseconds. Returns null if it cannot be parsed.\n */\nexport function parseDeferredTime(value: string): number | null {\n  const match = value.match(TIME_PATTERN);\n\n  if (!match) {\n    return null;\n  }\n\n  const [time, units] = match;\n  return parseFloat(time) * (units === 's' ? 1000 : 1);\n}\n"]}