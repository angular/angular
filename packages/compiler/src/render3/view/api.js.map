{"version":3,"file":"api.js","sourceRoot":"","sources":["api.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AA6UH,MAAM,CAAN,IAAY,wBAIX;AAJD,WAAY,wBAAwB;IAClC,iFAAa,CAAA;IACb,uEAAQ,CAAA;IACR,+EAAY,CAAA;AACd,CAAC,EAJW,wBAAwB,KAAxB,wBAAwB,QAInC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ChangeDetectionStrategy, ViewEncapsulation} from '../../core';\nimport {InterpolationConfig} from '../../ml_parser/defaults';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {R3DependencyMetadata} from '../r3_factory';\nimport {MaybeForwardRefExpression, R3Reference} from '../util';\n\n/**\n * Information needed to compile a directive for the render3 runtime.\n */\nexport interface R3DirectiveMetadata {\n  /**\n   * Name of the directive type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the directive itself.\n   */\n  type: R3Reference;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * A source span for the directive type.\n   */\n  typeSourceSpan: ParseSourceSpan;\n\n  /**\n   * Dependencies of the directive's constructor.\n   */\n  deps: R3DependencyMetadata[] | 'invalid' | null;\n\n  /**\n   * Unparsed selector of the directive, or `null` if there was no selector.\n   */\n  selector: string | null;\n\n  /**\n   * Information about the content queries made by the directive.\n   */\n  queries: R3QueryMetadata[];\n\n  /**\n   * Information about the view queries made by the directive.\n   */\n  viewQueries: R3QueryMetadata[];\n\n  /**\n   * Mappings indicating how the directive interacts with its host element (host bindings,\n   * listeners, etc).\n   */\n  host: R3HostMetadata;\n\n  /**\n   * Information about usage of specific lifecycle events which require special treatment in the\n   * code generator.\n   */\n  lifecycle: {\n    /**\n     * Whether the directive uses NgOnChanges.\n     */\n    usesOnChanges: boolean;\n  };\n\n  /**\n   * A mapping of inputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  inputs: {[field: string]: R3InputMetadata};\n\n  /**\n   * A mapping of outputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  outputs: {[field: string]: string};\n\n  /**\n   * Whether or not the component or directive inherits from another class\n   */\n  usesInheritance: boolean;\n\n  /**\n   * Whether or not the component or directive inherits its entire decorator from its base class.\n   */\n  fullInheritance: boolean;\n\n  /**\n   * Reference name under which to export the directive's type in a template,\n   * if any.\n   */\n  exportAs: string[] | null;\n\n  /**\n   * The list of providers defined in the directive.\n   */\n  providers: o.Expression | null;\n\n  /**\n   * Whether or not the component or directive is standalone.\n   */\n  isStandalone: boolean;\n\n  /**\n   * Whether or not the component or directive is signal-based.\n   */\n  isSignal: boolean;\n\n  /**\n   * Additional directives applied to the directive host.\n   */\n  hostDirectives: R3HostDirectiveMetadata[] | null;\n}\n\n/**\n * Defines how dynamic imports for deferred dependencies should be emitted in the\n * generated output:\n *  - either in a function on per-component basis (in case of local compilation)\n *  - or in a function on per-block basis (in full compilation mode)\n */\nexport const enum DeferBlockDepsEmitMode {\n  /**\n   * Dynamic imports are grouped on per-block basis.\n   *\n   * This is used in full compilation mode, when compiler has more information\n   * about particular dependencies that belong to this block.\n   */\n  PerBlock,\n\n  /**\n   * Dynamic imports are grouped on per-component basis.\n   *\n   * In local compilation, compiler doesn't have enough information to determine\n   * which deferred dependencies belong to which block. In this case we group all\n   * dynamic imports into a single file on per-component basis.\n   */\n  PerComponent,\n}\n\n/**\n * Specifies how a list of declaration type references should be emitted into the generated code.\n */\nexport const enum DeclarationListEmitMode {\n  /**\n   * The list of declarations is emitted into the generated code as is.\n   *\n   * ```ts\n   * directives: [MyDir],\n   * ```\n   */\n  Direct,\n\n  /**\n   * The list of declarations is emitted into the generated code wrapped inside a closure, which\n   * is needed when at least one declaration is a forward reference.\n   *\n   * ```ts\n   * directives: function () { return [MyDir, ForwardDir]; },\n   * ```\n   */\n  Closure,\n\n  /**\n   * Similar to `Closure`, with the addition that the list of declarations can contain individual\n   * items that are themselves forward references. This is relevant for JIT compilations, as\n   * unwrapping the forwardRef cannot be done statically so must be deferred. This mode emits\n   * the declaration list using a mapping transform through `resolveForwardRef` to ensure that\n   * any forward references within the list are resolved when the outer closure is invoked.\n   *\n   * Consider the case where the runtime has captured two declarations in two distinct values:\n   * ```ts\n   * const dirA = MyDir;\n   * const dirB = forwardRef(function() { return ForwardRef; });\n   * ```\n   *\n   * This mode would emit the declarations captured in `dirA` and `dirB` as follows:\n   * ```ts\n   * directives: function () { return [dirA, dirB].map(ng.resolveForwardRef); },\n   * ```\n   */\n  ClosureResolved,\n\n  RuntimeResolved,\n}\n\n/**\n * Information needed to compile a component for the render3 runtime.\n */\nexport interface R3ComponentMetadata<DeclarationT extends R3TemplateDependency>\n  extends R3DirectiveMetadata {\n  /**\n   * Information about the component's template.\n   */\n  template: {\n    /**\n     * Parsed nodes of the template.\n     */\n    nodes: t.Node[];\n\n    /**\n     * Any ng-content selectors extracted from the template. Contains `*` when an ng-content\n     * element without selector is present.\n     */\n    ngContentSelectors: string[];\n\n    /**\n     * Whether the template preserves whitespaces from the user's code.\n     */\n    preserveWhitespaces?: boolean;\n  };\n\n  declarations: DeclarationT[];\n\n  /** Metadata related to the deferred blocks in the component's template. */\n  defer: R3ComponentDeferMetadata;\n\n  /**\n   * Specifies how the 'directives' and/or `pipes` array, if generated, need to be emitted.\n   */\n  declarationListEmitMode: DeclarationListEmitMode;\n\n  /**\n   * A collection of styling data that will be applied and scoped to the component.\n   */\n  styles: string[];\n\n  /**\n   * A collection of style paths for external stylesheets that will be applied and scoped to the component.\n   */\n  externalStyles?: string[];\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Possible values:\n   * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n   *                                 a native Shadow DOM CSS encapsulation behavior.\n   * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n   * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n   */\n  encapsulation: ViewEncapsulation;\n\n  /**\n   * A collection of animation triggers that will be used in the component template.\n   */\n  animations: o.Expression | null;\n\n  /**\n   * The list of view providers defined in the component.\n   */\n  viewProviders: o.Expression | null;\n\n  /**\n   * Path to the .ts file in which this template's generated code will be included, relative to\n   * the compilation root. This will be used to generate identifiers that need to be globally\n   * unique in certain contexts (such as g3).\n   */\n  relativeContextFilePath: string;\n\n  /**\n   * Whether translation variable name should contain external message id\n   * (used by Closure Compiler's output of `goog.getMsg` for transition period).\n   */\n  i18nUseExternalIds: boolean;\n\n  /**\n   * Overrides the default interpolation start and end delimiters ({{ and }}).\n   */\n  interpolation: InterpolationConfig;\n\n  /**\n   * Strategy used for detecting changes in the component.\n   *\n   * In global compilation mode the value is ChangeDetectionStrategy if available as it is\n   * statically resolved during analysis phase. Whereas in local compilation mode the value is the\n   * expression as appears in the decorator.\n   */\n  changeDetection: ChangeDetectionStrategy | o.Expression | null;\n\n  /**\n   * Relative path to the component's template from the root of the project.\n   * Used to generate debugging information.\n   */\n  relativeTemplatePath: string | null;\n\n  /**\n   * Whether any of the component's dependencies are directives.\n   */\n  hasDirectiveDependencies: boolean;\n\n  /**\n   * The imports expression as appears on the component decorate for standalone component. This\n   * field is currently needed only for local compilation, and so in other compilation modes it may\n   * not be set. If component has empty array imports then this field is not set.\n   */\n  rawImports?: o.Expression;\n}\n\n/**\n * Information about the deferred blocks in a component's template.\n */\nexport type R3ComponentDeferMetadata =\n  | {\n      mode: DeferBlockDepsEmitMode.PerBlock;\n      blocks: Map<t.DeferredBlock, o.Expression | null>;\n    }\n  | {\n      mode: DeferBlockDepsEmitMode.PerComponent;\n      dependenciesFn: o.Expression | null;\n    };\n\n/**\n * Metadata for an individual input on a directive.\n */\nexport interface R3InputMetadata {\n  classPropertyName: string;\n  bindingPropertyName: string;\n  required: boolean;\n  isSignal: boolean;\n  /**\n   * Transform function for the input.\n   *\n   * Null if there is no transform, or if this is a signal input.\n   * Signal inputs capture their transform as part of the `InputSignal`.\n   */\n  transformFunction: o.Expression | null;\n}\n\nexport enum R3TemplateDependencyKind {\n  Directive = 0,\n  Pipe = 1,\n  NgModule = 2,\n}\n\n/**\n * A dependency that's used within a component template.\n */\nexport interface R3TemplateDependency {\n  kind: R3TemplateDependencyKind;\n\n  /**\n   * The type of the dependency as an expression.\n   */\n  type: o.Expression;\n}\n\n/**\n * A dependency that's used within a component template\n */\nexport type R3TemplateDependencyMetadata =\n  | R3DirectiveDependencyMetadata\n  | R3PipeDependencyMetadata\n  | R3NgModuleDependencyMetadata;\n\n/**\n * Information about a directive that is used in a component template. Only the stable, public\n * facing information of the directive is stored here.\n */\nexport interface R3DirectiveDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Directive;\n\n  /**\n   * The selector of the directive.\n   */\n  selector: string;\n\n  /**\n   * The binding property names of the inputs of the directive.\n   */\n  inputs: string[];\n\n  /**\n   * The binding property names of the outputs of the directive.\n   */\n  outputs: string[];\n\n  /**\n   * Name under which the directive is exported, if any (exportAs in Angular). Null otherwise.\n   */\n  exportAs: string[] | null;\n\n  /**\n   * If true then this directive is actually a component; otherwise it is not.\n   */\n  isComponent: boolean;\n}\n\nexport interface R3PipeDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Pipe;\n\n  name: string;\n}\n\nexport interface R3NgModuleDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.NgModule;\n}\n\n/**\n * Information needed to compile a query (view or content).\n */\nexport interface R3QueryMetadata {\n  /**\n   * Name of the property on the class to update with query results.\n   */\n  propertyName: string;\n\n  /**\n   * Whether to read only the first matching result, or an array of results.\n   */\n  first: boolean;\n\n  /**\n   * Either an expression representing a type or `InjectionToken` for the query\n   * predicate, or a set of string selectors.\n   *\n   * Note: At compile time we split selectors as an optimization that avoids this\n   * extra work at runtime creation phase.\n   *\n   * Notably, if the selector is not statically analyzable due to an expression,\n   * the selectors may need to be split up at runtime.\n   */\n  predicate: MaybeForwardRefExpression | string[];\n\n  /**\n   * Whether to include only direct children or all descendants.\n   */\n  descendants: boolean;\n\n  /**\n   * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n   * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n   * query resulted in the same list.)\n   */\n  emitDistinctChangesOnly: boolean;\n\n  /**\n   * An expression representing a type to read from each matched node, or null if the default value\n   * for a given node is to be returned.\n   */\n  read: o.Expression | null;\n\n  /**\n   * Whether or not this query should collect only static results.\n   *\n   * If static is true, the query's results will be set on the component after nodes are created,\n   * but before change detection runs. This means that any results that relied upon change detection\n   * to run (e.g. results inside *ngIf or *ngFor views) will not be collected. Query results are\n   * available in the ngOnInit hook.\n   *\n   * If static is false, the query's results will be set on the component after change detection\n   * runs. This means that the query results can contain nodes inside *ngIf or *ngFor views, but\n   * the results will not be available in the ngOnInit hook (only in the ngAfterContentInit for\n   * content hooks and ngAfterViewInit for view hooks).\n   *\n   * Note: For signal-based queries, this option does not have any effect.\n   */\n  static: boolean;\n\n  /** Whether the query is signal-based. */\n  isSignal: boolean;\n}\n\n/**\n * Mappings indicating how the class interacts with its\n * host element (host bindings, listeners, etc).\n */\nexport interface R3HostMetadata {\n  /**\n   * A mapping of attribute binding keys to `o.Expression`s.\n   */\n  attributes: {[key: string]: o.Expression};\n\n  /**\n   * A mapping of event binding keys to unparsed expressions.\n   */\n  listeners: {[key: string]: string};\n\n  /**\n   * A mapping of property binding keys to unparsed expressions.\n   */\n  properties: {[key: string]: string};\n\n  specialAttributes: {styleAttr?: string; classAttr?: string};\n}\n\n/**\n * Information needed to compile a host directive for the render3 runtime.\n */\nexport interface R3HostDirectiveMetadata {\n  /** An expression representing the host directive class itself. */\n  directive: R3Reference;\n\n  /** Whether the expression referring to the host directive is a forward reference. */\n  isForwardReference: boolean;\n\n  /** Inputs from the host directive that will be exposed on the host. */\n  inputs: {[publicName: string]: string} | null;\n\n  /** Outputs from the host directive that will be exposed on the host. */\n  outputs: {[publicName: string]: string} | null;\n}\n\n/**\n * Information needed to compile the defer block resolver function.\n */\nexport type R3DeferResolverFunctionMetadata =\n  | {\n      mode: DeferBlockDepsEmitMode.PerBlock;\n      dependencies: R3DeferPerBlockDependency[];\n    }\n  | {\n      mode: DeferBlockDepsEmitMode.PerComponent;\n      dependencies: R3DeferPerComponentDependency[];\n    };\n\n/**\n * Information about a single dependency of a defer block in `PerBlock` mode.\n */\nexport interface R3DeferPerBlockDependency {\n  /**\n   * Reference to a dependency.\n   */\n  typeReference: o.Expression;\n\n  /**\n   * Dependency class name.\n   */\n  symbolName: string;\n\n  /**\n   * Whether this dependency can be defer-loaded.\n   */\n  isDeferrable: boolean;\n\n  /**\n   * Import path where this dependency is located.\n   */\n  importPath: string | null;\n\n  /**\n   * Whether the symbol is the default export.\n   */\n  isDefaultImport: boolean;\n}\n\n/**\n * Information about a single dependency of a defer block in `PerComponent` mode.\n */\nexport interface R3DeferPerComponentDependency {\n  /**\n   * Dependency class name.\n   */\n  symbolName: string;\n\n  /**\n   * Import path where this dependency is located.\n   */\n  importPath: string;\n\n  /**\n   * Whether the symbol is the default export.\n   */\n  isDefaultImport: boolean;\n}\n"]}