{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InputFlags} from '../../core';\nimport {BindingType} from '../../expression_parser/ast';\nimport {splitNsName} from '../../ml_parser/tags';\nimport * as o from '../../output/output_ast';\nimport {CssSelector} from '../../directive_matching';\nimport * as t from '../r3_ast';\n\nimport {isI18nAttribute} from './i18n/util';\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * not work in some cases when object keys are mangled by a minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nexport const UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n\n/** Name of the temporary to use during data binding */\nexport const TEMPORARY_NAME = '_t';\n\n/** Name of the context parameter passed into a template function */\nexport const CONTEXT_NAME = 'ctx';\n\n/** Name of the RenderFlag passed into a template function */\nexport const RENDER_FLAGS = 'rf';\n\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nexport function temporaryAllocator(\n  pushStatement: (st: o.Statement) => void,\n  name: string,\n): () => o.ReadVarExpr {\n  let temp: o.ReadVarExpr | null = null;\n  return () => {\n    if (!temp) {\n      pushStatement(new o.DeclareVarStmt(TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n      temp = o.variable(name);\n    }\n    return temp;\n  };\n}\n\nexport function invalid<T>(this: t.Visitor, arg: o.Expression | o.Statement | t.Node): never {\n  throw new Error(\n    `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`,\n  );\n}\n\nexport function asLiteral(value: any): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(asLiteral));\n  }\n  return o.literal(value, o.INFERRED_TYPE);\n}\n\n/**\n * Serializes inputs and outputs for `defineDirective` and `defineComponent`.\n *\n * This will attempt to generate optimized data structures to minimize memory or\n * file size of fully compiled applications.\n */\nexport function conditionallyCreateDirectiveBindingLiteral(\n  map: Record<\n    string,\n    | string\n    | {\n        classPropertyName: string;\n        bindingPropertyName: string;\n        transformFunction: o.Expression | null;\n        isSignal: boolean;\n      }\n  >,\n  forInputs?: boolean,\n): o.Expression | null {\n  const keys = Object.getOwnPropertyNames(map);\n\n  if (keys.length === 0) {\n    return null;\n  }\n\n  return o.literalMap(\n    keys.map((key) => {\n      const value = map[key];\n      let declaredName: string;\n      let publicName: string;\n      let minifiedName: string;\n      let expressionValue: o.Expression;\n\n      if (typeof value === 'string') {\n        // canonical syntax: `dirProp: publicProp`\n        declaredName = key;\n        minifiedName = key;\n        publicName = value;\n        expressionValue = asLiteral(publicName);\n      } else {\n        minifiedName = key;\n        declaredName = value.classPropertyName;\n        publicName = value.bindingPropertyName;\n\n        const differentDeclaringName = publicName !== declaredName;\n        const hasDecoratorInputTransform = value.transformFunction !== null;\n        let flags = InputFlags.None;\n\n        // Build up input flags\n        if (value.isSignal) {\n          flags |= InputFlags.SignalBased;\n        }\n        if (hasDecoratorInputTransform) {\n          flags |= InputFlags.HasDecoratorInputTransform;\n        }\n\n        // Inputs, compared to outputs, will track their declared name (for `ngOnChanges`), support\n        // decorator input transform functions, or store flag information if there is any.\n        if (\n          forInputs &&\n          (differentDeclaringName || hasDecoratorInputTransform || flags !== InputFlags.None)\n        ) {\n          const result = [o.literal(flags), asLiteral(publicName)];\n\n          if (differentDeclaringName || hasDecoratorInputTransform) {\n            result.push(asLiteral(declaredName));\n\n            if (hasDecoratorInputTransform) {\n              result.push(value.transformFunction!);\n            }\n          }\n\n          expressionValue = o.literalArr(result);\n        } else {\n          expressionValue = asLiteral(publicName);\n        }\n      }\n\n      return {\n        key: minifiedName,\n        // put quotes around keys that contain potentially unsafe characters\n        quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n        value: expressionValue,\n      };\n    }),\n  );\n}\n\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nexport class DefinitionMap<T = any> {\n  values: {key: string; quoted: boolean; value: o.Expression}[] = [];\n\n  set(key: keyof T, value: o.Expression | null): void {\n    if (value) {\n      const existing = this.values.find((value) => value.key === key);\n\n      if (existing) {\n        existing.value = value;\n      } else {\n        this.values.push({key: key as string, value, quoted: false});\n      }\n    }\n  }\n\n  toLiteralMap(): o.LiteralMapExpr {\n    return o.literalMap(this.values);\n  }\n}\n\n/**\n * Creates a `CssSelector` from an AST node.\n */\nexport function createCssSelectorFromNode(node: t.Element | t.Template): CssSelector {\n  const elementName = node instanceof t.Element ? node.name : 'ng-template';\n  const attributes = getAttrsForDirectiveMatching(node);\n  const cssSelector = new CssSelector();\n  const elementNameNoNs = splitNsName(elementName)[1];\n\n  cssSelector.setElement(elementNameNoNs);\n\n  Object.getOwnPropertyNames(attributes).forEach((name) => {\n    const nameNoNs = splitNsName(name)[1];\n    const value = attributes[name];\n\n    cssSelector.addAttribute(nameNoNs, value);\n    if (name.toLowerCase() === 'class') {\n      const classes = value.trim().split(/\\s+/);\n      classes.forEach((className) => cssSelector.addClassName(className));\n    }\n  });\n\n  return cssSelector;\n}\n\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nfunction getAttrsForDirectiveMatching(elOrTpl: t.Element | t.Template): {[name: string]: string} {\n  const attributesMap: {[name: string]: string} = {};\n\n  if (elOrTpl instanceof t.Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach((a) => (attributesMap[a.name] = ''));\n  } else {\n    elOrTpl.attributes.forEach((a) => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n\n    elOrTpl.inputs.forEach((i) => {\n      if (i.type === BindingType.Property || i.type === BindingType.TwoWay) {\n        attributesMap[i.name] = '';\n      }\n    });\n    elOrTpl.outputs.forEach((o) => {\n      attributesMap[o.name] = '';\n    });\n  }\n\n  return attributesMap;\n}\n"]}