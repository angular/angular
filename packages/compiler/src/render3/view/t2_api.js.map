{"version":3,"file":"t2_api.js","sourceRoot":"","sources":["t2_api.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AST} from '../../expression_parser/ast';\nimport {\n  BoundAttribute,\n  BoundEvent,\n  Component,\n  Content,\n  DeferredBlock,\n  DeferredBlockError,\n  DeferredBlockLoading,\n  DeferredBlockPlaceholder,\n  DeferredTrigger,\n  Directive,\n  Element,\n  ForLoopBlock,\n  ForLoopBlockEmpty,\n  HostElement,\n  IfBlockBranch,\n  LetDeclaration,\n  Node,\n  Reference,\n  SwitchBlockCase,\n  Template,\n  TextAttribute,\n  Variable,\n} from '../r3_ast';\n\n/** Node that has a `Scope` associated with it. */\nexport type ScopedNode =\n  | Template\n  | SwitchBlockCase\n  | IfBlockBranch\n  | ForLoopBlock\n  | ForLoopBlockEmpty\n  | DeferredBlock\n  | DeferredBlockError\n  | DeferredBlockLoading\n  | DeferredBlockPlaceholder\n  | Content\n  | HostElement;\n\n/** Possible values that a reference can be resolved to. */\nexport type ReferenceTarget<DirectiveT> =\n  | {directive: DirectiveT; node: Exclude<DirectiveOwner, HostElement>}\n  | Element\n  | Template;\n\n/** Entity that is local to the template and defined within the template. */\nexport type TemplateEntity = Reference | Variable | LetDeclaration;\n\n/** Nodes that can have directives applied to them. */\nexport type DirectiveOwner = Element | Template | Component | Directive | HostElement;\n\n/*\n * t2 is the replacement for the `TemplateDefinitionBuilder`. It handles the operations of\n * analyzing Angular templates, extracting semantic info, and ultimately producing a template\n * definition function which renders the template using Ivy instructions.\n *\n * t2 data is also utilized by the template type-checking facilities to understand a template enough\n * to generate type-checking code for it.\n */\n\n/**\n * A logical target for analysis, which could contain a template or other types of bindings.\n */\nexport interface Target<DirectiveT> {\n  template?: Node[];\n  host?: {\n    node: HostElement;\n    directives: DirectiveT[];\n  };\n}\n\n/**\n * A data structure which can indicate whether a given property name is present or not.\n *\n * This is used to represent the set of inputs or outputs present on a directive, and allows the\n * binder to query for the presence of a mapping for property names.\n */\nexport interface InputOutputPropertySet {\n  hasBindingPropertyName(propertyName: string): boolean;\n}\n\n/**\n * A data structure which captures the animation trigger names that are statically resolvable\n * and whether some names could not be statically evaluated.\n */\nexport interface LegacyAnimationTriggerNames {\n  includesDynamicAnimations: boolean;\n  staticTriggerNames: string[];\n}\n\n/**\n * Metadata regarding a directive that's needed to match it against template elements. This is\n * provided by a consumer of the t2 APIs.\n */\nexport interface DirectiveMeta {\n  /**\n   * Name of the directive class (used for debugging).\n   */\n  name: string;\n\n  /** The selector for the directive or `null` if there isn't one. */\n  selector: string | null;\n\n  /**\n   * Whether the directive is a component.\n   */\n  isComponent: boolean;\n\n  /**\n   * Set of inputs which this directive claims.\n   *\n   * Goes from property names to field names.\n   */\n  inputs: InputOutputPropertySet;\n\n  /**\n   * Set of outputs which this directive claims.\n   *\n   * Goes from property names to field names.\n   */\n  outputs: InputOutputPropertySet;\n\n  /**\n   * Name under which the directive is exported, if any (exportAs in Angular).\n   *\n   * Null otherwise\n   */\n  exportAs: string[] | null;\n\n  /**\n   * Whether the directive is a structural directive (e.g. `<div *ngIf></div>`).\n   */\n  isStructural: boolean;\n\n  /**\n   * If the directive is a component, includes the selectors of its `ng-content` elements.\n   */\n  ngContentSelectors: string[] | null;\n\n  /**\n   * Whether the template of the component preserves whitespaces.\n   */\n  preserveWhitespaces: boolean;\n\n  /**\n   * The name of legacy animations that the user defines in the component.\n   * Only includes the legacy animation names.\n   */\n  animationTriggerNames: LegacyAnimationTriggerNames | null;\n}\n\n/**\n * Interface to the binding API, which processes a template and returns an object similar to the\n * `ts.TypeChecker`.\n *\n * The returned `BoundTarget` has an API for extracting information about the processed target.\n */\nexport interface TargetBinder<D extends DirectiveMeta> {\n  bind(target: Target<D>): BoundTarget<D>;\n}\n\n/**\n * Result of performing the binding operation against a `Target`.\n *\n * The original `Target` is accessible, as well as a suite of methods for extracting binding\n * information regarding the `Target`.\n *\n * @param DirectiveT directive metadata type\n */\nexport interface BoundTarget<DirectiveT extends DirectiveMeta> {\n  /**\n   * Get the original `Target` that was bound.\n   */\n  readonly target: Target<DirectiveT>;\n\n  /**\n   * For a given template node (either an `Element` or a `Template`), get the set of directives\n   * which matched the node, if any.\n   */\n  getDirectivesOfNode(node: DirectiveOwner): DirectiveT[] | null;\n\n  /**\n   * For a given `Reference`, get the reference's target - either an `Element`, a `Template`, or\n   * a directive on a particular node.\n   */\n  getReferenceTarget(ref: Reference): ReferenceTarget<DirectiveT> | null;\n\n  /**\n   * For a given binding, get the entity to which the binding is being made.\n   *\n   * This will either be a directive or the node itself.\n   */\n  getConsumerOfBinding(\n    binding: BoundAttribute | BoundEvent | TextAttribute,\n  ): DirectiveT | Element | Template | null;\n\n  /**\n   * If the given `AST` expression refers to a `Reference` or `Variable` within the `Target`, then\n   * return that.\n   *\n   * Otherwise, returns `null`.\n   *\n   * This is only defined for `AST` expressions that read or write to a property of an\n   * `ImplicitReceiver`.\n   */\n  getExpressionTarget(expr: AST): TemplateEntity | null;\n\n  /**\n   * Given a particular `Reference` or `Variable`, get the `ScopedNode` which created it.\n   *\n   * All `Variable`s are defined on node, so this will always return a value for a `Variable`\n   * from the `Target`. Returns `null` otherwise.\n   */\n  getDefinitionNodeOfSymbol(symbol: TemplateEntity): ScopedNode | null;\n\n  /**\n   * Get the nesting level of a particular `ScopedNode`.\n   *\n   * This starts at 1 for top-level nodes within the `Target` and increases for nodes\n   * nested at deeper levels.\n   */\n  getNestingLevel(node: ScopedNode): number;\n\n  /**\n   * Get all `Reference`s and `Variables` visible within the given `ScopedNode` (or at the top\n   * level, if `null` is passed).\n   */\n  getEntitiesInScope(node: ScopedNode | null): ReadonlySet<TemplateEntity>;\n\n  /**\n   * Get a list of all the directives used by the target,\n   * including directives from `@defer` blocks.\n   */\n  getUsedDirectives(): DirectiveT[];\n\n  /**\n   * Get a list of eagerly used directives from the target.\n   * Note: this list *excludes* directives from `@defer` blocks.\n   */\n  getEagerlyUsedDirectives(): DirectiveT[];\n\n  /**\n   * Get a list of all the pipes used by the target,\n   * including pipes from `@defer` blocks.\n   */\n  getUsedPipes(): string[];\n\n  /**\n   * Get a list of eagerly used pipes from the target.\n   * Note: this list *excludes* pipes from `@defer` blocks.\n   */\n  getEagerlyUsedPipes(): string[];\n\n  /**\n   * Get a list of all `@defer` blocks used by the target.\n   */\n  getDeferBlocks(): DeferredBlock[];\n\n  /**\n   * Gets the element that a specific deferred block trigger is targeting.\n   * @param block Block that the trigger belongs to.\n   * @param trigger Trigger whose target is being looked up.\n   */\n  getDeferredTriggerTarget(block: DeferredBlock, trigger: DeferredTrigger): Element | null;\n\n  /**\n   * Whether a given node is located in a `@defer` block.\n   */\n  isDeferred(node: Element): boolean;\n\n  /**\n   * Checks whether a component/directive that was referenced directly in the template exists.\n   * @param name Name of the component/directive.\n   */\n  referencedDirectiveExists(name: string): boolean;\n}\n"]}