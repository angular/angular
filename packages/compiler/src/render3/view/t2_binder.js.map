{"version":3,"file":"t2_binder.js","sourceRoot":"","sources":["t2_binder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AST,\n  BindingPipe,\n  ImplicitReceiver,\n  PropertyRead,\n  SafePropertyRead,\n  ThisReceiver,\n} from '../../expression_parser/ast';\nimport {CssSelector, SelectorlessMatcher, SelectorMatcher} from '../../directive_matching';\nimport {\n  BoundAttribute,\n  BoundEvent,\n  BoundText,\n  Comment,\n  Component,\n  Content,\n  DeferredBlock,\n  DeferredBlockError,\n  DeferredBlockLoading,\n  DeferredBlockPlaceholder,\n  DeferredTrigger,\n  Directive,\n  Element,\n  ForLoopBlock,\n  ForLoopBlockEmpty,\n  HostElement,\n  HoverDeferredTrigger,\n  Icu,\n  IfBlock,\n  IfBlockBranch,\n  InteractionDeferredTrigger,\n  LetDeclaration,\n  Node,\n  Reference,\n  SwitchBlock,\n  SwitchBlockCase,\n  Template,\n  Text,\n  TextAttribute,\n  UnknownBlock,\n  Variable,\n  ViewportDeferredTrigger,\n  Visitor,\n} from '../r3_ast';\n\nimport {\n  BoundTarget,\n  DirectiveMeta,\n  DirectiveOwner,\n  ReferenceTarget,\n  ScopedNode,\n  Target,\n  TargetBinder,\n  TemplateEntity,\n} from './t2_api';\nimport {parseTemplate} from './template';\nimport {createCssSelectorFromNode} from './util';\nimport {CombinedRecursiveAstVisitor} from '../../combined_visitor';\n\n/**\n * Computes a difference between full list (first argument) and\n * list of items that should be excluded from the full list (second\n * argument).\n */\nfunction diff(fullList: string[], itemsToExclude: string[]): string[] {\n  const exclude = new Set(itemsToExclude);\n  return fullList.filter((item) => !exclude.has(item));\n}\n\n/** Shorthand for a map between a binding AST node and the entity it's targeting. */\ntype BindingsMap<DirectiveT> = Map<\n  BoundAttribute | BoundEvent | TextAttribute,\n  DirectiveT | Template | Element\n>;\n\n/** Shorthand for a map between a reference AST node and the entity it's targeting. */\ntype ReferenceMap<DirectiveT> = Map<\n  Reference,\n  Template | Element | {directive: DirectiveT; node: Exclude<DirectiveOwner, HostElement>}\n>;\n\n/** Mapping between AST nodes and the directives that have been matched on them. */\ntype MatchedDirectives<DirectiveT> = Map<DirectiveOwner, DirectiveT[]>;\n\n/**\n * Mapping between a scoped not and the template entities that exist in it.\n * `null` represents the root scope.\n */\ntype ScopedNodeEntities = Map<ScopedNode | null, Set<TemplateEntity>>;\n\n/** Shorthand tuple type where a defer block is paired with its corresponding scope. */\ntype DeferBlockScopes = [DeferredBlock, Scope][];\n\n/**\n * Given a template string and a set of available directive selectors,\n * computes a list of matching selectors and splits them into 2 buckets:\n * (1) eagerly used in a template and (2) directives used only in defer\n * blocks. Similarly, returns 2 lists of pipes (eager and deferrable).\n *\n * Note: deferrable directives selectors and pipes names used in `@defer`\n * blocks are **candidates** and API caller should make sure that:\n *\n *  * A Component where a given template is defined is standalone\n *  * Underlying dependency classes are also standalone\n *  * Dependency class symbols are not eagerly used in a TS file\n *    where a host component (that owns the template) is located\n */\nexport function findMatchingDirectivesAndPipes(template: string, directiveSelectors: string[]) {\n  const matcher = new SelectorMatcher<DirectiveMeta[]>();\n  for (const selector of directiveSelectors) {\n    // Create a fake directive instance to account for the logic inside\n    // of the `R3TargetBinder` class (which invokes the `hasBindingPropertyName`\n    // function internally).\n    const fakeDirective = {\n      selector,\n      exportAs: null,\n      inputs: {\n        hasBindingPropertyName() {\n          return false;\n        },\n      },\n      outputs: {\n        hasBindingPropertyName() {\n          return false;\n        },\n      },\n    } as unknown as DirectiveMeta;\n    matcher.addSelectables(CssSelector.parse(selector), [fakeDirective]);\n  }\n  const parsedTemplate = parseTemplate(template, '' /* templateUrl */);\n  const binder = new R3TargetBinder(matcher);\n  const bound = binder.bind({template: parsedTemplate.nodes});\n\n  const eagerDirectiveSelectors = bound.getEagerlyUsedDirectives().map((dir) => dir.selector!);\n  const allMatchedDirectiveSelectors = bound.getUsedDirectives().map((dir) => dir.selector!);\n  const eagerPipes = bound.getEagerlyUsedPipes();\n  return {\n    directives: {\n      regular: eagerDirectiveSelectors,\n      deferCandidates: diff(allMatchedDirectiveSelectors, eagerDirectiveSelectors),\n    },\n    pipes: {\n      regular: eagerPipes,\n      deferCandidates: diff(bound.getUsedPipes(), eagerPipes),\n    },\n  };\n}\n\n/** Object used to match template nodes to directives. */\nexport type DirectiveMatcher<DirectiveT extends DirectiveMeta> =\n  | SelectorMatcher<DirectiveT[]>\n  | SelectorlessMatcher<DirectiveT>;\n\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nexport class R3TargetBinder<DirectiveT extends DirectiveMeta> implements TargetBinder<DirectiveT> {\n  constructor(private directiveMatcher: DirectiveMatcher<DirectiveT> | null) {}\n\n  /**\n   * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n   * metadata about the types referenced in the template.\n   */\n  bind(target: Target<DirectiveT>): BoundTarget<DirectiveT> {\n    if (!target.template && !target.host) {\n      throw new Error('Empty bound targets are not supported');\n    }\n\n    const directives: MatchedDirectives<DirectiveT> = new Map();\n    const eagerDirectives: DirectiveT[] = [];\n    const missingDirectives = new Set<string>();\n    const bindings: BindingsMap<DirectiveT> = new Map();\n    const references: ReferenceMap<DirectiveT> = new Map();\n    const scopedNodeEntities: ScopedNodeEntities = new Map();\n    const expressions = new Map<AST, TemplateEntity>();\n    const symbols = new Map<TemplateEntity, Template>();\n    const nestingLevel = new Map<ScopedNode, number>();\n    const usedPipes = new Set<string>();\n    const eagerPipes = new Set<string>();\n    const deferBlocks: DeferBlockScopes = [];\n\n    if (target.template) {\n      // First, parse the template into a `Scope` structure. This operation captures the syntactic\n      // scopes in the template and makes them available for later use.\n      const scope = Scope.apply(target.template);\n\n      // Use the `Scope` to extract the entities present at every level of the template.\n      extractScopedNodeEntities(scope, scopedNodeEntities);\n\n      // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n      //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n      //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n      //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n      //   - references: Map of #references to their targets.\n      DirectiveBinder.apply(\n        target.template,\n        this.directiveMatcher,\n        directives,\n        eagerDirectives,\n        missingDirectives,\n        bindings,\n        references,\n      );\n\n      // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n      // template. This extracts all the metadata that doesn't depend on directive matching.\n      TemplateBinder.applyWithScope(\n        target.template,\n        scope,\n        expressions,\n        symbols,\n        nestingLevel,\n        usedPipes,\n        eagerPipes,\n        deferBlocks,\n      );\n    }\n\n    // Bind the host element in a separate scope. Note that it only uses the\n    // `TemplateBinder` since directives don't apply inside a host context.\n    if (target.host) {\n      directives.set(target.host.node, target.host.directives);\n      TemplateBinder.applyWithScope(\n        target.host.node,\n        Scope.apply(target.host.node),\n        expressions,\n        symbols,\n        nestingLevel,\n        usedPipes,\n        eagerPipes,\n        deferBlocks,\n      );\n    }\n\n    return new R3BoundTarget(\n      target,\n      directives,\n      eagerDirectives,\n      missingDirectives,\n      bindings,\n      references,\n      expressions,\n      symbols,\n      nestingLevel,\n      scopedNodeEntities,\n      usedPipes,\n      eagerPipes,\n      deferBlocks,\n    );\n  }\n}\n\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nclass Scope implements Visitor {\n  /**\n   * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n   */\n  readonly namedEntities = new Map<string, TemplateEntity>();\n\n  /**\n   * Set of element-like nodes that belong to this scope.\n   */\n  readonly elementLikeInScope = new Set<Element | Component>();\n\n  /**\n   * Child `Scope`s for immediately nested `ScopedNode`s.\n   */\n  readonly childScopes = new Map<ScopedNode, Scope>();\n\n  /** Whether this scope is deferred or if any of its ancestors are deferred. */\n  readonly isDeferred: boolean;\n\n  private constructor(\n    readonly parentScope: Scope | null,\n    readonly rootNode: ScopedNode | null,\n  ) {\n    this.isDeferred =\n      parentScope !== null && parentScope.isDeferred ? true : rootNode instanceof DeferredBlock;\n  }\n\n  static newRootScope(): Scope {\n    return new Scope(null, null);\n  }\n\n  /**\n   * Process a template (either as a `Template` sub-template with variables, or a plain array of\n   * template `Node`s) and construct its `Scope`.\n   */\n  static apply(template: ScopedNode | Node[]): Scope {\n    const scope = Scope.newRootScope();\n    scope.ingest(template);\n    return scope;\n  }\n\n  /**\n   * Internal method to process the scoped node and populate the `Scope`.\n   */\n  private ingest(nodeOrNodes: ScopedNode | Node[]): void {\n    if (nodeOrNodes instanceof Template) {\n      // Variables on an <ng-template> are defined in the inner scope.\n      nodeOrNodes.variables.forEach((node) => this.visitVariable(node));\n\n      // Process the nodes of the template.\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitVariable(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitVariable(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach((v) => this.visitVariable(v));\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n    } else if (\n      nodeOrNodes instanceof SwitchBlockCase ||\n      nodeOrNodes instanceof ForLoopBlockEmpty ||\n      nodeOrNodes instanceof DeferredBlock ||\n      nodeOrNodes instanceof DeferredBlockError ||\n      nodeOrNodes instanceof DeferredBlockPlaceholder ||\n      nodeOrNodes instanceof DeferredBlockLoading ||\n      nodeOrNodes instanceof Content\n    ) {\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n    } else if (!(nodeOrNodes instanceof HostElement)) {\n      // No overarching `Template` instance, so process the nodes directly.\n      nodeOrNodes.forEach((node) => node.visit(this));\n    }\n  }\n\n  visitElement(element: Element) {\n    this.visitElementLike(element);\n  }\n\n  visitTemplate(template: Template) {\n    template.directives.forEach((node) => node.visit(this));\n\n    // References on a <ng-template> are defined in the outer scope, so capture them before\n    // processing the template's child scope.\n    template.references.forEach((node) => this.visitReference(node));\n\n    // Next, create an inner scope and process the template within it.\n    this.ingestScopedNode(template);\n  }\n\n  visitVariable(variable: Variable) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(variable);\n  }\n\n  visitReference(reference: Reference) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(reference);\n  }\n\n  visitDeferredBlock(deferred: DeferredBlock) {\n    this.ingestScopedNode(deferred);\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n\n  visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder) {\n    this.ingestScopedNode(block);\n  }\n\n  visitDeferredBlockError(block: DeferredBlockError) {\n    this.ingestScopedNode(block);\n  }\n\n  visitDeferredBlockLoading(block: DeferredBlockLoading) {\n    this.ingestScopedNode(block);\n  }\n\n  visitSwitchBlock(block: SwitchBlock) {\n    block.cases.forEach((node) => node.visit(this));\n  }\n\n  visitSwitchBlockCase(block: SwitchBlockCase) {\n    this.ingestScopedNode(block);\n  }\n\n  visitForLoopBlock(block: ForLoopBlock) {\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n\n  visitForLoopBlockEmpty(block: ForLoopBlockEmpty) {\n    this.ingestScopedNode(block);\n  }\n\n  visitIfBlock(block: IfBlock) {\n    block.branches.forEach((node) => node.visit(this));\n  }\n\n  visitIfBlockBranch(block: IfBlockBranch) {\n    this.ingestScopedNode(block);\n  }\n\n  visitContent(content: Content) {\n    this.ingestScopedNode(content);\n  }\n\n  visitLetDeclaration(decl: LetDeclaration) {\n    this.maybeDeclare(decl);\n  }\n\n  visitComponent(component: Component) {\n    this.visitElementLike(component);\n  }\n\n  visitDirective(directive: Directive) {\n    directive.references.forEach((current) => this.visitReference(current));\n  }\n\n  // Unused visitors.\n  visitBoundAttribute(attr: BoundAttribute) {}\n  visitBoundEvent(event: BoundEvent) {}\n  visitBoundText(text: BoundText) {}\n  visitText(text: Text) {}\n  visitTextAttribute(attr: TextAttribute) {}\n  visitIcu(icu: Icu) {}\n  visitDeferredTrigger(trigger: DeferredTrigger) {}\n  visitUnknownBlock(block: UnknownBlock) {}\n\n  private visitElementLike(node: Element | Component) {\n    node.directives.forEach((current) => current.visit(this));\n    node.references.forEach((current) => this.visitReference(current));\n    node.children.forEach((current) => current.visit(this));\n    this.elementLikeInScope.add(node);\n  }\n\n  private maybeDeclare(thing: TemplateEntity) {\n    // Declare something with a name, as long as that name isn't taken.\n    if (!this.namedEntities.has(thing.name)) {\n      this.namedEntities.set(thing.name, thing);\n    }\n  }\n\n  /**\n   * Look up a variable within this `Scope`.\n   *\n   * This can recurse into a parent `Scope` if it's available.\n   */\n  lookup(name: string): TemplateEntity | null {\n    if (this.namedEntities.has(name)) {\n      // Found in the local scope.\n      return this.namedEntities.get(name)!;\n    } else if (this.parentScope !== null) {\n      // Not in the local scope, but there's a parent scope so check there.\n      return this.parentScope.lookup(name);\n    } else {\n      // At the top level and it wasn't found.\n      return null;\n    }\n  }\n\n  /**\n   * Get the child scope for a `ScopedNode`.\n   *\n   * This should always be defined.\n   */\n  getChildScope(node: ScopedNode): Scope {\n    const res = this.childScopes.get(node);\n    if (res === undefined) {\n      throw new Error(`Assertion error: child scope for ${node} not found`);\n    }\n    return res;\n  }\n\n  private ingestScopedNode(node: ScopedNode) {\n    const scope = new Scope(this, node);\n    scope.ingest(node);\n    this.childScopes.set(node, scope);\n  }\n}\n\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nclass DirectiveBinder<DirectiveT extends DirectiveMeta> implements Visitor {\n  // Indicates whether we are visiting elements within a `defer` block\n  private isInDeferBlock = false;\n\n  private constructor(\n    private directiveMatcher: DirectiveMatcher<DirectiveT> | null,\n    private directives: MatchedDirectives<DirectiveT>,\n    private eagerDirectives: DirectiveT[],\n    private missingDirectives: Set<string>,\n    private bindings: BindingsMap<DirectiveT>,\n    private references: ReferenceMap<DirectiveT>,\n  ) {}\n\n  /**\n   * Process a template (list of `Node`s) and perform directive matching against each node.\n   *\n   * @param template the list of template `Node`s to match (recursively).\n   * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n   * this template.\n   * @returns three maps which contain information about directives in the template: the\n   * `directives` map which lists directives matched on each node, the `bindings` map which\n   * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n   * map which resolves #references (`Reference`s) within the template to the named directive or\n   * template node.\n   */\n  static apply<DirectiveT extends DirectiveMeta>(\n    template: Node[],\n    directiveMatcher: DirectiveMatcher<DirectiveT> | null,\n    directives: MatchedDirectives<DirectiveT>,\n    eagerDirectives: DirectiveT[],\n    missingDirectives: Set<string>,\n    bindings: BindingsMap<DirectiveT>,\n    references: ReferenceMap<DirectiveT>,\n  ): void {\n    const matcher = new DirectiveBinder(\n      directiveMatcher,\n      directives,\n      eagerDirectives,\n      missingDirectives,\n      bindings,\n      references,\n    );\n    matcher.ingest(template);\n  }\n\n  private ingest(template: Node[]): void {\n    template.forEach((node) => node.visit(this));\n  }\n\n  visitElement(element: Element): void {\n    this.visitElementOrTemplate(element);\n  }\n\n  visitTemplate(template: Template): void {\n    this.visitElementOrTemplate(template);\n  }\n\n  visitDeferredBlock(deferred: DeferredBlock): void {\n    const wasInDeferBlock = this.isInDeferBlock;\n    this.isInDeferBlock = true;\n    deferred.children.forEach((child) => child.visit(this));\n    this.isInDeferBlock = wasInDeferBlock;\n\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n\n  visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder): void {\n    block.children.forEach((child) => child.visit(this));\n  }\n\n  visitDeferredBlockError(block: DeferredBlockError): void {\n    block.children.forEach((child) => child.visit(this));\n  }\n\n  visitDeferredBlockLoading(block: DeferredBlockLoading): void {\n    block.children.forEach((child) => child.visit(this));\n  }\n\n  visitSwitchBlock(block: SwitchBlock) {\n    block.cases.forEach((node) => node.visit(this));\n  }\n\n  visitSwitchBlockCase(block: SwitchBlockCase) {\n    block.children.forEach((node) => node.visit(this));\n  }\n\n  visitForLoopBlock(block: ForLoopBlock) {\n    block.item.visit(this);\n    block.contextVariables.forEach((v) => v.visit(this));\n    block.children.forEach((node) => node.visit(this));\n    block.empty?.visit(this);\n  }\n\n  visitForLoopBlockEmpty(block: ForLoopBlockEmpty) {\n    block.children.forEach((node) => node.visit(this));\n  }\n\n  visitIfBlock(block: IfBlock) {\n    block.branches.forEach((node) => node.visit(this));\n  }\n\n  visitIfBlockBranch(block: IfBlockBranch) {\n    block.expressionAlias?.visit(this);\n    block.children.forEach((node) => node.visit(this));\n  }\n\n  visitContent(content: Content): void {\n    content.children.forEach((child) => child.visit(this));\n  }\n\n  visitComponent(node: Component): void {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const componentMatches = this.directiveMatcher.match(node.componentName);\n\n      if (componentMatches.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, componentMatches);\n      } else {\n        this.missingDirectives.add(node.componentName);\n      }\n    }\n\n    node.directives.forEach((directive) => directive.visit(this));\n    node.children.forEach((child) => child.visit(this));\n  }\n\n  visitDirective(node: Directive): void {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const directives = this.directiveMatcher.match(node.name);\n\n      if (directives.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, directives);\n      } else {\n        this.missingDirectives.add(node.name);\n      }\n    }\n  }\n\n  private visitElementOrTemplate(node: Element | Template): void {\n    if (this.directiveMatcher instanceof SelectorMatcher) {\n      const directives: DirectiveT[] = [];\n      const cssSelector = createCssSelectorFromNode(node);\n      this.directiveMatcher.match(cssSelector, (_, results) => directives.push(...results));\n      this.trackSelectorBasedBindingsAndDirectives(node, directives);\n    } else {\n      node.references.forEach((ref) => {\n        if (ref.value.trim() === '') {\n          this.references.set(ref, node);\n        }\n      });\n    }\n\n    node.directives.forEach((directive) => directive.visit(this));\n    node.children.forEach((child) => child.visit(this));\n  }\n\n  private trackMatchedDirectives(node: DirectiveOwner, directives: DirectiveT[]): void {\n    if (directives.length > 0) {\n      this.directives.set(node, directives);\n      if (!this.isInDeferBlock) {\n        this.eagerDirectives.push(...directives);\n      }\n    }\n  }\n\n  private trackSelectorlessMatchesAndDirectives(\n    node: Component | Directive,\n    directives: DirectiveT[],\n  ): void {\n    if (directives.length === 0) {\n      return;\n    }\n\n    this.trackMatchedDirectives(node, directives);\n\n    const setBinding = (\n      meta: DirectiveT,\n      attribute: BoundAttribute | BoundEvent | TextAttribute,\n      ioType: keyof Pick<DirectiveMeta, 'inputs' | 'outputs'>,\n    ) => {\n      if (meta[ioType].hasBindingPropertyName(attribute.name)) {\n        this.bindings.set(attribute, meta);\n      }\n    };\n\n    for (const directive of directives) {\n      node.inputs.forEach((input) => setBinding(directive, input, 'inputs'));\n      node.attributes.forEach((attr) => setBinding(directive, attr, 'inputs'));\n      node.outputs.forEach((output) => setBinding(directive, output, 'outputs'));\n    }\n\n    // TODO(crisbeto): currently it's unclear how references should behave under selectorless,\n    // given that there's one named class which can bring in multiple host directives.\n    // For the time being only register the first directive as the reference target.\n    node.references.forEach((ref) =>\n      this.references.set(ref, {directive: directives[0], node: node}),\n    );\n  }\n\n  private trackSelectorBasedBindingsAndDirectives(\n    node: Element | Template,\n    directives: DirectiveT[],\n  ): void {\n    this.trackMatchedDirectives(node, directives);\n\n    // Resolve any references that are created on this node.\n    node.references.forEach((ref) => {\n      let dirTarget: DirectiveT | null = null;\n\n      // If the reference expression is empty, then it matches the \"primary\" directive on the node\n      // (if there is one). Otherwise it matches the host node itself (either an element or\n      // <ng-template> node).\n      if (ref.value.trim() === '') {\n        // This could be a reference to a component if there is one.\n        dirTarget = directives.find((dir) => dir.isComponent) || null;\n      } else {\n        // This should be a reference to a directive exported via exportAs.\n        dirTarget =\n          directives.find(\n            (dir) => dir.exportAs !== null && dir.exportAs.some((value) => value === ref.value),\n          ) || null;\n        // Check if a matching directive was found.\n        if (dirTarget === null) {\n          // No matching directive was found - this reference points to an unknown target. Leave it\n          // unmapped.\n          return;\n        }\n      }\n\n      if (dirTarget !== null) {\n        // This reference points to a directive.\n        this.references.set(ref, {directive: dirTarget, node});\n      } else {\n        // This reference points to the node itself.\n        this.references.set(ref, node);\n      }\n    });\n\n    // Associate attributes/bindings on the node with directives or with the node itself.\n    const setAttributeBinding = (\n      attribute: BoundAttribute | BoundEvent | TextAttribute,\n      ioType: keyof Pick<DirectiveMeta, 'inputs' | 'outputs'>,\n    ) => {\n      const dir = directives.find((dir) => dir[ioType].hasBindingPropertyName(attribute.name));\n      const binding = dir !== undefined ? dir : node;\n      this.bindings.set(attribute, binding);\n    };\n\n    // Node inputs (bound attributes) and text attributes can be bound to an\n    // input on a directive.\n    node.inputs.forEach((input) => setAttributeBinding(input, 'inputs'));\n    node.attributes.forEach((attr) => setAttributeBinding(attr, 'inputs'));\n    if (node instanceof Template) {\n      node.templateAttrs.forEach((attr) => setAttributeBinding(attr, 'inputs'));\n    }\n    // Node outputs (bound events) can be bound to an output on a directive.\n    node.outputs.forEach((output) => setAttributeBinding(output, 'outputs'));\n  }\n\n  // Unused visitors.\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitBoundAttributeOrEvent(node: BoundAttribute | BoundEvent) {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n  visitDeferredTrigger(trigger: DeferredTrigger): void {}\n  visitUnknownBlock(block: UnknownBlock) {}\n  visitLetDeclaration(decl: LetDeclaration) {}\n}\n\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nclass TemplateBinder extends CombinedRecursiveAstVisitor {\n  private visitNode = (node: Node) => node.visit(this);\n\n  private constructor(\n    private bindings: Map<AST, TemplateEntity>,\n    private symbols: Map<TemplateEntity, ScopedNode>,\n    private usedPipes: Set<string>,\n    private eagerPipes: Set<string>,\n    private deferBlocks: DeferBlockScopes,\n    private nestingLevel: Map<ScopedNode, number>,\n    private scope: Scope,\n    private rootNode: ScopedNode | null,\n    private level: number,\n  ) {\n    super();\n  }\n\n  /**\n   * Process a template and extract metadata about expressions and symbols within.\n   *\n   * @param nodeOrNodes the nodes of the template to process\n   * @param scope the `Scope` of the template being processed.\n   * @returns three maps which contain metadata about the template: `expressions` which interprets\n   * special `AST` nodes in expressions as pointing to references or variables declared within the\n   * template, `symbols` which maps those variables and references to the nested `Template` which\n   * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n   * nesting level (how many levels deep within the template structure the `Template` is), starting\n   * at 1.\n   */\n  static applyWithScope(\n    nodeOrNodes: ScopedNode | Node[],\n    scope: Scope,\n    expressions: Map<AST, TemplateEntity>,\n    symbols: Map<TemplateEntity, Template>,\n    nestingLevel: Map<ScopedNode, number>,\n    usedPipes: Set<string>,\n    eagerPipes: Set<string>,\n    deferBlocks: DeferBlockScopes,\n  ): void {\n    const template = nodeOrNodes instanceof Template ? nodeOrNodes : null;\n    // The top-level template has nesting level 0.\n    const binder = new TemplateBinder(\n      expressions,\n      symbols,\n      usedPipes,\n      eagerPipes,\n      deferBlocks,\n      nestingLevel,\n      scope,\n      template,\n      0,\n    );\n    binder.ingest(nodeOrNodes);\n  }\n\n  private ingest(nodeOrNodes: ScopedNode | Node[]): void {\n    if (nodeOrNodes instanceof Template) {\n      // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n      // and references were all processed in the scope of the containing template.\n      nodeOrNodes.variables.forEach(this.visitNode);\n      nodeOrNodes.children.forEach(this.visitNode);\n\n      // Set the nesting level.\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitNode(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitNode(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach((v) => this.visitNode(v));\n      nodeOrNodes.trackBy.visit(this);\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof DeferredBlock) {\n      if (this.scope.rootNode !== nodeOrNodes) {\n        throw new Error(\n          `Assertion error: resolved incorrect scope for deferred block ${nodeOrNodes}`,\n        );\n      }\n      this.deferBlocks.push([nodeOrNodes, this.scope]);\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (\n      nodeOrNodes instanceof SwitchBlockCase ||\n      nodeOrNodes instanceof ForLoopBlockEmpty ||\n      nodeOrNodes instanceof DeferredBlockError ||\n      nodeOrNodes instanceof DeferredBlockPlaceholder ||\n      nodeOrNodes instanceof DeferredBlockLoading ||\n      nodeOrNodes instanceof Content\n    ) {\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof HostElement) {\n      // Host elements are always at the top level.\n      this.nestingLevel.set(nodeOrNodes, 0);\n    } else {\n      // Visit each node from the top-level template.\n      nodeOrNodes.forEach(this.visitNode);\n    }\n  }\n\n  override visitTemplate(template: Template) {\n    // First, visit inputs, outputs and template attributes of the template node.\n    template.inputs.forEach(this.visitNode);\n    template.outputs.forEach(this.visitNode);\n    template.directives.forEach(this.visitNode);\n    template.templateAttrs.forEach(this.visitNode);\n    template.references.forEach(this.visitNode);\n\n    // Next, recurse into the template.\n    this.ingestScopedNode(template);\n  }\n\n  override visitVariable(variable: Variable) {\n    // Register the `Variable` as a symbol in the current `Template`.\n    if (this.rootNode !== null) {\n      this.symbols.set(variable, this.rootNode);\n    }\n  }\n\n  override visitReference(reference: Reference) {\n    // Register the `Reference` as a symbol in the current `Template`.\n    if (this.rootNode !== null) {\n      this.symbols.set(reference, this.rootNode);\n    }\n  }\n\n  override visitDeferredBlock(deferred: DeferredBlock) {\n    this.ingestScopedNode(deferred);\n    deferred.triggers.when?.value.visit(this);\n    deferred.prefetchTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.never?.visit(this);\n    deferred.placeholder && this.visitNode(deferred.placeholder);\n    deferred.loading && this.visitNode(deferred.loading);\n    deferred.error && this.visitNode(deferred.error);\n  }\n\n  override visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder) {\n    this.ingestScopedNode(block);\n  }\n\n  override visitDeferredBlockError(block: DeferredBlockError) {\n    this.ingestScopedNode(block);\n  }\n\n  override visitDeferredBlockLoading(block: DeferredBlockLoading) {\n    this.ingestScopedNode(block);\n  }\n\n  override visitSwitchBlockCase(block: SwitchBlockCase) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n\n  override visitForLoopBlock(block: ForLoopBlock) {\n    block.expression.visit(this);\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n\n  override visitForLoopBlockEmpty(block: ForLoopBlockEmpty) {\n    this.ingestScopedNode(block);\n  }\n\n  override visitIfBlockBranch(block: IfBlockBranch) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n\n  override visitContent(content: Content) {\n    this.ingestScopedNode(content);\n  }\n\n  override visitLetDeclaration(decl: LetDeclaration) {\n    super.visitLetDeclaration(decl);\n\n    if (this.rootNode !== null) {\n      this.symbols.set(decl, this.rootNode);\n    }\n  }\n\n  override visitPipe(ast: BindingPipe, context: any): any {\n    this.usedPipes.add(ast.name);\n    if (!this.scope.isDeferred) {\n      this.eagerPipes.add(ast.name);\n    }\n    return super.visitPipe(ast, context);\n  }\n\n  // These five types of AST expressions can refer to expression roots, which could be variables\n  // or references in the current scope.\n\n  override visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.maybeMap(ast, ast.name);\n    return super.visitPropertyRead(ast, context);\n  }\n\n  override visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.maybeMap(ast, ast.name);\n    return super.visitSafePropertyRead(ast, context);\n  }\n\n  private ingestScopedNode(node: ScopedNode) {\n    const childScope = this.scope.getChildScope(node);\n    const binder = new TemplateBinder(\n      this.bindings,\n      this.symbols,\n      this.usedPipes,\n      this.eagerPipes,\n      this.deferBlocks,\n      this.nestingLevel,\n      childScope,\n      node,\n      this.level + 1,\n    );\n    binder.ingest(node);\n  }\n\n  private maybeMap(ast: PropertyRead | SafePropertyRead, name: string): void {\n    // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n    // `AST` expression that maps to a `Variable` or `Reference`.\n    if (!(ast.receiver instanceof ImplicitReceiver) || ast.receiver instanceof ThisReceiver) {\n      return;\n    }\n\n    // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n    // probably a property on the top-level component context.\n    const target = this.scope.lookup(name);\n    if (target !== null) {\n      this.bindings.set(ast, target);\n    }\n  }\n}\n\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nclass R3BoundTarget<DirectiveT extends DirectiveMeta> implements BoundTarget<DirectiveT> {\n  /** Deferred blocks, ordered as they appear in the template. */\n  private deferredBlocks: DeferredBlock[];\n\n  /** Map of deferred blocks to their scope. */\n  private deferredScopes: Map<DeferredBlock, Scope>;\n\n  constructor(\n    readonly target: Target<DirectiveT>,\n    private directives: MatchedDirectives<DirectiveT>,\n    private eagerDirectives: DirectiveT[],\n    private missingDirectives: Set<string>,\n    private bindings: BindingsMap<DirectiveT>,\n    private references: ReferenceMap<DirectiveT>,\n    private exprTargets: Map<AST, TemplateEntity>,\n    private symbols: Map<TemplateEntity, Template>,\n    private nestingLevel: Map<ScopedNode, number>,\n    private scopedNodeEntities: ScopedNodeEntities,\n    private usedPipes: Set<string>,\n    private eagerPipes: Set<string>,\n    rawDeferred: DeferBlockScopes,\n  ) {\n    this.deferredBlocks = rawDeferred.map((current) => current[0]);\n    this.deferredScopes = new Map(rawDeferred);\n  }\n\n  getEntitiesInScope(node: ScopedNode | null): ReadonlySet<TemplateEntity> {\n    return this.scopedNodeEntities.get(node) ?? new Set();\n  }\n\n  getDirectivesOfNode(node: DirectiveOwner): DirectiveT[] | null {\n    return this.directives.get(node) || null;\n  }\n\n  getReferenceTarget(ref: Reference): ReferenceTarget<DirectiveT> | null {\n    return this.references.get(ref) || null;\n  }\n\n  getConsumerOfBinding(\n    binding: BoundAttribute | BoundEvent | TextAttribute,\n  ): DirectiveT | Element | Template | null {\n    return this.bindings.get(binding) || null;\n  }\n\n  getExpressionTarget(expr: AST): TemplateEntity | null {\n    return this.exprTargets.get(expr) || null;\n  }\n\n  getDefinitionNodeOfSymbol(symbol: TemplateEntity): ScopedNode | null {\n    return this.symbols.get(symbol) || null;\n  }\n\n  getNestingLevel(node: ScopedNode): number {\n    return this.nestingLevel.get(node) || 0;\n  }\n\n  getUsedDirectives(): DirectiveT[] {\n    const set = new Set<DirectiveT>();\n    this.directives.forEach((dirs) => dirs.forEach((dir) => set.add(dir)));\n    return Array.from(set.values());\n  }\n\n  getEagerlyUsedDirectives(): DirectiveT[] {\n    const set = new Set<DirectiveT>(this.eagerDirectives);\n    return Array.from(set.values());\n  }\n\n  getUsedPipes(): string[] {\n    return Array.from(this.usedPipes);\n  }\n\n  getEagerlyUsedPipes(): string[] {\n    return Array.from(this.eagerPipes);\n  }\n\n  getDeferBlocks(): DeferredBlock[] {\n    return this.deferredBlocks;\n  }\n\n  getDeferredTriggerTarget(block: DeferredBlock, trigger: DeferredTrigger): Element | null {\n    // Only triggers that refer to DOM nodes can be resolved.\n    if (\n      !(trigger instanceof InteractionDeferredTrigger) &&\n      !(trigger instanceof ViewportDeferredTrigger) &&\n      !(trigger instanceof HoverDeferredTrigger)\n    ) {\n      return null;\n    }\n\n    const name = trigger.reference;\n\n    if (name === null) {\n      let target: Element | null = null;\n\n      if (block.placeholder !== null) {\n        for (const child of block.placeholder.children) {\n          // Skip over comment nodes. Currently by default the template parser doesn't capture\n          // comments, but we have a safeguard here just in case since it can be enabled.\n          if (child instanceof Comment) {\n            continue;\n          }\n\n          // We can only infer the trigger if there's one root element node. Any other\n          // nodes at the root make it so that we can't infer the trigger anymore.\n          if (target !== null) {\n            return null;\n          }\n\n          if (child instanceof Element) {\n            target = child;\n          }\n        }\n      }\n\n      return target;\n    }\n\n    const outsideRef = this.findEntityInScope(block, name);\n\n    // First try to resolve the target in the scope of the main deferred block. Note that we\n    // skip triggers defined inside the main block itself, because they might not exist yet.\n    if (outsideRef instanceof Reference && this.getDefinitionNodeOfSymbol(outsideRef) !== block) {\n      const target = this.getReferenceTarget(outsideRef);\n\n      if (target !== null) {\n        return this.referenceTargetToElement(target);\n      }\n    }\n\n    // If the trigger couldn't be found in the main block, check the\n    // placeholder block which is shown before the main block has loaded.\n    if (block.placeholder !== null) {\n      const refInPlaceholder = this.findEntityInScope(block.placeholder, name);\n      const targetInPlaceholder =\n        refInPlaceholder instanceof Reference ? this.getReferenceTarget(refInPlaceholder) : null;\n\n      if (targetInPlaceholder !== null) {\n        return this.referenceTargetToElement(targetInPlaceholder);\n      }\n    }\n\n    return null;\n  }\n\n  isDeferred(element: Element): boolean {\n    for (const block of this.deferredBlocks) {\n      if (!this.deferredScopes.has(block)) {\n        continue;\n      }\n\n      const stack: Scope[] = [this.deferredScopes.get(block)!];\n\n      while (stack.length > 0) {\n        const current = stack.pop()!;\n\n        if (current.elementLikeInScope.has(element)) {\n          return true;\n        }\n\n        stack.push(...current.childScopes.values());\n      }\n    }\n\n    return false;\n  }\n\n  referencedDirectiveExists(name: string): boolean {\n    return !this.missingDirectives.has(name);\n  }\n\n  /**\n   * Finds an entity with a specific name in a scope.\n   * @param rootNode Root node of the scope.\n   * @param name Name of the entity.\n   */\n  private findEntityInScope(rootNode: ScopedNode, name: string): TemplateEntity | null {\n    const entities = this.getEntitiesInScope(rootNode);\n\n    for (const entity of entities) {\n      if (entity.name === name) {\n        return entity;\n      }\n    }\n\n    return null;\n  }\n\n  /** Coerces a `ReferenceTarget` to an `Element`, if possible. */\n  private referenceTargetToElement(target: ReferenceTarget<DirectiveT>): Element | null {\n    if (target instanceof Element) {\n      return target;\n    }\n\n    if (\n      target instanceof Template ||\n      target.node instanceof Component ||\n      target.node instanceof Directive ||\n      target.node instanceof HostElement\n    ) {\n      return null;\n    }\n\n    return this.referenceTargetToElement(target.node);\n  }\n}\n\nfunction extractScopedNodeEntities(rootScope: Scope, templateEntities: ScopedNodeEntities): void {\n  const entityMap = new Map<ScopedNode | null, Map<string, TemplateEntity>>();\n\n  function extractScopeEntities(scope: Scope): Map<string, TemplateEntity> {\n    if (entityMap.has(scope.rootNode)) {\n      return entityMap.get(scope.rootNode)!;\n    }\n\n    const currentEntities = scope.namedEntities;\n\n    let entities: Map<string, TemplateEntity>;\n    if (scope.parentScope !== null) {\n      entities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n    } else {\n      entities = new Map(currentEntities);\n    }\n\n    entityMap.set(scope.rootNode, entities);\n    return entities;\n  }\n\n  const scopesToProcess: Scope[] = [rootScope];\n  while (scopesToProcess.length > 0) {\n    const scope = scopesToProcess.pop()!;\n    for (const childScope of scope.childScopes.values()) {\n      scopesToProcess.push(childScope);\n    }\n    extractScopeEntities(scope);\n  }\n\n  for (const [template, entities] of entityMap) {\n    templateEntities.set(template, new Set(entities.values()));\n  }\n}\n"]}