{"version":3,"file":"template.js","sourceRoot":"","sources":["template.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Lexer} from '../../expression_parser/lexer';\nimport {Parser} from '../../expression_parser/parser';\nimport * as html from '../../ml_parser/ast';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../ml_parser/defaults';\nimport {HtmlParser} from '../../ml_parser/html_parser';\nimport {WhitespaceVisitor} from '../../ml_parser/html_whitespaces';\nimport {LexerRange} from '../../ml_parser/lexer';\nimport {ParseError} from '../../parse_util';\nimport {DomElementSchemaRegistry} from '../../schema/dom_element_schema_registry';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport * as t from '../r3_ast';\nimport {htmlAstToRender3Ast} from '../r3_template_transform';\n\nimport {I18nMetaVisitor} from './i18n/meta';\n\nexport const LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n\n/**\n * Options that can be used to modify how a template is parsed by `parseTemplate()`.\n */\nexport interface ParseTemplateOptions {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n  /**\n   * Preserve original line endings instead of normalizing '\\r\\n' endings to '\\n'.\n   */\n  preserveLineEndings?: boolean;\n  /**\n   * Preserve whitespace significant to rendering.\n   */\n  preserveSignificantWhitespace?: boolean;\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n\n  /**\n   * Render `$localize` message ids with additional legacy message ids.\n   *\n   * This option defaults to `true` but in the future the default will be flipped.\n   *\n   * For now set this option to false if you have migrated the translation files to use the new\n   * `$localize` message id format and you are not using compile time translation merging.\n   */\n  enableI18nLegacyMessageIdFormat?: boolean;\n\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n\n  /**\n   * Whether to always attempt to convert the parsed HTML AST to an R3 AST, despite HTML or i18n\n   * Meta parse errors.\n   *\n   *\n   * This option is useful in the context of the language service, where we want to get as much\n   * information as possible, despite any errors in the HTML. As an example, a user may be adding\n   * a new tag and expecting autocomplete on that tag. In this scenario, the HTML is in an errored\n   * state, as there is an incomplete open tag. However, we're still able to convert the HTML AST\n   * nodes to R3 AST nodes in order to provide information for the language service.\n   *\n   * Note that even when `true` the HTML parse and i18n errors are still appended to the errors\n   * output, but this is done after converting the HTML AST to R3 AST.\n   */\n  alwaysAttemptHtmlToR3AstConversion?: boolean;\n\n  /**\n   * Include HTML Comment nodes in a top-level comments array on the returned R3 AST.\n   *\n   * This option is required by tooling that needs to know the location of comment nodes within the\n   * AST. A concrete example is @angular-eslint which requires this in order to enable\n   * \"eslint-disable\" comments within HTML templates, which then allows users to turn off specific\n   * rules on a case by case basis, instead of for their whole project within a configuration file.\n   */\n  collectCommentNodes?: boolean;\n\n  /** Whether the @ block syntax is enabled. */\n  enableBlockSyntax?: boolean;\n\n  /** Whether the `@let` syntax is enabled. */\n  enableLetSyntax?: boolean;\n\n  /** Whether the selectorless syntax is enabled. */\n  enableSelectorless?: boolean;\n}\n\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nexport function parseTemplate(\n  template: string,\n  templateUrl: string,\n  options: ParseTemplateOptions = {},\n): ParsedTemplate {\n  const {interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat} = options;\n  const selectorlessEnabled = options.enableSelectorless ?? false;\n  const bindingParser = makeBindingParser(interpolationConfig, selectorlessEnabled);\n  const htmlParser = new HtmlParser();\n  const parseResult = htmlParser.parse(template, templateUrl, {\n    leadingTriviaChars: LEADING_TRIVIA_CHARS,\n    ...options,\n    tokenizeExpansionForms: true,\n    tokenizeBlocks: options.enableBlockSyntax ?? true,\n    tokenizeLet: options.enableLetSyntax ?? true,\n    selectorlessEnabled,\n  });\n\n  if (\n    !options.alwaysAttemptHtmlToR3AstConversion &&\n    parseResult.errors &&\n    parseResult.errors.length > 0\n  ) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      errors: parseResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: [],\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  let rootNodes: html.Node[] = parseResult.rootNodes;\n\n  // We need to use the same `retainEmptyTokens` value for both parses to avoid\n  // causing a mismatch when reusing source spans, even if the\n  // `preserveSignificantWhitespace` behavior is different between the two\n  // parses.\n  const retainEmptyTokens = !(options.preserveSignificantWhitespace ?? true);\n\n  // process i18n meta information (scan attributes, generate ids)\n  // before we run whitespace removal process, because existing i18n\n  // extraction process (ng extract-i18n) relies on a raw content to generate\n  // message ids\n  const i18nMetaVisitor = new I18nMetaVisitor(\n    interpolationConfig,\n    /* keepI18nAttrs */ !preserveWhitespaces,\n    enableI18nLegacyMessageIdFormat,\n    /* containerBlocks */ undefined,\n    options.preserveSignificantWhitespace,\n    retainEmptyTokens,\n  );\n  const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n\n  if (\n    !options.alwaysAttemptHtmlToR3AstConversion &&\n    i18nMetaResult.errors &&\n    i18nMetaResult.errors.length > 0\n  ) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      errors: i18nMetaResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: [],\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  rootNodes = i18nMetaResult.rootNodes;\n\n  if (!preserveWhitespaces) {\n    // Always preserve significant whitespace here because this is used to generate the `goog.getMsg`\n    // and `$localize` calls which should retain significant whitespace in order to render the\n    // correct output. We let this diverge from the message IDs generated earlier which might not\n    // have preserved significant whitespace.\n    //\n    // This should use `visitAllWithSiblings` to set `WhitespaceVisitor` context correctly, however\n    // there is an existing bug where significant whitespace is not properly retained in the JS\n    // output of leading/trailing whitespace for ICU messages due to the existing lack of context\\\n    // in `WhitespaceVisitor`. Using `visitAllWithSiblings` here would fix that bug and retain the\n    // whitespace, however it would also change the runtime representation which we don't want to do\n    // right now.\n    rootNodes = html.visitAll(\n      new WhitespaceVisitor(\n        /* preserveSignificantWhitespace */ true,\n        /* originalNodeMap */ undefined,\n        /* requireContext */ false,\n      ),\n      rootNodes,\n    );\n\n    // run i18n meta visitor again in case whitespaces are removed (because that might affect\n    // generated i18n message content) and first pass indicated that i18n content is present in a\n    // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n    // mimic existing extraction process (ng extract-i18n)\n    if (i18nMetaVisitor.hasI18nMeta) {\n      rootNodes = html.visitAll(\n        new I18nMetaVisitor(\n          interpolationConfig,\n          /* keepI18nAttrs */ false,\n          /* enableI18nLegacyMessageIdFormat */ undefined,\n          /* containerBlocks */ undefined,\n          /* preserveSignificantWhitespace */ true,\n          retainEmptyTokens,\n        ),\n        rootNodes,\n      );\n    }\n  }\n\n  const {nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes} = htmlAstToRender3Ast(\n    rootNodes,\n    bindingParser,\n    {collectCommentNodes: !!options.collectCommentNodes},\n  );\n  errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n\n  const parsedTemplate: ParsedTemplate = {\n    interpolationConfig,\n    preserveWhitespaces,\n    errors: errors.length > 0 ? errors : null,\n    nodes,\n    styleUrls,\n    styles,\n    ngContentSelectors,\n  };\n\n  if (options.collectCommentNodes) {\n    parsedTemplate.commentNodes = commentNodes;\n  }\n  return parsedTemplate;\n}\n\nconst elementRegistry = new DomElementSchemaRegistry();\n\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nexport function makeBindingParser(\n  interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  selectorlessEnabled = false,\n): BindingParser {\n  return new BindingParser(\n    new Parser(new Lexer(), selectorlessEnabled),\n    interpolationConfig,\n    elementRegistry,\n    [],\n  );\n}\n\n/**\n * Information about the template which was extracted during parsing.\n *\n * This contains the actual parsed template as well as any metadata collected during its parsing,\n * some of which might be useful for re-parsing the template with different options.\n */\nexport interface ParsedTemplate {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * Any errors from parsing the template the first time.\n   *\n   * `null` if there are no errors. Otherwise, the array of errors is guaranteed to be non-empty.\n   */\n  errors: ParseError[] | null;\n\n  /**\n   * The template AST, parsed from the template.\n   */\n  nodes: t.Node[];\n\n  /**\n   * Any styleUrls extracted from the metadata.\n   */\n  styleUrls: string[];\n\n  /**\n   * Any inline styles extracted from the metadata.\n   */\n  styles: string[];\n\n  /**\n   * Any ng-content selectors extracted from the template.\n   */\n  ngContentSelectors: string[];\n\n  /**\n   * Any R3 Comment Nodes extracted from the template when the `collectCommentNodes` parse template\n   * option is enabled.\n   */\n  commentNodes?: t.Comment[];\n}\n"]}