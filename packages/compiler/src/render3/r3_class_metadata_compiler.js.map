{"version":3,"file":"r3_class_metadata_compiler.js","sourceRoot":"","sources":["r3_class_metadata_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {devOnlyGuardedExpression} from './util';\nimport {R3DeferPerComponentDependency} from './view/api';\n\nexport type CompileClassMetadataFn = (metadata: R3ClassMetadata) => o.Expression;\n\n/**\n * Metadata of a class which captures the original Angular decorators of a class. The original\n * decorators are preserved in the generated code to allow TestBed APIs to recompile the class\n * using the original decorator with a set of overrides applied.\n */\nexport interface R3ClassMetadata {\n  /**\n   * The class type for which the metadata is captured.\n   */\n  type: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the class.\n   */\n  decorators: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators applied to constructor parameters, or `null`\n   * if there is no constructor.\n   */\n  ctorParameters: o.Expression | null;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the properties of the\n   * class, or `null` if no properties have decorators.\n   */\n  propDecorators: o.Expression | null;\n}\n\nexport function compileClassMetadata(metadata: R3ClassMetadata): o.InvokeFunctionExpr {\n  const fnCall = internalCompileClassMetadata(metadata);\n  return o.arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]).callFn([]);\n}\n\n/** Compiles only the `setClassMetadata` call without any additional wrappers. */\nfunction internalCompileClassMetadata(metadata: R3ClassMetadata): o.InvokeFunctionExpr {\n  return o\n    .importExpr(R3.setClassMetadata)\n    .callFn([\n      metadata.type,\n      metadata.decorators,\n      metadata.ctorParameters ?? o.literal(null),\n      metadata.propDecorators ?? o.literal(null),\n    ]);\n}\n\n/**\n * Wraps the `setClassMetadata` function with extra logic that dynamically\n * loads dependencies from `@defer` blocks.\n *\n * Generates a call like this:\n * ```ts\n * setClassMetadataAsync(type, () => [\n *   import('./cmp-a').then(m => m.CmpA);\n *   import('./cmp-b').then(m => m.CmpB);\n * ], (CmpA, CmpB) => {\n *   setClassMetadata(type, decorators, ctorParameters, propParameters);\n * });\n * ```\n *\n * Similar to the `setClassMetadata` call, it's wrapped into the `ngDevMode`\n * check to tree-shake away this code in production mode.\n */\nexport function compileComponentClassMetadata(\n  metadata: R3ClassMetadata,\n  dependencies: R3DeferPerComponentDependency[] | null,\n): o.Expression {\n  if (dependencies === null || dependencies.length === 0) {\n    // If there are no deferrable symbols - just generate a regular `setClassMetadata` call.\n    return compileClassMetadata(metadata);\n  }\n\n  return internalCompileSetClassMetadataAsync(\n    metadata,\n    dependencies.map((dep) => new o.FnParam(dep.symbolName, o.DYNAMIC_TYPE)),\n    compileComponentMetadataAsyncResolver(dependencies),\n  );\n}\n\n/**\n * Identical to `compileComponentClassMetadata`. Used for the cases where we're unable to\n * analyze the deferred block dependencies, but we have a reference to the compiled\n * dependency resolver function that we can use as is.\n * @param metadata Class metadata for the internal `setClassMetadata` call.\n * @param deferResolver Expression representing the deferred dependency loading function.\n * @param deferredDependencyNames Names of the dependencies that are being loaded asynchronously.\n */\nexport function compileOpaqueAsyncClassMetadata(\n  metadata: R3ClassMetadata,\n  deferResolver: o.Expression,\n  deferredDependencyNames: string[],\n): o.Expression {\n  return internalCompileSetClassMetadataAsync(\n    metadata,\n    deferredDependencyNames.map((name) => new o.FnParam(name, o.DYNAMIC_TYPE)),\n    deferResolver,\n  );\n}\n\n/**\n * Internal logic used to compile a `setClassMetadataAsync` call.\n * @param metadata Class metadata for the internal `setClassMetadata` call.\n * @param wrapperParams Parameters to be set on the callback that wraps `setClassMetata`.\n * @param dependencyResolverFn Function to resolve the deferred dependencies.\n */\nfunction internalCompileSetClassMetadataAsync(\n  metadata: R3ClassMetadata,\n  wrapperParams: o.FnParam[],\n  dependencyResolverFn: o.Expression,\n): o.Expression {\n  // Omit the wrapper since it'll be added around `setClassMetadataAsync` instead.\n  const setClassMetadataCall = internalCompileClassMetadata(metadata);\n  const setClassMetaWrapper = o.arrowFn(wrapperParams, [setClassMetadataCall.toStmt()]);\n  const setClassMetaAsync = o\n    .importExpr(R3.setClassMetadataAsync)\n    .callFn([metadata.type, dependencyResolverFn, setClassMetaWrapper]);\n\n  return o.arrowFn([], [devOnlyGuardedExpression(setClassMetaAsync).toStmt()]).callFn([]);\n}\n\n/**\n * Compiles the function that loads the dependencies for the\n * entire component in `setClassMetadataAsync`.\n */\nexport function compileComponentMetadataAsyncResolver(\n  dependencies: R3DeferPerComponentDependency[],\n): o.ArrowFunctionExpr {\n  const dynamicImports = dependencies.map(({symbolName, importPath, isDefaultImport}) => {\n    // e.g. `(m) => m.CmpA`\n    const innerFn =\n      // Default imports are always accessed through the `default` property.\n      o.arrowFn(\n        [new o.FnParam('m', o.DYNAMIC_TYPE)],\n        o.variable('m').prop(isDefaultImport ? 'default' : symbolName),\n      );\n\n    // e.g. `import('./cmp-a').then(...)`\n    return new o.DynamicImportExpr(importPath).prop('then').callFn([innerFn]);\n  });\n\n  // e.g. `() => [ ... ];`\n  return o.arrowFn([], o.literalArr(dynamicImports));\n}\n"]}