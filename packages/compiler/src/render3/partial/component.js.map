{"version":3,"file":"component.js","sourceRoot":"","sources":["component.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as core from '../../core';\nimport {DEFAULT_INTERPOLATION_CONFIG} from '../../ml_parser/defaults';\nimport * as o from '../../output/output_ast';\nimport {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../parse_util';\nimport {RecursiveVisitor, visitAll} from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {generateForwardRef, R3CompiledExpression} from '../util';\nimport {\n  DeclarationListEmitMode,\n  DeferBlockDepsEmitMode,\n  R3ComponentMetadata,\n  R3TemplateDependencyKind,\n  R3TemplateDependencyMetadata,\n} from '../view/api';\nimport {createComponentType} from '../view/compiler';\nimport {ParsedTemplate} from '../view/template';\nimport {DefinitionMap} from '../view/util';\n\nimport {\n  R3DeclareComponentMetadata,\n  R3DeclareDirectiveDependencyMetadata,\n  R3DeclareNgModuleDependencyMetadata,\n  R3DeclarePipeDependencyMetadata,\n} from './api';\nimport {createDirectiveDefinitionMap} from './directive';\nimport {toOptionalLiteralArray} from './util';\n\nexport interface DeclareComponentTemplateInfo {\n  /**\n   * The string contents of the template.\n   *\n   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n   */\n  content: string;\n\n  /**\n   * A full path to the file which contains the template.\n   *\n   * This can be either the original .ts file if the template is inline, or the .html file if an\n   * external file was used.\n   */\n  sourceUrl: string;\n\n  /**\n   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n   */\n  isInline: boolean;\n\n  /**\n   * If the template was defined inline by a direct string literal, then this is that literal\n   * expression. Otherwise `null`, if the template was not defined inline or was not a literal.\n   */\n  inlineTemplateLiteralExpression: o.Expression | null;\n}\n\n/**\n * Compile a component declaration defined by the `R3ComponentMetadata`.\n */\nexport function compileDeclareComponentFromMetadata(\n  meta: R3ComponentMetadata<R3TemplateDependencyMetadata>,\n  template: ParsedTemplate,\n  additionalTemplateInfo: DeclareComponentTemplateInfo,\n): R3CompiledExpression {\n  const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n\n  const expression = o.importExpr(R3.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a component into a `DefinitionMap`.\n */\nexport function createComponentDefinitionMap(\n  meta: R3ComponentMetadata<R3TemplateDependencyMetadata>,\n  template: ParsedTemplate,\n  templateInfo: DeclareComponentTemplateInfo,\n): DefinitionMap<R3DeclareComponentMetadata> {\n  const definitionMap: DefinitionMap<R3DeclareComponentMetadata> =\n    createDirectiveDefinitionMap(meta);\n  const blockVisitor = new BlockPresenceVisitor();\n  visitAll(blockVisitor, template.nodes);\n\n  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n\n  if (templateInfo.isInline) {\n    definitionMap.set('isInline', o.literal(true));\n  }\n\n  // Set the minVersion to 17.0.0 if the component is using at least one block in its template.\n  // We don't do this for templates without blocks, in order to preserve backwards compatibility.\n  if (blockVisitor.hasBlocks) {\n    definitionMap.set('minVersion', o.literal('17.0.0'));\n  }\n\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, o.literal));\n  definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n\n  if (meta.changeDetection !== null) {\n    if (typeof meta.changeDetection === 'object') {\n      throw new Error('Impossible state! Change detection flag is not resolved!');\n    }\n\n    definitionMap.set(\n      'changeDetection',\n      o\n        .importExpr(R3.ChangeDetectionStrategy)\n        .prop(core.ChangeDetectionStrategy[meta.changeDetection]),\n    );\n  }\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set(\n      'encapsulation',\n      o.importExpr(R3.ViewEncapsulation).prop(core.ViewEncapsulation[meta.encapsulation]),\n    );\n  }\n  if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n    definitionMap.set(\n      'interpolation',\n      o.literalArr([o.literal(meta.interpolation.start), o.literal(meta.interpolation.end)]),\n    );\n  }\n\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', o.literal(true));\n  }\n\n  if (meta.defer.mode === DeferBlockDepsEmitMode.PerBlock) {\n    const resolvers: o.Expression[] = [];\n    let hasResolvers = false;\n\n    for (const deps of meta.defer.blocks.values()) {\n      // Note: we need to push a `null` even if there are no dependencies, because matching of\n      // defer resolver functions to defer blocks happens by index and not adding an array\n      // entry for a block can throw off the blocks coming after it.\n      if (deps === null) {\n        resolvers.push(o.literal(null));\n      } else {\n        resolvers.push(deps);\n        hasResolvers = true;\n      }\n    }\n    // If *all* the resolvers are null, we can skip the field.\n    if (hasResolvers) {\n      definitionMap.set('deferBlockDependencies', o.literalArr(resolvers));\n    }\n  } else {\n    throw new Error('Unsupported defer function emit mode in partial compilation');\n  }\n\n  return definitionMap;\n}\n\nfunction getTemplateExpression(\n  template: ParsedTemplate,\n  templateInfo: DeclareComponentTemplateInfo,\n): o.Expression {\n  // If the template has been defined using a direct literal, we use that expression directly\n  // without any modifications. This is ensures proper source mapping from the partially\n  // compiled code to the source file declaring the template. Note that this does not capture\n  // template literals referenced indirectly through an identifier.\n  if (templateInfo.inlineTemplateLiteralExpression !== null) {\n    return templateInfo.inlineTemplateLiteralExpression;\n  }\n\n  // If the template is defined inline but not through a literal, the template has been resolved\n  // through static interpretation. We create a literal but cannot provide any source span. Note\n  // that we cannot use the expression defining the template because the linker expects the template\n  // to be defined as a literal in the declaration.\n  if (templateInfo.isInline) {\n    return o.literal(templateInfo.content, null, null);\n  }\n\n  // The template is external so we must synthesize an expression node with\n  // the appropriate source-span.\n  const contents = templateInfo.content;\n  const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n  const start = new ParseLocation(file, 0, 0, 0);\n  const end = computeEndLocation(file, contents);\n  const span = new ParseSourceSpan(start, end);\n  return o.literal(contents, null, span);\n}\n\nfunction computeEndLocation(file: ParseSourceFile, contents: string): ParseLocation {\n  const length = contents.length;\n  let lineStart = 0;\n  let lastLineStart = 0;\n  let line = 0;\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\n\nfunction compileUsedDependenciesMetadata(\n  meta: R3ComponentMetadata<R3TemplateDependencyMetadata>,\n): o.LiteralArrayExpr | null {\n  const wrapType =\n    meta.declarationListEmitMode !== DeclarationListEmitMode.Direct\n      ? generateForwardRef\n      : (expr: o.Expression) => expr;\n\n  if (meta.declarationListEmitMode === DeclarationListEmitMode.RuntimeResolved) {\n    throw new Error(`Unsupported emit mode`);\n  }\n\n  return toOptionalLiteralArray(meta.declarations, (decl) => {\n    switch (decl.kind) {\n      case R3TemplateDependencyKind.Directive:\n        const dirMeta = new DefinitionMap<R3DeclareDirectiveDependencyMetadata>();\n        dirMeta.set('kind', o.literal(decl.isComponent ? 'component' : 'directive'));\n        dirMeta.set('type', wrapType(decl.type));\n        dirMeta.set('selector', o.literal(decl.selector));\n        dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, o.literal));\n        dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, o.literal));\n        dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, o.literal));\n        return dirMeta.toLiteralMap();\n      case R3TemplateDependencyKind.Pipe:\n        const pipeMeta = new DefinitionMap<R3DeclarePipeDependencyMetadata>();\n        pipeMeta.set('kind', o.literal('pipe'));\n        pipeMeta.set('type', wrapType(decl.type));\n        pipeMeta.set('name', o.literal(decl.name));\n        return pipeMeta.toLiteralMap();\n      case R3TemplateDependencyKind.NgModule:\n        const ngModuleMeta = new DefinitionMap<R3DeclareNgModuleDependencyMetadata>();\n        ngModuleMeta.set('kind', o.literal('ngmodule'));\n        ngModuleMeta.set('type', wrapType(decl.type));\n        return ngModuleMeta.toLiteralMap();\n    }\n  });\n}\n\nclass BlockPresenceVisitor extends RecursiveVisitor {\n  hasBlocks = false;\n\n  override visitDeferredBlock(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitDeferredBlockPlaceholder(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitDeferredBlockLoading(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitDeferredBlockError(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitIfBlock(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitIfBlockBranch(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitForLoopBlock(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitForLoopBlockEmpty(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitSwitchBlock(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitSwitchBlockCase(): void {\n    this.hasBlocks = true;\n  }\n}\n"]}