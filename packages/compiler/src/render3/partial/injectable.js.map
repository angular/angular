{"version":3,"file":"injectable.js","sourceRoot":"","sources":["injectable.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {createInjectableType, R3InjectableMetadata} from '../../injectable_compiler_2';\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareInjectableMetadata} from './api';\nimport {compileDependency} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\n/**\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\n */\nexport function compileDeclareInjectableFromMetadata(\n  meta: R3InjectableMetadata,\n): R3CompiledExpression {\n  const definitionMap = createInjectableDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectableType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\n */\nexport function createInjectableDefinitionMap(\n  meta: R3InjectableMetadata,\n): DefinitionMap<R3DeclareInjectableMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareInjectableMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('0.0.0-PLACEHOLDER'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.type.value);\n\n  // Only generate providedIn property if it has a non-null value\n  if (meta.providedIn !== undefined) {\n    const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n    if ((providedIn as o.LiteralExpr).value !== null) {\n      definitionMap.set('providedIn', providedIn);\n    }\n  }\n\n  if (meta.useClass !== undefined) {\n    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n  }\n  if (meta.useExisting !== undefined) {\n    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n  }\n  if (meta.useValue !== undefined) {\n    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n  }\n  // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n  // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n  // with `convertFromProviderExpression()`.\n  if (meta.useFactory !== undefined) {\n    definitionMap.set('useFactory', meta.useFactory);\n  }\n\n  if (meta.deps !== undefined) {\n    definitionMap.set('deps', o.literalArr(meta.deps.map(compileDependency)));\n  }\n\n  return definitionMap;\n}\n"]}