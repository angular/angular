{"version":3,"file":"r3_control_flow.js","sourceRoot":"","sources":["r3_control_flow.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ASTWithSource, EmptyExpr} from '../expression_parser/ast';\nimport * as html from '../ml_parser/ast';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\nimport {BindingParser} from '../template_parser/binding_parser';\n\nimport * as t from './r3_ast';\n\n/** Pattern for the expression in a for loop block. */\nconst FOR_LOOP_EXPRESSION_PATTERN = /^\\s*([0-9A-Za-z_$]*)\\s+of\\s+([\\S\\s]*)/;\n\n/** Pattern for the tracking expression in a for loop block. */\nconst FOR_LOOP_TRACK_PATTERN = /^track\\s+([\\S\\s]*)/;\n\n/** Pattern for the `as` expression in a conditional block. */\nconst CONDITIONAL_ALIAS_PATTERN = /^(as\\s+)(.*)/;\n\n/** Pattern used to identify an `else if` block. */\nconst ELSE_IF_PATTERN = /^else[^\\S\\r\\n]+if/;\n\n/** Pattern used to identify a `let` parameter. */\nconst FOR_LOOP_LET_PATTERN = /^let\\s+([\\S\\s]*)/;\n\n/** Pattern used to validate a JavaScript identifier. */\nconst IDENTIFIER_PATTERN = /^[$A-Z_][0-9A-Z_$]*$/i;\n\n/**\n * Pattern to group a string into leading whitespace, non whitespace, and trailing whitespace.\n * Useful for getting the variable name span when a span can contain leading and trailing space.\n */\nconst CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN = /(\\s*)(\\S+)(\\s*)/;\n\n/** Names of variables that are allowed to be used in the `let` expression of a `for` loop. */\nconst ALLOWED_FOR_LOOP_LET_VARIABLES = new Set([\n  '$index',\n  '$first',\n  '$last',\n  '$even',\n  '$odd',\n  '$count',\n]);\n\n/**\n * Predicate function that determines if a block with\n * a specific name cam be connected to a `for` block.\n */\nexport function isConnectedForLoopBlock(name: string): boolean {\n  return name === 'empty';\n}\n\n/**\n * Predicate function that determines if a block with\n * a specific name cam be connected to an `if` block.\n */\nexport function isConnectedIfLoopBlock(name: string): boolean {\n  return name === 'else' || ELSE_IF_PATTERN.test(name);\n}\n\n/** Creates an `if` loop block from an HTML AST node. */\nexport function createIfBlock(\n  ast: html.Block,\n  connectedBlocks: html.Block[],\n  visitor: html.Visitor,\n  bindingParser: BindingParser,\n): {node: t.IfBlock | null; errors: ParseError[]} {\n  const errors: ParseError[] = validateIfConnectedBlocks(connectedBlocks);\n  const branches: t.IfBlockBranch[] = [];\n  const mainBlockParams = parseConditionalBlockParameters(ast, errors, bindingParser);\n\n  if (mainBlockParams !== null) {\n    branches.push(\n      new t.IfBlockBranch(\n        mainBlockParams.expression,\n        html.visitAll(visitor, ast.children, ast.children),\n        mainBlockParams.expressionAlias,\n        ast.sourceSpan,\n        ast.startSourceSpan,\n        ast.endSourceSpan,\n        ast.nameSpan,\n        ast.i18n,\n      ),\n    );\n  }\n\n  for (const block of connectedBlocks) {\n    if (ELSE_IF_PATTERN.test(block.name)) {\n      const params = parseConditionalBlockParameters(block, errors, bindingParser);\n\n      if (params !== null) {\n        const children = html.visitAll(visitor, block.children, block.children);\n        branches.push(\n          new t.IfBlockBranch(\n            params.expression,\n            children,\n            params.expressionAlias,\n            block.sourceSpan,\n            block.startSourceSpan,\n            block.endSourceSpan,\n            block.nameSpan,\n            block.i18n,\n          ),\n        );\n      }\n    } else if (block.name === 'else') {\n      const children = html.visitAll(visitor, block.children, block.children);\n      branches.push(\n        new t.IfBlockBranch(\n          null,\n          children,\n          null,\n          block.sourceSpan,\n          block.startSourceSpan,\n          block.endSourceSpan,\n          block.nameSpan,\n          block.i18n,\n        ),\n      );\n    }\n  }\n\n  // The outer IfBlock should have a span that encapsulates all branches.\n  const ifBlockStartSourceSpan =\n    branches.length > 0 ? branches[0].startSourceSpan : ast.startSourceSpan;\n  const ifBlockEndSourceSpan =\n    branches.length > 0 ? branches[branches.length - 1].endSourceSpan : ast.endSourceSpan;\n\n  let wholeSourceSpan = ast.sourceSpan;\n  const lastBranch = branches[branches.length - 1];\n  if (lastBranch !== undefined) {\n    wholeSourceSpan = new ParseSourceSpan(ifBlockStartSourceSpan.start, lastBranch.sourceSpan.end);\n  }\n\n  return {\n    node: new t.IfBlock(\n      branches,\n      wholeSourceSpan,\n      ast.startSourceSpan,\n      ifBlockEndSourceSpan,\n      ast.nameSpan,\n    ),\n    errors,\n  };\n}\n\n/** Creates a `for` loop block from an HTML AST node. */\nexport function createForLoop(\n  ast: html.Block,\n  connectedBlocks: html.Block[],\n  visitor: html.Visitor,\n  bindingParser: BindingParser,\n): {node: t.ForLoopBlock | null; errors: ParseError[]} {\n  const errors: ParseError[] = [];\n  const params = parseForLoopParameters(ast, errors, bindingParser);\n  let node: t.ForLoopBlock | null = null;\n  let empty: t.ForLoopBlockEmpty | null = null;\n\n  for (const block of connectedBlocks) {\n    if (block.name === 'empty') {\n      if (empty !== null) {\n        errors.push(new ParseError(block.sourceSpan, '@for loop can only have one @empty block'));\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.sourceSpan, '@empty block cannot have parameters'));\n      } else {\n        empty = new t.ForLoopBlockEmpty(\n          html.visitAll(visitor, block.children, block.children),\n          block.sourceSpan,\n          block.startSourceSpan,\n          block.endSourceSpan,\n          block.nameSpan,\n          block.i18n,\n        );\n      }\n    } else {\n      errors.push(new ParseError(block.sourceSpan, `Unrecognized @for loop block \"${block.name}\"`));\n    }\n  }\n\n  if (params !== null) {\n    if (params.trackBy === null) {\n      // TODO: We should not fail here, and instead try to produce some AST for the language\n      // service.\n      errors.push(new ParseError(ast.startSourceSpan, '@for loop must have a \"track\" expression'));\n    } else {\n      // The `for` block has a main span that includes the `empty` branch. For only the span of the\n      // main `for` body, use `mainSourceSpan`.\n      const endSpan = empty?.endSourceSpan ?? ast.endSourceSpan;\n      const sourceSpan = new ParseSourceSpan(\n        ast.sourceSpan.start,\n        endSpan?.end ?? ast.sourceSpan.end,\n      );\n      node = new t.ForLoopBlock(\n        params.itemName,\n        params.expression,\n        params.trackBy.expression,\n        params.trackBy.keywordSpan,\n        params.context,\n        html.visitAll(visitor, ast.children, ast.children),\n        empty,\n        sourceSpan,\n        ast.sourceSpan,\n        ast.startSourceSpan,\n        endSpan,\n        ast.nameSpan,\n        ast.i18n,\n      );\n    }\n  }\n\n  return {node, errors};\n}\n\n/** Creates a switch block from an HTML AST node. */\nexport function createSwitchBlock(\n  ast: html.Block,\n  visitor: html.Visitor,\n  bindingParser: BindingParser,\n): {node: t.SwitchBlock | null; errors: ParseError[]} {\n  const errors = validateSwitchBlock(ast);\n  const primaryExpression =\n    ast.parameters.length > 0\n      ? parseBlockParameterToBinding(ast.parameters[0], bindingParser)\n      : bindingParser.parseBinding('', false, ast.sourceSpan, 0);\n  const cases: t.SwitchBlockCase[] = [];\n  const unknownBlocks: t.UnknownBlock[] = [];\n  let defaultCase: t.SwitchBlockCase | null = null;\n\n  // Here we assume that all the blocks are valid given that we validated them above.\n  for (const node of ast.children) {\n    if (!(node instanceof html.Block)) {\n      continue;\n    }\n\n    if ((node.name !== 'case' || node.parameters.length === 0) && node.name !== 'default') {\n      unknownBlocks.push(new t.UnknownBlock(node.name, node.sourceSpan, node.nameSpan));\n      continue;\n    }\n\n    const expression =\n      node.name === 'case' ? parseBlockParameterToBinding(node.parameters[0], bindingParser) : null;\n    const ast = new t.SwitchBlockCase(\n      expression,\n      html.visitAll(visitor, node.children, node.children),\n      node.sourceSpan,\n      node.startSourceSpan,\n      node.endSourceSpan,\n      node.nameSpan,\n      node.i18n,\n    );\n\n    if (expression === null) {\n      defaultCase = ast;\n    } else {\n      cases.push(ast);\n    }\n  }\n\n  // Ensure that the default case is last in the array.\n  if (defaultCase !== null) {\n    cases.push(defaultCase);\n  }\n\n  return {\n    node: new t.SwitchBlock(\n      primaryExpression,\n      cases,\n      unknownBlocks,\n      ast.sourceSpan,\n      ast.startSourceSpan,\n      ast.endSourceSpan,\n      ast.nameSpan,\n    ),\n    errors,\n  };\n}\n\n/** Parses the parameters of a `for` loop block. */\nfunction parseForLoopParameters(\n  block: html.Block,\n  errors: ParseError[],\n  bindingParser: BindingParser,\n) {\n  if (block.parameters.length === 0) {\n    errors.push(new ParseError(block.startSourceSpan, '@for loop does not have an expression'));\n    return null;\n  }\n\n  const [expressionParam, ...secondaryParams] = block.parameters;\n  const match = stripOptionalParentheses(expressionParam, errors)?.match(\n    FOR_LOOP_EXPRESSION_PATTERN,\n  );\n\n  if (!match || match[2].trim().length === 0) {\n    errors.push(\n      new ParseError(\n        expressionParam.sourceSpan,\n        'Cannot parse expression. @for loop expression must match the pattern \"<identifier> of <expression>\"',\n      ),\n    );\n    return null;\n  }\n\n  const [, itemName, rawExpression] = match;\n  if (ALLOWED_FOR_LOOP_LET_VARIABLES.has(itemName)) {\n    errors.push(\n      new ParseError(\n        expressionParam.sourceSpan,\n        `@for loop item name cannot be one of ${Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES).join(\n          ', ',\n        )}.`,\n      ),\n    );\n  }\n\n  // `expressionParam.expression` contains the variable declaration and the expression of the\n  // for...of statement, i.e. 'user of users' The variable of a ForOfStatement is _only_ the \"const\n  // user\" part and does not include \"of x\".\n  const variableName = expressionParam.expression.split(' ')[0];\n  const variableSpan = new ParseSourceSpan(\n    expressionParam.sourceSpan.start,\n    expressionParam.sourceSpan.start.moveBy(variableName.length),\n  );\n  const result = {\n    itemName: new t.Variable(itemName, '$implicit', variableSpan, variableSpan),\n    trackBy: null as {expression: ASTWithSource; keywordSpan: ParseSourceSpan} | null,\n    expression: parseBlockParameterToBinding(expressionParam, bindingParser, rawExpression),\n    context: Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES, (variableName) => {\n      // Give ambiently-available context variables empty spans at the end of\n      // the start of the `for` block, since they are not explicitly defined.\n      const emptySpanAfterForBlockStart = new ParseSourceSpan(\n        block.startSourceSpan.end,\n        block.startSourceSpan.end,\n      );\n      return new t.Variable(\n        variableName,\n        variableName,\n        emptySpanAfterForBlockStart,\n        emptySpanAfterForBlockStart,\n      );\n    }),\n  };\n\n  for (const param of secondaryParams) {\n    const letMatch = param.expression.match(FOR_LOOP_LET_PATTERN);\n\n    if (letMatch !== null) {\n      const variablesSpan = new ParseSourceSpan(\n        param.sourceSpan.start.moveBy(letMatch[0].length - letMatch[1].length),\n        param.sourceSpan.end,\n      );\n      parseLetParameter(\n        param.sourceSpan,\n        letMatch[1],\n        variablesSpan,\n        itemName,\n        result.context,\n        errors,\n      );\n      continue;\n    }\n\n    const trackMatch = param.expression.match(FOR_LOOP_TRACK_PATTERN);\n\n    if (trackMatch !== null) {\n      if (result.trackBy !== null) {\n        errors.push(\n          new ParseError(param.sourceSpan, '@for loop can only have one \"track\" expression'),\n        );\n      } else {\n        const expression = parseBlockParameterToBinding(param, bindingParser, trackMatch[1]);\n        if (expression.ast instanceof EmptyExpr) {\n          errors.push(\n            new ParseError(block.startSourceSpan, '@for loop must have a \"track\" expression'),\n          );\n        }\n        const keywordSpan = new ParseSourceSpan(\n          param.sourceSpan.start,\n          param.sourceSpan.start.moveBy('track'.length),\n        );\n        result.trackBy = {expression, keywordSpan};\n      }\n      continue;\n    }\n\n    errors.push(\n      new ParseError(param.sourceSpan, `Unrecognized @for loop parameter \"${param.expression}\"`),\n    );\n  }\n\n  return result;\n}\n\n/** Parses the `let` parameter of a `for` loop block. */\nfunction parseLetParameter(\n  sourceSpan: ParseSourceSpan,\n  expression: string,\n  span: ParseSourceSpan,\n  loopItemName: string,\n  context: t.Variable[],\n  errors: ParseError[],\n): void {\n  const parts = expression.split(',');\n  let startSpan = span.start;\n  for (const part of parts) {\n    const expressionParts = part.split('=');\n    const name = expressionParts.length === 2 ? expressionParts[0].trim() : '';\n    const variableName = expressionParts.length === 2 ? expressionParts[1].trim() : '';\n\n    if (name.length === 0 || variableName.length === 0) {\n      errors.push(\n        new ParseError(\n          sourceSpan,\n          `Invalid @for loop \"let\" parameter. Parameter should match the pattern \"<name> = <variable name>\"`,\n        ),\n      );\n    } else if (!ALLOWED_FOR_LOOP_LET_VARIABLES.has(variableName)) {\n      errors.push(\n        new ParseError(\n          sourceSpan,\n          `Unknown \"let\" parameter variable \"${variableName}\". The allowed variables are: ${Array.from(\n            ALLOWED_FOR_LOOP_LET_VARIABLES,\n          ).join(', ')}`,\n        ),\n      );\n    } else if (name === loopItemName) {\n      errors.push(\n        new ParseError(\n          sourceSpan,\n          `Invalid @for loop \"let\" parameter. Variable cannot be called \"${loopItemName}\"`,\n        ),\n      );\n    } else if (context.some((v) => v.name === name)) {\n      errors.push(\n        new ParseError(sourceSpan, `Duplicate \"let\" parameter variable \"${variableName}\"`),\n      );\n    } else {\n      const [, keyLeadingWhitespace, keyName] =\n        expressionParts[0].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n      const keySpan =\n        keyLeadingWhitespace !== undefined && expressionParts.length === 2\n          ? new ParseSourceSpan(\n              /* strip leading spaces */\n              startSpan.moveBy(keyLeadingWhitespace.length),\n              /* advance to end of the variable name */\n              startSpan.moveBy(keyLeadingWhitespace.length + keyName.length),\n            )\n          : span;\n\n      let valueSpan: ParseSourceSpan | undefined = undefined;\n      if (expressionParts.length === 2) {\n        const [, valueLeadingWhitespace, implicit] =\n          expressionParts[1].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n        valueSpan =\n          valueLeadingWhitespace !== undefined\n            ? new ParseSourceSpan(\n                startSpan.moveBy(expressionParts[0].length + 1 + valueLeadingWhitespace.length),\n                startSpan.moveBy(\n                  expressionParts[0].length + 1 + valueLeadingWhitespace.length + implicit.length,\n                ),\n              )\n            : undefined;\n      }\n      const sourceSpan = new ParseSourceSpan(keySpan.start, valueSpan?.end ?? keySpan.end);\n      context.push(new t.Variable(name, variableName, sourceSpan, keySpan, valueSpan));\n    }\n    startSpan = startSpan.moveBy(part.length + 1 /* add 1 to move past the comma */);\n  }\n}\n\n/**\n * Checks that the shape of the blocks connected to an\n * `@if` block is correct. Returns an array of errors.\n */\nfunction validateIfConnectedBlocks(connectedBlocks: html.Block[]): ParseError[] {\n  const errors: ParseError[] = [];\n  let hasElse = false;\n\n  for (let i = 0; i < connectedBlocks.length; i++) {\n    const block = connectedBlocks[i];\n\n    if (block.name === 'else') {\n      if (hasElse) {\n        errors.push(\n          new ParseError(block.startSourceSpan, 'Conditional can only have one @else block'),\n        );\n      } else if (connectedBlocks.length > 1 && i < connectedBlocks.length - 1) {\n        errors.push(\n          new ParseError(block.startSourceSpan, '@else block must be last inside the conditional'),\n        );\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.startSourceSpan, '@else block cannot have parameters'));\n      }\n      hasElse = true;\n    } else if (!ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(\n        new ParseError(block.startSourceSpan, `Unrecognized conditional block @${block.name}`),\n      );\n    }\n  }\n\n  return errors;\n}\n\n/** Checks that the shape of a `switch` block is valid. Returns an array of errors. */\nfunction validateSwitchBlock(ast: html.Block): ParseError[] {\n  const errors: ParseError[] = [];\n  let hasDefault = false;\n\n  if (ast.parameters.length !== 1) {\n    errors.push(\n      new ParseError(ast.startSourceSpan, '@switch block must have exactly one parameter'),\n    );\n    return errors;\n  }\n\n  for (const node of ast.children) {\n    // Skip over comments and empty text nodes inside the switch block.\n    // Empty text nodes can be used for formatting while comments don't affect the runtime.\n    if (\n      node instanceof html.Comment ||\n      (node instanceof html.Text && node.value.trim().length === 0)\n    ) {\n      continue;\n    }\n\n    if (!(node instanceof html.Block) || (node.name !== 'case' && node.name !== 'default')) {\n      errors.push(\n        new ParseError(node.sourceSpan, '@switch block can only contain @case and @default blocks'),\n      );\n      continue;\n    }\n\n    if (node.name === 'default') {\n      if (hasDefault) {\n        errors.push(\n          new ParseError(node.startSourceSpan, '@switch block can only have one @default block'),\n        );\n      } else if (node.parameters.length > 0) {\n        errors.push(new ParseError(node.startSourceSpan, '@default block cannot have parameters'));\n      }\n      hasDefault = true;\n    } else if (node.name === 'case' && node.parameters.length !== 1) {\n      errors.push(\n        new ParseError(node.startSourceSpan, '@case block must have exactly one parameter'),\n      );\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Parses a block parameter into a binding AST.\n * @param ast Block parameter that should be parsed.\n * @param bindingParser Parser that the expression should be parsed with.\n * @param part Specific part of the expression that should be parsed.\n */\nfunction parseBlockParameterToBinding(\n  ast: html.BlockParameter,\n  bindingParser: BindingParser,\n  part?: string,\n): ASTWithSource {\n  let start: number;\n  let end: number;\n\n  if (typeof part === 'string') {\n    // Note: `lastIndexOf` here should be enough to know the start index of the expression,\n    // because we know that it'll be at the end of the param. Ideally we could use the `d`\n    // flag when matching via regex and get the index from `match.indices`, but it's unclear\n    // if we can use it yet since it's a relatively new feature. See:\n    // https://github.com/tc39/proposal-regexp-match-indices\n    start = Math.max(0, ast.expression.lastIndexOf(part));\n    end = start + part.length;\n  } else {\n    start = 0;\n    end = ast.expression.length;\n  }\n\n  return bindingParser.parseBinding(\n    ast.expression.slice(start, end),\n    false,\n    ast.sourceSpan,\n    ast.sourceSpan.start.offset + start,\n  );\n}\n\n/** Parses the parameter of a conditional block (`if` or `else if`). */\nfunction parseConditionalBlockParameters(\n  block: html.Block,\n  errors: ParseError[],\n  bindingParser: BindingParser,\n) {\n  if (block.parameters.length === 0) {\n    errors.push(\n      new ParseError(block.startSourceSpan, 'Conditional block does not have an expression'),\n    );\n    return null;\n  }\n\n  const expression = parseBlockParameterToBinding(block.parameters[0], bindingParser);\n  let expressionAlias: t.Variable | null = null;\n\n  // Start from 1 since we processed the first parameter already.\n  for (let i = 1; i < block.parameters.length; i++) {\n    const param = block.parameters[i];\n    const aliasMatch = param.expression.match(CONDITIONAL_ALIAS_PATTERN);\n\n    // For now conditionals can only have an `as` parameter.\n    // We may want to rework this later if we add more.\n    if (aliasMatch === null) {\n      errors.push(\n        new ParseError(\n          param.sourceSpan,\n          `Unrecognized conditional parameter \"${param.expression}\"`,\n        ),\n      );\n    } else if (block.name !== 'if' && !ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(\n        new ParseError(\n          param.sourceSpan,\n          '\"as\" expression is only allowed on `@if` and `@else if` blocks',\n        ),\n      );\n    } else if (expressionAlias !== null) {\n      errors.push(\n        new ParseError(param.sourceSpan, 'Conditional can only have one \"as\" expression'),\n      );\n    } else {\n      const name = aliasMatch[2].trim();\n\n      if (IDENTIFIER_PATTERN.test(name)) {\n        const variableStart = param.sourceSpan.start.moveBy(aliasMatch[1].length);\n        const variableSpan = new ParseSourceSpan(variableStart, variableStart.moveBy(name.length));\n        expressionAlias = new t.Variable(name, name, variableSpan, variableSpan);\n      } else {\n        errors.push(\n          new ParseError(param.sourceSpan, '\"as\" expression must be a valid JavaScript identifier'),\n        );\n      }\n    }\n  }\n\n  return {expression, expressionAlias};\n}\n\n/** Strips optional parentheses around from a control from expression parameter. */\nfunction stripOptionalParentheses(param: html.BlockParameter, errors: ParseError[]): string | null {\n  const expression = param.expression;\n  const spaceRegex = /^\\s$/;\n  let openParens = 0;\n  let start = 0;\n  let end = expression.length - 1;\n\n  for (let i = 0; i < expression.length; i++) {\n    const char = expression[i];\n\n    if (char === '(') {\n      start = i + 1;\n      openParens++;\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n\n  if (openParens === 0) {\n    return expression;\n  }\n\n  for (let i = expression.length - 1; i > -1; i--) {\n    const char = expression[i];\n\n    if (char === ')') {\n      end = i;\n      openParens--;\n      if (openParens === 0) {\n        break;\n      }\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n\n  if (openParens !== 0) {\n    errors.push(new ParseError(param.sourceSpan, 'Unclosed parentheses in expression'));\n    return null;\n  }\n\n  return expression.slice(start, end);\n}\n"]}