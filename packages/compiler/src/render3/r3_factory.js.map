{"version":3,"file":"r3_factory.js","sourceRoot":"","sources":["r3_factory.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {FactoryTarget} from '../compiler_facade_interface';\nimport {InjectFlags} from '../core';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\n\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3ConstructorFactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the interface type being constructed.\n   */\n  type: R3Reference;\n\n  /** Number of arguments for the `type`. */\n  typeArgumentCount: number;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\n   * be inherited from `fnOrClass` which is interpreted as the current type. If this is `'invalid'`,\n   * then one or more of the parameters wasn't resolvable and any attempt to use these deps will\n   * result in a runtime error.\n   */\n  deps: R3DependencyMetadata[] | 'invalid' | null;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: FactoryTarget;\n}\n\nexport enum R3FactoryDelegateType {\n  Class = 0,\n  Function = 1,\n}\n\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType;\n  delegateDeps: R3DependencyMetadata[];\n}\n\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\n  expression: o.Expression;\n}\n\nexport type R3FactoryMetadata =\n  | R3ConstructorFactoryMetadata\n  | R3DelegatedFnOrClassMetadata\n  | R3ExpressionFactoryMetadata;\n\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   * Or `null` if the dependency could not be resolved - making it invalid.\n   */\n  token: o.Expression | null;\n\n  /**\n   * If an @Attribute decorator is present, this is the literal type of the attribute name, or\n   * the unknown type if no literal type is available (e.g. the attribute name is an expression).\n   * Otherwise it is null;\n   */\n  attributeNameType: o.Expression | null;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const t = o.variable('__ngFactoryType__');\n  let baseFactoryVar: o.ReadVarExpr | null = null;\n\n  // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n  const typeForCtor = !isDelegatedFactoryMetadata(meta)\n    ? new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.type.value)\n    : t;\n\n  let ctorExpr: o.Expression | null = null;\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new o.InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    baseFactoryVar = o.variable(`ɵ${meta.name}_BaseFactory`);\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n\n  const body: o.Statement[] = [];\n  let retExpr: o.Expression | null = null;\n\n  function makeConditionalFactory(nonCtorExpr: o.Expression): o.ReadVarExpr {\n    const r = o.variable('__ngConditionalFactory__');\n    body.push(new o.DeclareVarStmt(r.name, o.NULL_EXPR, o.INFERRED_TYPE));\n    const ctorStmt =\n      ctorExpr !== null\n        ? r.set(ctorExpr).toStmt()\n        : o.importExpr(R3.invalidFactory).callFn([]).toStmt();\n    body.push(o.ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedFactoryMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n    // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n    const factoryExpr = new (\n      meta.delegateType === R3FactoryDelegateType.Class ? o.InstantiateExpr : o.InvokeFunctionExpr\n    )(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n  if (retExpr === null) {\n    // The expression cannot be formed so render an `ɵɵinvalidFactory()` call.\n    body.push(o.importExpr(R3.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    // This factory uses a base factory, so call `ɵɵgetInheritedFactory()` to compute it.\n    const getInheritedFactoryCall = o.importExpr(R3.getInheritedFactory).callFn([meta.type.value]);\n    // Memoize the base factoryFn: `baseFactory || (baseFactory = ɵɵgetInheritedFactory(...))`\n    const baseFactory = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Or,\n      baseFactoryVar,\n      baseFactoryVar.set(getInheritedFactoryCall),\n    );\n    body.push(new o.ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    // This is straightforward factory, just return it.\n    body.push(new o.ReturnStatement(retExpr));\n  }\n\n  let factoryFn: o.Expression = o.fn(\n    [new o.FnParam(t.name, o.DYNAMIC_TYPE)],\n    body,\n    o.INFERRED_TYPE,\n    undefined,\n    `${meta.name}_Factory`,\n  );\n\n  if (baseFactoryVar !== null) {\n    // There is a base factory variable so wrap its declaration along with the factory function into\n    // an IIFE.\n    factoryFn = o\n      .arrowFn([], [new o.DeclareVarStmt(baseFactoryVar.name!), new o.ReturnStatement(factoryFn)])\n      .callFn([], /* sourceSpan */ undefined, /* pure */ true);\n  }\n\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n\nexport function createFactoryType(meta: R3FactoryMetadata) {\n  const ctorDepsType =\n    meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : o.NONE_TYPE;\n  return o.expressionType(\n    o.importExpr(R3.FactoryDeclaration, [\n      typeWithParameters(meta.type.type, meta.typeArgumentCount),\n      ctorDepsType,\n    ]),\n  );\n}\n\nfunction injectDependencies(deps: R3DependencyMetadata[], target: FactoryTarget): o.Expression[] {\n  return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\n\nfunction compileInjectDependency(\n  dep: R3DependencyMetadata,\n  target: FactoryTarget,\n  index: number,\n): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  if (dep.token === null) {\n    return o.importExpr(R3.invalidFactoryDep).callFn([o.literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    // Build up the injection flags according to the metadata.\n    const flags =\n      InjectFlags.Default |\n      (dep.self ? InjectFlags.Self : 0) |\n      (dep.skipSelf ? InjectFlags.SkipSelf : 0) |\n      (dep.host ? InjectFlags.Host : 0) |\n      (dep.optional ? InjectFlags.Optional : 0) |\n      (target === FactoryTarget.Pipe ? InjectFlags.ForPipe : 0);\n\n    // If this dependency is optional or otherwise has non-default flags, then additional\n    // parameters describing how to inject the dependency must be passed to the inject function\n    // that's being used.\n    let flagsParam: o.LiteralExpr | null =\n      flags !== InjectFlags.Default || dep.optional ? o.literal(flags) : null;\n\n    // Build up the arguments to the injectFn call.\n    const injectArgs = [dep.token];\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n    const injectFn = getInjectFn(target);\n    return o.importExpr(injectFn).callFn(injectArgs);\n  } else {\n    // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n    // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n    // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n    // we want to generate `ɵɵinjectAttribute(foo())`.\n    //\n    // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n    // typings.\n    return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n  }\n}\n\nfunction createCtorDepsType(deps: R3DependencyMetadata[]): o.Type {\n  let hasTypes = false;\n  const attributeTypes = deps.map((dep) => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return o.literal(null);\n    }\n  });\n\n  if (hasTypes) {\n    return o.expressionType(o.literalArr(attributeTypes));\n  } else {\n    return o.NONE_TYPE;\n  }\n}\n\nfunction createCtorDepType(dep: R3DependencyMetadata): o.LiteralMapExpr | null {\n  const entries: {key: string; quoted: boolean; value: o.Expression}[] = [];\n\n  if (dep.attributeNameType !== null) {\n    entries.push({key: 'attribute', value: dep.attributeNameType, quoted: false});\n  }\n  if (dep.optional) {\n    entries.push({key: 'optional', value: o.literal(true), quoted: false});\n  }\n  if (dep.host) {\n    entries.push({key: 'host', value: o.literal(true), quoted: false});\n  }\n  if (dep.self) {\n    entries.push({key: 'self', value: o.literal(true), quoted: false});\n  }\n  if (dep.skipSelf) {\n    entries.push({key: 'skipSelf', value: o.literal(true), quoted: false});\n  }\n\n  return entries.length > 0 ? o.literalMap(entries) : null;\n}\n\nexport function isDelegatedFactoryMetadata(\n  meta: R3FactoryMetadata,\n): meta is R3DelegatedFnOrClassMetadata {\n  return (meta as any).delegateType !== undefined;\n}\n\nexport function isExpressionFactoryMetadata(\n  meta: R3FactoryMetadata,\n): meta is R3ExpressionFactoryMetadata {\n  return (meta as any).expression !== undefined;\n}\n\nfunction getInjectFn(target: FactoryTarget): o.ExternalReference {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return R3.directiveInject;\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return R3.inject;\n  }\n}\n"]}