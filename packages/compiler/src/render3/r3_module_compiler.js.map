{"version":3,"file":"r3_module_compiler.js","sourceRoot":"","sources":["r3_module_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {R3DeclareNgModuleFacade} from '../compiler_facade_interface';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {jitOnlyGuardedExpression, R3CompiledExpression, R3Reference, refsToArray} from './util';\nimport {DefinitionMap} from './view/util';\n\n/**\n * How the selector scope of an NgModule (its declarations, imports, and exports) should be emitted\n * as a part of the NgModule definition.\n */\nexport enum R3SelectorScopeMode {\n  /**\n   * Emit the declarations inline into the module definition.\n   *\n   * This option is useful in certain contexts where it's known that JIT support is required. The\n   * tradeoff here is that this emit style prevents directives and pipes from being tree-shaken if\n   * they are unused, but the NgModule is used.\n   */\n  Inline,\n\n  /**\n   * Emit the declarations using a side effectful function call, `ɵɵsetNgModuleScope`, that is\n   * guarded with the `ngJitMode` flag.\n   *\n   * This form of emit supports JIT and can be optimized away if the `ngJitMode` flag is set to\n   * false, which allows unused directives and pipes to be tree-shaken.\n   */\n  SideEffect,\n\n  /**\n   * Don't generate selector scopes at all.\n   *\n   * This is useful for contexts where JIT support is known to be unnecessary.\n   */\n  Omit,\n}\n\n/**\n * The type of the NgModule meta data.\n * - Global: Used for full and partial compilation modes which mainly includes R3References.\n * - Local: Used for the local compilation mode which mainly includes the raw expressions as appears\n * in the NgModule decorator.\n */\nexport enum R3NgModuleMetadataKind {\n  Global,\n  Local,\n}\n\ninterface R3NgModuleMetadataCommon {\n  kind: R3NgModuleMetadataKind;\n\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: R3Reference;\n\n  /**\n   * How to emit the selector scope values (declarations, imports, exports).\n   */\n  selectorScopeMode: R3SelectorScopeMode;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas: R3Reference[] | null;\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id: o.Expression | null;\n}\n\n/**\n * Metadata required by the module compiler in full/partial mode to generate a module def (`ɵmod`)\n * for a type.\n */\nexport interface R3NgModuleMetadataGlobal extends R3NgModuleMetadataCommon {\n  kind: R3NgModuleMetadataKind.Global;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * Those declarations which should be visible to downstream consumers. If not specified, all\n   * declarations are made visible to downstream consumers.\n   */\n  publicDeclarationTypes: o.Expression[] | null;\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * Whether or not to include `imports` in generated type declarations.\n   */\n  includeImportTypes: boolean;\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * Whether to generate closure wrappers for bootstrap, declarations, imports, and exports.\n   */\n  containsForwardDecls: boolean;\n}\n\n/**\n * Metadata required by the module compiler in local mode to generate a module def (`ɵmod`) for a\n * type.\n */\nexport interface R3NgModuleMetadataLocal extends R3NgModuleMetadataCommon {\n  kind: R3NgModuleMetadataKind.Local;\n\n  /**\n   * The output expression representing the bootstrap components specified by the module.\n   */\n  bootstrapExpression: o.Expression | null;\n\n  /**\n   * The output expression representing the declarations of the module.\n   */\n  declarationsExpression: o.Expression | null;\n\n  /**\n   * The output expression representing the imports of the module.\n   */\n  importsExpression: o.Expression | null;\n\n  /**\n   * The output expression representing the exports of the module.\n   */\n  exportsExpression: o.Expression | null;\n\n  /**\n   * Local compilation mode always requires scope to be handled using side effect function calls.\n   */\n  selectorScopeMode: R3SelectorScopeMode.SideEffect;\n}\n\n/**\n * Metadata required by the module compiler to generate a module def (`ɵmod`) for a type.\n */\nexport type R3NgModuleMetadata = R3NgModuleMetadataGlobal | R3NgModuleMetadataLocal;\n\n/**\n * The shape of the object literal that is passed to the `ɵɵdefineNgModule()` call.\n */\ninterface R3NgModuleDefMap {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the bootstrap components\n   * specified by the module.\n   */\n  bootstrap?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the directives and pipes\n   * declared by the module.\n   */\n  declarations?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the imports of the module.\n   */\n  imports?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the exports of the module.\n   */\n  exports?: o.Expression;\n  /**\n   * A literal array expression containing the schemas that declare elements to be allowed in the\n   * NgModule.\n   */\n  schemas?: o.LiteralArrayExpr;\n  /**\n   * An expression evaluating to the unique ID of an NgModule.\n   * */\n  id?: o.Expression;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const statements: o.Statement[] = [];\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', meta.type.value);\n\n  // Assign bootstrap definition. In local compilation mode (i.e., for\n  // `R3NgModuleMetadataKind.LOCAL`) we assign the bootstrap field using the runtime\n  // `ɵɵsetNgModuleScope`.\n  if (meta.kind === R3NgModuleMetadataKind.Global && meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n\n  if (meta.selectorScopeMode === R3SelectorScopeMode.Inline) {\n    // If requested to emit scope information inline, pass the `declarations`, `imports` and\n    // `exports` to the `ɵɵdefineNgModule()` call directly.\n\n    if (meta.declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n\n    if (meta.imports.length > 0) {\n      definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n\n    if (meta.exports.length > 0) {\n      definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else if (meta.selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n    // In this mode, scope information is not passed into `ɵɵdefineNgModule` as it\n    // would prevent tree-shaking of the declarations, imports and exports references. Instead, it's\n    // patched onto the NgModule definition with a `ɵɵsetNgModuleScope` call that's guarded by the\n    // `ngJitMode` flag.\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  } else {\n    // Selector scope emit was not requested, so skip it.\n  }\n\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(meta.schemas.map((ref) => ref.value)));\n  }\n\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n\n    // Generate a side-effectful call to register this NgModule by its id, as per the semantics of\n    // NgModule ids.\n    statements.push(\n      o.importExpr(R3.registerNgModuleType).callFn([meta.type.value, meta.id]).toStmt(),\n    );\n  }\n\n  const expression = o\n    .importExpr(R3.defineNgModule)\n    .callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements};\n}\n\n/**\n * This function is used in JIT mode to generate the call to `ɵɵdefineNgModule()` from a call to\n * `ɵɵngDeclareNgModule()`.\n */\nexport function compileNgModuleDeclarationExpression(meta: R3DeclareNgModuleFacade): o.Expression {\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', new o.WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new o.WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new o.WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new o.WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new o.WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new o.WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new o.WrappedNodeExpr(meta.id));\n  }\n  return o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\n\nexport function createNgModuleType(meta: R3NgModuleMetadata): o.ExpressionType {\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    return new o.ExpressionType(meta.type.value);\n  }\n\n  const {\n    type: moduleType,\n    declarations,\n    exports,\n    imports,\n    includeImportTypes,\n    publicDeclarationTypes,\n  } = meta;\n\n  return new o.ExpressionType(\n    o.importExpr(R3.NgModuleDeclaration, [\n      new o.ExpressionType(moduleType.type),\n      publicDeclarationTypes === null\n        ? tupleTypeOf(declarations)\n        : tupleOfTypes(publicDeclarationTypes),\n      includeImportTypes ? tupleTypeOf(imports) : o.NONE_TYPE,\n      tupleTypeOf(exports),\n    ]),\n  );\n}\n\n/**\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement | null {\n  const scopeMap = new DefinitionMap<{\n    declarations: o.Expression;\n    imports: o.Expression;\n    exports: o.Expression;\n    bootstrap: o.Expression;\n  }>();\n\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.declarations.length > 0) {\n      scopeMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.declarationsExpression) {\n      scopeMap.set('declarations', meta.declarationsExpression);\n    }\n  }\n\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.imports.length > 0) {\n      scopeMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.importsExpression) {\n      scopeMap.set('imports', meta.importsExpression);\n    }\n  }\n\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.exports.length > 0) {\n      scopeMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.exportsExpression) {\n      scopeMap.set('exports', meta.exportsExpression);\n    }\n  }\n\n  if (meta.kind === R3NgModuleMetadataKind.Local && meta.bootstrapExpression) {\n    scopeMap.set('bootstrap', meta.bootstrapExpression);\n  }\n\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n\n  // setNgModuleScope(...)\n  const fnCall = new o.InvokeFunctionExpr(\n    /* fn */ o.importExpr(R3.setNgModuleScope),\n    /* args */ [meta.type.value, scopeMap.toLiteralMap()],\n  );\n\n  // (ngJitMode guard) && setNgModuleScope(...)\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n\n  // function() { (ngJitMode guard) && setNgModuleScope(...); }\n  const iife = new o.FunctionExpr(/* params */ [], /* statements */ [guardedCall.toStmt()]);\n\n  // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n  const iifeCall = new o.InvokeFunctionExpr(/* fn */ iife, /* args */ []);\n\n  return iifeCall.toStmt();\n}\n\nfunction tupleTypeOf(exp: R3Reference[]): o.Type {\n  const types = exp.map((ref) => o.typeofExpr(ref.type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}\n\nfunction tupleOfTypes(types: o.Expression[]): o.Type {\n  const typeofTypes = types.map((type) => o.typeofExpr(type));\n  return types.length > 0 ? o.expressionType(o.literalArr(typeofTypes)) : o.NONE_TYPE;\n}\n"]}