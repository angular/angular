{"version":3,"file":"binding_parser.js","sourceRoot":"","sources":["binding_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../core';\nimport {\n  AbsoluteSourceSpan,\n  AST,\n  ASTWithSource,\n  BindingType,\n  BoundElementProperty,\n  Call,\n  EmptyExpr,\n  ImplicitReceiver,\n  KeyedRead,\n  NonNullAssert,\n  ParenthesizedExpression,\n  ParsedEvent,\n  ParsedEventType,\n  ParsedProperty,\n  ParsedPropertyType,\n  ParsedVariable,\n  PropertyRead,\n  SafeKeyedRead,\n  SafePropertyRead,\n  TemplateBinding,\n  ThisReceiver,\n  VariableBinding,\n} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/defaults';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from '../ml_parser/tokens';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../directive_matching';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst ANIMATE_PREFIX = 'animate';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst LEGACY_ANIMATE_PROP_PREFIX = 'animate-';\n\nexport interface HostProperties {\n  [key: string]: string;\n}\n\nexport interface HostListeners {\n  [key: string]: string;\n}\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  constructor(\n    private _exprParser: Parser,\n    private _interpolationConfig: InterpolationConfig,\n    private _schemaRegistry: ElementSchemaRegistry,\n    public errors: ParseError[],\n  ) {}\n\n  get interpolationConfig(): InterpolationConfig {\n    return this._interpolationConfig;\n  }\n\n  createBoundHostProperties(\n    properties: HostProperties,\n    sourceSpan: ParseSourceSpan,\n  ): ParsedProperty[] | null {\n    const boundProps: ParsedProperty[] = [];\n    for (const propName of Object.keys(properties)) {\n      const expression = properties[propName];\n      if (typeof expression === 'string') {\n        this.parsePropertyBinding(\n          propName,\n          expression,\n          true,\n          false,\n          sourceSpan,\n          sourceSpan.start.offset,\n          undefined,\n          [],\n          // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n          // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n          // source of the host binding (which doesn't exist in the template). Regardless,\n          // neither of these values are used in Ivy but are only here to satisfy the function\n          // signature. This should likely be refactored in the future so that `sourceSpan`\n          // isn't being used inaccurately.\n          boundProps,\n          sourceSpan,\n        );\n      } else {\n        this._reportError(\n          `Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n          sourceSpan,\n        );\n      }\n    }\n    return boundProps;\n  }\n\n  createDirectiveHostEventAsts(\n    hostListeners: HostListeners,\n    sourceSpan: ParseSourceSpan,\n  ): ParsedEvent[] | null {\n    const targetEvents: ParsedEvent[] = [];\n    for (const propName of Object.keys(hostListeners)) {\n      const expression = hostListeners[propName];\n      if (typeof expression === 'string') {\n        // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n        // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n        // rather than the source of the host binding (which doesn't exist in the template).\n        // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n        // function signature. This should likely be refactored in the future so that `sourceSpan`\n        // isn't being used inaccurately.\n        this.parseEvent(\n          propName,\n          expression,\n          /* isAssignmentEvent */ false,\n          sourceSpan,\n          sourceSpan,\n          [],\n          targetEvents,\n          sourceSpan,\n        );\n      } else {\n        this._reportError(\n          `Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n          sourceSpan,\n        );\n      }\n    }\n    return targetEvents;\n  }\n\n  parseInterpolation(\n    value: string,\n    sourceSpan: ParseSourceSpan,\n    interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null,\n  ): ASTWithSource {\n    const absoluteOffset = sourceSpan.fullStart.offset;\n\n    try {\n      const ast = this._exprParser.parseInterpolation(\n        value,\n        sourceSpan,\n        absoluteOffset,\n        interpolatedTokens,\n        this._interpolationConfig,\n      )!;\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(expression: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const absoluteOffset = sourceSpan.start.offset;\n\n    try {\n      const ast = this._exprParser.parseInterpolationExpression(\n        expression,\n        sourceSpan,\n        absoluteOffset,\n      );\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, and converts them to\n   * `ParsedProperty` or `ParsedVariable`.\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteValueOffset start of the tplValue relative to the entire template\n   * @param targetMatchableAttrs potential attributes to match in the template\n   * @param targetProps target property bindings in the template\n   * @param targetVars target variables in the template\n   */\n  parseInlineTemplateBinding(\n    tplKey: string,\n    tplValue: string,\n    sourceSpan: ParseSourceSpan,\n    absoluteValueOffset: number,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n    targetVars: ParsedVariable[],\n    isIvyAst: boolean,\n  ) {\n    const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\n    const bindings = this._parseTemplateBindings(\n      tplKey,\n      tplValue,\n      sourceSpan,\n      absoluteKeyOffset,\n      absoluteValueOffset,\n    );\n\n    for (const binding of bindings) {\n      // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n      // binding within the microsyntax expression so it's more narrow than sourceSpan.\n      const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n      const key = binding.key.source;\n      const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n      if (binding instanceof VariableBinding) {\n        const value = binding.value ? binding.value.source : '$implicit';\n        const valueSpan = binding.value\n          ? moveParseSourceSpan(sourceSpan, binding.value.span)\n          : undefined;\n        targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n      } else if (binding.value) {\n        const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n        const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n        this._parsePropertyAst(\n          key,\n          binding.value,\n          false,\n          srcSpan,\n          keySpan,\n          valueSpan,\n          targetMatchableAttrs,\n          targetProps,\n        );\n      } else {\n        targetMatchableAttrs.push([key, '' /* value */]);\n        // Since this is a literal attribute with no RHS, source span should be\n        // just the key span.\n        this.parseLiteralAttr(\n          key,\n          null /* value */,\n          keySpan,\n          absoluteValueOffset,\n          undefined /* valueSpan */,\n          targetMatchableAttrs,\n          targetProps,\n          keySpan,\n        );\n      }\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, e.g.\n   * ```html\n   *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n   * ```\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteKeyOffset start of the `tplKey`\n   * @param absoluteValueOffset start of the `tplValue`\n   */\n  private _parseTemplateBindings(\n    tplKey: string,\n    tplValue: string,\n    sourceSpan: ParseSourceSpan,\n    absoluteKeyOffset: number,\n    absoluteValueOffset: number,\n  ): TemplateBinding[] {\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(\n        tplKey,\n        tplValue,\n        sourceSpan,\n        absoluteKeyOffset,\n        absoluteValueOffset,\n      );\n      bindingsResult.errors.forEach((e) => this.errors.push(e));\n      bindingsResult.warnings.forEach((warning) => {\n        this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n      });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n    name: string,\n    value: string | null,\n    sourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n    keySpan: ParseSourceSpan,\n  ) {\n    if (isLegacyAnimationLabel(name)) {\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n          keySpan,\n          new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset),\n        );\n      }\n      if (value) {\n        this._reportError(\n          `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n            ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n          sourceSpan,\n          ParseErrorLevel.ERROR,\n        );\n      }\n      this._parseLegacyAnimation(\n        name,\n        value,\n        sourceSpan,\n        absoluteOffset,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n    } else {\n      targetProps.push(\n        new ParsedProperty(\n          name,\n          this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset),\n          ParsedPropertyType.LITERAL_ATTR,\n          sourceSpan,\n          keySpan,\n          valueSpan,\n        ),\n      );\n    }\n  }\n\n  parsePropertyBinding(\n    name: string,\n    expression: string,\n    isHost: boolean,\n    isPartOfAssignmentBinding: boolean,\n    sourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n    keySpan: ParseSourceSpan,\n  ) {\n    if (name.length === 0) {\n      this._reportError(`Property name is missing in binding`, sourceSpan);\n    }\n\n    let isLegacyAnimationProp = false;\n    if (name.startsWith(LEGACY_ANIMATE_PROP_PREFIX)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(LEGACY_ANIMATE_PROP_PREFIX.length);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n          keySpan,\n          new AbsoluteSourceSpan(\n            keySpan.start.offset + LEGACY_ANIMATE_PROP_PREFIX.length,\n            keySpan.end.offset,\n          ),\n        );\n      }\n    } else if (isLegacyAnimationLabel(name)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n          keySpan,\n          new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset),\n        );\n      }\n    }\n\n    if (isLegacyAnimationProp) {\n      this._parseLegacyAnimation(\n        name,\n        expression,\n        sourceSpan,\n        absoluteOffset,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n    } else if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      this._parseAnimation(\n        name,\n        this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset),\n        sourceSpan,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n    } else {\n      this._parsePropertyAst(\n        name,\n        this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset),\n        isPartOfAssignmentBinding,\n        sourceSpan,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n    }\n  }\n\n  parsePropertyInterpolation(\n    name: string,\n    value: string,\n    sourceSpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n    keySpan: ParseSourceSpan,\n    interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null,\n  ): boolean {\n    const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);\n    if (expr) {\n      this._parsePropertyAst(\n        name,\n        expr,\n        false,\n        sourceSpan,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n    name: string,\n    ast: ASTWithSource,\n    isPartOfAssignmentBinding: boolean,\n    sourceSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n  ) {\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(\n      new ParsedProperty(\n        name,\n        ast,\n        isPartOfAssignmentBinding ? ParsedPropertyType.TWO_WAY : ParsedPropertyType.DEFAULT,\n        sourceSpan,\n        keySpan,\n        valueSpan,\n      ),\n    );\n  }\n\n  private _parseAnimation(\n    name: string,\n    ast: ASTWithSource,\n    sourceSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n  ) {\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(\n      new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan),\n    );\n  }\n\n  private _parseLegacyAnimation(\n    name: string,\n    expression: string | null,\n    sourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    keySpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n  ) {\n    if (name.length === 0) {\n      this._reportError('Animation trigger is missing', sourceSpan);\n    }\n\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this.parseBinding(\n      expression || 'undefined',\n      false,\n      valueSpan || sourceSpan,\n      absoluteOffset,\n    );\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(\n      new ParsedProperty(\n        name,\n        ast,\n        ParsedPropertyType.LEGACY_ANIMATION,\n        sourceSpan,\n        keySpan,\n        valueSpan,\n      ),\n    );\n  }\n\n  parseBinding(\n    value: string,\n    isHostBinding: boolean,\n    sourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n  ): ASTWithSource {\n    try {\n      const ast = isHostBinding\n        ? this._exprParser.parseSimpleBinding(\n            value,\n            sourceSpan,\n            absoluteOffset,\n            this._interpolationConfig,\n          )\n        : this._exprParser.parseBinding(\n            value,\n            sourceSpan,\n            absoluteOffset,\n            this._interpolationConfig,\n          );\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n\n  createBoundElementProperty(\n    elementSelector: string | null,\n    boundProp: ParsedProperty,\n    skipValidation: boolean = false,\n    mapPropertyName: boolean = true,\n  ): BoundElementProperty {\n    if (boundProp.isLegacyAnimation) {\n      return new BoundElementProperty(\n        boundProp.name,\n        BindingType.LegacyAnimation,\n        SecurityContext.NONE,\n        boundProp.expression,\n        null,\n        boundProp.sourceSpan,\n        boundProp.keySpan,\n        boundProp.valueSpan,\n      );\n    }\n\n    let unit: string | null = null;\n    let bindingType: BindingType = undefined!;\n    let boundPropertyName: string | null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined!;\n\n    // Check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        }\n        securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry,\n          elementSelector,\n          boundPropertyName,\n          true,\n        );\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      } else if (parts[0] == ANIMATE_PREFIX) {\n        boundPropertyName = boundProp.name;\n        bindingType = BindingType.Animation;\n        securityContexts = [SecurityContext.NONE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n      securityContexts = calcPossibleSecurityContexts(\n        this._schemaRegistry,\n        elementSelector,\n        mappedPropName,\n        false,\n      );\n      bindingType =\n        boundProp.type === ParsedPropertyType.TWO_WAY ? BindingType.TwoWay : BindingType.Property;\n      if (!skipValidation) {\n        this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n      }\n    }\n\n    return new BoundElementProperty(\n      boundPropertyName,\n      bindingType,\n      securityContexts[0],\n      boundProp.expression,\n      unit,\n      boundProp.sourceSpan,\n      boundProp.keySpan,\n      boundProp.valueSpan,\n    );\n  }\n\n  parseEvent(\n    name: string,\n    expression: string,\n    isAssignmentEvent: boolean,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    targetMatchableAttrs: string[][],\n    targetEvents: ParsedEvent[],\n    keySpan: ParseSourceSpan,\n  ) {\n    if (name.length === 0) {\n      this._reportError(`Event name is missing in binding`, sourceSpan);\n    }\n\n    if (isLegacyAnimationLabel(name)) {\n      name = name.slice(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n          keySpan,\n          new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset),\n        );\n      }\n      this._parseLegacyAnimationEvent(\n        name,\n        expression,\n        sourceSpan,\n        handlerSpan,\n        targetEvents,\n        keySpan,\n      );\n    } else {\n      this._parseRegularEvent(\n        name,\n        expression,\n        isAssignmentEvent,\n        sourceSpan,\n        handlerSpan,\n        targetMatchableAttrs,\n        targetEvents,\n        keySpan,\n      );\n    }\n  }\n\n  calcPossibleSecurityContexts(\n    selector: string,\n    propName: string,\n    isAttribute: boolean,\n  ): SecurityContext[] {\n    const prop = this._schemaRegistry.getMappedPropName(propName);\n    return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n  }\n\n  parseEventListenerName(rawName: string): {eventName: string; target: string | null} {\n    const [target, eventName] = splitAtColon(rawName, [null, rawName]);\n    return {eventName: eventName!, target};\n  }\n\n  parseLegacyAnimationEventName(rawName: string): {eventName: string; phase: string | null} {\n    const matches = splitAtPeriod(rawName, [rawName, null]);\n    return {eventName: matches[0]!, phase: matches[1] === null ? null : matches[1].toLowerCase()};\n  }\n\n  private _parseLegacyAnimationEvent(\n    name: string,\n    expression: string,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    targetEvents: ParsedEvent[],\n    keySpan: ParseSourceSpan,\n  ) {\n    const {eventName, phase} = this.parseLegacyAnimationEventName(name);\n    const ast = this._parseAction(expression, handlerSpan);\n    targetEvents.push(\n      new ParsedEvent(\n        eventName,\n        phase,\n        ParsedEventType.LegacyAnimation,\n        ast,\n        sourceSpan,\n        handlerSpan,\n        keySpan,\n      ),\n    );\n\n    if (eventName.length === 0) {\n      this._reportError(`Animation event name is missing in binding`, sourceSpan);\n    }\n    if (phase) {\n      if (phase !== 'start' && phase !== 'done') {\n        this._reportError(\n          `The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`,\n          sourceSpan,\n        );\n      }\n    } else {\n      this._reportError(\n        `The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`,\n        sourceSpan,\n      );\n    }\n  }\n\n  private _parseRegularEvent(\n    name: string,\n    expression: string,\n    isAssignmentEvent: boolean,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    targetMatchableAttrs: string[][],\n    targetEvents: ParsedEvent[],\n    keySpan: ParseSourceSpan,\n  ): void {\n    // long format: 'target: eventName'\n    const {eventName, target} = this.parseEventListenerName(name);\n    const prevErrorCount = this.errors.length;\n    const ast = this._parseAction(expression, handlerSpan);\n    const isValid = this.errors.length === prevErrorCount;\n    targetMatchableAttrs.push([name!, ast.source!]);\n\n    // Don't try to validate assignment events if there were other\n    // parsing errors to avoid adding more noise to the error logs.\n    if (isAssignmentEvent && isValid && !this._isAllowedAssignmentEvent(ast)) {\n      this._reportError('Unsupported expression in a two-way binding', sourceSpan);\n    }\n\n    let eventType = ParsedEventType.Regular;\n    if (isAssignmentEvent) {\n      eventType = ParsedEventType.TwoWay;\n    }\n    if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      eventType = ParsedEventType.Animation;\n    }\n\n    targetEvents.push(\n      new ParsedEvent(eventName, target, eventType, ast, sourceSpan, handlerSpan, keySpan),\n    );\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;\n\n    try {\n      const ast = this._exprParser.parseAction(\n        value,\n        sourceSpan,\n        absoluteOffset,\n        this._interpolationConfig,\n      );\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n\n  private _reportError(\n    message: string,\n    sourceSpan: ParseSourceSpan,\n    level: ParseErrorLevel = ParseErrorLevel.ERROR,\n  ) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n    propName: string,\n    sourceSpan: ParseSourceSpan,\n    isAttr: boolean,\n  ): void {\n    const report = isAttr\n      ? this._schemaRegistry.validateAttribute(propName)\n      : this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg!, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n\n  /**\n   * Returns whether a parsed AST is allowed to be used within the event side of a two-way binding.\n   * @param ast Parsed AST to be checked.\n   */\n  private _isAllowedAssignmentEvent(ast: AST): boolean {\n    if (ast instanceof ASTWithSource) {\n      return this._isAllowedAssignmentEvent(ast.ast);\n    }\n\n    if (ast instanceof NonNullAssert) {\n      return this._isAllowedAssignmentEvent(ast.expression);\n    }\n\n    if (\n      ast instanceof Call &&\n      ast.args.length === 1 &&\n      ast.receiver instanceof PropertyRead &&\n      ast.receiver.name === '$any' &&\n      ast.receiver.receiver instanceof ImplicitReceiver &&\n      !(ast.receiver.receiver instanceof ThisReceiver)\n    ) {\n      return this._isAllowedAssignmentEvent(ast.args[0]);\n    }\n\n    if (ast instanceof PropertyRead || ast instanceof KeyedRead) {\n      if (!hasRecursiveSafeReceiver(ast)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasRecursiveSafeReceiver(ast: AST): boolean {\n  if (ast instanceof SafePropertyRead || ast instanceof SafeKeyedRead) {\n    return true;\n  }\n\n  if (ast instanceof ParenthesizedExpression) {\n    return hasRecursiveSafeReceiver(ast.expression);\n  }\n\n  if (ast instanceof PropertyRead || ast instanceof KeyedRead || ast instanceof Call) {\n    return hasRecursiveSafeReceiver(ast.receiver);\n  }\n\n  return false;\n}\n\nfunction isLegacyAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n  registry: ElementSchemaRegistry,\n  selector: string | null,\n  propName: string,\n  isAttribute: boolean,\n): SecurityContext[] {\n  let ctxs: SecurityContext[];\n  const nameToContext = (elName: string) => registry.securityContext(elName, propName, isAttribute);\n\n  if (selector === null) {\n    ctxs = registry.allKnownElementNames().map(nameToContext);\n  } else {\n    ctxs = [];\n    CssSelector.parse(selector).forEach((selector) => {\n      const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n      const notElementNames = new Set(\n        selector.notSelectors\n          .filter((selector) => selector.isElementSelector())\n          .map((selector) => selector.element),\n      );\n      const possibleElementNames = elementNames.filter((elName) => !notElementNames.has(elName));\n\n      ctxs.push(...possibleElementNames.map(nameToContext));\n    });\n  }\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\nfunction moveParseSourceSpan(\n  sourceSpan: ParseSourceSpan,\n  absoluteSpan: AbsoluteSourceSpan,\n): ParseSourceSpan {\n  // The difference of two absolute offsets provide the relative offset\n  const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(\n    sourceSpan.start.moveBy(startDiff),\n    sourceSpan.end.moveBy(endDiff),\n    sourceSpan.fullStart.moveBy(startDiff),\n    sourceSpan.details,\n  );\n}\n"]}