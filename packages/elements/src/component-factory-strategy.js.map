{"version":3,"file":"component-factory-strategy.js","sourceRoot":"","sources":["component-factory-strategy.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Needed for the global `Zone` ambient types to be available.\nimport type {} from 'zone.js';\n\nimport {\n  ApplicationRef,\n  ComponentFactory,\n  ComponentFactoryResolver,\n  ComponentRef,\n  EventEmitter,\n  Injector,\n  NgZone,\n  Type,\n  ɵChangeDetectionScheduler as ChangeDetectionScheduler,\n  ɵNotificationSource as NotificationSource,\n  ɵViewRef as ViewRef,\n  ɵisViewDirty as isViewDirty,\n  ɵmarkForRefresh as markForRefresh,\n  OutputRef,\n} from '@angular/core';\nimport {merge, Observable, ReplaySubject} from 'rxjs';\nimport {switchMap} from 'rxjs/operators';\n\nimport {\n  NgElementStrategy,\n  NgElementStrategyEvent,\n  NgElementStrategyFactory,\n} from './element-strategy';\nimport {extractProjectableNodes} from './extract-projectable-nodes';\nimport {scheduler} from './utils';\n\n/** Time in milliseconds to wait before destroying the component ref when disconnected. */\nconst DESTROY_DELAY = 10;\n\n/**\n * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the\n * constructor's injector's factory resolver and passes that factory to each strategy.\n */\nexport class ComponentNgElementStrategyFactory implements NgElementStrategyFactory {\n  componentFactory: ComponentFactory<any>;\n\n  inputMap = new Map<string, string>();\n\n  constructor(component: Type<any>, injector: Injector) {\n    this.componentFactory = injector\n      .get(ComponentFactoryResolver)\n      .resolveComponentFactory(component);\n    for (const input of this.componentFactory.inputs) {\n      this.inputMap.set(input.propName, input.templateName);\n    }\n  }\n\n  create(injector: Injector) {\n    return new ComponentNgElementStrategy(this.componentFactory, injector, this.inputMap);\n  }\n}\n\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n */\nexport class ComponentNgElementStrategy implements NgElementStrategy {\n  // Subject of `NgElementStrategyEvent` observables corresponding to the component's outputs.\n  private eventEmitters = new ReplaySubject<Observable<NgElementStrategyEvent>[]>(1);\n\n  /** Merged stream of the component's output events. */\n  readonly events = this.eventEmitters.pipe(switchMap((emitters) => merge(...emitters)));\n\n  /** Reference to the component that was created on connect. */\n  private componentRef: ComponentRef<any> | null = null;\n\n  /** Callback function that when called will cancel a scheduled destruction on the component. */\n  private scheduledDestroyFn: (() => void) | null = null;\n\n  /** Initial input values that were set before the component was created. */\n  private readonly initialInputValues = new Map<string, any>();\n\n  /** Service for setting zone context. */\n  private readonly ngZone: NgZone;\n\n  /** The zone the element was created in or `null` if Zone.js is not loaded. */\n  private readonly elementZone: Zone | null;\n\n  /**\n   * The `ApplicationRef` shared by all instances of this custom element (and potentially others).\n   */\n  private readonly appRef: ApplicationRef;\n\n  /**\n   * Angular's change detection scheduler, which works independently of zone.js.\n   */\n  private cdScheduler: ChangeDetectionScheduler;\n\n  constructor(\n    private componentFactory: ComponentFactory<any>,\n    private injector: Injector,\n    private inputMap: Map<string, string>,\n  ) {\n    this.ngZone = this.injector.get(NgZone);\n    this.appRef = this.injector.get(ApplicationRef);\n    this.cdScheduler = injector.get(ChangeDetectionScheduler);\n    this.elementZone = typeof Zone === 'undefined' ? null : this.ngZone.run(() => Zone.current);\n  }\n\n  /**\n   * Initializes a new component if one has not yet been created and cancels any scheduled\n   * destruction.\n   */\n  connect(element: HTMLElement) {\n    this.runInZone(() => {\n      // If the element is marked to be destroyed, cancel the task since the component was\n      // reconnected\n      if (this.scheduledDestroyFn !== null) {\n        this.scheduledDestroyFn();\n        this.scheduledDestroyFn = null;\n        return;\n      }\n\n      if (this.componentRef === null) {\n        this.initializeComponent(element);\n      }\n    });\n  }\n\n  /**\n   * Schedules the component to be destroyed after some small delay in case the element is just\n   * being moved across the DOM.\n   */\n  disconnect() {\n    this.runInZone(() => {\n      // Return if there is no componentRef or the component is already scheduled for destruction\n      if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n        return;\n      }\n\n      // Schedule the component to be destroyed after a small timeout in case it is being\n      // moved elsewhere in the DOM\n      this.scheduledDestroyFn = scheduler.schedule(() => {\n        if (this.componentRef !== null) {\n          this.componentRef.destroy();\n          this.componentRef = null;\n        }\n      }, DESTROY_DELAY);\n    });\n  }\n\n  /**\n   * Returns the component property value. If the component has not yet been created, the value is\n   * retrieved from the cached initialization values.\n   */\n  getInputValue(property: string): any {\n    return this.runInZone(() => {\n      if (this.componentRef === null) {\n        return this.initialInputValues.get(property);\n      }\n\n      return this.componentRef.instance[property];\n    });\n  }\n\n  /**\n   * Sets the input value for the property. If the component has not yet been created, the value is\n   * cached and set when the component is created.\n   */\n  setInputValue(property: string, value: any): void {\n    if (this.componentRef === null) {\n      this.initialInputValues.set(property, value);\n      return;\n    }\n\n    this.runInZone(() => {\n      this.componentRef!.setInput(this.inputMap.get(property) ?? property, value);\n\n      // `setInput` won't mark the view dirty if the input didn't change from its previous value.\n      if (isViewDirty(this.componentRef!.hostView as ViewRef<unknown>)) {\n        // `setInput` will have marked the view dirty already, but also mark it for refresh. This\n        // guarantees the view will be checked even if the input is being set from within change\n        // detection. This provides backwards compatibility, since we used to unconditionally\n        // schedule change detection in addition to the current zone run.\n        markForRefresh(this.componentRef!.changeDetectorRef as ViewRef<unknown>);\n\n        // Notifying the scheduler with `NotificationSource.CustomElement` causes a `tick()` to be\n        // scheduled unconditionally, even if the scheduler is otherwise disabled.\n        this.cdScheduler.notify(NotificationSource.CustomElement);\n      }\n    });\n  }\n\n  /**\n   * Creates a new component through the component factory with the provided element host and\n   * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n   */\n  protected initializeComponent(element: HTMLElement) {\n    const childInjector = Injector.create({providers: [], parent: this.injector});\n    const projectableNodes = extractProjectableNodes(\n      element,\n      this.componentFactory.ngContentSelectors,\n    );\n    this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n\n    this.initializeInputs();\n    this.initializeOutputs(this.componentRef);\n\n    this.appRef.attachView(this.componentRef.hostView);\n    this.componentRef.hostView.detectChanges();\n  }\n\n  /** Set any stored initial inputs on the component's properties. */\n  protected initializeInputs(): void {\n    for (const [propName, value] of this.initialInputValues) {\n      this.setInputValue(propName, value);\n    }\n\n    this.initialInputValues.clear();\n  }\n\n  /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n  protected initializeOutputs(componentRef: ComponentRef<any>): void {\n    const eventEmitters: Observable<NgElementStrategyEvent>[] = this.componentFactory.outputs.map(\n      ({propName, templateName}) => {\n        const emitter: EventEmitter<any> | OutputRef<any> = componentRef.instance[propName];\n        return new Observable((observer) => {\n          const sub = emitter.subscribe((value) => observer.next({name: templateName, value}));\n          return () => sub.unsubscribe();\n        });\n      },\n    );\n\n    this.eventEmitters.next(eventEmitters);\n  }\n\n  /** Runs in the angular zone, if present. */\n  private runInZone(fn: () => unknown) {\n    return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(fn) : fn();\n  }\n}\n"]}