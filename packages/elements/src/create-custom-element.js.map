{"version":3,"file":"create-custom-element.js","sourceRoot":"","sources":["create-custom-element.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, Type} from '@angular/core';\nimport {Subscription} from 'rxjs';\n\nimport {ComponentNgElementStrategyFactory} from './component-factory-strategy';\nimport {NgElementStrategy, NgElementStrategyFactory} from './element-strategy';\nimport {getComponentInputs, getDefaultAttributeToPropertyInputs} from './utils';\n\n/**\n * Prototype for a class constructor based on an Angular component\n * that can be used for custom element registration. Implemented and returned\n * by the {@link createCustomElement createCustomElement() function}.\n *\n * @see [Angular Elements Overview](guide/elements \"Turning Angular components into custom elements\")\n *\n * @publicApi\n */\nexport interface NgElementConstructor<P> {\n  /**\n   * An array of observed attribute names for the custom element,\n   * derived by transforming input property names from the source component.\n   */\n  readonly observedAttributes: string[];\n\n  /**\n   * Initializes a constructor instance.\n   * @param injector If provided, overrides the configured injector.\n   */\n  new (injector?: Injector): NgElement & WithProperties<P>;\n}\n\n/**\n * Implements the functionality needed for a custom element.\n *\n * @publicApi\n */\nexport abstract class NgElement extends HTMLElement {\n  /**\n   * The strategy that controls how a component is transformed in a custom element.\n   */\n  protected abstract ngElementStrategy: NgElementStrategy;\n  /**\n   * A subscription to change, connect, and disconnect events in the custom element.\n   */\n  protected ngElementEventsSubscription: Subscription | null = null;\n\n  /**\n   * Prototype for a handler that responds to a change in an observed attribute.\n   * @param attrName The name of the attribute that has changed.\n   * @param oldValue The previous value of the attribute.\n   * @param newValue The new value of the attribute.\n   * @param namespace The namespace in which the attribute is defined.\n   * @returns Nothing.\n   */\n  abstract attributeChangedCallback(\n    attrName: string,\n    oldValue: string | null,\n    newValue: string,\n    namespace?: string,\n  ): void;\n  /**\n   * Prototype for a handler that responds to the insertion of the custom element in the DOM.\n   * @returns Nothing.\n   */\n  abstract connectedCallback(): void;\n  /**\n   * Prototype for a handler that responds to the deletion of the custom element from the DOM.\n   * @returns Nothing.\n   */\n  abstract disconnectedCallback(): void;\n}\n\n/**\n * Additional type information that can be added to the NgElement class,\n * for properties that are added based\n * on the inputs and methods of the underlying component.\n *\n * @publicApi\n */\nexport type WithProperties<P> = {\n  [property in keyof P]: P[property];\n};\n\n/**\n * A configuration that initializes an NgElementConstructor with the\n * dependencies and strategy it needs to transform a component into\n * a custom element class.\n *\n * @publicApi\n */\nexport interface NgElementConfig {\n  /**\n   * The injector to use for retrieving the component's factory.\n   */\n  injector: Injector;\n  /**\n   * An optional custom strategy factory to use instead of the default.\n   * The strategy controls how the transformation is performed.\n   */\n  strategyFactory?: NgElementStrategyFactory;\n}\n\n/**\n *  @description Creates a custom element class based on an Angular component.\n *\n * Builds a class that encapsulates the functionality of the provided component and\n * uses the configuration information to provide more context to the class.\n * Takes the component factory's inputs and outputs to convert them to the proper\n * custom element API and add hooks to input changes.\n *\n * The configuration's injector is the initial injector set on the class,\n * and used by default for each created instance.This behavior can be overridden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations.\n *\n * @see [Angular Elements Overview](guide/elements \"Turning Angular components into custom elements\")\n *\n * @param component The component to transform.\n * @param config A configuration that provides initialization information to the created class.\n * @returns The custom-element construction class, which can be registered with\n * a browser's `CustomElementRegistry`.\n *\n * @publicApi\n */\nexport function createCustomElement<P>(\n  component: Type<any>,\n  config: NgElementConfig,\n): NgElementConstructor<P> {\n  const inputs = getComponentInputs(component, config.injector);\n\n  const strategyFactory =\n    config.strategyFactory || new ComponentNgElementStrategyFactory(component, config.injector);\n\n  const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);\n\n  class NgElementImpl extends NgElement {\n    // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static\n    // field externs. So using quoted access to explicitly prevent renaming.\n    static readonly ['observedAttributes'] = Object.keys(attributeToPropertyInputs);\n\n    protected override get ngElementStrategy(): NgElementStrategy {\n      // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For\n      // now this is tested using a Google internal test suite.\n      if (!this._ngElementStrategy) {\n        const strategy = (this._ngElementStrategy = strategyFactory.create(\n          this.injector || config.injector,\n        ));\n\n        // Re-apply pre-existing input values (set as properties on the element) through the\n        // strategy.\n        // TODO(alxhub): why are we doing this? this makes no sense.\n        inputs.forEach(({propName, transform}) => {\n          if (!this.hasOwnProperty(propName)) {\n            // No pre-existing value for `propName`.\n            return;\n          }\n\n          // Delete the property from the DOM node and re-apply it through the strategy.\n          const value = (this as any)[propName];\n          delete (this as any)[propName];\n          strategy.setInputValue(propName, value, transform);\n        });\n      }\n\n      return this._ngElementStrategy!;\n    }\n\n    private _ngElementStrategy?: NgElementStrategy;\n\n    constructor(private readonly injector?: Injector) {\n      super();\n    }\n\n    override attributeChangedCallback(\n      attrName: string,\n      oldValue: string | null,\n      newValue: string,\n      namespace?: string,\n    ): void {\n      const [propName, transform] = attributeToPropertyInputs[attrName]!;\n      this.ngElementStrategy.setInputValue(propName, newValue, transform);\n    }\n\n    override connectedCallback(): void {\n      // For historical reasons, some strategies may not have initialized the `events` property\n      // until after `connect()` is run. Subscribe to `events` if it is available before running\n      // `connect()` (in order to capture events emitted during initialization), otherwise subscribe\n      // afterwards.\n      //\n      // TODO: Consider deprecating/removing the post-connect subscription in a future major version\n      //       (e.g. v11).\n\n      let subscribedToEvents = false;\n\n      if (this.ngElementStrategy.events) {\n        // `events` are already available: Subscribe to it asap.\n        this.subscribeToEvents();\n        subscribedToEvents = true;\n      }\n\n      this.ngElementStrategy.connect(this);\n\n      if (!subscribedToEvents) {\n        // `events` were not initialized before running `connect()`: Subscribe to them now.\n        // The events emitted during the component initialization have been missed, but at least\n        // future events will be captured.\n        this.subscribeToEvents();\n      }\n    }\n\n    override disconnectedCallback(): void {\n      // Not using `this.ngElementStrategy` to avoid unnecessarily creating the `NgElementStrategy`.\n      if (this._ngElementStrategy) {\n        this._ngElementStrategy.disconnect();\n      }\n\n      if (this.ngElementEventsSubscription) {\n        this.ngElementEventsSubscription.unsubscribe();\n        this.ngElementEventsSubscription = null;\n      }\n    }\n\n    private subscribeToEvents(): void {\n      // Listen for events from the strategy and dispatch them as custom events.\n      this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe((e) => {\n        const customEvent = new CustomEvent(e.name, {detail: e.value});\n        this.dispatchEvent(customEvent);\n      });\n    }\n  }\n\n  // Add getters and setters to the prototype for each property input.\n  inputs.forEach(({propName, transform}) => {\n    Object.defineProperty(NgElementImpl.prototype, propName, {\n      get(): any {\n        return this.ngElementStrategy.getInputValue(propName);\n      },\n      set(newValue: any): void {\n        this.ngElementStrategy.setInputValue(propName, newValue, transform);\n      },\n      configurable: true,\n      enumerable: true,\n    });\n  });\n\n  return NgElementImpl as any as NgElementConstructor<P>;\n}\n"]}