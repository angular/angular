{"version":3,"file":"event_manager.js","sourceRoot":"","sources":["event_manager.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;AAEH,OAAO,EACL,MAAM,EACN,UAAU,EACV,cAAc,EAEd,aAAa,IAAI,YAAY,GAE9B,MAAM,eAAe,CAAC;AAIvB;;;;GAIG;AACH,MAAM,CAAC,MAAM,qBAAqB,GAAG,IAAI,cAAc,CACrD,OAAO,SAAS,KAAK,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC,EAAE,CACzE,CAAC;AAEF;;;;;GAKG;AAEI,IAAM,YAAY,GAAlB,MAAM,YAAY;IAIvB;;OAEG;IACH,YACiC,OAA6B,EACpD,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;QAPf,uBAAkB,GAAG,IAAI,GAAG,EAA8B,CAAC;QASjE,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YACzB,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC;QACxB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,KAAK,EAAE,CAAC,OAAO,EAAE,CAAC;IAC5C,CAAC;IAED;;;;;;;;;OASG;IACH,gBAAgB,CACd,OAAoB,EACpB,SAAiB,EACjB,OAAiB,EACjB,OAAyB;QAEzB,MAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;QAC9C,OAAO,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;IACvE,CAAC;IAED;;OAEG;IACH,OAAO;QACL,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,gBAAgB;IAChB,cAAc,CAAC,SAAiB;QAC9B,IAAI,MAAM,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACpD,IAAI,MAAM,EAAE,CAAC;YACX,OAAO,MAAM,CAAC;QAChB,CAAC;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC9B,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,MAAM,IAAI,YAAY,kDAEpB,CAAC,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,CAAC;gBAC7C,2CAA2C,SAAS,EAAE,CACzD,CAAC;QACJ,CAAC;QAED,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;QAC/C,OAAO,MAAM,CAAC;IAChB,CAAC;CACF,CAAA;AAhEY,YAAY;IADxB,UAAU,EAAE;IASR,WAAA,MAAM,CAAC,qBAAqB,CAAC,CAAA;GARrB,YAAY,CAgExB;;AAED;;;;;;;GAOG;AACH,MAAM,OAAgB,kBAAkB;IACtC,sCAAsC;IACtC,YAAoB,IAAS;QAAT,SAAI,GAAJ,IAAI,CAAK;IAAG,CAAC;CAmBlC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Inject,\n  Injectable,\n  InjectionToken,\n  NgZone,\n  ÉµRuntimeError as RuntimeError,\n  type ListenerOptions,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../errors';\n\n/**\n * The injection token for plugins of the `EventManager` service.\n *\n * @publicApi\n */\nexport const EVENT_MANAGER_PLUGINS = new InjectionToken<EventManagerPlugin[]>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'EventManagerPlugins' : '',\n);\n\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * @publicApi\n */\n@Injectable()\nexport class EventManager {\n  private _plugins: EventManagerPlugin[];\n  private _eventNameToPlugin = new Map<string, EventManagerPlugin>();\n\n  /**\n   * Initializes an instance of the event-manager service.\n   */\n  constructor(\n    @Inject(EVENT_MANAGER_PLUGINS) plugins: EventManagerPlugin[],\n    private _zone: NgZone,\n  ) {\n    plugins.forEach((plugin) => {\n      plugin.manager = this;\n    });\n    this._plugins = plugins.slice().reverse();\n  }\n\n  /**\n   * Registers a handler for a specific element and event.\n   *\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @param options Options that configure how the event listener is bound.\n   * @returns  A callback function that can be used to remove the handler.\n   */\n  addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: Function,\n    options?: ListenerOptions,\n  ): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addEventListener(element, eventName, handler, options);\n  }\n\n  /**\n   * Retrieves the compilation zone in which event listeners are registered.\n   */\n  getZone(): NgZone {\n    return this._zone;\n  }\n\n  /** @internal */\n  _findPluginFor(eventName: string): EventManagerPlugin {\n    let plugin = this._eventNameToPlugin.get(eventName);\n    if (plugin) {\n      return plugin;\n    }\n\n    const plugins = this._plugins;\n    plugin = plugins.find((plugin) => plugin.supports(eventName));\n    if (!plugin) {\n      throw new RuntimeError(\n        RuntimeErrorCode.NO_PLUGIN_FOR_EVENT,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `No event manager plugin found for event ${eventName}`,\n      );\n    }\n\n    this._eventNameToPlugin.set(eventName, plugin);\n    return plugin;\n  }\n}\n\n/**\n * The plugin definition for the `EventManager` class\n *\n * It can be used as a base class to create custom manager plugins, i.e. you can create your own\n * class that extends the `EventManagerPlugin` one.\n *\n * @publicApi\n */\nexport abstract class EventManagerPlugin {\n  // TODO: remove (has some usage in G3)\n  constructor(private _doc: any) {}\n\n  // Using non-null assertion because it's set by EventManager's constructor\n  manager!: EventManager;\n\n  /**\n   * Should return `true` for every event name that should be supported by this plugin\n   */\n  abstract supports(eventName: string): boolean;\n\n  /**\n   * Implement the behaviour for the supported events\n   */\n  abstract addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: Function,\n    options?: ListenerOptions,\n  ): Function;\n}\n"]}