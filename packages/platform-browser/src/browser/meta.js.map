{"version":3,"file":"meta.js","sourceRoot":"","sources":["meta.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT, ɵDomAdapter as DomAdapter, ɵgetDOM as getDOM} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\n\n/**\n * Represents the attributes of an HTML `<meta>` element. The element itself is\n * represented by the internal `HTMLMetaElement`.\n *\n * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)\n * @see {@link Meta}\n *\n * @publicApi\n */\nexport type MetaDefinition = {\n  charset?: string;\n  content?: string;\n  httpEquiv?: string;\n  id?: string;\n  itemprop?: string;\n  name?: string;\n  property?: string;\n  scheme?: string;\n  url?: string;\n} & {\n  // TODO(IgorMinar): this type looks wrong\n  [prop: string]: string;\n};\n\n/**\n * A service for managing HTML `<meta>` tags.\n *\n * Properties of the `MetaDefinition` object match the attributes of the\n * HTML `<meta>` tag. These tags define document metadata that is important for\n * things like configuring a Content Security Policy, defining browser compatibility\n * and security settings, setting HTTP Headers, defining rich content for social sharing,\n * and Search Engine Optimization (SEO).\n *\n * To identify specific `<meta>` tags in a document, use an attribute selection\n * string in the format `\"tag_attribute='value string'\"`.\n * For example, an `attrSelector` value of `\"name='description'\"` matches a tag\n * whose `name` attribute has the value `\"description\"`.\n * Selectors are used with the `querySelector()` Document method,\n * in the format `meta[{attrSelector}]`.\n *\n * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)\n * @see [Document.querySelector()](https://developer.mozilla.org/docs/Web/API/Document/querySelector)\n *\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class Meta {\n  private _dom: DomAdapter;\n  constructor(@Inject(DOCUMENT) private _doc: any) {\n    this._dom = getDOM();\n  }\n  /**\n   * Retrieves or creates a specific `<meta>` tag element in the current HTML document.\n   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n   * values in the provided tag definition, and verifies that all other attribute values are equal.\n   * If an existing element is found, it is returned and is not modified in any way.\n   * @param tag The definition of a `<meta>` element to match or create.\n   * @param forceCreation True to create a new element without checking whether one already exists.\n   * @returns The existing element with the same attributes and values if found,\n   * the new element if no match is found, or `null` if the tag parameter is not defined.\n   */\n  addTag(tag: MetaDefinition, forceCreation: boolean = false): HTMLMetaElement | null {\n    if (!tag) return null;\n    return this._getOrCreateElement(tag, forceCreation);\n  }\n\n  /**\n   * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.\n   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n   * values in the provided tag definition, and verifies that all other attribute values are equal.\n   * @param tags An array of tag definitions to match or create.\n   * @param forceCreation True to create new elements without checking whether they already exist.\n   * @returns The matching elements if found, or the new elements.\n   */\n  addTags(tags: MetaDefinition[], forceCreation: boolean = false): HTMLMetaElement[] {\n    if (!tags) return [];\n    return tags.reduce((result: HTMLMetaElement[], tag: MetaDefinition) => {\n      if (tag) {\n        result.push(this._getOrCreateElement(tag, forceCreation));\n      }\n      return result;\n    }, []);\n  }\n\n  /**\n   * Retrieves a `<meta>` tag element in the current HTML document.\n   * @param attrSelector The tag attribute and value to match against, in the format\n   * `\"tag_attribute='value string'\"`.\n   * @returns The matching element, if any.\n   */\n  getTag(attrSelector: string): HTMLMetaElement | null {\n    if (!attrSelector) return null;\n    return this._doc.querySelector(`meta[${attrSelector}]`) || null;\n  }\n\n  /**\n   * Retrieves a set of `<meta>` tag elements in the current HTML document.\n   * @param attrSelector The tag attribute and value to match against, in the format\n   * `\"tag_attribute='value string'\"`.\n   * @returns The matching elements, if any.\n   */\n  getTags(attrSelector: string): HTMLMetaElement[] {\n    if (!attrSelector) return [];\n    const list /*NodeList*/ = this._doc.querySelectorAll(`meta[${attrSelector}]`);\n    return list ? [].slice.call(list) : [];\n  }\n\n  /**\n   * Modifies an existing `<meta>` tag element in the current HTML document.\n   * @param tag The tag description with which to replace the existing tag content.\n   * @param selector A tag attribute and value to match against, to identify\n   * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n   * If not supplied, matches a tag with the same `name` or `property` attribute value as the\n   * replacement tag.\n   * @return The modified element.\n   */\n  updateTag(tag: MetaDefinition, selector?: string): HTMLMetaElement | null {\n    if (!tag) return null;\n    selector = selector || this._parseSelector(tag);\n    const meta: HTMLMetaElement = this.getTag(selector)!;\n    if (meta) {\n      return this._setMetaElementAttributes(tag, meta);\n    }\n    return this._getOrCreateElement(tag, true);\n  }\n\n  /**\n   * Removes an existing `<meta>` tag element from the current HTML document.\n   * @param attrSelector A tag attribute and value to match against, to identify\n   * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n   */\n  removeTag(attrSelector: string): void {\n    this.removeTagElement(this.getTag(attrSelector)!);\n  }\n\n  /**\n   * Removes an existing `<meta>` tag element from the current HTML document.\n   * @param meta The tag definition to match against to identify an existing tag.\n   */\n  removeTagElement(meta: HTMLMetaElement): void {\n    if (meta) {\n      this._dom.remove(meta);\n    }\n  }\n\n  private _getOrCreateElement(\n    meta: MetaDefinition,\n    forceCreation: boolean = false,\n  ): HTMLMetaElement {\n    if (!forceCreation) {\n      const selector: string = this._parseSelector(meta);\n      // It's allowed to have multiple elements with the same name so it's not enough to\n      // just check that element with the same name already present on the page. We also need to\n      // check if element has tag attributes\n      const elem = this.getTags(selector).filter((elem) => this._containsAttributes(meta, elem))[0];\n      if (elem !== undefined) return elem;\n    }\n    const element: HTMLMetaElement = this._dom.createElement('meta') as HTMLMetaElement;\n    this._setMetaElementAttributes(meta, element);\n    const head = this._doc.getElementsByTagName('head')[0];\n    head.appendChild(element);\n    return element;\n  }\n\n  private _setMetaElementAttributes(tag: MetaDefinition, el: HTMLMetaElement): HTMLMetaElement {\n    Object.keys(tag).forEach((prop: string) =>\n      el.setAttribute(this._getMetaKeyMap(prop), tag[prop]),\n    );\n    return el;\n  }\n\n  private _parseSelector(tag: MetaDefinition): string {\n    const attr: string = tag.name ? 'name' : 'property';\n    return `${attr}=\"${tag[attr]}\"`;\n  }\n\n  private _containsAttributes(tag: MetaDefinition, elem: HTMLMetaElement): boolean {\n    return Object.keys(tag).every(\n      (key: string) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key],\n    );\n  }\n\n  private _getMetaKeyMap(prop: string): string {\n    return META_KEYS_MAP[prop] || prop;\n  }\n}\n\n/**\n * Mapping for MetaDefinition properties with their correct meta attribute names\n */\nconst META_KEYS_MAP: {[prop: string]: string} = {\n  httpEquiv: 'http-equiv',\n};\n"]}