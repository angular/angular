{"version":3,"file":"jsonp.js","sourceRoot":"","sources":["jsonp.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '../../index';\nimport {\n  EnvironmentInjector,\n  Inject,\n  inject,\n  Injectable,\n  runInInjectionContext,\n  ÉµRuntimeError as RuntimeError,\n} from '@angular/core';\nimport {Observable, Observer} from 'rxjs';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpHandlerFn} from './interceptor';\nimport {HttpRequest} from './request';\nimport {\n  HTTP_STATUS_CODE_OK,\n  HttpErrorResponse,\n  HttpEvent,\n  HttpEventType,\n  HttpResponse,\n} from './response';\nimport {RuntimeErrorCode} from './errors';\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet nextRequestId: number = 0;\n\n/**\n * When a pending <script> is unsubscribed we'll move it to this document, so it won't be\n * executed.\n */\nlet foreignDocument: Document | undefined;\n\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nexport const JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nexport const JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nexport const JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n\n// Error text given when a request is passed to the JsonpClientBackend that has\n// headers set\nexport const JSONP_ERR_HEADERS_NOT_SUPPORTED = 'JSONP requests do not support headers.';\n\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n *\n * In the browser, this should always be the `window` object.\n *\n *\n */\nexport abstract class JsonpCallbackContext {\n  [key: string]: (data: any) => void;\n}\n\n/**\n * Factory function that determines where to store JSONP callbacks.\n *\n * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist\n * in test environments. In that case, callbacks are stored on an anonymous object instead.\n *\n *\n */\nexport function jsonpCallbackContext(): Object {\n  if (typeof window === 'object') {\n    return window;\n  }\n  return {};\n}\n\n/**\n * Processes an `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n * @see {@link HttpHandler}\n * @see {@link HttpXhrBackend}\n *\n * @publicApi\n */\n@Injectable()\nexport class JsonpClientBackend implements HttpBackend {\n  /**\n   * A resolved promise that can be used to schedule microtasks in the event handlers.\n   */\n  private readonly resolvedPromise = Promise.resolve();\n\n  constructor(\n    private callbackMap: JsonpCallbackContext,\n    @Inject(DOCUMENT) private document: any,\n  ) {}\n\n  /**\n   * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n   */\n  private nextCallback(): string {\n    return `ng_jsonp_callback_${nextRequestId++}`;\n  }\n\n  /**\n   * Processes a JSONP request and returns an event stream of the results.\n   * @param req The request object.\n   * @returns An observable of the response events.\n   *\n   */\n  handle(req: HttpRequest<never>): Observable<HttpEvent<any>> {\n    // Firstly, check both the method and response type. If either doesn't match\n    // then the request was improperly routed here and cannot be handled.\n    if (req.method !== 'JSONP') {\n      throw new RuntimeError(\n        RuntimeErrorCode.JSONP_WRONG_METHOD,\n        ngDevMode && JSONP_ERR_WRONG_METHOD,\n      );\n    } else if (req.responseType !== 'json') {\n      throw new RuntimeError(\n        RuntimeErrorCode.JSONP_WRONG_RESPONSE_TYPE,\n        ngDevMode && JSONP_ERR_WRONG_RESPONSE_TYPE,\n      );\n    }\n\n    // Check the request headers. JSONP doesn't support headers and\n    // cannot set any that were supplied.\n    if (req.headers.keys().length > 0) {\n      throw new RuntimeError(\n        RuntimeErrorCode.JSONP_HEADERS_NOT_SUPPORTED,\n        ngDevMode && JSONP_ERR_HEADERS_NOT_SUPPORTED,\n      );\n    }\n\n    // Everything else happens inside the Observable boundary.\n    return new Observable<HttpEvent<any>>((observer: Observer<HttpEvent<any>>) => {\n      // The first step to make a request is to generate the callback name, and replace the\n      // callback placeholder in the URL with the name. Care has to be taken here to ensure\n      // a trailing &, if matched, gets inserted back into the URL in the correct place.\n      const callback = this.nextCallback();\n      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n\n      // Construct the <script> tag and point it at the URL.\n      const node = this.document.createElement('script');\n      node.src = url;\n\n      // A JSONP request requires waiting for multiple callbacks. These variables\n      // are closed over and track state across those callbacks.\n\n      // The response object, if one has been received, or null otherwise.\n      let body: any | null = null;\n\n      // Whether the response callback has been called.\n      let finished: boolean = false;\n\n      // Set the response callback in this.callbackMap (which will be the window\n      // object in the browser. The script being loaded via the <script> tag will\n      // eventually call this callback.\n      this.callbackMap[callback] = (data?: any) => {\n        // Data has been received from the JSONP script. Firstly, delete this callback.\n        delete this.callbackMap[callback];\n\n        // Set state to indicate data was received.\n        body = data;\n        finished = true;\n      };\n\n      // cleanup() is a utility closure that removes the <script> from the page and\n      // the response callback from the window. This logic is used in both the\n      // success, error, and cancellation paths, so it's extracted out for convenience.\n      const cleanup = () => {\n        node.removeEventListener('load', onLoad);\n        node.removeEventListener('error', onError);\n\n        // Remove the <script> tag if it's still on the page.\n        node.remove();\n\n        // Remove the response callback from the callbackMap (window object in the\n        // browser).\n        delete this.callbackMap[callback];\n      };\n\n      // onLoad() is the success callback which runs after the response callback\n      // if the JSONP script loads successfully. The event itself is unimportant.\n      // If something went wrong, onLoad() may run without the response callback\n      // having been invoked.\n      const onLoad = () => {\n        // We wrap it in an extra Promise, to ensure the microtask\n        // is scheduled after the loaded endpoint has executed any potential microtask itself,\n        // which is not guaranteed in Internet Explorer and EdgeHTML. See issue #39496\n        this.resolvedPromise.then(() => {\n          // Cleanup the page.\n          cleanup();\n\n          // Check whether the response callback has run.\n          if (!finished) {\n            // It hasn't, something went wrong with the request. Return an error via\n            // the Observable error path. All JSONP errors have status 0.\n            observer.error(\n              new HttpErrorResponse({\n                url,\n                status: 0,\n                statusText: 'JSONP Error',\n                error: new Error(JSONP_ERR_NO_CALLBACK),\n              }),\n            );\n            return;\n          }\n\n          // Success. body either contains the response body or null if none was\n          // returned.\n          observer.next(\n            new HttpResponse({\n              body,\n              status: HTTP_STATUS_CODE_OK,\n              statusText: 'OK',\n              url,\n            }),\n          );\n\n          // Complete the stream, the response is over.\n          observer.complete();\n        });\n      };\n\n      // onError() is the error callback, which runs if the script returned generates\n      // a Javascript error. It emits the error via the Observable error channel as\n      // a HttpErrorResponse.\n      const onError = (error: Error) => {\n        cleanup();\n\n        // Wrap the error in a HttpErrorResponse.\n        observer.error(\n          new HttpErrorResponse({\n            error,\n            status: 0,\n            statusText: 'JSONP Error',\n            url,\n          }),\n        );\n      };\n\n      // Subscribe to both the success (load) and error events on the <script> tag,\n      // and add it to the page.\n      node.addEventListener('load', onLoad);\n      node.addEventListener('error', onError);\n      this.document.body.appendChild(node);\n\n      // The request has now been successfully sent.\n      observer.next({type: HttpEventType.Sent});\n\n      // Cancellation handler.\n      return () => {\n        if (!finished) {\n          this.removeListeners(node);\n        }\n\n        // And finally, clean up the page.\n        cleanup();\n      };\n    });\n  }\n\n  private removeListeners(script: HTMLScriptElement): void {\n    // Issue #34818\n    // Changing <script>'s ownerDocument will prevent it from execution.\n    // https://html.spec.whatwg.org/multipage/scripting.html#execute-the-script-block\n    foreignDocument ??= (this.document.implementation as DOMImplementation).createHTMLDocument();\n\n    foreignDocument.adoptNode(script);\n  }\n}\n\n/**\n * Identifies requests with the method JSONP and shifts them to the `JsonpClientBackend`.\n */\nexport function jsonpInterceptorFn(\n  req: HttpRequest<unknown>,\n  next: HttpHandlerFn,\n): Observable<HttpEvent<unknown>> {\n  if (req.method === 'JSONP') {\n    return inject(JsonpClientBackend).handle(req as HttpRequest<never>);\n  }\n\n  // Fall through for normal HTTP requests.\n  return next(req);\n}\n\n/**\n * Identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n *\n * @see {@link HttpInterceptor}\n *\n * @publicApi\n */\n@Injectable()\nexport class JsonpInterceptor {\n  constructor(private injector: EnvironmentInjector) {}\n\n  /**\n   * Identifies and handles a given JSONP request.\n   * @param initialRequest The outgoing request object to handle.\n   * @param next The next interceptor in the chain, or the backend\n   * if no interceptors remain in the chain.\n   * @returns An observable of the event stream.\n   */\n  intercept(initialRequest: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return runInInjectionContext(this.injector, () =>\n      jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)),\n    );\n  }\n}\n"]}