{"version":3,"file":"xhr.js","sourceRoot":"","sources":["xhr.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {XhrFactory} from '../../index';\nimport {\n  Injectable,\n  ɵRuntimeError as RuntimeError,\n  ɵformatRuntimeError as formatRuntimeError,\n} from '@angular/core';\nimport {from, Observable, Observer, of} from 'rxjs';\nimport {switchMap} from 'rxjs/operators';\n\nimport type {HttpBackend} from './backend';\nimport {RuntimeErrorCode} from './errors';\nimport {HttpHeaders} from './headers';\nimport {ACCEPT_HEADER, ACCEPT_HEADER_VALUE, CONTENT_TYPE_HEADER, HttpRequest} from './request';\nimport {\n  HTTP_STATUS_CODE_NO_CONTENT,\n  HTTP_STATUS_CODE_OK,\n  HttpDownloadProgressEvent,\n  HttpErrorResponse,\n  HttpEvent,\n  HttpEventType,\n  HttpHeaderResponse,\n  HttpJsonParseError,\n  HttpResponse,\n  HttpUploadProgressEvent,\n} from './response';\n\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n\n/**\n * Validates whether the request is compatible with the XHR backend.\n * Show a warning if the request contains options that are not supported by XHR.\n */\nfunction validateXhrCompatibility(req: HttpRequest<any>) {\n  const unsupportedOptions: {\n    property: keyof HttpRequest<any>;\n    errorCode: RuntimeErrorCode;\n  }[] = [\n    {\n      property: 'keepalive',\n      errorCode: RuntimeErrorCode.KEEPALIVE_NOT_SUPPORTED_WITH_XHR,\n    },\n    {\n      property: 'cache',\n      errorCode: RuntimeErrorCode.CACHE_NOT_SUPPORTED_WITH_XHR,\n    },\n    {\n      property: 'priority',\n      errorCode: RuntimeErrorCode.PRIORITY_NOT_SUPPORTED_WITH_XHR,\n    },\n    {\n      property: 'mode',\n      errorCode: RuntimeErrorCode.MODE_NOT_SUPPORTED_WITH_XHR,\n    },\n    {\n      property: 'redirect',\n      errorCode: RuntimeErrorCode.REDIRECT_NOT_SUPPORTED_WITH_XHR,\n    },\n    {\n      property: 'credentials',\n      errorCode: RuntimeErrorCode.CREDENTIALS_NOT_SUPPORTED_WITH_XHR,\n    },\n    {\n      property: 'integrity',\n      errorCode: RuntimeErrorCode.INTEGRITY_NOT_SUPPORTED_WITH_XHR,\n    },\n    {\n      property: 'referrer',\n      errorCode: RuntimeErrorCode.REFERRER_NOT_SUPPORTED_WITH_XHR,\n    },\n  ];\n\n  // Check each unsupported option and warn if present\n  for (const {property, errorCode} of unsupportedOptions) {\n    if (req[property]) {\n      console.warn(\n        formatRuntimeError(\n          errorCode,\n          `Angular detected that a \\`HttpClient\\` request with the \\`${property}\\` option was sent using XHR, which does not support it. To use the \\`${property}\\` option, enable Fetch API support by passing \\`withFetch()\\` as an argument to \\`provideHttpClient()\\`.`,\n        ),\n      );\n    }\n  }\n}\n\n/**\n * Uses `XMLHttpRequest` to send requests to a backend server.\n * @see {@link HttpHandler}\n * @see {@link JsonpClientBackend}\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class HttpXhrBackend implements HttpBackend {\n  constructor(private xhrFactory: XhrFactory) {}\n\n  /**\n   * Processes a request and returns a stream of response events.\n   * @param req The request object.\n   * @returns An observable of the response events.\n   */\n  handle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    // Quick check to give a better error message when a user attempts to use\n    // HttpClient.jsonp() without installing the HttpClientJsonpModule\n    if (req.method === 'JSONP') {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_JSONP_MODULE,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \\`withJsonpSupport()\\` call (if \\`provideHttpClient()\\` is used) or import the \\`HttpClientJsonpModule\\` in the root NgModule.`,\n      );\n    }\n\n    // Validate that the request is compatible with the XHR backend.\n    ngDevMode && validateXhrCompatibility(req);\n\n    // Check whether this factory has a special function to load an XHR implementation\n    // for various non-browser environments. We currently limit it to only `ServerXhr`\n    // class, which needs to load an XHR implementation.\n    const xhrFactory: XhrFactory & {ɵloadImpl?: () => Promise<void>} = this.xhrFactory;\n    const source: Observable<void | null> =\n      // Note that `ɵloadImpl` is never defined in client bundles and can be\n      // safely dropped whenever we're running in the browser.\n      // This branching is redundant.\n      // The `ngServerMode` guard also enables tree-shaking of the `from()`\n      // function from the common bundle, as it's only used in server code.\n      typeof ngServerMode !== 'undefined' && ngServerMode && xhrFactory.ɵloadImpl\n        ? from(xhrFactory.ɵloadImpl())\n        : of(null);\n\n    return source.pipe(\n      switchMap(() => {\n        // Everything happens on Observable subscription.\n        return new Observable((observer: Observer<HttpEvent<any>>) => {\n          // Start by setting up the XHR object with request method, URL, and withCredentials\n          // flag.\n          const xhr = xhrFactory.build();\n          xhr.open(req.method, req.urlWithParams);\n          if (req.withCredentials) {\n            xhr.withCredentials = true;\n          }\n\n          // Add all the requested headers.\n          req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n\n          // Add an Accept header if one isn't present already.\n          if (!req.headers.has(ACCEPT_HEADER)) {\n            xhr.setRequestHeader(ACCEPT_HEADER, ACCEPT_HEADER_VALUE);\n          }\n\n          // Auto-detect the Content-Type header if one isn't present already.\n          if (!req.headers.has(CONTENT_TYPE_HEADER)) {\n            const detectedType = req.detectContentTypeHeader();\n            // Sometimes Content-Type detection fails.\n            if (detectedType !== null) {\n              xhr.setRequestHeader(CONTENT_TYPE_HEADER, detectedType);\n            }\n          }\n\n          if (req.timeout) {\n            xhr.timeout = req.timeout;\n          }\n\n          // Set the responseType if one was requested.\n          if (req.responseType) {\n            const responseType = req.responseType.toLowerCase();\n\n            // JSON responses need to be processed as text. This is because if the server\n            // returns an XSSI-prefixed JSON response, the browser will fail to parse it,\n            // xhr.response will be null, and xhr.responseText cannot be accessed to\n            // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON\n            // is parsed by first requesting text and then applying JSON.parse.\n            xhr.responseType = (responseType !== 'json' ? responseType : 'text') as any;\n          }\n\n          // Serialize the request body if one is present. If not, this will be set to null.\n          const reqBody = req.serializeBody();\n\n          // If progress events are enabled, response headers will be delivered\n          // in two events - the HttpHeaderResponse event and the full HttpResponse\n          // event. However, since response headers don't change in between these\n          // two events, it doesn't make sense to parse them twice. So headerResponse\n          // caches the data extracted from the response whenever it's first parsed,\n          // to ensure parsing isn't duplicated.\n          let headerResponse: HttpHeaderResponse | null = null;\n\n          // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n          // state, and memoizes it into headerResponse.\n          const partialFromXhr = (): HttpHeaderResponse => {\n            if (headerResponse !== null) {\n              return headerResponse;\n            }\n\n            const statusText = xhr.statusText || 'OK';\n\n            // Parse headers from XMLHttpRequest - this step is lazy.\n            const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n\n            // Read the response URL from the XMLHttpResponse instance and fall back on the\n            // request URL.\n            const url = xhr.responseURL || req.url;\n\n            // Construct the HttpHeaderResponse and memoize it.\n            headerResponse = new HttpHeaderResponse({headers, status: xhr.status, statusText, url});\n            return headerResponse;\n          };\n\n          // Next, a few closures are defined for the various events which XMLHttpRequest can\n          // emit. This allows them to be unregistered as event listeners later.\n\n          // First up is the load event, which represents a response being fully available.\n          const onLoad = () => {\n            // Read response state from the memoized partial data.\n            let {headers, status, statusText, url} = partialFromXhr();\n\n            // The body will be read out if present.\n            let body: any | null = null;\n\n            if (status !== HTTP_STATUS_CODE_NO_CONTENT) {\n              // Use XMLHttpRequest.response if set, responseText otherwise.\n              body = typeof xhr.response === 'undefined' ? xhr.responseText : xhr.response;\n            }\n\n            // Normalize another potential bug (this one comes from CORS).\n            if (status === 0) {\n              status = !!body ? HTTP_STATUS_CODE_OK : 0;\n            }\n\n            // ok determines whether the response will be transmitted on the event or\n            // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n            // but a successful status code can still result in an error if the user\n            // asked for JSON data and the body cannot be parsed as such.\n            let ok = status >= 200 && status < 300;\n\n            // Check whether the body needs to be parsed as JSON (in many cases the browser\n            // will have done that already).\n            if (req.responseType === 'json' && typeof body === 'string') {\n              // Save the original body, before attempting XSSI prefix stripping.\n              const originalBody = body;\n              body = body.replace(XSSI_PREFIX, '');\n              try {\n                // Attempt the parse. If it fails, a parse error should be delivered to the\n                // user.\n                body = body !== '' ? JSON.parse(body) : null;\n              } catch (error) {\n                // Since the JSON.parse failed, it's reasonable to assume this might not have\n                // been a JSON response. Restore the original body (including any XSSI prefix)\n                // to deliver a better error response.\n                body = originalBody;\n\n                // If this was an error request to begin with, leave it as a string, it\n                // probably just isn't JSON. Otherwise, deliver the parsing error to the user.\n                if (ok) {\n                  // Even though the response status was 2xx, this is still an error.\n                  ok = false;\n                  // The parse error contains the text of the body that failed to parse.\n                  body = {error, text: body} as HttpJsonParseError;\n                }\n              }\n            }\n\n            if (ok) {\n              // A successful response is delivered on the event stream.\n              observer.next(\n                new HttpResponse({\n                  body,\n                  headers,\n                  status,\n                  statusText,\n                  url: url || undefined,\n                }),\n              );\n              // The full body has been received and delivered, no further events\n              // are possible. This request is complete.\n              observer.complete();\n            } else {\n              // An unsuccessful request is delivered on the error channel.\n              observer.error(\n                new HttpErrorResponse({\n                  // The error in this case is the response body (error from the server).\n                  error: body,\n                  headers,\n                  status,\n                  statusText,\n                  url: url || undefined,\n                }),\n              );\n            }\n          };\n\n          // The onError callback is called when something goes wrong at the network level.\n          // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n          // transmitted on the error channel.\n          const onError = (error: ProgressEvent) => {\n            const {url} = partialFromXhr();\n            const res = new HttpErrorResponse({\n              error,\n              status: xhr.status || 0,\n              statusText: xhr.statusText || 'Unknown Error',\n              url: url || undefined,\n            });\n            observer.error(res);\n          };\n\n          let onTimeout = onError;\n\n          if (req.timeout) {\n            onTimeout = (_: ProgressEvent) => {\n              const {url} = partialFromXhr();\n              const res = new HttpErrorResponse({\n                error: new DOMException('Request timed out', 'TimeoutError'),\n                status: xhr.status || 0,\n                statusText: xhr.statusText || 'Request timeout',\n                url: url || undefined,\n              });\n              observer.error(res);\n            };\n          }\n\n          // The sentHeaders flag tracks whether the HttpResponseHeaders event\n          // has been sent on the stream. This is necessary to track if progress\n          // is enabled since the event will be sent on only the first download\n          // progress event.\n          let sentHeaders = false;\n\n          // The download progress event handler, which is only registered if\n          // progress events are enabled.\n          const onDownProgress = (event: ProgressEvent) => {\n            // Send the HttpResponseHeaders event if it hasn't been sent already.\n            if (!sentHeaders) {\n              observer.next(partialFromXhr());\n              sentHeaders = true;\n            }\n\n            // Start building the download progress event to deliver on the response\n            // event stream.\n            let progressEvent: HttpDownloadProgressEvent = {\n              type: HttpEventType.DownloadProgress,\n              loaded: event.loaded,\n            };\n\n            // Set the total number of bytes in the event if it's available.\n            if (event.lengthComputable) {\n              progressEvent.total = event.total;\n            }\n\n            // If the request was for text content and a partial response is\n            // available on XMLHttpRequest, include it in the progress event\n            // to allow for streaming reads.\n            if (req.responseType === 'text' && !!xhr.responseText) {\n              progressEvent.partialText = xhr.responseText;\n            }\n\n            // Finally, fire the event.\n            observer.next(progressEvent);\n          };\n\n          // The upload progress event handler, which is only registered if\n          // progress events are enabled.\n          const onUpProgress = (event: ProgressEvent) => {\n            // Upload progress events are simpler. Begin building the progress\n            // event.\n            let progress: HttpUploadProgressEvent = {\n              type: HttpEventType.UploadProgress,\n              loaded: event.loaded,\n            };\n\n            // If the total number of bytes being uploaded is available, include\n            // it.\n            if (event.lengthComputable) {\n              progress.total = event.total;\n            }\n\n            // Send the event.\n            observer.next(progress);\n          };\n\n          // By default, register for load and error events.\n          xhr.addEventListener('load', onLoad);\n          xhr.addEventListener('error', onError);\n          xhr.addEventListener('timeout', onTimeout);\n          xhr.addEventListener('abort', onError);\n\n          // Progress events are only enabled if requested.\n          if (req.reportProgress) {\n            // Download progress is always enabled if requested.\n            xhr.addEventListener('progress', onDownProgress);\n\n            // Upload progress depends on whether there is a body to upload.\n            if (reqBody !== null && xhr.upload) {\n              xhr.upload.addEventListener('progress', onUpProgress);\n            }\n          }\n\n          // Fire the request, and notify the event stream that it was fired.\n          xhr.send(reqBody!);\n          observer.next({type: HttpEventType.Sent});\n          // This is the return from the Observable function, which is the\n          // request cancellation handler.\n          return () => {\n            // On a cancellation, remove all registered event listeners.\n            xhr.removeEventListener('error', onError);\n            xhr.removeEventListener('abort', onError);\n            xhr.removeEventListener('load', onLoad);\n            xhr.removeEventListener('timeout', onTimeout);\n\n            if (req.reportProgress) {\n              xhr.removeEventListener('progress', onDownProgress);\n              if (reqBody !== null && xhr.upload) {\n                xhr.upload.removeEventListener('progress', onUpProgress);\n              }\n            }\n\n            // Finally, abort the in-flight request.\n            if (xhr.readyState !== xhr.DONE) {\n              xhr.abort();\n            }\n          };\n        });\n      }),\n    );\n  }\n}\n"]}