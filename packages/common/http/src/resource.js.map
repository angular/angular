{"version":3,"file":"resource.js","sourceRoot":"","sources":["resource.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Injector,\n  Signal,\n  ɵResourceImpl as ResourceImpl,\n  inject,\n  linkedSignal,\n  assertInInjectionContext,\n  signal,\n  computed,\n  ResourceStreamItem,\n  type ValueEqualityFn,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n  ɵencapsulateResourceError as encapsulateResourceError,\n} from '@angular/core';\nimport type {Subscription} from 'rxjs';\n\nimport {HttpRequest} from './request';\nimport {HttpClient} from './client';\nimport {HttpErrorResponse, HttpEventType, HttpProgressEvent, HttpResponseBase} from './response';\nimport {HttpHeaders} from './headers';\nimport {HttpParams} from './params';\nimport {HttpResourceRef, HttpResourceOptions, HttpResourceRequest} from './resource_api';\n\n/**\n * Type for the `httpRequest` top-level function, which includes the call signatures for the JSON-\n * based `httpRequest` as well as sub-functions for `ArrayBuffer`, `Blob`, and `string` type\n * requests.\n *\n * @experimental 19.2\n */\nexport interface HttpResourceFn {\n  /**\n   * Create a `Resource` that fetches data with an HTTP GET request to the given URL.\n   *\n   * The resource will update when the URL changes via signals.\n   *\n   * Uses `HttpClient` to make requests and supports interceptors, testing, and the other features\n   * of the `HttpClient` API. Data is parsed as JSON by default - use a sub-function of\n   * `httpResource`, such as `httpResource.text()`, to parse the response differently.\n   *\n   * @experimental 19.2\n   */\n  <TResult = unknown>(\n    url: () => string | undefined,\n    options: HttpResourceOptions<TResult, unknown> & {defaultValue: NoInfer<TResult>},\n  ): HttpResourceRef<TResult>;\n\n  /**\n   * Create a `Resource` that fetches data with an HTTP GET request to the given URL.\n   *\n   * The resource will update when the URL changes via signals.\n   *\n   * Uses `HttpClient` to make requests and supports interceptors, testing, and the other features\n   * of the `HttpClient` API. Data is parsed as JSON by default - use a sub-function of\n   * `httpResource`, such as `httpResource.text()`, to parse the response differently.\n   *\n   * @experimental 19.2\n   */\n  <TResult = unknown>(\n    url: () => string | undefined,\n    options?: HttpResourceOptions<TResult, unknown>,\n  ): HttpResourceRef<TResult | undefined>;\n\n  /**\n   * Create a `Resource` that fetches data with the configured HTTP request.\n   *\n   * The resource will update when the request changes via signals.\n   *\n   * Uses `HttpClient` to make requests and supports interceptors, testing, and the other features\n   * of the `HttpClient` API. Data is parsed as JSON by default - use a sub-function of\n   * `httpResource`, such as `httpResource.text()`, to parse the response differently.\n   *\n   * @experimental 19.2\n   */\n  <TResult = unknown>(\n    request: () => HttpResourceRequest | undefined,\n    options: HttpResourceOptions<TResult, unknown> & {defaultValue: NoInfer<TResult>},\n  ): HttpResourceRef<TResult>;\n\n  /**\n   * Create a `Resource` that fetches data with the configured HTTP request.\n   *\n   * The resource will update when the request changes via signals.\n   *\n   * Uses `HttpClient` to make requests and supports interceptors, testing, and the other features\n   * of the `HttpClient` API. Data is parsed as JSON by default - use a sub-function of\n   * `httpResource`, such as `httpResource.text()`, to parse the response differently.\n   *\n   * @experimental 19.2\n   */\n  <TResult = unknown>(\n    request: () => HttpResourceRequest | undefined,\n    options?: HttpResourceOptions<TResult, unknown>,\n  ): HttpResourceRef<TResult | undefined>;\n\n  /**\n   * Create a `Resource` that fetches data with the configured HTTP request.\n   *\n   * The resource will update when the URL or request changes via signals.\n   *\n   * Uses `HttpClient` to make requests and supports interceptors, testing, and the other features\n   * of the `HttpClient` API. Data is parsed into an `ArrayBuffer`.\n   *\n   * @experimental 19.2\n   */\n  arrayBuffer: {\n    <TResult = ArrayBuffer>(\n      url: () => string | undefined,\n      options: HttpResourceOptions<TResult, ArrayBuffer> & {defaultValue: NoInfer<TResult>},\n    ): HttpResourceRef<TResult>;\n\n    <TResult = ArrayBuffer>(\n      url: () => string | undefined,\n      options?: HttpResourceOptions<TResult, ArrayBuffer>,\n    ): HttpResourceRef<TResult | undefined>;\n\n    <TResult = ArrayBuffer>(\n      request: () => HttpResourceRequest | undefined,\n      options: HttpResourceOptions<TResult, ArrayBuffer> & {defaultValue: NoInfer<TResult>},\n    ): HttpResourceRef<TResult>;\n\n    <TResult = ArrayBuffer>(\n      request: () => HttpResourceRequest | undefined,\n      options?: HttpResourceOptions<TResult, ArrayBuffer>,\n    ): HttpResourceRef<TResult | undefined>;\n  };\n\n  /**\n   * Create a `Resource` that fetches data with the configured HTTP request.\n   *\n   * The resource will update when the URL or request changes via signals.\n   *\n   * Uses `HttpClient` to make requests and supports interceptors, testing, and the other features\n   * of the `HttpClient` API. Data is parsed into a `Blob`.\n   *\n   * @experimental 19.2\n   */\n  blob: {\n    <TResult = Blob>(\n      url: () => string | undefined,\n      options: HttpResourceOptions<TResult, Blob> & {defaultValue: NoInfer<TResult>},\n    ): HttpResourceRef<TResult>;\n\n    <TResult = Blob>(\n      url: () => string | undefined,\n      options?: HttpResourceOptions<TResult, Blob>,\n    ): HttpResourceRef<TResult | undefined>;\n\n    <TResult = Blob>(\n      request: () => HttpResourceRequest | undefined,\n      options: HttpResourceOptions<TResult, Blob> & {defaultValue: NoInfer<TResult>},\n    ): HttpResourceRef<TResult>;\n\n    <TResult = Blob>(\n      request: () => HttpResourceRequest | undefined,\n      options?: HttpResourceOptions<TResult, Blob>,\n    ): HttpResourceRef<TResult | undefined>;\n  };\n\n  /**\n   * Create a `Resource` that fetches data with the configured HTTP request.\n   *\n   * The resource will update when the URL or request changes via signals.\n   *\n   * Uses `HttpClient` to make requests and supports interceptors, testing, and the other features\n   * of the `HttpClient` API. Data is parsed as a `string`.\n   *\n   * @experimental 19.2\n   */\n  text: {\n    <TResult = string>(\n      url: () => string | undefined,\n      options: HttpResourceOptions<TResult, string> & {defaultValue: NoInfer<TResult>},\n    ): HttpResourceRef<TResult>;\n\n    <TResult = string>(\n      url: () => string | undefined,\n      options?: HttpResourceOptions<TResult, string>,\n    ): HttpResourceRef<TResult | undefined>;\n\n    <TResult = string>(\n      request: () => HttpResourceRequest | undefined,\n      options: HttpResourceOptions<TResult, string> & {defaultValue: NoInfer<TResult>},\n    ): HttpResourceRef<TResult>;\n\n    <TResult = string>(\n      request: () => HttpResourceRequest | undefined,\n      options?: HttpResourceOptions<TResult, string>,\n    ): HttpResourceRef<TResult | undefined>;\n  };\n}\n\n/**\n * `httpResource` makes a reactive HTTP request and exposes the request status and response value as\n * a `WritableResource`. By default, it assumes that the backend will return JSON data. To make a\n * request that expects a different kind of data, you can use a sub-constructor of `httpResource`,\n * such as `httpResource.text`.\n *\n * @experimental 19.2\n * @initializerApiFunction\n */\nexport const httpResource: HttpResourceFn = (() => {\n  const jsonFn = makeHttpResourceFn<unknown>('json') as HttpResourceFn;\n  jsonFn.arrayBuffer = makeHttpResourceFn<ArrayBuffer>('arraybuffer');\n  jsonFn.blob = makeHttpResourceFn('blob');\n  jsonFn.text = makeHttpResourceFn('text');\n  return jsonFn;\n})();\n\n/**\n * The expected response type of the server.\n *\n * This is used to parse the response appropriately before returning it to\n * the requestee.\n */\ntype ResponseType = 'arraybuffer' | 'blob' | 'json' | 'text';\ntype RawRequestType = (() => string | undefined) | (() => HttpResourceRequest | undefined);\n\nfunction makeHttpResourceFn<TRaw>(responseType: ResponseType) {\n  return function httpResource<TResult = TRaw>(\n    request: RawRequestType,\n    options?: HttpResourceOptions<TResult, TRaw>,\n  ): HttpResourceRef<TResult> {\n    if (ngDevMode && !options?.injector) {\n      assertInInjectionContext(httpResource);\n    }\n    const injector = options?.injector ?? inject(Injector);\n    return new HttpResourceImpl(\n      injector,\n      () => normalizeRequest(request, responseType),\n      options?.defaultValue,\n      options?.parse as (value: unknown) => TResult,\n      options?.equal as ValueEqualityFn<unknown>,\n    ) as HttpResourceRef<TResult>;\n  };\n}\n\nfunction normalizeRequest(\n  request: RawRequestType,\n  responseType: ResponseType,\n): HttpRequest<unknown> | undefined {\n  let unwrappedRequest = typeof request === 'function' ? request() : request;\n  if (unwrappedRequest === undefined) {\n    return undefined;\n  } else if (typeof unwrappedRequest === 'string') {\n    unwrappedRequest = {url: unwrappedRequest};\n  }\n\n  const headers =\n    unwrappedRequest.headers instanceof HttpHeaders\n      ? unwrappedRequest.headers\n      : new HttpHeaders(\n          unwrappedRequest.headers as\n            | Record<string, string | number | Array<string | number>>\n            | undefined,\n        );\n\n  const params =\n    unwrappedRequest.params instanceof HttpParams\n      ? unwrappedRequest.params\n      : new HttpParams({fromObject: unwrappedRequest.params});\n\n  return new HttpRequest(\n    unwrappedRequest.method ?? 'GET',\n    unwrappedRequest.url,\n    unwrappedRequest.body ?? null,\n    {\n      headers,\n      params,\n      reportProgress: unwrappedRequest.reportProgress,\n      withCredentials: unwrappedRequest.withCredentials,\n      keepalive: unwrappedRequest.keepalive,\n      cache: unwrappedRequest.cache as RequestCache,\n      priority: unwrappedRequest.priority as RequestPriority,\n      mode: unwrappedRequest.mode as RequestMode,\n      redirect: unwrappedRequest.redirect as RequestRedirect,\n      responseType,\n      context: unwrappedRequest.context,\n      transferCache: unwrappedRequest.transferCache,\n      credentials: unwrappedRequest.credentials as RequestCredentials,\n      referrer: unwrappedRequest.referrer,\n      integrity: unwrappedRequest.integrity,\n      timeout: unwrappedRequest.timeout,\n    },\n  );\n}\nclass HttpResourceImpl<T>\n  extends ResourceImpl<T, HttpRequest<unknown> | undefined>\n  implements HttpResourceRef<T>\n{\n  private client!: HttpClient;\n  private _headers = linkedSignal({\n    source: this.extRequest,\n    computation: () => undefined as HttpHeaders | undefined,\n  });\n  private _progress = linkedSignal({\n    source: this.extRequest,\n    computation: () => undefined as HttpProgressEvent | undefined,\n  });\n  private _statusCode = linkedSignal({\n    source: this.extRequest,\n    computation: () => undefined as number | undefined,\n  });\n\n  readonly headers = computed(() =>\n    this.status() === 'resolved' || this.status() === 'error' ? this._headers() : undefined,\n  );\n  readonly progress = this._progress.asReadonly();\n  readonly statusCode = this._statusCode.asReadonly();\n\n  constructor(\n    injector: Injector,\n    request: () => HttpRequest<T> | undefined,\n    defaultValue: T,\n    parse?: (value: unknown) => T,\n    equal?: ValueEqualityFn<unknown>,\n  ) {\n    super(\n      request,\n      ({params: request, abortSignal}) => {\n        let sub: Subscription;\n\n        // Track the abort listener so it can be removed if the Observable completes (as a memory\n        // optimization).\n        const onAbort = () => sub.unsubscribe();\n        abortSignal.addEventListener('abort', onAbort);\n\n        // Start off stream as undefined.\n        const stream = signal<ResourceStreamItem<T>>({value: undefined as T});\n        let resolve: ((value: Signal<ResourceStreamItem<T>>) => void) | undefined;\n        const promise = new Promise<Signal<ResourceStreamItem<T>>>((r) => (resolve = r));\n\n        const send = (value: ResourceStreamItem<T>): void => {\n          stream.set(value);\n          resolve?.(stream);\n          resolve = undefined;\n        };\n\n        sub = this.client.request(request!).subscribe({\n          next: (event) => {\n            switch (event.type) {\n              case HttpEventType.Response:\n                this._headers.set(event.headers);\n                this._statusCode.set(event.status);\n                try {\n                  send({value: parse ? parse(event.body) : (event.body as T)});\n                } catch (error) {\n                  send({error: encapsulateResourceError(error)});\n                }\n                break;\n              case HttpEventType.DownloadProgress:\n                this._progress.set(event);\n                break;\n            }\n          },\n          error: (error) => {\n            if (error instanceof HttpErrorResponse) {\n              this._headers.set(error.headers);\n              this._statusCode.set(error.status);\n            }\n\n            send({error});\n            abortSignal.removeEventListener('abort', onAbort);\n          },\n          complete: () => {\n            if (resolve) {\n              send({\n                error: new ɵRuntimeError(\n                  ɵRuntimeErrorCode.RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE,\n                  ngDevMode && 'Resource completed before producing a value',\n                ),\n              });\n            }\n            abortSignal.removeEventListener('abort', onAbort);\n          },\n        });\n\n        return promise;\n      },\n      defaultValue,\n      equal,\n      injector,\n    );\n    this.client = injector.get(HttpClient);\n  }\n\n  override set(value: T): void {\n    super.set(value);\n\n    this._headers.set(undefined);\n    this._progress.set(undefined);\n    this._statusCode.set(undefined);\n  }\n\n  // This is a type only override of the method\n  declare hasValue: () => this is HttpResourceRef<Exclude<T, undefined>>;\n}\n"]}