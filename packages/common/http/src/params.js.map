{"version":3,"file":"params.js","sourceRoot":"","sources":["params.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ÉµRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\n\n/**\n * A codec for encoding and decoding parameters in URLs.\n *\n * Used by `HttpParams`.\n *\n * @publicApi\n **/\nexport interface HttpParameterCodec {\n  encodeKey(key: string): string;\n  encodeValue(value: string): string;\n\n  decodeKey(key: string): string;\n  decodeValue(value: string): string;\n}\n\n/**\n * Provides encoding and decoding of URL parameter and query-string values.\n *\n * Serializes and parses URL parameter keys and values to encode and decode them.\n * If you pass URL query parameters without encoding,\n * the query parameters can be misinterpreted at the receiving end.\n *\n *\n * @publicApi\n */\nexport class HttpUrlEncodingCodec implements HttpParameterCodec {\n  /**\n   * Encodes a key name for a URL parameter or query-string.\n   * @param key The key name.\n   * @returns The encoded key name.\n   */\n  encodeKey(key: string): string {\n    return standardEncoding(key);\n  }\n\n  /**\n   * Encodes the value of a URL parameter or query-string.\n   * @param value The value.\n   * @returns The encoded value.\n   */\n  encodeValue(value: string): string {\n    return standardEncoding(value);\n  }\n\n  /**\n   * Decodes an encoded URL parameter or query-string key.\n   * @param key The encoded key name.\n   * @returns The decoded key name.\n   */\n  decodeKey(key: string): string {\n    return decodeURIComponent(key);\n  }\n\n  /**\n   * Decodes an encoded URL parameter or query-string value.\n   * @param value The encoded value.\n   * @returns The decoded value.\n   */\n  decodeValue(value: string) {\n    return decodeURIComponent(value);\n  }\n}\n\nfunction paramParser(rawParams: string, codec: HttpParameterCodec): Map<string, string[]> {\n  const map = new Map<string, string[]>();\n  if (rawParams.length > 0) {\n    // The `window.location.search` can be used while creating an instance of the `HttpParams` class\n    // (e.g. `new HttpParams({ fromString: window.location.search })`). The `window.location.search`\n    // may start with the `?` char, so we strip it if it's present.\n    const params: string[] = rawParams.replace(/^\\?/, '').split('&');\n    params.forEach((param: string) => {\n      const eqIdx = param.indexOf('=');\n      const [key, val]: string[] =\n        eqIdx == -1\n          ? [codec.decodeKey(param), '']\n          : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];\n      const list = map.get(key) || [];\n      list.push(val);\n      map.set(key, list);\n    });\n  }\n  return map;\n}\n\n/**\n * Encode input string with standard encodeURIComponent and then un-encode specific characters.\n */\nconst STANDARD_ENCODING_REGEX = /%(\\d[a-f0-9])/gi;\nconst STANDARD_ENCODING_REPLACEMENTS: {[x: string]: string} = {\n  '40': '@',\n  '3A': ':',\n  '24': '$',\n  '2C': ',',\n  '3B': ';',\n  '3D': '=',\n  '3F': '?',\n  '2F': '/',\n};\n\nfunction standardEncoding(v: string): string {\n  return encodeURIComponent(v).replace(\n    STANDARD_ENCODING_REGEX,\n    (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s,\n  );\n}\n\nfunction valueToString(value: string | number | boolean): string {\n  return `${value}`;\n}\n\ninterface Update {\n  param: string;\n  value?: string | number | boolean;\n  op: 'a' | 'd' | 's';\n}\n\n/**\n * Options used to construct an `HttpParams` instance.\n *\n * @publicApi\n */\nexport interface HttpParamsOptions {\n  /**\n   * String representation of the HTTP parameters in URL-query-string format.\n   * Mutually exclusive with `fromObject`.\n   */\n  fromString?: string;\n\n  /** Object map of the HTTP parameters. Mutually exclusive with `fromString`. */\n  fromObject?: {\n    [param: string]: string | number | boolean | ReadonlyArray<string | number | boolean>;\n  };\n\n  /** Encoding codec used to parse and serialize the parameters. */\n  encoder?: HttpParameterCodec;\n}\n\n/**\n * An HTTP request/response body that represents serialized parameters,\n * per the MIME type `application/x-www-form-urlencoded`.\n *\n * This class is immutable; all mutation operations return a new instance.\n *\n * @publicApi\n */\nexport class HttpParams {\n  private map: Map<string, string[]> | null;\n  private encoder: HttpParameterCodec;\n  private updates: Update[] | null = null;\n  private cloneFrom: HttpParams | null = null;\n\n  constructor(options: HttpParamsOptions = {} as HttpParamsOptions) {\n    this.encoder = options.encoder || new HttpUrlEncodingCodec();\n    if (options.fromString) {\n      if (options.fromObject) {\n        throw new RuntimeError(\n          RuntimeErrorCode.CANNOT_SPECIFY_BOTH_FROM_STRING_AND_FROM_OBJECT,\n          ngDevMode && 'Cannot specify both fromString and fromObject.',\n        );\n      }\n      this.map = paramParser(options.fromString, this.encoder);\n    } else if (!!options.fromObject) {\n      this.map = new Map<string, string[]>();\n      Object.keys(options.fromObject).forEach((key) => {\n        const value = (options.fromObject as any)[key];\n        // convert the values to strings\n        const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];\n        this.map!.set(key, values);\n      });\n    } else {\n      this.map = null;\n    }\n  }\n\n  /**\n   * Reports whether the body includes one or more values for a given parameter.\n   * @param param The parameter name.\n   * @returns True if the parameter has one or more values,\n   * false if it has no value or is not present.\n   */\n  has(param: string): boolean {\n    this.init();\n    return this.map!.has(param);\n  }\n\n  /**\n   * Retrieves the first value for a parameter.\n   * @param param The parameter name.\n   * @returns The first value of the given parameter,\n   * or `null` if the parameter is not present.\n   */\n  get(param: string): string | null {\n    this.init();\n    const res = this.map!.get(param);\n    return !!res ? res[0] : null;\n  }\n\n  /**\n   * Retrieves all values for a  parameter.\n   * @param param The parameter name.\n   * @returns All values in a string array,\n   * or `null` if the parameter not present.\n   */\n  getAll(param: string): string[] | null {\n    this.init();\n    return this.map!.get(param) || null;\n  }\n\n  /**\n   * Retrieves all the parameters for this body.\n   * @returns The parameter names in a string array.\n   */\n  keys(): string[] {\n    this.init();\n    return Array.from(this.map!.keys());\n  }\n\n  /**\n   * Appends a new value to existing values for a parameter.\n   * @param param The parameter name.\n   * @param value The new value to add.\n   * @return A new body with the appended value.\n   */\n  append(param: string, value: string | number | boolean): HttpParams {\n    return this.clone({param, value, op: 'a'});\n  }\n\n  /**\n   * Constructs a new body with appended values for the given parameter name.\n   * @param params parameters and values\n   * @return A new body with the new value.\n   */\n  appendAll(params: {\n    [param: string]: string | number | boolean | ReadonlyArray<string | number | boolean>;\n  }): HttpParams {\n    const updates: Update[] = [];\n    Object.keys(params).forEach((param) => {\n      const value = params[param];\n      if (Array.isArray(value)) {\n        value.forEach((_value) => {\n          updates.push({param, value: _value, op: 'a'});\n        });\n      } else {\n        updates.push({param, value: value as string | number | boolean, op: 'a'});\n      }\n    });\n    return this.clone(updates);\n  }\n\n  /**\n   * Replaces the value for a parameter.\n   * @param param The parameter name.\n   * @param value The new value.\n   * @return A new body with the new value.\n   */\n  set(param: string, value: string | number | boolean): HttpParams {\n    return this.clone({param, value, op: 's'});\n  }\n\n  /**\n   * Removes a given value or all values from a parameter.\n   * @param param The parameter name.\n   * @param value The value to remove, if provided.\n   * @return A new body with the given value removed, or with all values\n   * removed if no value is specified.\n   */\n  delete(param: string, value?: string | number | boolean): HttpParams {\n    return this.clone({param, value, op: 'd'});\n  }\n\n  /**\n   * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are\n   * separated by `&`s.\n   */\n  toString(): string {\n    this.init();\n    return (\n      this.keys()\n        .map((key) => {\n          const eKey = this.encoder.encodeKey(key);\n          // `a: ['1']` produces `'a=1'`\n          // `b: []` produces `''`\n          // `c: ['1', '2']` produces `'c=1&c=2'`\n          return this.map!.get(key)!\n            .map((value) => eKey + '=' + this.encoder.encodeValue(value))\n            .join('&');\n        })\n        // filter out empty values because `b: []` produces `''`\n        // which results in `a=1&&c=1&c=2` instead of `a=1&c=1&c=2` if we don't\n        .filter((param) => param !== '')\n        .join('&')\n    );\n  }\n\n  private clone(update: Update | Update[]): HttpParams {\n    const clone = new HttpParams({encoder: this.encoder} as HttpParamsOptions);\n    clone.cloneFrom = this.cloneFrom || this;\n    clone.updates = (this.updates || []).concat(update);\n    return clone;\n  }\n\n  private init() {\n    if (this.map === null) {\n      this.map = new Map<string, string[]>();\n    }\n    if (this.cloneFrom !== null) {\n      this.cloneFrom.init();\n      this.cloneFrom.keys().forEach((key) => this.map!.set(key, this.cloneFrom!.map!.get(key)!));\n      this.updates!.forEach((update) => {\n        switch (update.op) {\n          case 'a':\n          case 's':\n            const base = (update.op === 'a' ? this.map!.get(update.param) : undefined) || [];\n            base.push(valueToString(update.value!));\n            this.map!.set(update.param, base);\n            break;\n          case 'd':\n            if (update.value !== undefined) {\n              let base = this.map!.get(update.param) || [];\n              const idx = base.indexOf(valueToString(update.value));\n              if (idx !== -1) {\n                base.splice(idx, 1);\n              }\n              if (base.length > 0) {\n                this.map!.set(update.param, base);\n              } else {\n                this.map!.delete(update.param);\n              }\n            } else {\n              this.map!.delete(update.param);\n              break;\n            }\n        }\n      });\n      this.cloneFrom = this.updates = null;\n    }\n  }\n}\n"]}