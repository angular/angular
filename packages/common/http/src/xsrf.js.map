{"version":3,"file":"xsrf.js","sourceRoot":"","sources":["xsrf.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT, ÉµparseCookieValue as parseCookieValue} from '../../index';\nimport {\n  EnvironmentInjector,\n  Inject,\n  inject,\n  Injectable,\n  InjectionToken,\n  runInInjectionContext,\n} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {HttpHandler} from './backend';\nimport {HttpHandlerFn, HttpInterceptor} from './interceptor';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\nexport const XSRF_ENABLED = new InjectionToken<boolean>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'XSRF_ENABLED' : '',\n  {\n    factory: () => true,\n  },\n);\n\nexport const XSRF_DEFAULT_COOKIE_NAME = 'XSRF-TOKEN';\nexport const XSRF_COOKIE_NAME = new InjectionToken<string>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'XSRF_COOKIE_NAME' : '',\n  {\n    providedIn: 'root',\n    factory: () => XSRF_DEFAULT_COOKIE_NAME,\n  },\n);\n\nexport const XSRF_DEFAULT_HEADER_NAME = 'X-XSRF-TOKEN';\nexport const XSRF_HEADER_NAME = new InjectionToken<string>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'XSRF_HEADER_NAME' : '',\n  {\n    providedIn: 'root',\n    factory: () => XSRF_DEFAULT_HEADER_NAME,\n  },\n);\n\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\n@Injectable({providedIn: 'root'})\nexport class HttpXsrfCookieExtractor implements HttpXsrfTokenExtractor {\n  private lastCookieString: string = '';\n  private lastToken: string | null = null;\n\n  /**\n   * @internal for testing\n   */\n  parseCount: number = 0;\n\n  constructor(\n    @Inject(DOCUMENT) private doc: any,\n    @Inject(XSRF_COOKIE_NAME) private cookieName: string,\n  ) {}\n\n  getToken(): string | null {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n      return null;\n    }\n    const cookieString = this.doc.cookie || '';\n    if (cookieString !== this.lastCookieString) {\n      this.parseCount++;\n      this.lastToken = parseCookieValue(cookieString, this.cookieName);\n      this.lastCookieString = cookieString;\n    }\n    return this.lastToken;\n  }\n}\n\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useExisting: HttpXsrfCookieExtractor})\nexport abstract class HttpXsrfTokenExtractor {\n  /**\n   * Get the XSRF token to use with an outgoing request.\n   *\n   * Will be called for every request, so the token may change between requests.\n   */\n  abstract getToken(): string | null;\n}\n\nexport function xsrfInterceptorFn(\n  req: HttpRequest<unknown>,\n  next: HttpHandlerFn,\n): Observable<HttpEvent<unknown>> {\n  const lcUrl = req.url.toLowerCase();\n  // Skip both non-mutating requests and absolute URLs.\n  // Non-mutating requests don't require a token, and absolute URLs require special handling\n  // anyway as the cookie set\n  // on our origin is not the same as the token expected by another origin.\n  if (\n    !inject(XSRF_ENABLED) ||\n    req.method === 'GET' ||\n    req.method === 'HEAD' ||\n    lcUrl.startsWith('http://') ||\n    lcUrl.startsWith('https://')\n  ) {\n    return next(req);\n  }\n\n  const token = inject(HttpXsrfTokenExtractor).getToken();\n  const headerName = inject(XSRF_HEADER_NAME);\n\n  // Be careful not to overwrite an existing header of the same name.\n  if (token != null && !req.headers.has(headerName)) {\n    req = req.clone({headers: req.headers.set(headerName, token)});\n  }\n  return next(req);\n}\n\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\n@Injectable()\nexport class HttpXsrfInterceptor implements HttpInterceptor {\n  constructor(private injector: EnvironmentInjector) {}\n\n  intercept(initialRequest: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return runInInjectionContext(this.injector, () =>\n      xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)),\n    );\n  }\n}\n"]}