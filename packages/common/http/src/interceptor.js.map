{"version":3,"file":"interceptor.js","sourceRoot":"","sources":["interceptor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EnvironmentInjector,\n  inject,\n  InjectionToken,\n  runInInjectionContext,\n  PendingTasks,\n} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {finalize} from 'rxjs/operators';\n\nimport type {HttpHandler} from './backend';\n\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\n/**\n * Intercepts and handles an `HttpRequest` or `HttpResponse`.\n *\n * Most interceptors transform the outgoing request before passing it to the\n * next interceptor in the chain, by calling `next.handle(transformedReq)`.\n * An interceptor may transform the\n * response event stream as well, by applying additional RxJS operators on the stream\n * returned by `next.handle()`.\n *\n * More rarely, an interceptor may handle the request entirely,\n * and compose a new event stream instead of invoking `next.handle()`. This is an\n * acceptable behavior, but keep in mind that further interceptors will be skipped entirely.\n *\n * It is also rare but valid for an interceptor to return multiple responses on the\n * event stream for a single request.\n *\n * @publicApi\n *\n * @see [HTTP Guide](guide/http/interceptors)\n * @see {@link HttpInterceptorFn}\n *\n * @usageNotes\n *\n * To use the same instance of `HttpInterceptors` for the entire app, import the `HttpClientModule`\n * only in your `AppModule`, and add the interceptors to the root application injector.\n * If you import `HttpClientModule` multiple times across different modules (for example, in lazy\n * loading modules), each import creates a new copy of the `HttpClientModule`, which overwrites the\n * interceptors provided in the root module.\n */\nexport interface HttpInterceptor {\n  /**\n   * Identifies and handles a given HTTP request.\n   * @param req The outgoing request object to handle.\n   * @param next The next interceptor in the chain, or the backend\n   * if no interceptors remain in the chain.\n   * @returns An observable of the event stream.\n   */\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\n}\n\n/**\n * Represents the next interceptor in an interceptor chain, or the real backend if there are no\n * further interceptors.\n *\n * Most interceptors will delegate to this function, and either modify the outgoing request or the\n * response when it arrives. Within the scope of the current request, however, this function may be\n * called any number of times, for any number of downstream requests. Such downstream requests need\n * not be to the same URL or even the same origin as the current request. It is also valid to not\n * call the downstream handler at all, and process the current request entirely within the\n * interceptor.\n *\n * This function should only be called within the scope of the request that's currently being\n * intercepted. Once that request is complete, this downstream handler function should not be\n * called.\n *\n * @publicApi\n *\n * @see [HTTP Guide](guide/http/interceptors)\n */\nexport type HttpHandlerFn = (req: HttpRequest<unknown>) => Observable<HttpEvent<unknown>>;\n\n/**\n * An interceptor for HTTP requests made via `HttpClient`.\n *\n * `HttpInterceptorFn`s are middleware functions which `HttpClient` calls when a request is made.\n * These functions have the opportunity to modify the outgoing request or any response that comes\n * back, as well as block, redirect, or otherwise change the request or response semantics.\n *\n * An `HttpHandlerFn` representing the next interceptor (or the backend which will make a real HTTP\n * request) is provided. Most interceptors will delegate to this function, but that is not required\n * (see `HttpHandlerFn` for more details).\n *\n * `HttpInterceptorFn`s are executed in an [injection context](guide/di/dependency-injection-context).\n * They have access to `inject()` via the `EnvironmentInjector` from which they were configured.\n *\n * @see [HTTP Guide](guide/http/interceptors)\n * @see {@link withInterceptors}\n *\n * @usageNotes\n * Here is a noop interceptor that passes the request through without modifying it:\n * ```ts\n * export const noopInterceptor: HttpInterceptorFn = (req: HttpRequest<unknown>, next:\n * HttpHandlerFn) => {\n *   return next(modifiedReq);\n * };\n * ```\n *\n * If you want to alter a request, clone it first and modify the clone before passing it to the\n * `next()` handler function.\n *\n * Here is a basic interceptor that adds a bearer token to the headers\n * ```ts\n * export const authenticationInterceptor: HttpInterceptorFn = (req: HttpRequest<unknown>, next:\n * HttpHandlerFn) => {\n *    const userToken = 'MY_TOKEN'; const modifiedReq = req.clone({\n *      headers: req.headers.set('Authorization', `Bearer ${userToken}`),\n *    });\n *\n *    return next(modifiedReq);\n * };\n * ```\n */\nexport type HttpInterceptorFn = (\n  req: HttpRequest<unknown>,\n  next: HttpHandlerFn,\n) => Observable<HttpEvent<unknown>>;\n\n/**\n * Function which invokes an HTTP interceptor chain.\n *\n * Each interceptor in the interceptor chain is turned into a `ChainedInterceptorFn` which closes\n * over the rest of the chain (represented by another `ChainedInterceptorFn`). The last such\n * function in the chain will instead delegate to the `finalHandlerFn`, which is passed down when\n * the chain is invoked.\n *\n * This pattern allows for a chain of many interceptors to be composed and wrapped in a single\n * `HttpInterceptorFn`, which is a useful abstraction for including different kinds of interceptors\n * (e.g. legacy class-based interceptors) in the same chain.\n */\nexport type ChainedInterceptorFn<RequestT> = (\n  req: HttpRequest<RequestT>,\n  finalHandlerFn: HttpHandlerFn,\n) => Observable<HttpEvent<RequestT>>;\n\nexport function interceptorChainEndFn(\n  req: HttpRequest<any>,\n  finalHandlerFn: HttpHandlerFn,\n): Observable<HttpEvent<any>> {\n  return finalHandlerFn(req);\n}\n\n/**\n * Constructs a `ChainedInterceptorFn` which adapts a legacy `HttpInterceptor` to the\n * `ChainedInterceptorFn` interface.\n */\nexport function adaptLegacyInterceptorToChain(\n  chainTailFn: ChainedInterceptorFn<any>,\n  interceptor: HttpInterceptor,\n): ChainedInterceptorFn<any> {\n  return (initialRequest, finalHandlerFn) =>\n    interceptor.intercept(initialRequest, {\n      handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn),\n    });\n}\n\n/**\n * Constructs a `ChainedInterceptorFn` which wraps and invokes a functional interceptor in the given\n * injector.\n */\nexport function chainedInterceptorFn(\n  chainTailFn: ChainedInterceptorFn<unknown>,\n  interceptorFn: HttpInterceptorFn,\n  injector: EnvironmentInjector,\n): ChainedInterceptorFn<unknown> {\n  return (initialRequest, finalHandlerFn) =>\n    runInInjectionContext(injector, () =>\n      interceptorFn(initialRequest, (downstreamRequest) =>\n        chainTailFn(downstreamRequest, finalHandlerFn),\n      ),\n    );\n}\n\n/**\n * A multi-provider token that represents the array of registered\n * `HttpInterceptor` objects.\n *\n * @publicApi\n */\nexport const HTTP_INTERCEPTORS = new InjectionToken<readonly HttpInterceptor[]>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'HTTP_INTERCEPTORS' : '',\n);\n\n/**\n * A multi-provided token of `HttpInterceptorFn`s.\n */\nexport const HTTP_INTERCEPTOR_FNS = new InjectionToken<readonly HttpInterceptorFn[]>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'HTTP_INTERCEPTOR_FNS' : '',\n  {factory: () => []},\n);\n\n/**\n * A multi-provided token of `HttpInterceptorFn`s that are only set in root.\n */\nexport const HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken<readonly HttpInterceptorFn[]>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'HTTP_ROOT_INTERCEPTOR_FNS' : '',\n);\n\n// TODO(atscott): We need a larger discussion about stability and what should contribute to stability.\n// Should the whole interceptor chain contribute to stability or just the backend request #55075?\n// Should HttpClient contribute to stability automatically at all?\nexport const REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken<boolean>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'REQUESTS_CONTRIBUTE_TO_STABILITY' : '',\n  {providedIn: 'root', factory: () => true},\n);\n\n/**\n * Creates an `HttpInterceptorFn` which lazily initializes an interceptor chain from the legacy\n * class-based interceptors and runs the request through it.\n */\nexport function legacyInterceptorFnFactory(): HttpInterceptorFn {\n  let chain: ChainedInterceptorFn<any> | null = null;\n\n  return (req, handler) => {\n    if (chain === null) {\n      const interceptors = inject(HTTP_INTERCEPTORS, {optional: true}) ?? [];\n      // Note: interceptors are wrapped right-to-left so that final execution order is\n      // left-to-right. That is, if `interceptors` is the array `[a, b, c]`, we want to\n      // produce a chain that is conceptually `c(b(a(end)))`, which we build from the inside\n      // out.\n      chain = interceptors.reduceRight(\n        adaptLegacyInterceptorToChain,\n        interceptorChainEndFn as ChainedInterceptorFn<any>,\n      );\n    }\n\n    const pendingTasks = inject(PendingTasks);\n    const contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);\n    if (contributeToStability) {\n      const removeTask = pendingTasks.add();\n      return chain(req, handler).pipe(finalize(removeTask));\n    } else {\n      return chain(req, handler);\n    }\n  };\n}\n"]}