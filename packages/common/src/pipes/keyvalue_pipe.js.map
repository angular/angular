{"version":3,"file":"keyvalue_pipe.js","sourceRoot":"","sources":["keyvalue_pipe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  KeyValueChangeRecord,\n  KeyValueChanges,\n  KeyValueDiffer,\n  KeyValueDiffers,\n  Pipe,\n  PipeTransform,\n} from '@angular/core';\n\nfunction makeKeyValuePair<K, V>(key: K, value: V): KeyValue<K, V> {\n  return {key: key, value: value};\n}\n\n/**\n * A key value pair.\n * Usually used to represent the key value pairs from a Map or Object.\n *\n * @publicApi\n */\nexport interface KeyValue<K, V> {\n  key: K;\n  value: V;\n}\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Transforms Object or Map into an array of key value pairs.\n *\n * The output array will be ordered by keys.\n * By default the comparator will be by Unicode point value.\n * You can optionally pass a compareFn if your keys are complex types.\n * Passing `null` as the compareFn will use natural ordering of the input.\n *\n * @usageNotes\n * ### Examples\n *\n * This examples show how an Object or a Map can be iterated by ngFor with the use of this\n * keyvalue pipe.\n *\n * {@example common/pipes/ts/keyvalue_pipe.ts region='KeyValuePipe'}\n *\n * @publicApi\n */\n@Pipe({\n  name: 'keyvalue',\n  pure: false,\n})\nexport class KeyValuePipe implements PipeTransform {\n  constructor(private readonly differs: KeyValueDiffers) {}\n\n  private differ!: KeyValueDiffer<any, any>;\n  private keyValues: Array<KeyValue<any, any>> = [];\n  private compareFn: ((a: KeyValue<any, any>, b: KeyValue<any, any>) => number) | null =\n    defaultComparator;\n\n  /*\n   * NOTE: when the `input` value is a simple Record<K, V> object, the keys are extracted with\n   * Object.keys(). This means that even if the `input` type is Record<number, V> the keys are\n   * compared/returned as `string`s.\n   */\n  transform<K, V>(\n    input: ReadonlyMap<K, V>,\n    compareFn?: ((a: KeyValue<K, V>, b: KeyValue<K, V>) => number) | null,\n  ): Array<KeyValue<K, V>>;\n  transform<K extends number, V>(\n    input: Record<K, V>,\n    compareFn?: ((a: KeyValue<string, V>, b: KeyValue<string, V>) => number) | null,\n  ): Array<KeyValue<string, V>>;\n  transform<K extends string, V>(\n    input: Record<K, V> | ReadonlyMap<K, V>,\n    compareFn?: ((a: KeyValue<K, V>, b: KeyValue<K, V>) => number) | null,\n  ): Array<KeyValue<K, V>>;\n  transform(\n    input: null | undefined,\n    compareFn?: ((a: KeyValue<unknown, unknown>, b: KeyValue<unknown, unknown>) => number) | null,\n  ): null;\n  transform<K, V>(\n    input: ReadonlyMap<K, V> | null | undefined,\n    compareFn?: ((a: KeyValue<K, V>, b: KeyValue<K, V>) => number) | null,\n  ): Array<KeyValue<K, V>> | null;\n  transform<K extends number, V>(\n    input: Record<K, V> | null | undefined,\n    compareFn?: ((a: KeyValue<string, V>, b: KeyValue<string, V>) => number) | null,\n  ): Array<KeyValue<string, V>> | null;\n  transform<K extends string, V>(\n    input: Record<K, V> | ReadonlyMap<K, V> | null | undefined,\n    compareFn?: ((a: KeyValue<K, V>, b: KeyValue<K, V>) => number) | null,\n  ): Array<KeyValue<K, V>> | null;\n  transform<K, V>(\n    input: undefined | null | {[key: string]: V; [key: number]: V} | ReadonlyMap<K, V>,\n    compareFn: ((a: KeyValue<K, V>, b: KeyValue<K, V>) => number) | null = defaultComparator,\n  ): Array<KeyValue<K, V>> | null {\n    if (!input || (!(input instanceof Map) && typeof input !== 'object')) {\n      return null;\n    }\n\n    // make a differ for whatever type we've been passed in\n    this.differ ??= this.differs.find(input).create();\n\n    const differChanges: KeyValueChanges<K, V> | null = this.differ.diff(input as any);\n    const compareFnChanged = compareFn !== this.compareFn;\n\n    if (differChanges) {\n      this.keyValues = [];\n      differChanges.forEachItem((r: KeyValueChangeRecord<K, V>) => {\n        this.keyValues.push(makeKeyValuePair(r.key, r.currentValue!));\n      });\n    }\n    if (differChanges || compareFnChanged) {\n      if (compareFn) {\n        this.keyValues.sort(compareFn);\n      }\n      this.compareFn = compareFn;\n    }\n    return this.keyValues;\n  }\n}\n\nexport function defaultComparator<K, V>(\n  keyValueA: KeyValue<K, V>,\n  keyValueB: KeyValue<K, V>,\n): number {\n  const a = keyValueA.key;\n  const b = keyValueB.key;\n  // If both keys are the same, return 0 (no sorting needed).\n  if (a === b) return 0;\n  // If one of the keys is `null` or `undefined`, place it at the end of the sort.\n  if (a == null) return 1; // `a` comes after `b`.\n  if (b == null) return -1; // `b` comes after `a`.\n  // If both keys are strings, compare them lexicographically.\n  if (typeof a == 'string' && typeof b == 'string') {\n    return a < b ? -1 : 1;\n  }\n  // If both keys are numbers, sort them numerically.\n  if (typeof a == 'number' && typeof b == 'number') {\n    return a - b;\n  }\n  // If both keys are booleans, sort `false` before `true`.\n  if (typeof a == 'boolean' && typeof b == 'boolean') {\n    return a < b ? -1 : 1;\n  }\n  // Fallback case: if keys are of different types, compare their string representations.\n  const aString = String(a);\n  const bString = String(b);\n  // Compare the string representations lexicographically.\n  return aString == bString ? 0 : aString < bString ? -1 : 1;\n}\n"]}