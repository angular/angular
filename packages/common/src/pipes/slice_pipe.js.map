{"version":3,"file":"slice_pipe.js","sourceRoot":"","sources":["slice_pipe.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;;AAEH,OAAO,EAAC,IAAI,EAAgB,MAAM,eAAe,CAAC;AAElD,OAAO,EAAC,wBAAwB,EAAC,MAAM,+BAA+B,CAAC;AAEvE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCG;AAKI,IAAM,SAAS,iBAAf,MAAM,SAAS;IAyBpB,SAAS,CACP,KAAmD,EACnD,KAAa,EACb,GAAY;QAEZ,IAAI,KAAK,IAAI,IAAI;YAAE,OAAO,IAAI,CAAC;QAE/B,MAAM,QAAQ,GAAG,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAEnE,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,MAAM,wBAAwB,CAAC,WAAS,EAAE,KAAK,CAAC,CAAC;QACnD,CAAC;QAED,OAAO,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACjC,CAAC;CACF,CAAA;AAxCY,SAAS;IAJrB,IAAI,CAAC;QACJ,IAAI,EAAE,OAAO;QACb,IAAI,EAAE,KAAK;KACZ,CAAC;GACW,SAAS,CAwCrB","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Pipe, PipeTransform} from '@angular/core';\n\nimport {invalidPipeArgumentError} from './invalid_pipe_argument_error';\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Creates a new `Array` or `String` containing a subset (slice) of the elements.\n *\n * @usageNotes\n *\n * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`\n * and `String.prototype.slice()`.\n *\n * When operating on an `Array`, the returned `Array` is always a copy even when all\n * the elements are being returned.\n *\n * When operating on a blank value, the pipe returns the blank value.\n *\n * ### List Example\n *\n * This `ngFor` example:\n *\n * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}\n *\n * produces the following:\n *\n * ```html\n * <li>b</li>\n * <li>c</li>\n * ```\n *\n * ### String Examples\n *\n * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}\n *\n * @publicApi\n */\n@Pipe({\n  name: 'slice',\n  pure: false,\n})\nexport class SlicePipe implements PipeTransform {\n  /**\n   * @param value a list or a string to be sliced.\n   * @param start the starting index of the subset to return:\n   *   - **a positive integer**: return the item at `start` index and all items after\n   *     in the list or string expression.\n   *   - **a negative integer**: return the item at `start` index from the end and all items after\n   *     in the list or string expression.\n   *   - **if positive and greater than the size of the expression**: return an empty list or\n   * string.\n   *   - **if negative and greater than the size of the expression**: return entire list or string.\n   * @param end the ending index of the subset to return:\n   *   - **omitted**: return all items until the end.\n   *   - **if positive**: return all items before `end` index of the list or string.\n   *   - **if negative**: return all items before `end` index from the end of the list or string.\n   */\n  transform<T>(value: ReadonlyArray<T>, start: number, end?: number): Array<T>;\n  transform(value: null | undefined, start: number, end?: number): null;\n  transform<T>(\n    value: ReadonlyArray<T> | null | undefined,\n    start: number,\n    end?: number,\n  ): Array<T> | null;\n  transform(value: string, start: number, end?: number): string;\n  transform(value: string | null | undefined, start: number, end?: number): string | null;\n  transform<T>(\n    value: ReadonlyArray<T> | string | null | undefined,\n    start: number,\n    end?: number,\n  ): Array<T> | string | null {\n    if (value == null) return null;\n\n    const supports = typeof value === 'string' || Array.isArray(value);\n\n    if (!supports) {\n      throw invalidPipeArgumentError(SlicePipe, value);\n    }\n\n    return value.slice(start, end);\n  }\n}\n"]}