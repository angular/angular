{"version":3,"file":"async_pipe.js","sourceRoot":"","sources":["async_pipe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ChangeDetectorRef,\n  EventEmitter,\n  OnDestroy,\n  Pipe,\n  PipeTransform,\n  untracked,\n  ɵisPromise,\n  ɵisSubscribable,\n  ɵINTERNAL_APPLICATION_ERROR_HANDLER as INTERNAL_APPLICATION_ERROR_HANDLER,\n  inject,\n} from '@angular/core';\nimport type {Observable, Subscribable, Unsubscribable} from 'rxjs';\n\nimport {invalidPipeArgumentError} from './invalid_pipe_argument_error';\n\ninterface SubscriptionStrategy {\n  createSubscription(\n    async: Subscribable<any> | PromiseLike<any>,\n    updateLatestValue: any,\n    onError: (e: unknown) => void,\n  ): Unsubscribable | PromiseLike<any>;\n  dispose(subscription: Unsubscribable | PromiseLike<any>): void;\n}\n\nclass SubscribableStrategy implements SubscriptionStrategy {\n  createSubscription(\n    async: Subscribable<any>,\n    updateLatestValue: any,\n    onError: (e: unknown) => void,\n  ): Unsubscribable {\n    // Subscription can be side-effectful, and we don't want any signal reads which happen in the\n    // side effect of the subscription to be tracked by a component's template when that\n    // subscription is triggered via the async pipe. So we wrap the subscription in `untracked` to\n    // decouple from the current reactive context.\n    //\n    // `untracked` also prevents signal _writes_ which happen in the subscription side effect from\n    // being treated as signal writes during the template evaluation (which throws errors).\n    return untracked(() =>\n      async.subscribe({\n        next: updateLatestValue,\n        error: onError,\n      }),\n    );\n  }\n\n  dispose(subscription: Unsubscribable): void {\n    // See the comment in `createSubscription` above on the use of `untracked`.\n    untracked(() => subscription.unsubscribe());\n  }\n}\n\nclass PromiseStrategy implements SubscriptionStrategy {\n  createSubscription(\n    async: PromiseLike<any>,\n    updateLatestValue: ((v: any) => any) | null,\n    onError: ((e: unknown) => void) | null,\n  ): Unsubscribable {\n    // According to the promise specification, promises are not cancellable by default.\n    // Once a promise is created, it will either resolve or reject, and it doesn't\n    // provide a built-in mechanism to cancel it.\n    // There may be situations where a promise is provided, and it either resolves after\n    // the pipe has been destroyed or never resolves at all. If the promise never\n    // resolves — potentially due to factors beyond our control, such as third-party\n    // libraries — this can lead to a memory leak.\n    // When we use `async.then(updateLatestValue)`, the engine captures a reference to the\n    // `updateLatestValue` function. This allows the promise to invoke that function when it\n    // resolves. In this case, the promise directly captures a reference to the\n    // `updateLatestValue` function. If the promise resolves later, it retains a reference\n    // to the original `updateLatestValue`, meaning that even if the context where\n    // `updateLatestValue` was defined has been destroyed, the function reference remains in memory.\n    // This can lead to memory leaks if `updateLatestValue` is no longer needed or if it holds\n    // onto resources that should be released.\n    // When we do `async.then(v => ...)` the promise captures a reference to the lambda\n    // function (the arrow function).\n    // When we assign `updateLatestValue = null` within the context of an `unsubscribe` function,\n    // we're changing the reference of `updateLatestValue` in the current scope to `null`.\n    // The lambda will no longer have access to it after the assignment, effectively\n    // preventing any further calls to the original function and allowing it to be garbage collected.\n    async.then(\n      // Using optional chaining because we may have set it to `null`; since the promise\n      // is async, the view might be destroyed by the time the promise resolves.\n      (v) => updateLatestValue?.(v),\n      (e) => onError?.(e),\n    );\n    return {\n      unsubscribe: () => {\n        updateLatestValue = null;\n        onError = null;\n      },\n    };\n  }\n\n  dispose(subscription: Unsubscribable): void {\n    subscription.unsubscribe();\n  }\n}\n\nconst _promiseStrategy = new PromiseStrategy();\nconst _subscribableStrategy = new SubscribableStrategy();\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Unwraps a value from an asynchronous primitive.\n *\n * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has\n * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for\n * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid\n * potential memory leaks. When the reference of the expression changes, the `async` pipe\n * automatically unsubscribes from the old `Observable` or `Promise` and subscribes to the new one.\n *\n * @usageNotes\n *\n * ### Examples\n *\n * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the\n * promise.\n *\n * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}\n *\n * It's also possible to use `async` with Observables. The example below binds the `time` Observable\n * to the view. The Observable continuously updates the view with the current time.\n *\n * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}\n *\n * @publicApi\n */\n@Pipe({\n  name: 'async',\n  pure: false,\n})\nexport class AsyncPipe implements OnDestroy, PipeTransform {\n  private _ref: ChangeDetectorRef | null;\n  private _latestValue: any = null;\n  private markForCheckOnValueUpdate = true;\n\n  private _subscription: Unsubscribable | PromiseLike<any> | null = null;\n  private _obj: Subscribable<any> | PromiseLike<any> | EventEmitter<any> | null = null;\n  private _strategy: SubscriptionStrategy | null = null;\n  private readonly applicationErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n\n  constructor(ref: ChangeDetectorRef) {\n    // Assign `ref` into `this._ref` manually instead of declaring `_ref` in the constructor\n    // parameter list, as the type of `this._ref` includes `null` unlike the type of `ref`.\n    this._ref = ref;\n  }\n\n  ngOnDestroy(): void {\n    if (this._subscription) {\n      this._dispose();\n    }\n    // Clear the `ChangeDetectorRef` and its association with the view data, to mitigate\n    // potential memory leaks in Observables that could otherwise cause the view data to\n    // be retained.\n    // https://github.com/angular/angular/issues/17624\n    this._ref = null;\n  }\n\n  // NOTE(@benlesh): Because Observable has deprecated a few call patterns for `subscribe`,\n  // TypeScript has a hard time matching Observable to Subscribable, for more information\n  // see https://github.com/microsoft/TypeScript/issues/43643\n\n  transform<T>(obj: Observable<T> | Subscribable<T> | PromiseLike<T>): T | null;\n  transform<T>(obj: null | undefined): null;\n  transform<T>(obj: Observable<T> | Subscribable<T> | PromiseLike<T> | null | undefined): T | null;\n  transform<T>(obj: Observable<T> | Subscribable<T> | PromiseLike<T> | null | undefined): T | null {\n    if (!this._obj) {\n      if (obj) {\n        try {\n          // Only call `markForCheck` if the value is updated asynchronously.\n          // Synchronous updates _during_ subscription should not wastefully mark for check -\n          // this value is already going to be returned from the transform function.\n          this.markForCheckOnValueUpdate = false;\n          this._subscribe(obj);\n        } finally {\n          this.markForCheckOnValueUpdate = true;\n        }\n      }\n      return this._latestValue;\n    }\n\n    if (obj !== this._obj) {\n      this._dispose();\n      return this.transform(obj);\n    }\n\n    return this._latestValue;\n  }\n\n  private _subscribe(obj: Subscribable<any> | PromiseLike<any> | EventEmitter<any>): void {\n    this._obj = obj;\n    this._strategy = this._selectStrategy(obj);\n    this._subscription = this._strategy.createSubscription(\n      obj,\n      (value: Object) => this._updateLatestValue(obj, value),\n      (e) => this.applicationErrorHandler(e),\n    );\n  }\n\n  private _selectStrategy(\n    obj: Subscribable<any> | PromiseLike<any> | EventEmitter<any>,\n  ): SubscriptionStrategy {\n    if (ɵisPromise(obj)) {\n      return _promiseStrategy;\n    }\n\n    if (ɵisSubscribable(obj)) {\n      return _subscribableStrategy;\n    }\n\n    throw invalidPipeArgumentError(AsyncPipe, obj);\n  }\n\n  private _dispose(): void {\n    // Note: `dispose` is only called if a subscription has been initialized before, indicating\n    // that `this._strategy` is also available.\n    this._strategy!.dispose(this._subscription!);\n    this._latestValue = null;\n    this._subscription = null;\n    this._obj = null;\n  }\n\n  private _updateLatestValue(async: any, value: Object): void {\n    if (async === this._obj) {\n      this._latestValue = value;\n      if (this.markForCheckOnValueUpdate) {\n        this._ref?.markForCheck();\n      }\n    }\n  }\n}\n"]}