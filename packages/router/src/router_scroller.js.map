{"version":3,"file":"router_scroller.js","sourceRoot":"","sources":["router_scroller.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ViewportScroller} from '@angular/common';\nimport {Injectable, InjectionToken, NgZone, OnDestroy} from '@angular/core';\nimport {Unsubscribable} from 'rxjs';\n\nimport {\n  IMPERATIVE_NAVIGATION,\n  NavigationEnd,\n  NavigationSkipped,\n  NavigationSkippedCode,\n  NavigationStart,\n  NavigationTrigger,\n  Scroll,\n} from './events';\nimport {NavigationTransitions} from './navigation_transition';\nimport {UrlSerializer} from './url_tree';\n\nexport const ROUTER_SCROLLER = new InjectionToken<RouterScroller>('');\n\n@Injectable()\nexport class RouterScroller implements OnDestroy {\n  private routerEventsSubscription?: Unsubscribable;\n  private scrollEventsSubscription?: Unsubscribable;\n\n  private lastId = 0;\n  private lastSource: NavigationTrigger | undefined = IMPERATIVE_NAVIGATION;\n  private restoredId = 0;\n  private store: {[key: string]: [number, number]} = {};\n\n  /** @docs-private */\n  constructor(\n    readonly urlSerializer: UrlSerializer,\n    private transitions: NavigationTransitions,\n    public readonly viewportScroller: ViewportScroller,\n    private readonly zone: NgZone,\n    private options: {\n      scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n      anchorScrolling?: 'disabled' | 'enabled';\n    } = {},\n  ) {\n    // Default both options to 'disabled'\n    options.scrollPositionRestoration ||= 'disabled';\n    options.anchorScrolling ||= 'disabled';\n  }\n\n  init(): void {\n    // we want to disable the automatic scrolling because having two places\n    // responsible for scrolling results race conditions, especially given\n    // that browser don't implement this behavior consistently\n    if (this.options.scrollPositionRestoration !== 'disabled') {\n      this.viewportScroller.setHistoryScrollRestoration('manual');\n    }\n    this.routerEventsSubscription = this.createScrollEvents();\n    this.scrollEventsSubscription = this.consumeScrollEvents();\n  }\n\n  private createScrollEvents() {\n    return this.transitions.events.subscribe((e) => {\n      if (e instanceof NavigationStart) {\n        // store the scroll position of the current stable navigations.\n        this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n        this.lastSource = e.navigationTrigger;\n        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n      } else if (e instanceof NavigationEnd) {\n        this.lastId = e.id;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);\n      } else if (\n        e instanceof NavigationSkipped &&\n        e.code === NavigationSkippedCode.IgnoredSameUrlNavigation\n      ) {\n        this.lastSource = undefined;\n        this.restoredId = 0;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);\n      }\n    });\n  }\n\n  private consumeScrollEvents() {\n    return this.transitions.events.subscribe((e) => {\n      if (!(e instanceof Scroll)) return;\n      // a popstate event. The pop state event will always ignore anchor scrolling.\n      if (e.position) {\n        if (this.options.scrollPositionRestoration === 'top') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        } else if (this.options.scrollPositionRestoration === 'enabled') {\n          this.viewportScroller.scrollToPosition(e.position);\n        }\n        // imperative navigation \"forward\"\n      } else {\n        if (e.anchor && this.options.anchorScrolling === 'enabled') {\n          this.viewportScroller.scrollToAnchor(e.anchor);\n        } else if (this.options.scrollPositionRestoration !== 'disabled') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        }\n      }\n    });\n  }\n\n  private scheduleScrollEvent(\n    routerEvent: NavigationEnd | NavigationSkipped,\n    anchor: string | null,\n  ): void {\n    this.zone.runOutsideAngular(async () => {\n      // The scroll event needs to be delayed until after change detection. Otherwise, we may\n      // attempt to restore the scroll position before the router outlet has fully rendered the\n      // component by executing its update block of the template function.\n      //\n      // #57109 (we need to wait at least a macrotask before scrolling. AfterNextRender resolves in microtask event loop with Zones)\n      // We could consider _also_ waiting for a render promise though one should have already happened or been scheduled by this point\n      // and should definitely happen before rAF/setTimeout.\n      // #53985 (cannot rely solely on setTimeout because a frame may paint before the timeout)\n      await new Promise((resolve) => {\n        setTimeout(resolve);\n        if (typeof requestAnimationFrame !== 'undefined') {\n          requestAnimationFrame(resolve);\n        }\n      });\n      this.zone.run(() => {\n        this.transitions.events.next(\n          new Scroll(\n            routerEvent,\n            this.lastSource === 'popstate' ? this.store[this.restoredId] : null,\n            anchor,\n          ),\n        );\n      });\n    });\n  }\n\n  /** @docs-private */\n  ngOnDestroy(): void {\n    this.routerEventsSubscription?.unsubscribe();\n    this.scrollEventsSubscription?.unsubscribe();\n  }\n}\n"]}