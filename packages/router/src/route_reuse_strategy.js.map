{"version":3,"file":"route_reuse_strategy.js","sourceRoot":"","sources":["route_reuse_strategy.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;AAEH,OAAO,EAAe,MAAM,EAAE,UAAU,EAAC,MAAM,eAAe,CAAC;AAyB/D;;;;;;GAMG;AAEI,IAAe,kBAAkB,GAAjC,MAAe,kBAAkB;CAmBvC,CAAA;AAnBqB,kBAAkB;IADvC,UAAU,CAAC,EAAC,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,yBAAyB,CAAC,EAAC,CAAC;GAChE,kBAAkB,CAmBvC;;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,OAAgB,sBAAsB;IAC1C;;;SAGK;IACL,YAAY,CAAC,KAA6B;QACxC,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,KAA6B,EAAE,YAAiC,IAAS,CAAC;IAEhF,+EAA+E;IAC/E,YAAY,CAAC,KAA6B;QACxC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,mFAAmF;IACnF,QAAQ,CAAC,KAA6B;QACpC,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;OAIG;IACH,gBAAgB,CAAC,MAA8B,EAAE,IAA4B;QAC3E,OAAO,MAAM,CAAC,WAAW,KAAK,IAAI,CAAC,WAAW,CAAC;IACjD,CAAC;CACF;AAGM,IAAM,yBAAyB,GAA/B,MAAM,yBAA0B,SAAQ,sBAAsB;CAAG,CAAA;AAA3D,yBAAyB;IADrC,UAAU,CAAC,EAAC,UAAU,EAAE,MAAM,EAAC,CAAC;GACpB,yBAAyB,CAAkC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentRef, inject, Injectable} from '@angular/core';\n\nimport {OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport type DetachedRouteHandle = {};\n\n/** @internal */\nexport type DetachedRouteHandleInternal = {\n  contexts: Map<string, OutletContext>;\n  componentRef: ComponentRef<any>;\n  route: TreeNode<ActivatedRoute>;\n};\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy)})\nexport abstract class RouteReuseStrategy {\n  /** Determines if this route (and its subtree) should be detached to be reused later */\n  abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   */\n  abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;\n\n  /** Determines if this route (and its subtree) should be reattached */\n  abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n\n  /** Retrieves the previously stored route */\n  abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\n\n  /** Determines if a route should be reused */\n  abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the route parameters, query parameters or fragment change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nexport abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {\n  /**\n   * Whether the given route should detach for later reuse.\n   * Always returns false for `BaseRouteReuseStrategy`.\n   * */\n  shouldDetach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /**\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n   */\n  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {}\n\n  /** Returns `false`, meaning the route (and its subtree) is never reattached */\n  shouldAttach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /** Returns `null` because this strategy does not store routes for later re-use. */\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null {\n    return null;\n  }\n\n  /**\n   * Determines if a route should be reused.\n   * This strategy returns `true` when the future route config and current route config are\n   * identical.\n   */\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\n\n@Injectable({providedIn: 'root'})\nexport class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {}\n"]}