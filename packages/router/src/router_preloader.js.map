{"version":3,"file":"router_preloader.js","sourceRoot":"","sources":["router_preloader.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {createEnvironmentInjector, EnvironmentInjector, Injectable, OnDestroy} from '@angular/core';\nimport {from, Observable, of, Subscription} from 'rxjs';\nimport {catchError, concatMap, filter, mergeAll, mergeMap} from 'rxjs/operators';\n\nimport {Event, NavigationEnd} from './events';\nimport {LoadedRouterConfig, Route, Routes} from './models';\nimport {Router} from './router';\nimport {RouterConfigLoader} from './router_config_loader';\n\n/**\n * @description\n *\n * Provides a preloading strategy.\n *\n * @publicApi\n */\nexport abstract class PreloadingStrategy {\n  abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```ts\n * RouterModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class PreloadAllModules implements PreloadingStrategy {\n  preload(route: Route, fn: () => Observable<any>): Observable<any> {\n    return fn().pipe(catchError(() => of(null)));\n  }\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class NoPreloading implements PreloadingStrategy {\n  preload(route: Route, fn: () => Observable<any>): Observable<any> {\n    return of(null);\n  }\n}\n\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class RouterPreloader implements OnDestroy {\n  private subscription?: Subscription;\n\n  constructor(\n    private router: Router,\n    private injector: EnvironmentInjector,\n    private preloadingStrategy: PreloadingStrategy,\n    private loader: RouterConfigLoader,\n  ) {}\n\n  setUpPreloading(): void {\n    this.subscription = this.router.events\n      .pipe(\n        filter((e: Event) => e instanceof NavigationEnd),\n        concatMap(() => this.preload()),\n      )\n      .subscribe(() => {});\n  }\n\n  preload(): Observable<any> {\n    return this.processRoutes(this.injector, this.router.config);\n  }\n\n  /** @docs-private */\n  ngOnDestroy(): void {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  private processRoutes(injector: EnvironmentInjector, routes: Routes): Observable<void> {\n    const res: Observable<any>[] = [];\n    for (const route of routes) {\n      if (route.providers && !route._injector) {\n        route._injector = createEnvironmentInjector(\n          route.providers,\n          injector,\n          `Route: ${route.path}`,\n        );\n      }\n\n      const injectorForCurrentRoute = route._injector ?? injector;\n      const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;\n\n      // Note that `canLoad` is only checked as a condition that prevents `loadChildren` and not\n      // `loadComponent`. `canLoad` guards only block loading of child routes by design. This\n      // happens as a consequence of needing to descend into children for route matching immediately\n      // while component loading is deferred until route activation. Because `canLoad` guards can\n      // have side effects, we cannot execute them here so we instead skip preloading altogether\n      // when present. Lastly, it remains to be decided whether `canLoad` should behave this way\n      // at all. Code splitting and lazy loading is separate from client-side authorization checks\n      // and should not be used as a security measure to prevent loading of code.\n      if (\n        (route.loadChildren && !route._loadedRoutes && route.canLoad === undefined) ||\n        (route.loadComponent && !route._loadedComponent)\n      ) {\n        res.push(this.preloadConfig(injectorForCurrentRoute, route));\n      }\n      if (route.children || route._loadedRoutes) {\n        res.push(this.processRoutes(injectorForChildren, (route.children ?? route._loadedRoutes)!));\n      }\n    }\n    return from(res).pipe(mergeAll());\n  }\n\n  private preloadConfig(injector: EnvironmentInjector, route: Route): Observable<void> {\n    return this.preloadingStrategy.preload(route, () => {\n      let loadedChildren$: Observable<LoadedRouterConfig | null>;\n      if (route.loadChildren && route.canLoad === undefined) {\n        loadedChildren$ = this.loader.loadChildren(injector, route);\n      } else {\n        loadedChildren$ = of(null);\n      }\n\n      const recursiveLoadChildren$ = loadedChildren$.pipe(\n        mergeMap((config: LoadedRouterConfig | null) => {\n          if (config === null) {\n            return of(void 0);\n          }\n          route._loadedRoutes = config.routes;\n          route._loadedInjector = config.injector;\n          // If the loaded config was a module, use that as the module/module injector going\n          // forward. Otherwise, continue using the current module/module injector.\n          return this.processRoutes(config.injector ?? injector, config.routes);\n        }),\n      );\n      if (route.loadComponent && !route._loadedComponent) {\n        const loadComponent$ = this.loader.loadComponent(injector, route);\n        return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());\n      } else {\n        return recursiveLoadChildren$;\n      }\n    });\n  }\n}\n"]}