{"version":3,"file":"router_outlet_context.js","sourceRoot":"","sources":["router_outlet_context.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;AAEH,OAAO,EAAoC,UAAU,EAAC,MAAM,eAAe,CAAC;AAI5E,OAAO,EAAC,uBAAuB,EAAC,MAAM,gBAAgB,CAAC;AAEvD;;;;GAIG;AACH,MAAM,OAAO,aAAa;IAKxB,IAAI,QAAQ;QACV,OAAO,uBAAuB,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC;IAC5E,CAAC;IAED,YAA6B,YAAiC;QAAjC,iBAAY,GAAZ,YAAY,CAAqB;QAR9D,WAAM,GAAgC,IAAI,CAAC;QAC3C,UAAK,GAA0B,IAAI,CAAC;QAEpC,cAAS,GAA6B,IAAI,CAAC;QAMzC,IAAI,CAAC,QAAQ,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAChE,CAAC;CACF;AAED;;;;GAIG;AAEI,IAAM,sBAAsB,GAA5B,MAAM,sBAAsB;IAIjC,oBAAoB;IACpB,YAAoB,YAAiC;QAAjC,iBAAY,GAAZ,YAAY,CAAqB;QAJrD,uCAAuC;QAC/B,aAAQ,GAAG,IAAI,GAAG,EAAyB,CAAC;IAGI,CAAC;IAEzD,6DAA6D;IAC7D,oBAAoB,CAAC,SAAiB,EAAE,MAA4B;QAClE,MAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;QACnD,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC;QACxB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;IACxC,CAAC;IAED;;;;OAIG;IACH,sBAAsB,CAAC,SAAiB;QACtC,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QAC3C,IAAI,OAAO,EAAE,CAAC;YACZ,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;YACtB,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC;QAC3B,CAAC;IACH,CAAC;IAED;;;OAGG;IACH,mBAAmB;QACjB,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;QAC1B,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,kBAAkB,CAAC,QAAoC;QACrD,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAED,kBAAkB,CAAC,SAAiB;QAClC,IAAI,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QAEzC,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,OAAO,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAC/C,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QACxC,CAAC;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,UAAU,CAAC,SAAiB;QAC1B,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC;IAC9C,CAAC;CACF,CAAA;AAvDY,sBAAsB;IADlC,UAAU,CAAC,EAAC,UAAU,EAAE,MAAM,EAAC,CAAC;GACpB,sBAAsB,CAuDlC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentRef, EnvironmentInjector, Injectable} from '@angular/core';\n\nimport type {RouterOutletContract} from './directives/router_outlet';\nimport {ActivatedRoute} from './router_state';\nimport {getClosestRouteInjector} from './utils/config';\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport class OutletContext {\n  outlet: RouterOutletContract | null = null;\n  route: ActivatedRoute | null = null;\n  children: ChildrenOutletContexts;\n  attachRef: ComponentRef<any> | null = null;\n  get injector(): EnvironmentInjector {\n    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\n  }\n\n  constructor(private readonly rootInjector: EnvironmentInjector) {\n    this.children = new ChildrenOutletContexts(this.rootInjector);\n  }\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class ChildrenOutletContexts {\n  // contexts for child outlets, by name.\n  private contexts = new Map<string, OutletContext>();\n\n  /** @docs-private */\n  constructor(private rootInjector: EnvironmentInjector) {}\n\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName: string, outlet: RouterOutletContract): void {\n    const context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n\n  /**\n   * Called when a `RouterOutlet` directive is destroyed.\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n   * re-created later.\n   */\n  onChildOutletDestroyed(childName: string): void {\n    const context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n      context.attachRef = null;\n    }\n  }\n\n  /**\n   * Called when the corresponding route is deactivated during navigation.\n   * Because the component get destroyed, all children outlet are destroyed.\n   */\n  onOutletDeactivated(): Map<string, OutletContext> {\n    const contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n\n  onOutletReAttached(contexts: Map<string, OutletContext>): void {\n    this.contexts = contexts;\n  }\n\n  getOrCreateContext(childName: string): OutletContext {\n    let context = this.getContext(childName);\n\n    if (!context) {\n      context = new OutletContext(this.rootInjector);\n      this.contexts.set(childName, context);\n    }\n\n    return context;\n  }\n\n  getContext(childName: string): OutletContext | null {\n    return this.contexts.get(childName) || null;\n  }\n}\n"]}