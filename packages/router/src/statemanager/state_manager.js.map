{"version":3,"file":"state_manager.js","sourceRoot":"","sources":["state_manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {inject, Injectable} from '@angular/core';\nimport {SubscriptionLike} from 'rxjs';\n\nimport {\n  BeforeActivateRoutes,\n  Event,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationError,\n  NavigationSkipped,\n  NavigationStart,\n  NavigationTrigger,\n  PrivateRouterEvents,\n  RoutesRecognized,\n} from '../events';\nimport {Navigation, RestoredState} from '../navigation_transition';\nimport {ROUTER_CONFIGURATION} from '../router_config';\nimport {createEmptyState, RouterState} from '../router_state';\nimport {UrlHandlingStrategy} from '../url_handling_strategy';\nimport {UrlSerializer, UrlTree} from '../url_tree';\n\n@Injectable({providedIn: 'root', useFactory: () => inject(HistoryStateManager)})\nexport abstract class StateManager {\n  protected readonly urlSerializer = inject(UrlSerializer);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  protected readonly canceledNavigationResolution =\n    this.options.canceledNavigationResolution || 'replace';\n  protected location = inject(Location);\n  protected urlHandlingStrategy = inject(UrlHandlingStrategy);\n  protected urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n\n  private currentUrlTree = new UrlTree();\n  /**\n   * Returns the currently activated `UrlTree`.\n   *\n   * This `UrlTree` shows only URLs that the `Router` is configured to handle (through\n   * `UrlHandlingStrategy`).\n   *\n   * The value is set after finding the route config tree to activate but before activating the\n   * route.\n   */\n  getCurrentUrlTree(): UrlTree {\n    return this.currentUrlTree;\n  }\n\n  private rawUrlTree = this.currentUrlTree;\n  /**\n   * Returns a `UrlTree` that is represents what the browser is actually showing.\n   *\n   * In the life of a navigation transition:\n   * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being\n   * navigated to.\n   * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due\n   * to `UrlHandlingStrategy`).\n   * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the\n   * original raw URL.\n   *\n   * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and\n   * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not\n   * deviated from the raw `UrlTree`.\n   *\n   * For `extract`, a raw `UrlTree` is needed because `extract` may only return part\n   * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser\n   * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation\n   * occurs, it needs to know the _whole_ browser URL, not just the part handled by\n   * `UrlHandlingStrategy`.\n   * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but\n   * still updates the raw `UrlTree` with the assumption that the navigation was caused by the\n   * location change listener due to a URL update by the AngularJS router. In this case, the router\n   * still need to know what the browser's URL is for future navigations.\n   */\n  getRawUrlTree(): UrlTree {\n    return this.rawUrlTree;\n  }\n\n  protected createBrowserPath({finalUrl, initialUrl, targetBrowserUrl}: Navigation): string {\n    const rawUrl =\n      finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl!, initialUrl) : initialUrl;\n    const url = targetBrowserUrl ?? rawUrl;\n    const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n    return path;\n  }\n\n  protected commitTransition({targetRouterState, finalUrl, initialUrl}: Navigation): void {\n    // If we are committing the transition after having a final URL and target state, we're updating\n    // all pieces of the state. Otherwise, we likely skipped the transition (due to URL handling strategy)\n    // and only want to update the rawUrlTree, which represents the browser URL (and doesn't necessarily match router state).\n    if (finalUrl && targetRouterState) {\n      this.currentUrlTree = finalUrl;\n      this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);\n      this.routerState = targetRouterState;\n    } else {\n      this.rawUrlTree = initialUrl;\n    }\n  }\n\n  private routerState = createEmptyState(null);\n\n  /** Returns the current RouterState. */\n  getRouterState(): RouterState {\n    return this.routerState;\n  }\n\n  private stateMemento = this.createStateMemento();\n\n  protected updateStateMemento(): void {\n    this.stateMemento = this.createStateMemento();\n  }\n\n  private createStateMemento() {\n    return {\n      rawUrlTree: this.rawUrlTree,\n      currentUrlTree: this.currentUrlTree,\n      routerState: this.routerState,\n    };\n  }\n\n  protected resetInternalState({finalUrl}: Navigation): void {\n    this.routerState = this.stateMemento.routerState;\n    this.currentUrlTree = this.stateMemento.currentUrlTree;\n    // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\n    // configured to handle only part of the navigation URL. This means we would only want to reset\n    // the part of the navigation handled by the Angular router rather than the whole URL. In\n    // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n    // when merging, such as the query params so they are not lost on a refresh.\n    this.rawUrlTree = this.urlHandlingStrategy.merge(\n      this.currentUrlTree,\n      finalUrl ?? this.rawUrlTree,\n    );\n  }\n\n  /** Returns the current state stored by the browser for the current history entry. */\n  abstract restoredState(): RestoredState | null | undefined;\n\n  /**\n   * Registers a listener that is called whenever the current history entry changes by some API\n   * outside the Router. This includes user-activated changes like back buttons and link clicks, but\n   * also includes programmatic APIs called by non-Router JavaScript.\n   */\n  abstract registerNonRouterCurrentEntryChangeListener(\n    listener: (\n      url: string,\n      state: RestoredState | null | undefined,\n      trigger: NavigationTrigger,\n    ) => void,\n  ): SubscriptionLike;\n\n  /**\n   * Handles a navigation event sent from the Router. These are typically events that indicate a\n   * navigation has started, progressed, been cancelled, or finished.\n   */\n  abstract handleRouterEvent(e: Event | PrivateRouterEvents, currentTransition: Navigation): void;\n}\n\n@Injectable({providedIn: 'root'})\nexport class HistoryStateManager extends StateManager {\n  /**\n   * The id of the currently active page in the router.\n   * Updated to the transition's target id on a successful navigation.\n   *\n   * This is used to track what page the router last activated. When an attempted navigation fails,\n   * the router can then use this to compute how to restore the state back to the previously active\n   * page.\n   */\n  private currentPageId: number = 0;\n  private lastSuccessfulId: number = -1;\n\n  override restoredState(): RestoredState | null | undefined {\n    return this.location.getState() as RestoredState | null | undefined;\n  }\n\n  /**\n   * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n   * important for computing the target page id for new navigations because we need to ensure each\n   * page id in the browser history is 1 more than the previous entry.\n   */\n  private get browserPageId(): number {\n    if (this.canceledNavigationResolution !== 'computed') {\n      return this.currentPageId;\n    }\n    return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;\n  }\n\n  override registerNonRouterCurrentEntryChangeListener(\n    listener: (\n      url: string,\n      state: RestoredState | null | undefined,\n      trigger: NavigationTrigger,\n    ) => void,\n  ): SubscriptionLike {\n    return this.location.subscribe((event) => {\n      if (event['type'] === 'popstate') {\n        // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n        // hybrid apps.\n        setTimeout(() => {\n          listener(event['url']!, event.state as RestoredState | null | undefined, 'popstate');\n        });\n      }\n    });\n  }\n\n  override handleRouterEvent(e: Event | PrivateRouterEvents, currentTransition: Navigation): void {\n    if (e instanceof NavigationStart) {\n      this.updateStateMemento();\n    } else if (e instanceof NavigationSkipped) {\n      this.commitTransition(currentTransition);\n    } else if (e instanceof RoutesRecognized) {\n      if (this.urlUpdateStrategy === 'eager') {\n        if (!currentTransition.extras.skipLocationChange) {\n          this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n        }\n      }\n    } else if (e instanceof BeforeActivateRoutes) {\n      this.commitTransition(currentTransition);\n      if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\n        this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n      }\n    } else if (\n      e instanceof NavigationCancel &&\n      e.code !== NavigationCancellationCode.SupersededByNewNavigation &&\n      e.code !== NavigationCancellationCode.Redirect\n    ) {\n      this.restoreHistory(currentTransition);\n    } else if (e instanceof NavigationError) {\n      this.restoreHistory(currentTransition, true);\n    } else if (e instanceof NavigationEnd) {\n      this.lastSuccessfulId = e.id;\n      this.currentPageId = this.browserPageId;\n    }\n  }\n\n  private setBrowserUrl(path: string, {extras, id}: Navigation) {\n    const {replaceUrl, state} = extras;\n    if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {\n      // replacements do not update the target page\n      const currentBrowserPageId = this.browserPageId;\n      const newState = {\n        ...state,\n        ...this.generateNgRouterState(id, currentBrowserPageId),\n      };\n      this.location.replaceState(path, '', newState);\n    } else {\n      const newState = {\n        ...state,\n        ...this.generateNgRouterState(id, this.browserPageId + 1),\n      };\n      this.location.go(path, '', newState);\n    }\n  }\n\n  /**\n   * Performs the necessary rollback action to restore the browser URL to the\n   * state before the transition.\n   */\n  private restoreHistory(navigation: Navigation, restoringFromCaughtError = false) {\n    if (this.canceledNavigationResolution === 'computed') {\n      const currentBrowserPageId = this.browserPageId;\n      const targetPagePosition = this.currentPageId - currentBrowserPageId;\n      if (targetPagePosition !== 0) {\n        this.location.historyGo(targetPagePosition);\n      } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {\n        // We got to the activation stage (where currentUrlTree is set to the navigation's\n        // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n        // We still need to reset the router state back to what it was when the navigation started.\n        this.resetInternalState(navigation);\n        this.resetUrlToCurrentUrlTree();\n      } else {\n        // The browser URL and router state was not updated before the navigation cancelled so\n        // there's no restoration needed.\n      }\n    } else if (this.canceledNavigationResolution === 'replace') {\n      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n      // for `deferred` navigations that haven't change the internal state yet because guards\n      // reject. For 'eager' navigations, it seems like we also really should reset the state\n      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n      if (restoringFromCaughtError) {\n        this.resetInternalState(navigation);\n      }\n      this.resetUrlToCurrentUrlTree();\n    }\n  }\n\n  private resetUrlToCurrentUrlTree(): void {\n    this.location.replaceState(\n      this.urlSerializer.serialize(this.getRawUrlTree()),\n      '',\n      this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId),\n    );\n  }\n\n  private generateNgRouterState(navigationId: number, routerPageId: number) {\n    if (this.canceledNavigationResolution === 'computed') {\n      return {navigationId, ɵrouterPageId: routerPageId};\n    }\n    return {navigationId};\n  }\n}\n"]}