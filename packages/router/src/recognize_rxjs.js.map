{"version":3,"file":"recognize_rxjs.js","sourceRoot":"","sources":["recognize_rxjs.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, Type, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {from, Observable, of} from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  defaultIfEmpty,\n  first,\n  last,\n  map,\n  mergeMap,\n  scan,\n  switchMap,\n  tap,\n} from 'rxjs/operators';\n\nimport {\n  AbsoluteRedirect,\n  ApplyRedirects,\n  canLoadFails,\n  noMatch,\n  NoMatch,\n} from './apply_redirects_rxjs';\nimport {createUrlTreeFromSnapshot} from './create_url_tree';\nimport {RuntimeErrorCode} from './errors';\nimport {Data, LoadedRouterConfig, ResolveData, Route, Routes} from './models';\nimport {runCanLoadGuards} from './operators/check_guards';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {\n  ActivatedRouteSnapshot,\n  getInherited,\n  ParamsInheritanceStrategy,\n  RouterStateSnapshot,\n} from './router_state';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {getOutlet, sortByMatchingOutlets} from './utils/config';\nimport {\n  emptyPathMatch,\n  match,\n  matchWithChecks,\n  noLeftoversInUrl,\n  split,\n} from './utils/config_matching';\nimport {TreeNode} from './utils/tree';\nimport {isEmptyError} from './utils/type_guards';\n\n/**\n * Class used to indicate there were no additional route config matches but that all segments of\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\n * try to match child configs in case there are empty path children.\n */\nclass NoLeftoversInUrl {}\n\nexport function recognize(\n  injector: EnvironmentInjector,\n  configLoader: RouterConfigLoader,\n  rootComponentType: Type<any> | null,\n  config: Routes,\n  urlTree: UrlTree,\n  urlSerializer: UrlSerializer,\n  paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n  abortSignal: AbortSignal,\n): Observable<{state: RouterStateSnapshot; tree: UrlTree}> {\n  return new Recognizer(\n    injector,\n    configLoader,\n    rootComponentType,\n    config,\n    urlTree,\n    paramsInheritanceStrategy,\n    urlSerializer,\n  ).recognize();\n}\n\nconst MAX_ALLOWED_REDIRECTS = 31;\n\nexport class Recognizer {\n  private applyRedirects: ApplyRedirects;\n  private absoluteRedirectCount = 0;\n  allowRedirects = true;\n\n  constructor(\n    private injector: EnvironmentInjector,\n    private configLoader: RouterConfigLoader,\n    private rootComponentType: Type<any> | null,\n    private config: Routes,\n    private urlTree: UrlTree,\n    private paramsInheritanceStrategy: ParamsInheritanceStrategy,\n    private readonly urlSerializer: UrlSerializer,\n  ) {\n    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  }\n\n  private noMatchError(e: NoMatch): RuntimeError<RuntimeErrorCode.NO_MATCH> {\n    return new RuntimeError(\n      RuntimeErrorCode.NO_MATCH,\n      typeof ngDevMode === 'undefined' || ngDevMode\n        ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'`\n        : `'${e.segmentGroup}'`,\n    );\n  }\n\n  recognize(): Observable<{state: RouterStateSnapshot; tree: UrlTree}> {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n\n    return this.match(rootSegmentGroup).pipe(\n      map(({children, rootSnapshot}) => {\n        const rootNode = new TreeNode(rootSnapshot, children);\n        const routeState = new RouterStateSnapshot('', rootNode);\n        const tree = createUrlTreeFromSnapshot(\n          rootSnapshot,\n          [],\n          this.urlTree.queryParams,\n          this.urlTree.fragment,\n        );\n        // https://github.com/angular/angular/issues/47307\n        // Creating the tree stringifies the query params\n        // We don't want to do this here so reassign them to the original.\n        tree.queryParams = this.urlTree.queryParams;\n        routeState.url = this.urlSerializer.serialize(tree);\n        return {state: routeState, tree};\n      }),\n    );\n  }\n\n  private match(rootSegmentGroup: UrlSegmentGroup): Observable<{\n    children: TreeNode<ActivatedRouteSnapshot>[];\n    rootSnapshot: ActivatedRouteSnapshot;\n  }> {\n    // Use Object.freeze to prevent readers of the Router state from modifying it outside\n    // of a navigation, resulting in the router being out of sync with the browser.\n    const rootSnapshot = new ActivatedRouteSnapshot(\n      [],\n      Object.freeze({}),\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      Object.freeze({}),\n      PRIMARY_OUTLET,\n      this.rootComponentType,\n      null,\n      {},\n    );\n    return this.processSegmentGroup(\n      this.injector,\n      this.config,\n      rootSegmentGroup,\n      PRIMARY_OUTLET,\n      rootSnapshot,\n    ).pipe(\n      map((children) => {\n        return {children, rootSnapshot};\n      }),\n      catchError((e: any) => {\n        if (e instanceof AbsoluteRedirect) {\n          this.urlTree = e.urlTree;\n          return this.match(e.urlTree.root);\n        }\n        if (e instanceof NoMatch) {\n          throw this.noMatchError(e);\n        }\n\n        throw e;\n      }),\n    );\n  }\n\n  processSegmentGroup(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup, parentRoute);\n    }\n\n    return this.processSegment(\n      injector,\n      config,\n      segmentGroup,\n      segmentGroup.segments,\n      outlet,\n      true,\n      parentRoute,\n    ).pipe(map((child) => (child instanceof TreeNode ? [child] : [])));\n  }\n\n  /**\n   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n   * we cannot find a match for _any_ of the children.\n   *\n   * @param config - The `Routes` to match against\n   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n   *     config.\n   */\n  processChildren(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n    // because an absolute redirect from the primary outlet takes precedence.\n    const childOutlets: string[] = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n    return from(childOutlets).pipe(\n      concatMap((childOutlet) => {\n        const child = segmentGroup.children[childOutlet];\n        // Sort the config so that routes with outlets that match the one being activated\n        // appear first, followed by routes for other outlets, which might match if they have\n        // an empty path.\n        const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n        return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n      }),\n      scan((children, outletChildren) => {\n        children.push(...outletChildren);\n        return children;\n      }),\n      defaultIfEmpty(null as TreeNode<ActivatedRouteSnapshot>[] | null),\n      last(),\n      mergeMap((children) => {\n        if (children === null) return noMatch(segmentGroup);\n        // Because we may have matched two outlets to the same empty path segment, we can have\n        // multiple activated results for the same outlet. We should merge the children of\n        // these results so the final return value is only one `TreeNode` per outlet.\n        const mergedChildren = mergeEmptyPathMatches(children);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          // This should really never happen - we are only taking the first match for each\n          // outlet and merge the empty path matches.\n          checkOutletNameUniqueness(mergedChildren);\n        }\n        sortActivatedRouteSnapshots(mergedChildren);\n        return of(mergedChildren);\n      }),\n    );\n  }\n\n  processSegment(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    segmentGroup: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    return from(routes).pipe(\n      concatMap((r) => {\n        return this.processSegmentAgainstRoute(\n          r._injector ?? injector,\n          routes,\n          r,\n          segmentGroup,\n          segments,\n          outlet,\n          allowRedirects,\n          parentRoute,\n        ).pipe(\n          catchError((e: any) => {\n            if (e instanceof NoMatch) {\n              return of(null);\n            }\n            throw e;\n          }),\n        );\n      }),\n      first((x): x is TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl => !!x),\n      catchError((e) => {\n        if (isEmptyError(e)) {\n          if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return of(new NoLeftoversInUrl());\n          }\n          return noMatch(segmentGroup);\n        }\n        throw e;\n      }),\n    );\n  }\n\n  processSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    route: Route,\n    rawSegment: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n    // a config like\n    // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n    // or even\n    // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n    //\n    // The exception here is when the segment outlet is for the primary outlet. This would\n    // result in a match inside the named outlet because all children there are written as primary\n    // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n    // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n    // This should only match if the url is `/(x:b)`.\n    if (\n      getOutlet(route) !== outlet &&\n      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))\n    ) {\n      return noMatch(rawSegment);\n    }\n\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(\n        injector,\n        rawSegment,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(\n        injector,\n        rawSegment,\n        routes,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    return noMatch(rawSegment);\n  }\n\n  private expandSegmentAgainstRouteUsingRedirect(\n    injector: EnvironmentInjector,\n    segmentGroup: UrlSegmentGroup,\n    routes: Route[],\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    const {matched, parameters, consumedSegments, positionalParamSegments, remainingSegments} =\n      match(segmentGroup, route, segments);\n    if (!matched) return noMatch(segmentGroup);\n\n    // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\n    // size exceeded in production\n    if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new RuntimeError(\n            RuntimeErrorCode.INFINITE_REDIRECT,\n            `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` +\n              `This is currently a dev mode only error but will become a` +\n              ` call stack size exceeded error in production in a future major version.`,\n          );\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const currentSnapshot = new ActivatedRouteSnapshot(\n      segments,\n      parameters,\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      getData(route),\n      getOutlet(route),\n      route.component ?? route._loadedComponent ?? null,\n      route,\n      getResolve(route),\n    );\n    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n    currentSnapshot.params = Object.freeze(inherited.params);\n    currentSnapshot.data = Object.freeze(inherited.data);\n    const newTree$: Observable<UrlTree> = this.applyRedirects.applyRedirectCommands(\n      consumedSegments,\n      route.redirectTo!,\n      positionalParamSegments,\n      currentSnapshot,\n      injector,\n    );\n\n    return newTree$.pipe(\n      switchMap((newTree) => this.applyRedirects.lineralizeSegments(route, newTree)),\n      mergeMap((newSegments: UrlSegment[]) => {\n        return this.processSegment(\n          injector,\n          routes,\n          segmentGroup,\n          newSegments.concat(remainingSegments),\n          outlet,\n          false,\n          parentRoute,\n        );\n      }),\n    );\n  }\n\n  matchSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    rawSegment: UrlSegmentGroup,\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>> {\n    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n    if (route.path === '**') {\n      // Prior versions of the route matching algorithm would stop matching at the wildcard route.\n      // We should investigate a better strategy for any existing children. Otherwise, these\n      // child segments are silently dropped from the navigation.\n      // https://github.com/angular/angular/issues/40089\n      rawSegment.children = {};\n    }\n\n    return matchResult.pipe(\n      switchMap((result) => {\n        if (!result.matched) {\n          return noMatch(rawSegment);\n        }\n        // If the route has an injector created from providers, we should start using that.\n        injector = route._injector ?? injector;\n        return this.getChildConfig(injector, route, segments).pipe(\n          switchMap(({routes: childConfig}) => {\n            const childInjector = route._loadedInjector ?? injector;\n\n            const {parameters, consumedSegments, remainingSegments} = result;\n            const snapshot = new ActivatedRouteSnapshot(\n              consumedSegments,\n              parameters,\n              Object.freeze({...this.urlTree.queryParams}),\n              this.urlTree.fragment,\n              getData(route),\n              getOutlet(route),\n              route.component ?? route._loadedComponent ?? null,\n              route,\n              getResolve(route),\n            );\n            const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n            snapshot.params = Object.freeze(inherited.params);\n            snapshot.data = Object.freeze(inherited.data);\n\n            const {segmentGroup, slicedSegments} = split(\n              rawSegment,\n              consumedSegments,\n              remainingSegments,\n              childConfig,\n            );\n\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n              return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(\n                map((children) => {\n                  return new TreeNode(snapshot, children);\n                }),\n              );\n            }\n\n            if (childConfig.length === 0 && slicedSegments.length === 0) {\n              return of(new TreeNode(snapshot, []));\n            }\n\n            const matchedOnOutlet = getOutlet(route) === outlet;\n            // If we matched a config due to empty path match on a different outlet, we need to\n            // continue passing the current outlet for the segment rather than switch to PRIMARY.\n            // Note that we switch to primary when we have a match because outlet configs look like\n            // this: {path: 'a', outlet: 'a', children: [\n            //  {path: 'b', component: B},\n            //  {path: 'c', component: C},\n            // ]}\n            // Notice that the children of the named outlet are configured with the primary outlet\n            return this.processSegment(\n              childInjector,\n              childConfig,\n              segmentGroup,\n              slicedSegments,\n              matchedOnOutlet ? PRIMARY_OUTLET : outlet,\n              true,\n              snapshot,\n            ).pipe(\n              map((child) => {\n                return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n              }),\n            );\n          }),\n        );\n      }),\n    );\n  }\n  private getChildConfig(\n    injector: EnvironmentInjector,\n    route: Route,\n    segments: UrlSegment[],\n  ): Observable<LoadedRouterConfig> {\n    if (route.children) {\n      // The children belong to the same module\n      return of({routes: route.children, injector});\n    }\n\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedRoutes !== undefined) {\n        return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n      }\n\n      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(\n        mergeMap((shouldLoadResult: boolean) => {\n          if (shouldLoadResult) {\n            return this.configLoader.loadChildren(injector, route).pipe(\n              tap((cfg: LoadedRouterConfig) => {\n                route._loadedRoutes = cfg.routes;\n                route._loadedInjector = cfg.injector;\n              }),\n            );\n          }\n          return canLoadFails(route);\n        }),\n      );\n    }\n\n    return of({routes: [], injector});\n  }\n}\n\nfunction sortActivatedRouteSnapshots(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n\nfunction hasEmptyPathConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\n\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\nfunction mergeEmptyPathMatches(\n  nodes: Array<TreeNode<ActivatedRouteSnapshot>>,\n): Array<TreeNode<ActivatedRouteSnapshot>> {\n  const result: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n  // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n  const mergedNodes: Set<TreeNode<ActivatedRouteSnapshot>> = new Set();\n\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n\n    const duplicateEmptyPathNode = result.find(\n      (resultNode) => node.value.routeConfig === resultNode.value.routeConfig,\n    );\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n  // by also merging those children. This is necessary when there are multiple empty path configs\n  // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n  // if any of those children can be combined into a single node as well.\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter((n) => !mergedNodes.has(n));\n}\n\nfunction checkOutletNameUniqueness(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  const names: {[k: string]: ActivatedRouteSnapshot} = {};\n  nodes.forEach((n) => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map((s) => s.toString()).join('/');\n      const c = n.value.url.map((s) => s.toString()).join('/');\n      throw new RuntimeError(\n        RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Two segments cannot have the same outlet name: '${p}' and '${c}'.`,\n      );\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\n\nfunction getData(route: Route): Data {\n  return route.data || {};\n}\n\nfunction getResolve(route: Route): ResolveData {\n  return route.resolve || {};\n}\n"]}