{"version":3,"file":"functional_guards.js","sourceRoot":"","sources":["functional_guards.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,MAAM,EAAO,MAAM,eAAe,CAAC;AAe3C;;;;;;;;GAQG;AACH,MAAM,UAAU,aAAa,CAAC,SAAgC;IAC5D,OAAO,SAAS,CAAC,GAAG,CAClB,CAAC,QAAQ,EAAE,EAAE,CACX,CAAC,GAAG,MAAM,EAAE,EAAE,CACZ,MAAM,CAAC,QAAQ,CAAC,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,CACzC,CAAC;AACJ,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,gBAAgB,CAAC,SAAmC;IAClE,OAAO,SAAS,CAAC,GAAG,CAClB,CAAC,QAAQ,EAAE,EAAE,CACX,CAAC,GAAG,MAAM,EAAE,EAAE,CACZ,MAAM,CAAC,QAAQ,CAAC,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC,CAC5C,CAAC;AACJ,CAAC;AACD;;;;;;;;GAQG;AACH,MAAM,UAAU,qBAAqB,CACnC,SAAwC;IAExC,OAAO,SAAS,CAAC,GAAG,CAClB,CAAC,QAAQ,EAAE,EAAE,CACX,CAAC,GAAG,MAAM,EAAE,EAAE,CACZ,MAAM,CAAC,QAAQ,CAAC,CAAC,gBAAgB,CAAC,GAAG,MAAM,CAAC,CACjD,CAAC;AACJ,CAAC;AACD;;;;;;;;GAQG;AACH,MAAM,UAAU,kBAAkB,CAChC,SAAwC;IAExC,OAAO,SAAS,CAAC,GAAG,CAClB,CAAC,QAAQ,EAAE,EAAE,CACX,CAAC,GAAG,MAAM,EAAE,EAAE,CACZ,MAAM,CAAC,QAAQ,CAAC,CAAC,aAAa,CAAC,GAAG,MAAM,CAAC,CAC9C,CAAC;AACJ,CAAC;AACD;;;;;;;;GAQG;AACH,MAAM,UAAU,YAAY,CAAI,QAA0B;IACxD,OAAO,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC,CAAC;AAC5D,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Type} from '@angular/core';\n\nimport {\n  CanActivate,\n  CanActivateChild,\n  CanActivateChildFn,\n  CanActivateFn,\n  CanDeactivate,\n  CanDeactivateFn,\n  CanMatch,\n  CanMatchFn,\n  Resolve,\n  ResolveFn,\n} from '../models';\n\n/**\n * Maps an array of injectable classes with canMatch functions to an array of equivalent\n * `CanMatchFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToCanMatch(providers: Array<Type<CanMatch>>): CanMatchFn[] {\n  return providers.map(\n    (provider) =>\n      (...params) =>\n        inject(provider).canMatch(...params),\n  );\n}\n\n/**\n * Maps an array of injectable classes with canActivate functions to an array of equivalent\n * `CanActivateFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToCanActivate(providers: Array<Type<CanActivate>>): CanActivateFn[] {\n  return providers.map(\n    (provider) =>\n      (...params) =>\n        inject(provider).canActivate(...params),\n  );\n}\n/**\n * Maps an array of injectable classes with canActivateChild functions to an array of equivalent\n * `CanActivateChildFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToCanActivateChild(\n  providers: Array<Type<CanActivateChild>>,\n): CanActivateChildFn[] {\n  return providers.map(\n    (provider) =>\n      (...params) =>\n        inject(provider).canActivateChild(...params),\n  );\n}\n/**\n * Maps an array of injectable classes with canDeactivate functions to an array of equivalent\n * `CanDeactivateFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToCanDeactivate<T = unknown>(\n  providers: Array<Type<CanDeactivate<T>>>,\n): CanDeactivateFn<T>[] {\n  return providers.map(\n    (provider) =>\n      (...params) =>\n        inject(provider).canDeactivate(...params),\n  );\n}\n/**\n * Maps an injectable class with a resolve function to an equivalent `ResolveFn`\n * for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='Resolve'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToResolve<T>(provider: Type<Resolve<T>>): ResolveFn<T> {\n  return (...params) => inject(provider).resolve(...params);\n}\n"]}