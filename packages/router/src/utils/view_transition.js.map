{"version":3,"file":"view_transition.js","sourceRoot":"","sources":["view_transition.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,QAAQ,EAAC,MAAM,iBAAiB,CAAC;AACzC,OAAO,EAAC,eAAe,EAAE,cAAc,EAAY,qBAAqB,EAAC,MAAM,eAAe,CAAC;AAI/F,MAAM,CAAC,MAAM,sBAAsB,GAAG,IAAI,cAAc,CACtD,OAAO,SAAS,KAAK,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC,EAAE,CAC5E,CAAC;AACF,MAAM,CAAC,MAAM,uBAAuB,GAAG,IAAI,cAAc,CAEvD,OAAO,SAAS,KAAK,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC,yBAAyB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;AA6ChF;;;;;GAKG;AACH,MAAM,UAAU,oBAAoB,CAClC,QAAkB,EAClB,IAA4B,EAC5B,EAA0B;IAE1B,MAAM,iBAAiB,GAAG,QAAQ,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;IAChE,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IACxC,IAAI,CAAC,QAAQ,CAAC,mBAAmB,IAAI,iBAAiB,CAAC,kBAAkB,EAAE,CAAC;QAC1E,iBAAiB,CAAC,kBAAkB,GAAG,KAAK,CAAC;QAC7C,mFAAmF;QACnF,uFAAuF;QACvF,wBAAwB;QACxB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;IACvD,CAAC;IAED,IAAI,4BAAwC,CAAC;IAC7C,MAAM,qBAAqB,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;QAC1D,4BAA4B,GAAG,OAAO,CAAC;IACzC,CAAC,CAAC,CAAC;IACH,MAAM,UAAU,GAAG,QAAQ,CAAC,mBAAmB,CAAC,GAAG,EAAE;QACnD,4BAA4B,EAAE,CAAC;QAC/B,0FAA0F;QAC1F,wFAAwF;QACxF,uFAAuF;QACvF,8EAA8E;QAC9E,OAAO,mBAAmB,CAAC,QAAQ,CAAC,CAAC;IACvC,CAAC,CAAC,CAAC;IACH,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;QAC/B,IAAI,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,EAAE,CAAC;YAClD,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACvB,CAAC;IACH,CAAC,CAAC,CAAC;IACH,MAAM,EAAC,uBAAuB,EAAC,GAAG,iBAAiB,CAAC;IACpD,IAAI,uBAAuB,EAAE,CAAC;QAC5B,qBAAqB,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,uBAAuB,CAAC,EAAC,UAAU,EAAE,IAAI,EAAE,EAAE,EAAC,CAAC,CAAC,CAAC;IACzF,CAAC;IACD,OAAO,qBAAqB,CAAC;AAC/B,CAAC;AAED;;GAEG;AACH,SAAS,mBAAmB,CAAC,QAAkB;IAC7C,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;QACnC,gGAAgG;QAChG,qFAAqF;QACrF,oCAAoC;QACpC,eAAe,CAAC,EAAC,IAAI,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,EAAC,EAAE,EAAC,QAAQ,EAAC,CAAC,CAAC;IACjE,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {afterNextRender, InjectionToken, Injector, runInInjectionContext} from '@angular/core';\n\nimport {ActivatedRouteSnapshot} from '../router_state';\n\nexport const CREATE_VIEW_TRANSITION = new InjectionToken<typeof createViewTransition>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'view transition helper' : '',\n);\nexport const VIEW_TRANSITION_OPTIONS = new InjectionToken<\n  ViewTransitionsFeatureOptions & {skipNextTransition: boolean}\n>(typeof ngDevMode !== undefined && ngDevMode ? 'view transition options' : '');\n\n/**\n * Options to configure the View Transitions integration in the Router.\n *\n * @developerPreview 20.0\n * @see withViewTransitions\n */\nexport interface ViewTransitionsFeatureOptions {\n  /**\n   * Skips the very first call to `startViewTransition`. This can be useful for disabling the\n   * animation during the application's initial loading phase.\n   */\n  skipInitialTransition?: boolean;\n\n  /**\n   * A function to run after the `ViewTransition` is created.\n   *\n   * This function is run in an injection context and can use `inject`.\n   */\n  onViewTransitionCreated?: (transitionInfo: ViewTransitionInfo) => void;\n}\n\n/**\n * The information passed to the `onViewTransitionCreated` function provided in the\n * `withViewTransitions` feature options.\n *\n * @developerPreview 20.0\n */\nexport interface ViewTransitionInfo {\n  /**\n   * The `ViewTransition` returned by the call to `startViewTransition`.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition\n   */\n  transition: ViewTransition;\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning from.\n   */\n  from: ActivatedRouteSnapshot;\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning to.\n   */\n  to: ActivatedRouteSnapshot;\n}\n\n/**\n * A helper function for using browser view transitions. This function skips the call to\n * `startViewTransition` if the browser does not support it.\n *\n * @returns A Promise that resolves when the view transition callback begins.\n */\nexport function createViewTransition(\n  injector: Injector,\n  from: ActivatedRouteSnapshot,\n  to: ActivatedRouteSnapshot,\n): Promise<void> {\n  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n  const document = injector.get(DOCUMENT);\n  if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n    transitionOptions.skipNextTransition = false;\n    // The timing of `startViewTransition` is closer to a macrotask. It won't be called\n    // until the current event loop exits so we use a promise resolved in a timeout instead\n    // of Promise.resolve().\n    return new Promise((resolve) => setTimeout(resolve));\n  }\n\n  let resolveViewTransitionStarted: () => void;\n  const viewTransitionStarted = new Promise<void>((resolve) => {\n    resolveViewTransitionStarted = resolve;\n  });\n  const transition = document.startViewTransition(() => {\n    resolveViewTransitionStarted();\n    // We don't actually update dom within the transition callback. The resolving of the above\n    // promise unblocks the Router navigation, which synchronously activates and deactivates\n    // routes (the DOM update). This view transition waits for the next change detection to\n    // complete (below), which includes the update phase of the routed components.\n    return createRenderPromise(injector);\n  });\n  transition.ready.catch((error) => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.error(error);\n    }\n  });\n  const {onViewTransitionCreated} = transitionOptions;\n  if (onViewTransitionCreated) {\n    runInInjectionContext(injector, () => onViewTransitionCreated({transition, from, to}));\n  }\n  return viewTransitionStarted;\n}\n\n/**\n * Creates a promise that resolves after next render.\n */\nfunction createRenderPromise(injector: Injector) {\n  return new Promise<void>((resolve) => {\n    // Wait for the microtask queue to empty after the next render happens (by waiting a macrotask).\n    // This ensures any follow-up renders in the microtask queue are completed before the\n    // view transition starts animating.\n    afterNextRender({read: () => setTimeout(resolve)}, {injector});\n  });\n}\n"]}