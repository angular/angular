{"version":3,"file":"type_guards.js","sourceRoot":"","sources":["type_guards.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,UAAU,EAAC,MAAM,MAAM,CAAC;AAUhC;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,UAAU,CAAI,CAAM;IAClC,OAAO,OAAO,CAAC,KAAK,UAAU,CAAC;AACjC,CAAC;AAED,MAAM,UAAU,SAAS,CAAC,CAAM;IAC9B,OAAO,OAAO,CAAC,KAAK,SAAS,CAAC;AAChC,CAAC;AAED,MAAM,UAAU,SAAS,CAAC,KAAU;IAClC,OAAO,KAAK,IAAI,UAAU,CAAY,KAAK,CAAC,OAAO,CAAC,CAAC;AACvD,CAAC;AAED,MAAM,UAAU,aAAa,CAAC,KAAU;IACtC,OAAO,KAAK,IAAI,UAAU,CAAgB,KAAK,CAAC,WAAW,CAAC,CAAC;AAC/D,CAAC;AAED,MAAM,UAAU,kBAAkB,CAAC,KAAU;IAC3C,OAAO,KAAK,IAAI,UAAU,CAAqB,KAAK,CAAC,gBAAgB,CAAC,CAAC;AACzE,CAAC;AAED,MAAM,UAAU,eAAe,CAAI,KAAU;IAC3C,OAAO,KAAK,IAAI,UAAU,CAAqB,KAAK,CAAC,aAAa,CAAC,CAAC;AACtE,CAAC;AACD,MAAM,UAAU,UAAU,CAAC,KAAU;IACnC,OAAO,KAAK,IAAI,UAAU,CAAa,KAAK,CAAC,QAAQ,CAAC,CAAC;AACzD,CAAC;AAED,MAAM,UAAU,YAAY,CAAC,CAAQ;IACnC,OAAO,CAAC,YAAY,UAAU,IAAI,CAAC,EAAE,IAAI,KAAK,YAAY,CAAC;AAC7D,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EmptyError} from 'rxjs';\n\nimport {CanActivateChildFn, CanActivateFn, CanDeactivateFn, CanLoadFn, CanMatchFn} from '../models';\nimport {\n  NAVIGATION_CANCELING_ERROR,\n  NavigationCancelingError,\n  RedirectingNavigationCancelingError,\n} from '../navigation_canceling_error';\nimport {isUrlTree} from '../url_tree';\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\nexport function isFunction<T>(v: any): v is T {\n  return typeof v === 'function';\n}\n\nexport function isBoolean(v: any): v is boolean {\n  return typeof v === 'boolean';\n}\n\nexport function isCanLoad(guard: any): guard is {canLoad: CanLoadFn} {\n  return guard && isFunction<CanLoadFn>(guard.canLoad);\n}\n\nexport function isCanActivate(guard: any): guard is {canActivate: CanActivateFn} {\n  return guard && isFunction<CanActivateFn>(guard.canActivate);\n}\n\nexport function isCanActivateChild(guard: any): guard is {canActivateChild: CanActivateChildFn} {\n  return guard && isFunction<CanActivateChildFn>(guard.canActivateChild);\n}\n\nexport function isCanDeactivate<T>(guard: any): guard is {canDeactivate: CanDeactivateFn<T>} {\n  return guard && isFunction<CanDeactivateFn<T>>(guard.canDeactivate);\n}\nexport function isCanMatch(guard: any): guard is {canMatch: CanMatchFn} {\n  return guard && isFunction<CanMatchFn>(guard.canMatch);\n}\n\nexport function isEmptyError(e: Error): e is EmptyError {\n  return e instanceof EmptyError || e?.name === 'EmptyError';\n}\n"]}