{"version":3,"file":"router_outlet.js","sourceRoot":"","sources":["router_outlet.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ChangeDetectorRef,\n  ComponentRef,\n  Directive,\n  EnvironmentInjector,\n  EventEmitter,\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  Input,\n  input,\n  OnDestroy,\n  OnInit,\n  Output,\n  reflectComponentType,\n  ÉµRuntimeError as RuntimeError,\n  Signal,\n  SimpleChanges,\n  ViewContainerRef,\n} from '@angular/core';\nimport {combineLatest, of, Subscription} from 'rxjs';\nimport {switchMap} from 'rxjs/operators';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {Data} from '../models';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * An `InjectionToken` provided by the `RouterOutlet` and can be set using the `routerOutletData`\n * input.\n *\n * When unset, this value is `null` by default.\n *\n * @usageNotes\n *\n * To set the data from the template of the component with `router-outlet`:\n * ```html\n * <router-outlet [routerOutletData]=\"{name: 'Angular'}\" />\n * ```\n *\n * To read the data in the routed component:\n * ```ts\n * data = inject(ROUTER_OUTLET_DATA) as Signal<{name: string}>;\n * ```\n *\n * @publicApi\n */\nexport const ROUTER_OUTLET_DATA = new InjectionToken<Signal<unknown | undefined>>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'RouterOutlet data' : '',\n);\n\n/**\n * An interface that defines the contract for developing a component outlet for the `Router`.\n *\n * An outlet acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * A router outlet should register itself with the `Router` via\n * `ChildrenOutletContexts#onChildOutletCreated` and unregister with\n * `ChildrenOutletContexts#onChildOutletDestroyed`. When the `Router` identifies a matched `Route`,\n * it looks for a registered outlet in the `ChildrenOutletContexts` and activates it.\n *\n * @see {@link ChildrenOutletContexts}\n * @publicApi\n */\nexport interface RouterOutletContract {\n  /**\n   * Whether the given outlet is activated.\n   *\n   * An outlet is considered \"activated\" if it has an active component.\n   */\n  isActivated: boolean;\n\n  /** The instance of the activated component or `null` if the outlet is not activated. */\n  component: Object | null;\n\n  /**\n   * The `Data` of the `ActivatedRoute` snapshot.\n   */\n  activatedRouteData: Data;\n\n  /**\n   * The `ActivatedRoute` for the outlet or `null` if the outlet is not activated.\n   */\n  activatedRoute: ActivatedRoute | null;\n\n  /**\n   * Called by the `Router` when the outlet should activate (create a component).\n   */\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector): void;\n\n  /**\n   * A request to destroy the currently activated component.\n   *\n   * When a `RouteReuseStrategy` indicates that an `ActivatedRoute` should be removed but stored for\n   * later re-use rather than destroyed, the `Router` will call `detach` instead.\n   */\n  deactivate(): void;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree.\n   *\n   * This is similar to `deactivate`, but the activated component should _not_ be destroyed.\n   * Instead, it is returned so that it can be reattached later via the `attach` method.\n   */\n  detach(): ComponentRef<unknown>;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree.\n   */\n  attach(ref: ComponentRef<unknown>, activatedRoute: ActivatedRoute): void;\n\n  /**\n   * Emits an activate event when a new component is instantiated\n   **/\n  activateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a deactivate event when a component is destroyed.\n   */\n  deactivateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  attachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  detachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Used to indicate that the outlet is able to bind data from the `Router` to the outlet\n   * component's inputs.\n   *\n   * When this is `undefined` or `false` and the developer has opted in to the\n   * feature using `withComponentInputBinding`, a warning will be logged in dev mode if this outlet\n   * is used in the application.\n   */\n  readonly supportsBindingToComponentInputs?: true;\n}\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```html\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```html\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see {@link RouterLink}\n * @see {@link Route}\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: 'router-outlet',\n  exportAs: 'outlet',\n})\nexport class RouterOutlet implements OnDestroy, OnInit, RouterOutletContract {\n  private activated: ComponentRef<any> | null = null;\n  /** @internal */\n  get activatedComponentRef(): ComponentRef<any> | null {\n    return this.activated;\n  }\n  private _activatedRoute: ActivatedRoute | null = null;\n  /**\n   * The name of the outlet\n   *\n   */\n  @Input() name = PRIMARY_OUTLET;\n\n  @Output('activate') activateEvents = new EventEmitter<any>();\n  @Output('deactivate') deactivateEvents = new EventEmitter<any>();\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  @Output('attach') attachEvents = new EventEmitter<unknown>();\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  @Output('detach') detachEvents = new EventEmitter<unknown>();\n\n  /**\n   * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.\n   *\n   * When unset, the value of the token is `undefined` by default.\n   */\n  readonly routerOutletData = input<unknown>(undefined);\n\n  private parentContexts = inject(ChildrenOutletContexts);\n  private location = inject(ViewContainerRef);\n  private changeDetector = inject(ChangeDetectorRef);\n  private inputBinder = inject(INPUT_BINDER, {optional: true});\n  /** @docs-private */\n  readonly supportsBindingToComponentInputs = true;\n\n  /** @docs-private */\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['name']) {\n      const {firstChange, previousValue} = changes['name'];\n      if (firstChange) {\n        // The first change is handled by ngOnInit. Because ngOnChanges doesn't get called when no\n        // input is set at all, we need to centrally handle the first change there.\n        return;\n      }\n\n      // unregister with the old name\n      if (this.isTrackedInParentContexts(previousValue)) {\n        this.deactivate();\n        this.parentContexts.onChildOutletDestroyed(previousValue);\n      }\n      // register the new name\n      this.initializeOutletWithName();\n    }\n  }\n\n  /** @docs-private */\n  ngOnDestroy(): void {\n    // Ensure that the registered outlet is this one before removing it on the context.\n    if (this.isTrackedInParentContexts(this.name)) {\n      this.parentContexts.onChildOutletDestroyed(this.name);\n    }\n    this.inputBinder?.unsubscribeFromRouteData(this);\n  }\n\n  private isTrackedInParentContexts(outletName: string) {\n    return this.parentContexts.getContext(outletName)?.outlet === this;\n  }\n\n  /** @docs-private */\n  ngOnInit(): void {\n    this.initializeOutletWithName();\n  }\n\n  private initializeOutletWithName() {\n    this.parentContexts.onChildOutletCreated(this.name, this);\n    if (this.activated) {\n      return;\n    }\n\n    // If the outlet was not instantiated at the time the route got activated we need to populate\n    // the outlet when it is initialized (ie inside a NgIf)\n    const context = this.parentContexts.getContext(this.name);\n    if (context?.route) {\n      if (context.attachRef) {\n        // `attachRef` is populated when there is an existing component to mount\n        this.attach(context.attachRef, context.route);\n      } else {\n        // otherwise the component defined in the configuration is created\n        this.activateWith(context.route, context.injector);\n      }\n    }\n  }\n\n  get isActivated(): boolean {\n    return !!this.activated;\n  }\n\n  /**\n   * @returns The currently activated component instance.\n   * @throws An error if the outlet is not activated.\n   */\n  get component(): Object {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    return this.activated.instance;\n  }\n\n  get activatedRoute(): ActivatedRoute {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    return this._activatedRoute as ActivatedRoute;\n  }\n\n  get activatedRouteData(): Data {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   */\n  detach(): ComponentRef<any> {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    this.location.detach();\n    const cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    this.detachEvents.emit(cmp.instance);\n    return cmp;\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   */\n  attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.attachEvents.emit(ref.instance);\n  }\n\n  deactivate(): void {\n    if (this.activated) {\n      const c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector): void {\n    if (this.isActivated) {\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          'Cannot activate an already activated outlet',\n      );\n    }\n    this._activatedRoute = activatedRoute;\n    const location = this.location;\n    const snapshot = activatedRoute.snapshot;\n    const component = snapshot.component!;\n    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const injector = new OutletInjector(\n      activatedRoute,\n      childContexts,\n      location.injector,\n      this.routerOutletData,\n    );\n\n    this.activated = location.createComponent(component, {\n      index: location.length,\n      injector,\n      environmentInjector: environmentInjector,\n    });\n    // Calling `markForCheck` to make sure we will run the change detection when the\n    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n    this.changeDetector.markForCheck();\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.activateEvents.emit(this.activated.instance);\n  }\n}\n\nclass OutletInjector implements Injector {\n  constructor(\n    private route: ActivatedRoute,\n    private childContexts: ChildrenOutletContexts,\n    private parent: Injector,\n    private outletData: Signal<unknown>,\n  ) {}\n\n  get(token: any, notFoundValue?: any): any {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n\n    if (token === ROUTER_OUTLET_DATA) {\n      return this.outletData;\n    }\n\n    return this.parent.get(token, notFoundValue);\n  }\n}\n\nexport const INPUT_BINDER = new InjectionToken<RoutedComponentInputBinder>('');\n\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\n@Injectable()\nexport class RoutedComponentInputBinder {\n  private outletDataSubscriptions = new Map<RouterOutlet, Subscription>();\n\n  bindActivatedRouteToOutletComponent(outlet: RouterOutlet): void {\n    this.unsubscribeFromRouteData(outlet);\n    this.subscribeToRouteData(outlet);\n  }\n\n  unsubscribeFromRouteData(outlet: RouterOutlet): void {\n    this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n    this.outletDataSubscriptions.delete(outlet);\n  }\n\n  private subscribeToRouteData(outlet: RouterOutlet) {\n    const {activatedRoute} = outlet;\n    const dataSubscription = combineLatest([\n      activatedRoute.queryParams,\n      activatedRoute.params,\n      activatedRoute.data,\n    ])\n      .pipe(\n        switchMap(([queryParams, params, data], index) => {\n          data = {...queryParams, ...params, ...data};\n          // Get the first result from the data subscription synchronously so it's available to\n          // the component as soon as possible (and doesn't require a second change detection).\n          if (index === 0) {\n            return of(data);\n          }\n          // Promise.resolve is used to avoid synchronously writing the wrong data when\n          // two of the Observables in the `combineLatest` stream emit one after\n          // another.\n          return Promise.resolve(data);\n        }),\n      )\n      .subscribe((data) => {\n        // Outlet may have been deactivated or changed names to be associated with a different\n        // route\n        if (\n          !outlet.isActivated ||\n          !outlet.activatedComponentRef ||\n          outlet.activatedRoute !== activatedRoute ||\n          activatedRoute.component === null\n        ) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n\n        const mirror = reflectComponentType(activatedRoute.component);\n        if (!mirror) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n\n        for (const {templateName} of mirror.inputs) {\n          outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n        }\n      });\n\n    this.outletDataSubscriptions.set(outlet, dataSubscription);\n  }\n}\n"]}