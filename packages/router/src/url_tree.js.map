{"version":3,"file":"url_tree.js","sourceRoot":"","sources":["url_tree.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET} from './shared';\nimport {equalArraysOrString, shallowEqual} from './utils/collection';\n\n/**\n * A set of options which specify how to determine if a `UrlTree` is active, given the `UrlTree`\n * for the current router state.\n *\n * @publicApi\n * @see {@link Router#isActive}\n */\nexport interface IsActiveMatchOptions {\n  /**\n   * Defines the strategy for comparing the matrix parameters of two `UrlTree`s.\n   *\n   * The matrix parameter matching is dependent on the strategy for matching the\n   * segments. That is, if the `paths` option is set to `'subset'`, only\n   * the matrix parameters of the matching segments will be compared.\n   *\n   * - `'exact'`: Requires that matching segments also have exact matrix parameter\n   * matches.\n   * - `'subset'`: The matching segments in the router's active `UrlTree` may contain\n   * extra matrix parameters, but those that exist in the `UrlTree` in question must match.\n   * - `'ignored'`: When comparing `UrlTree`s, matrix params will be ignored.\n   */\n  matrixParams: 'exact' | 'subset' | 'ignored';\n  /**\n   * Defines the strategy for comparing the query parameters of two `UrlTree`s.\n   *\n   * - `'exact'`: the query parameters must match exactly.\n   * - `'subset'`: the active `UrlTree` may contain extra parameters,\n   * but must match the key and value of any that exist in the `UrlTree` in question.\n   * - `'ignored'`: When comparing `UrlTree`s, query params will be ignored.\n   */\n  queryParams: 'exact' | 'subset' | 'ignored';\n  /**\n   * Defines the strategy for comparing the `UrlSegment`s of the `UrlTree`s.\n   *\n   * - `'exact'`: all segments in each `UrlTree` must match.\n   * - `'subset'`: a `UrlTree` will be determined to be active if it\n   * is a subtree of the active route. That is, the active route may contain extra\n   * segments, but must at least have all the segments of the `UrlTree` in question.\n   */\n  paths: 'exact' | 'subset';\n  /**\n   * - `'exact'`: indicates that the `UrlTree` fragments must be equal.\n   * - `'ignored'`: the fragments will not be compared when determining if a\n   * `UrlTree` is active.\n   */\n  fragment: 'exact' | 'ignored';\n}\n\ntype ParamMatchOptions = 'exact' | 'subset' | 'ignored';\n\ntype PathCompareFn = (\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n) => boolean;\ntype ParamCompareFn = (container: Params, containee: Params) => boolean;\n\nconst pathCompareMap: Record<IsActiveMatchOptions['paths'], PathCompareFn> = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup,\n};\nconst paramCompareMap: Record<ParamMatchOptions, ParamCompareFn> = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true,\n};\n\nexport function containsTree(\n  container: UrlTree,\n  containee: UrlTree,\n  options: IsActiveMatchOptions,\n): boolean {\n  return (\n    pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n    paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n    !(options.fragment === 'exact' && container.fragment !== containee.fragment)\n  );\n}\n\nfunction equalParams(container: Params, containee: Params): boolean {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n\nfunction equalSegmentGroups(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n): boolean {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\n      return false;\n  }\n  return true;\n}\n\nfunction containsParams(container: Params, containee: Params): boolean {\n  return (\n    Object.keys(containee).length <= Object.keys(container).length &&\n    Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]))\n  );\n}\n\nfunction containsSegmentGroup(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n): boolean {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\n\nfunction containsSegmentGroupHelper(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  containeePaths: UrlSegment[],\n  matrixParams: ParamMatchOptions,\n): boolean {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(\n      container.children[PRIMARY_OUTLET],\n      containee,\n      next,\n      matrixParams,\n    );\n  }\n}\n\nfunction matrixParamsMatch(\n  containerPaths: UrlSegment[],\n  containeePaths: UrlSegment[],\n  options: ParamMatchOptions,\n) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlTree {\n  /** @internal */\n  _queryParamMap?: ParamMap;\n\n  constructor(\n    /** The root segment group of the URL tree */\n    public root: UrlSegmentGroup = new UrlSegmentGroup([], {}),\n    /** The query params of the URL */\n    public queryParams: Params = {},\n    /** The fragment of the URL */\n    public fragment: string | null = null,\n  ) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (root.segments.length > 0) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROOT_URL_SEGMENT,\n          'The root `UrlSegmentGroup` should not contain `segments`. ' +\n            'Instead, these segments belong in the `children` so they can be associated with a named outlet.',\n        );\n      }\n    }\n  }\n\n  get queryParamMap(): ParamMap {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport class UrlSegmentGroup {\n  /** The parent node in the url tree */\n  parent: UrlSegmentGroup | null = null;\n\n  constructor(\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    public segments: UrlSegment[],\n    /** The list of children of this group */\n    public children: {[key: string]: UrlSegmentGroup},\n  ) {\n    Object.values(children).forEach((v) => (v.parent = this));\n  }\n\n  /** Whether the segment has child segments */\n  hasChildren(): boolean {\n    return this.numberOfChildren > 0;\n  }\n\n  /** Number of child segments */\n  get numberOfChildren(): number {\n    return Object.keys(this.children).length;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePaths(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlSegment {\n  /** @internal */\n  _parameterMap?: ParamMap;\n\n  constructor(\n    /** The path part of a URL segment */\n    public path: string,\n\n    /** The matrix parameters associated with a segment */\n    public parameters: {[name: string]: string},\n  ) {}\n\n  get parameterMap(): ParamMap {\n    this._parameterMap ??= convertToParamMap(this.parameters);\n    return this._parameterMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePath(this);\n  }\n}\n\nexport function equalSegments(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\n\nexport function equalPath(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\n\nexport function mapChildrenIntoArray<T>(\n  segment: UrlSegmentGroup,\n  fn: (v: UrlSegmentGroup, k: string) => T[],\n): T[] {\n  let res: T[] = [];\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => new DefaultUrlSerializer()})\nexport abstract class UrlSerializer {\n  /** Parse a url into a `UrlTree` */\n  abstract parse(url: string): UrlTree;\n\n  /** Converts a `UrlTree` into a url */\n  abstract serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport class DefaultUrlSerializer implements UrlSerializer {\n  /** Parses a url into a `UrlTree` */\n  parse(url: string): UrlTree {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n\n  /** Converts a `UrlTree` into a url */\n  serialize(tree: UrlTree): string {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment =\n      typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n\n    return `${segment}${query}${fragment}`;\n  }\n}\n\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n\nexport function serializePaths(segment: UrlSegmentGroup): string {\n  return segment.segments.map((p) => serializePath(p)).join('/');\n}\n\nfunction serializeSegment(segment: UrlSegmentGroup, root: boolean): string {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET]\n      ? serializeSegment(segment.children[PRIMARY_OUTLET], false)\n      : '';\n    const children: string[] = [];\n\n    Object.entries(segment.children).forEach(([k, v]) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n  } else {\n    const children = mapChildrenIntoArray(segment, (v: UrlSegmentGroup, k: string) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n\n    // use no parenthesis if the only child is a primary outlet route\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\n\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\nfunction encodeUriString(s: string): string {\n  return encodeURIComponent(s)\n    .replace(/%40/g, '@')\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',');\n}\n\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriQuery(s: string): string {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriFragment(s: string): string {\n  return encodeURI(s);\n}\n\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriSegment(s: string): string {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n\nexport function decode(s: string): string {\n  return decodeURIComponent(s);\n}\n\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nexport function decodeQuery(s: string): string {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n\nexport function serializePath(path: UrlSegment): string {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\n\nfunction serializeMatrixParams(params: {[key: string]: string}): string {\n  return Object.entries(params)\n    .map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`)\n    .join('');\n}\n\nfunction serializeQueryParams(params: {[key: string]: any}): string {\n  const strParams: string[] = Object.entries(params)\n    .map(([name, value]) => {\n      return Array.isArray(value)\n        ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&')\n        : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n    })\n    .filter((s) => s);\n\n  return strParams.length ? `?${strParams.join('&')}` : '';\n}\n\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str: string): string {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str: string): string {\n  const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str: string): string {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str: string): string {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nclass UrlParser {\n  private remaining: string;\n\n  constructor(private url: string) {\n    this.remaining = url;\n  }\n\n  parseRootSegment(): UrlSegmentGroup {\n    this.consumeOptional('/');\n\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n\n    // The root segment group never has segments\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n\n  parseQueryParams(): Params {\n    const params: Params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n\n  parseFragment(): string | null {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n\n  private parseChildren(): {[outlet: string]: UrlSegmentGroup} {\n    if (this.remaining === '') {\n      return {};\n    }\n\n    this.consumeOptional('/');\n\n    const segments: UrlSegment[] = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n\n    let children: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n\n    let res: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n\n    return res;\n  }\n\n  // parse a segment with its matrix parameters\n  // ie `name;k1=v1;k2`\n  private parseSegment(): UrlSegment {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new RuntimeError(\n        RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Empty path url segment cannot have parameters: '${this.remaining}'.`,\n      );\n    }\n\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n\n  private parseMatrixParams(): {[key: string]: string} {\n    const params: {[key: string]: string} = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n\n  private parseParam(params: {[key: string]: string}): void {\n    const key = matchMatrixKeySegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    params[decode(key)] = decode(value);\n  }\n\n  // Parse a single query parameter `name[=value]`\n  private parseQueryParam(params: Params): void {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n\n    if (params.hasOwnProperty(decodedKey)) {\n      // Append to existing values\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      // Create a new value\n      params[decodedKey] = decodedVal;\n    }\n  }\n\n  // parse `(a/b//outlet_name:c/d)`\n  private parseParens(allowPrimary: boolean): {[outlet: string]: UrlSegmentGroup} {\n    const segments: {[key: string]: UrlSegmentGroup} = {};\n    this.capture('(');\n\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n\n      const next = this.remaining[path.length];\n\n      // if is is not one of these characters, then the segment was unescaped\n      // or the group was not closed\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new RuntimeError(\n          RuntimeErrorCode.UNPARSABLE_URL,\n          (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`,\n        );\n      }\n\n      let outletName: string = undefined!;\n      if (path.indexOf(':') > -1) {\n        outletName = path.slice(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n\n      const children = this.parseChildren();\n      segments[outletName] =\n        Object.keys(children).length === 1\n          ? children[PRIMARY_OUTLET]\n          : new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n\n    return segments;\n  }\n\n  private peekStartsWith(str: string): boolean {\n    return this.remaining.startsWith(str);\n  }\n\n  // Consumes the prefix when it is present and returns whether it has been consumed\n  private consumeOptional(str: string): boolean {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n\n  private capture(str: string): void {\n    if (!this.consumeOptional(str)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`,\n      );\n    }\n  }\n}\n\nexport function createRoot(rootCandidate: UrlSegmentGroup): UrlSegmentGroup {\n  return rootCandidate.segments.length > 0\n    ? new UrlSegmentGroup([], {[PRIMARY_OUTLET]: rootCandidate})\n    : rootCandidate;\n}\n\n/**\n * Recursively\n * - merges primary segment children into their parents\n * - drops empty children (those which have no segments and no children themselves). This latter\n * prevents serializing a group into something like `/a(aux:)`, where `aux` is an empty child\n * segment.\n * - merges named outlets without a primary segment sibling into the children. This prevents\n * serializing a URL like `//(a:a)(b:b) instead of `/(a:a//b:b)` when the aux b route lives on the\n * root but the `a` route lives under an empty path primary route.\n */\nexport function squashSegmentGroup(segmentGroup: UrlSegmentGroup): UrlSegmentGroup {\n  const newChildren: Record<string, UrlSegmentGroup> = {};\n  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n    const childCandidate = squashSegmentGroup(child);\n    // moves named children in an empty path primary child into this group\n    if (\n      childOutlet === PRIMARY_OUTLET &&\n      childCandidate.segments.length === 0 &&\n      childCandidate.hasChildren()\n    ) {\n      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n        newChildren[grandChildOutlet] = grandChild;\n      }\n    } // don't add empty children\n    else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\n\n/**\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n *\n * When a segment group has only one child which is a primary outlet, merges that child into the\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\n * group into the parent.\n */\nfunction mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n\nexport function isUrlTree(v: any): v is UrlTree {\n  return v instanceof UrlTree;\n}\n"]}