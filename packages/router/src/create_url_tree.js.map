{"version":3,"file":"create_url_tree.js","sourceRoot":"","sources":["create_url_tree.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {createRoot, squashSegmentGroup, UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\nimport {last, shallowEqual} from './utils/collection';\n\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n *\n * @usageNotes\n *\n * ```ts\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nexport function createUrlTreeFromSnapshot(\n  relativeTo: ActivatedRouteSnapshot,\n  commands: readonly any[],\n  queryParams: Params | null = null,\n  fragment: string | null = null,\n): UrlTree {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\n\nexport function createSegmentGroupFromRoute(route: ActivatedRouteSnapshot): UrlSegmentGroup {\n  let targetGroup: UrlSegmentGroup | undefined;\n\n  function createSegmentGroupFromRouteRecursive(\n    currentRoute: ActivatedRouteSnapshot,\n  ): UrlSegmentGroup {\n    const childOutlets: {[outlet: string]: UrlSegmentGroup} = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n\n  return targetGroup ?? rootSegmentGroup;\n}\n\nexport function createUrlTreeFromSegmentGroup(\n  relativeTo: UrlSegmentGroup,\n  commands: readonly any[],\n  queryParams: Params | null,\n  fragment: string | null,\n): UrlTree {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  // There are no commands so the `UrlTree` goes to the same path as the one created from the\n  // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n  // applying any other logic.\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren\n    ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands)\n    : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\n\nfunction isMatrixParams(command: any): boolean {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n\n/**\n * Determines if a given command has an `outlets` map. When we encounter a command\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n */\nfunction isCommandWithOutlets(command: any): command is {outlets: {[key: string]: any}} {\n  return typeof command === 'object' && command != null && command.outlets;\n}\n\nfunction tree(\n  oldRoot: UrlSegmentGroup,\n  oldSegmentGroup: UrlSegmentGroup,\n  newSegmentGroup: UrlSegmentGroup,\n  queryParams: Params | null,\n  fragment: string | null,\n): UrlTree {\n  let qp: any = {};\n  if (queryParams) {\n    Object.entries(queryParams).forEach(([name, value]) => {\n      qp[name] = Array.isArray(value) ? value.map((v: any) => `${v}`) : `${value}`;\n    });\n  }\n\n  let rootCandidate: UrlSegmentGroup;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\n\n/**\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\n * value.\n */\nfunction replaceSegment(\n  current: UrlSegmentGroup,\n  oldSegment: UrlSegmentGroup,\n  newSegment: UrlSegmentGroup,\n): UrlSegmentGroup {\n  const children: {[key: string]: UrlSegmentGroup} = {};\n  Object.entries(current.children).forEach(([outletName, c]) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nclass Navigation {\n  constructor(\n    public isAbsolute: boolean,\n    public numberOfDoubleDots: number,\n    public commands: readonly any[],\n  ) {\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new RuntimeError(\n        RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          'Root segment cannot have matrix parameters',\n      );\n    }\n\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          '{outlets:{}} has to be the last command',\n      );\n    }\n  }\n\n  public toRoot(): boolean {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\n\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands: readonly any[]): Navigation {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n\n  const res: any[] = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets: {[k: string]: any} = {};\n        Object.entries(cmd.outlets).forEach(([name, commands]) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {outlets}];\n      }\n\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') {\n          // skip './a'\n        } else if (partIndex == 0 && urlPart === '') {\n          //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n\n      return res;\n    }\n\n    return [...res, cmd];\n  }, []);\n\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nclass Position {\n  constructor(\n    public segmentGroup: UrlSegmentGroup,\n    public processChildren: boolean,\n    public index: number,\n  ) {}\n}\n\nfunction findStartingPositionForTargetGroup(\n  nav: Navigation,\n  root: UrlSegmentGroup,\n  target: UrlSegmentGroup,\n): Position {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n\n  if (!target) {\n    // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n    // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n    // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n    // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\n\nfunction createPositionApplyingDoubleDots(\n  group: UrlSegmentGroup,\n  index: number,\n  numberOfDoubleDots: number,\n): Position {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent!;\n    if (!g) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_DOUBLE_DOTS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\",\n      );\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\n\nfunction getOutlets(commands: readonly unknown[]): {[k: string]: readonly unknown[] | string} {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n\n  return {[PRIMARY_OUTLET]: commands};\n}\n\nfunction updateSegmentGroup(\n  segmentGroup: UrlSegmentGroup | undefined,\n  startIndex: number,\n  commands: readonly any[],\n): UrlSegmentGroup {\n  segmentGroup ??= new UrlSegmentGroup([], {});\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(\n      segmentGroup.segments.slice(m.pathIndex),\n      segmentGroup.children,\n    );\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n\nfunction updateSegmentGroupChildren(\n  segmentGroup: UrlSegmentGroup,\n  startIndex: number,\n  commands: readonly any[],\n): UrlSegmentGroup {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children: {[key: string]: UrlSegmentGroup} = {};\n    // If the set of commands applies to anything other than the primary outlet and the child\n    // segment is an empty path primary segment on its own, we want to apply the commands to the\n    // empty child path rather than here. The outcome is that the empty primary child is effectively\n    // removed from the final output UrlTree. Imagine the following config:\n    //\n    // {path: '', children: [{path: '**', outlet: 'popup'}]}.\n    //\n    // Navigation to /(popup:a) will activate the child outlet correctly Given a follow-up\n    // navigation with commands\n    // ['/', {outlets: {'popup': 'b'}}], we _would not_ want to apply the outlet commands to the\n    // root segment because that would result in\n    // //(popup:a)(popup:b) since the outlet command got applied one level above where it appears in\n    // the `ActivatedRoute` rather than updating the existing one.\n    //\n    // Because empty paths do not appear in the URL segments and the fact that the segments used in\n    // the output `UrlTree` are squashed to eliminate these empty paths where possible\n    // https://github.com/angular/angular/blob/13f10de40e25c6900ca55bd83b36bd533dacfa9e/packages/router/src/url_tree.ts#L755\n    // it can be hard to determine what is the right thing to do when applying commands to a\n    // `UrlSegmentGroup` that is created from an \"unsquashed\"/expanded `ActivatedRoute` tree.\n    // This code effectively \"squashes\" empty path primary routes when they have no siblings on\n    // the same level of the tree.\n    if (\n      Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) &&\n      segmentGroup.children[PRIMARY_OUTLET] &&\n      segmentGroup.numberOfChildren === 1 &&\n      segmentGroup.children[PRIMARY_OUTLET].segments.length === 0\n    ) {\n      const childrenOfEmptyChild = updateSegmentGroupChildren(\n        segmentGroup.children[PRIMARY_OUTLET],\n        startIndex,\n        commands,\n      );\n      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n    }\n\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n\n    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n\nfunction prefixedWith(segmentGroup: UrlSegmentGroup, startIndex: number, commands: readonly any[]) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n\n  const noMatch = {match: false, pathIndex: 0, commandIndex: 0};\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    // Do not try to consume command as part of the prefixing if it has outlets because it can\n    // contain outlets other than the one being processed. Consuming the outlets command would\n    // result in other outlets being ignored.\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next =\n      currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n\n  return {match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex};\n}\n\nfunction createNewSegmentGroup(\n  segmentGroup: UrlSegmentGroup,\n  startIndex: number,\n  commands: readonly any[],\n): UrlSegmentGroup {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n\n    // if we start with an object literal, we need to reuse the path part from the segment\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = i < commands.length - 1 ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\n\nfunction createNewSegmentChildren(outlets: {[name: string]: readonly unknown[] | string}): {\n  [outlet: string]: UrlSegmentGroup;\n} {\n  const children: {[outlet: string]: UrlSegmentGroup} = {};\n  Object.entries(outlets).forEach(([outlet, commands]) => {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n\nfunction stringify(params: {[key: string]: any}): {[key: string]: string} {\n  const res: {[key: string]: string} = {};\n  Object.entries(params).forEach(([k, v]) => (res[k] = `${v}`));\n  return res;\n}\n\nfunction compare(path: string, params: {[key: string]: any}, segment: UrlSegment): boolean {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n"]}