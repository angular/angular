{"version":3,"file":"switch_tap.js","sourceRoot":"","sources":["switch_tap.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,IAAI,EAA6C,EAAE,EAAC,MAAM,MAAM,CAAC;AACzE,OAAO,EAAC,GAAG,EAAE,SAAS,EAAC,MAAM,gBAAgB,CAAC;AAE9C;;;;;GAKG;AACH,MAAM,UAAU,SAAS,CACvB,IAA2C;IAE3C,OAAO,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE;QACrB,MAAM,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QAC3B,IAAI,UAAU,EAAE,CAAC;YACf,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAC7C,CAAC;QACD,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {from, MonoTypeOperatorFunction, ObservableInput, of} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nexport function switchTap<T>(\n  next: (x: T) => void | ObservableInput<any>,\n): MonoTypeOperatorFunction<T> {\n  return switchMap((v) => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\n"]}