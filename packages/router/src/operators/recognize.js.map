{"version":3,"file":"recognize.js","sourceRoot":"","sources":["recognize.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAGL,cAAc,EACd,wBAAwB,GAEzB,MAAM,eAAe,CAAC;AACvB,OAAO,EAA2B,EAAE,EAAC,MAAM,MAAM,CAAC;AAClD,OAAO,EAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAC,MAAM,gBAAgB,CAAC;AAIxD,OAAO,EAAC,SAAS,IAAI,WAAW,EAAC,MAAM,cAAc,CAAC;AACtD,OAAO,EAAC,SAAS,IAAI,eAAe,EAAC,MAAM,mBAAmB,CAAC;AAI/D,MAAM,mBAAmB,GAAG,IAAI,CAAC;AAEjC,MAAM,cAAc,GAAG,IAAI,cAAc,CACvC,gBAAgB,EAChB;IACE,UAAU,EAAE,MAAM;IAClB,OAAO,EAAE,GAAG,EAAE;QACZ,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACzB,OAAO,eAAe,CAAC;QACzB,CAAC;QACD,OAAO,WAAW,CAAC;IACrB,CAAC;CACF,CACF,CAAC;AAEF;;GAEG;AACH,MAAM,UAAU,6BAA6B;IAC3C,OAAO,wBAAwB,CAAC,CAAC,EAAC,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAE,eAAe,EAAC,CAAC,CAAC,CAAC;AAC1F,CAAC;AAED,MAAM,UAAU,SAAS,CACvB,QAA6B,EAC7B,YAAgC,EAChC,iBAAmC,EACnC,MAAe,EACf,UAAyB,EACzB,yBAAiD,EACjD,WAAwB;IAExB,iFAAiF;IACjF,MAAM,aAAa,GAAG,QAAQ,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IACnD,OAAO,QAAQ,CAAC,CAAC,CAAC,EAAE,EAAE,CACpB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACR,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CACd,aAAa,CACX,QAAQ,EACR,YAAY,EACZ,iBAAiB,EACjB,MAAM,EACN,CAAC,CAAC,YAAY,EACd,UAAU,EACV,yBAAyB,EACzB,WAAW,CACZ,CACF,EACD,GAAG,CAAC,CAAC,EAAC,KAAK,EAAE,cAAc,EAAE,IAAI,EAAE,iBAAiB,EAAC,EAAE,EAAE;QACvD,OAAO,EAAC,GAAG,CAAC,EAAE,cAAc,EAAE,iBAAiB,EAAC,CAAC;IACnD,CAAC,CAAC,CACH,CACF,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EnvironmentInjector,\n  EnvironmentProviders,\n  InjectionToken,\n  makeEnvironmentProviders,\n  Type,\n} from '@angular/core';\nimport {MonoTypeOperatorFunction, of} from 'rxjs';\nimport {map, mergeMap, switchMap} from 'rxjs/operators';\n\nimport type {Route} from '../models';\nimport type {NavigationTransition} from '../navigation_transition';\nimport {recognize as recognizeFn} from '../recognize';\nimport {recognize as recognizeFnRxjs} from '../recognize_rxjs';\nimport type {RouterConfigLoader} from '../router_config_loader';\nimport type {UrlSerializer} from '../url_tree';\n\nconst USE_ASYNC_RECOGNIZE = true;\n\nconst RECOGNIZE_IMPL = new InjectionToken<typeof recognizeFn | typeof recognizeFnRxjs>(\n  'RECOGNIZE_IMPL',\n  {\n    providedIn: 'root',\n    factory: () => {\n      if (!USE_ASYNC_RECOGNIZE) {\n        return recognizeFnRxjs;\n      }\n      return recognizeFn;\n    },\n  },\n);\n\n/**\n * Provides a way to use the synchronous version of the recognize function using rxjs.\n */\nexport function provideSometimesSyncRecognize(): EnvironmentProviders {\n  return makeEnvironmentProviders([{provide: RECOGNIZE_IMPL, useValue: recognizeFnRxjs}]);\n}\n\nexport function recognize(\n  injector: EnvironmentInjector,\n  configLoader: RouterConfigLoader,\n  rootComponentType: Type<any> | null,\n  config: Route[],\n  serializer: UrlSerializer,\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n  abortSignal: AbortSignal,\n): MonoTypeOperatorFunction<NavigationTransition> {\n  // TODO(atscott): Simplify once we do not need to support both forms of recognize\n  const recognizeImpl = injector.get(RECOGNIZE_IMPL);\n  return mergeMap((t) =>\n    of(t).pipe(\n      switchMap((t) =>\n        recognizeImpl(\n          injector,\n          configLoader,\n          rootComponentType,\n          config,\n          t.extractedUrl,\n          serializer,\n          paramsInheritanceStrategy,\n          abortSignal,\n        ),\n      ),\n      map(({state: targetSnapshot, tree: urlAfterRedirects}) => {\n        return {...t, targetSnapshot, urlAfterRedirects};\n      }),\n    ),\n  );\n}\n"]}