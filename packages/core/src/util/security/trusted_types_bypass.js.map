{"version":3,"file":"trusted_types_bypass.js","sourceRoot":"","sources":["trusted_types_bypass.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH;;;;;;;;;GASG;AAEH,OAAO,EAAC,MAAM,EAAC,MAAM,WAAW,CAAC;AASjC;;;GAGG;AACH,IAAI,MAA4C,CAAC;AAEjD;;;GAGG;AACH,SAAS,SAAS;IAChB,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;QACzB,MAAM,GAAG,IAAI,CAAC;QACd,IAAI,MAAM,CAAC,YAAY,EAAE,CAAC;YACxB,IAAI,CAAC;gBACH,MAAM,GAAI,MAAM,CAAC,YAAyC,CAAC,YAAY,CACrE,uBAAuB,EACvB;oBACE,UAAU,EAAE,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC;oBAC5B,YAAY,EAAE,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC;oBAC9B,eAAe,EAAE,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC;iBAClC,CACF,CAAC;YACJ,CAAC;YAAC,MAAM,CAAC;gBACP,iEAAiE;gBACjE,uEAAuE;gBACvE,sEAAsE;gBACtE,mDAAmD;YACrD,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,2BAA2B,CAAC,IAAY;IACtD,OAAO,SAAS,EAAE,EAAE,UAAU,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC;AAC/C,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,6BAA6B,CAAC,MAAc;IAC1D,OAAO,SAAS,EAAE,EAAE,YAAY,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC;AACrD,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,gCAAgC,CAAC,GAAW;IAC1D,OAAO,SAAS,EAAE,EAAE,eAAe,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC;AAClD,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular specifically for bypassSecurityTrust* and custom sanitizers. It\n * lazily constructs the Trusted Types policy, providing helper utilities for\n * promoting strings to Trusted Types. When Trusted Types are not available,\n * strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../global';\nimport {\n  TrustedHTML,\n  TrustedScript,\n  TrustedScriptURL,\n  TrustedTypePolicy,\n  TrustedTypePolicyFactory,\n} from './trusted_type_defs';\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy | null | undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy | null {\n  if (policy === undefined) {\n    policy = null;\n    if (global.trustedTypes) {\n      try {\n        policy = (global.trustedTypes as TrustedTypePolicyFactory).createPolicy(\n          'angular#unsafe-bypass',\n          {\n            createHTML: (s: string) => s,\n            createScript: (s: string) => s,\n            createScriptURL: (s: string) => s,\n          },\n        );\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nexport function trustedHTMLFromStringBypass(html: string): TrustedHTML | string {\n  return getPolicy()?.createHTML(html) || html;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nexport function trustedScriptFromStringBypass(script: string): TrustedScript | string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nexport function trustedScriptURLFromStringBypass(url: string): TrustedScriptURL | string {\n  return getPolicy()?.createScriptURL(url) || url;\n}\n"]}