{"version":3,"file":"callback_scheduler.js","sourceRoot":"","sources":["callback_scheduler.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,IAAI,EAAC,MAAM,QAAQ,CAAC;AAE5B;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,MAAM,UAAU,2BAA2B,CAAC,QAAkB;IAC5D,IAAI,SAAiB,CAAC;IACtB,IAAI,gBAAwB,CAAC;IAC7B,SAAS,OAAO;QACd,QAAQ,GAAG,IAAI,CAAC;QAChB,IAAI,CAAC;YACH,IAAI,gBAAgB,KAAK,SAAS,IAAI,OAAO,oBAAoB,KAAK,UAAU,EAAE,CAAC;gBACjF,oBAAoB,CAAC,gBAAgB,CAAC,CAAC;YACzC,CAAC;YACD,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;gBAC5B,YAAY,CAAC,SAAS,CAAC,CAAC;YAC1B,CAAC;QACH,CAAC;QAAC,MAAM,CAAC;YACP,kGAAkG;YAClG,qGAAqG;QACvG,CAAC;IACH,CAAC;IACD,SAAS,GAAG,UAAU,CAAC,GAAG,EAAE;QAC1B,QAAQ,EAAE,CAAC;QACX,OAAO,EAAE,CAAC;IACZ,CAAC,CAAsB,CAAC;IACxB,IAAI,OAAO,qBAAqB,KAAK,UAAU,EAAE,CAAC;QAChD,gBAAgB,GAAG,qBAAqB,CAAC,GAAG,EAAE;YAC5C,QAAQ,EAAE,CAAC;YACX,OAAO,EAAE,CAAC;QACZ,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO,GAAG,EAAE,CAAC,OAAO,EAAE,CAAC;AACzB,CAAC;AAED,MAAM,UAAU,6BAA6B,CAAC,QAAkB;IAC9D,cAAc,CAAC,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC;IAEjC,OAAO,GAAG,EAAE;QACV,QAAQ,GAAG,IAAI,CAAC;IAClB,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {noop} from './noop';\n\n/**\n * Gets a scheduling function that runs the callback after the first of setTimeout and\n * requestAnimationFrame resolves.\n *\n * - `requestAnimationFrame` ensures that change detection runs ahead of a browser repaint.\n * This ensures that the create and update passes of a change detection always happen\n * in the same frame.\n * - When the browser is resource-starved, `rAF` can execute _before_ a `setTimeout` because\n * rendering is a very high priority process. This means that `setTimeout` cannot guarantee\n * same-frame create and update pass, when `setTimeout` is used to schedule the update phase.\n * - While `rAF` gives us the desirable same-frame updates, it has two limitations that\n * prevent it from being used alone. First, it does not run in background tabs, which would\n * prevent Angular from initializing an application when opened in a new tab (for example).\n * Second, repeated calls to requestAnimationFrame will execute at the refresh rate of the\n * hardware (~16ms for a 60Hz display). This would cause significant slowdown of tests that\n * are written with several updates and asserts in the form of \"update; await stable; assert;\".\n * - Both `setTimeout` and `rAF` are able to \"coalesce\" several events from a single user\n * interaction into a single change detection. Importantly, this reduces view tree traversals when\n * compared to an alternative timing mechanism like `queueMicrotask`, where change detection would\n * then be interleaves between each event.\n *\n * By running change detection after the first of `setTimeout` and `rAF` to execute, we get the\n * best of both worlds.\n *\n * @returns a function to cancel the scheduled callback\n */\nexport function scheduleCallbackWithRafRace(callback: Function): () => void {\n  let timeoutId: number;\n  let animationFrameId: number;\n  function cleanup() {\n    callback = noop;\n    try {\n      if (animationFrameId !== undefined && typeof cancelAnimationFrame === 'function') {\n        cancelAnimationFrame(animationFrameId);\n      }\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    } catch {\n      // Clearing/canceling can fail in tests due to the timing of functions being patched and unpatched\n      // Just ignore the errors - we protect ourselves from this issue by also making the callback a no-op.\n    }\n  }\n  timeoutId = setTimeout(() => {\n    callback();\n    cleanup();\n  }) as unknown as number;\n  if (typeof requestAnimationFrame === 'function') {\n    animationFrameId = requestAnimationFrame(() => {\n      callback();\n      cleanup();\n    });\n  }\n\n  return () => cleanup();\n}\n\nexport function scheduleCallbackWithMicrotask(callback: Function): () => void {\n  queueMicrotask(() => callback());\n\n  return () => {\n    callback = noop;\n  };\n}\n"]}