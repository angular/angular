{"version":3,"file":"debug_node.js","sourceRoot":"","sources":["debug_node.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,mBAAmB,EAAC,MAAM,mBAAmB,CAAC;AACtD,OAAO,EAAC,WAAW,EAAC,MAAM,8BAA8B,CAAC;AACzD,OAAO,EAAC,uBAAuB,EAAc,MAAM,EAAC,MAAM,iCAAiC,CAAC;AAE5F,OAAO,EAAC,eAAe,EAAE,YAAY,EAAC,MAAM,mCAAmC,CAAC;AAChF,OAAO,EACL,0BAA0B,EAE1B,MAAM,EACN,MAAM,EAEN,KAAK,GACN,MAAM,4BAA4B,CAAC;AACpC,OAAO,EACL,YAAY,EACZ,UAAU,EACV,kBAAkB,EAClB,WAAW,EACX,YAAY,EACZ,YAAY,EACZ,kBAAkB,GACnB,MAAM,iCAAiC,CAAC;AACzC,OAAO,EAAC,uBAAuB,EAAC,MAAM,4BAA4B,CAAC;AACnE,OAAO,EAAC,eAAe,EAAC,MAAM,iCAAiC,CAAC;AAChE,OAAO,EAAC,wBAAwB,EAAE,sBAAsB,EAAC,MAAM,4BAA4B,CAAC;AAC5F,OAAO,EAAC,aAAa,EAAC,MAAM,gBAAgB,CAAC;AAE7C;;GAEG;AACH,MAAM,OAAO,kBAAkB;IAC7B,YACS,IAAY,EACZ,QAAkB;QADlB,SAAI,GAAJ,IAAI,CAAQ;QACZ,aAAQ,GAAR,QAAQ,CAAU;IACxB,CAAC;CACL;AAED;;GAEG;AACH,MAAM,UAAU,gBAAgB,CAAC,QAAwB;IACvD,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,aAAa,CAAC,CAAC;AAChD,CAAC;AAED;;GAEG;AACH,MAAM,OAAO,SAAS;IAMpB,YAAY,UAAgB;QAC1B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;IAED;;OAEG;IACH,IAAI,MAAM;QACR,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,UAAqB,CAAC;QACrD,OAAO,MAAM,CAAC,CAAC,CAAC,IAAI,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAClD,CAAC;IAED;;OAEG;IACH,IAAI,QAAQ;QACV,OAAO,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACtC,CAAC;IAED;;OAEG;IACH,IAAI,iBAAiB;QACnB,MAAM,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC;QACtC,OAAO,CACL,aAAa,IAAI,CAAC,YAAY,CAAC,aAAwB,CAAC,IAAI,kBAAkB,CAAC,aAAa,CAAC,CAAC,CAC/F,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACH,IAAI,OAAO;QACT,OAAO,YAAY,CAAC,IAAI,CAAC,UAAqB,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,UAAqB,CAAC,CAAC;IAC5F,CAAC;IAED;;;OAGG;IACH,IAAI,SAAS;QACX,OAAO,YAAY,CAAC,IAAI,CAAC,UAAqB,CAAC,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC;IAChG,CAAC;IAED;;;OAGG;IACH,IAAI,UAAU;QACZ,OAAO,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACvC,CAAC;IAED;;;OAGG;IACH,IAAI,cAAc;QAChB,OAAO,kBAAkB,CAAC,IAAI,CAAC,UAAqB,CAAC,CAAC;IACxD,CAAC;CACF;AAED;;;;;;GAMG;AACH,MAAM,OAAO,YAAa,SAAQ,SAAS;IACzC,YAAY,UAAmB;QAC7B,SAAS,IAAI,aAAa,CAAC,UAAU,CAAC,CAAC;QACvC,KAAK,CAAC,UAAU,CAAC,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,IAAI,IAAI,CAAC,YAAY,CAAC,CAAC,CAAE,IAAI,CAAC,UAAsB,CAAC,CAAC,CAAC,IAAI,CAAC;IAC7F,CAAC;IAED;;OAEG;IACH,IAAI,IAAI;QACN,MAAM,OAAO,GAAG,WAAW,CAAC,IAAI,CAAC,UAAU,CAAE,CAAC;QAC9C,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;QAE7C,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;YACnB,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC;YAChC,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,CAAU,CAAC;YAChD,OAAO,KAAK,CAAC,KAAM,CAAC;QACtB,CAAC;aAAM,CAAC;YACN,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC;QAClC,CAAC;IACH,CAAC;IAED;;;;;;;;;;;OAWG;IACH,IAAI,UAAU;QACZ,MAAM,OAAO,GAAG,WAAW,CAAC,IAAI,CAAC,UAAU,CAAE,CAAC;QAC9C,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;QAE7C,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;YACnB,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC;QAChC,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,CAAU,CAAC;QAEhD,MAAM,UAAU,GAA4B,EAAE,CAAC;QAC/C,mCAAmC;QACnC,iBAAiB,CAAC,IAAI,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;QAClD,wFAAwF;QACxF,+DAA+D;QAC/D,uBAAuB,CAAC,UAAU,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;QACzD,OAAO,UAAU,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,qDAAqD;IACrD,IAAI,UAAU;QACZ,MAAM,UAAU,GAAmC,EAAE,CAAC;QACtD,MAAM,OAAO,GAAG,IAAI,CAAC,aAAoC,CAAC;QAE1D,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,OAAO,UAAU,CAAC;QACpB,CAAC;QAED,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,CAAE,CAAC;QACtC,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;QAE7C,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;YACnB,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,MAAM,UAAU,GAAI,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAW,CAAC,KAAK,CAAC;QACzE,MAAM,mBAAmB,GAAa,EAAE,CAAC;QAEzC,2FAA2F;QAC3F,6FAA6F;QAC7F,+FAA+F;QAC/F,+FAA+F;QAC/F,4FAA4F;QAC5F,6FAA6F;QAC7F,sEAAsE;QACtE,IAAI,UAAU,EAAE,CAAC;YACf,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC;gBAC7B,MAAM,QAAQ,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;gBAE/B,yFAAyF;gBACzF,4EAA4E;gBAC5E,IAAI,OAAO,QAAQ,KAAK,QAAQ;oBAAE,MAAM;gBAExC,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACpC,UAAU,CAAC,QAAQ,CAAC,GAAG,SAAmB,CAAC;gBAC3C,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC,CAAC;gBAEjD,CAAC,IAAI,CAAC,CAAC;YACT,CAAC;QACH,CAAC;QAED,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;YACtC,gEAAgE;YAChE,gEAAgE;YAChE,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC7C,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;YACrC,CAAC;QACH,CAAC;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,qDAAqD;IACrD,IAAI,MAAM;QACR,MAAM,OAAO,GAAG,IAAI,CAAC,aAAmC,CAAC;QACzD,OAAO,CAAC,OAAO,EAAE,KAAK,IAAI,EAAE,CAAmC,CAAC;IAClE,CAAC;IAED;;;;;;;;;OASG;IACH,IAAI,OAAO;QACT,MAAM,MAAM,GAA6B,EAAE,CAAC;QAC5C,MAAM,OAAO,GAAG,IAAI,CAAC,aAAyC,CAAC;QAE/D,4FAA4F;QAC5F,MAAM,SAAS,GAAG,OAAO,CAAC,SAAuC,CAAC;QAClE,MAAM,OAAO,GACX,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAEtF,OAAO,CAAC,OAAO,CAAC,CAAC,KAAa,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;QAE3D,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACH,IAAI,UAAU;QACZ,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC;QAC9C,MAAM,QAAQ,GAAgB,EAAE,CAAC;QACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC3C,MAAM,OAAO,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9B,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAE,CAAC,CAAC;QACxC,CAAC;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;OAEG;IACH,IAAI,QAAQ;QACV,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;QACzC,IAAI,CAAC,aAAa;YAAE,OAAO,EAAE,CAAC;QAC9B,MAAM,UAAU,GAAG,aAAa,CAAC,QAAQ,CAAC;QAC1C,MAAM,QAAQ,GAAmB,EAAE,CAAC;QACpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC3C,MAAM,OAAO,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9B,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAiB,CAAC,CAAC;QACvD,CAAC;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,SAAkC;QACtC,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACzC,OAAO,OAAO,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC;IAC5B,CAAC;IAED;;OAEG;IACH,QAAQ,CAAC,SAAkC;QACzC,MAAM,OAAO,GAAmB,EAAE,CAAC;QACnC,SAAS,CAAC,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;QAC1C,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;OAEG;IACH,aAAa,CAAC,SAA+B;QAC3C,MAAM,OAAO,GAAgB,EAAE,CAAC;QAChC,SAAS,CAAC,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QAC3C,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;;;;;;;;;;OAWG;IACH,mBAAmB,CAAC,SAAiB,EAAE,QAAc;QACnD,MAAM,IAAI,GAAG,IAAI,CAAC,UAAiB,CAAC;QACpC,MAAM,gBAAgB,GAAe,EAAE,CAAC;QAExC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;YAClC,IAAI,QAAQ,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;gBAChC,MAAM,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;gBACnC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;gBAC9B,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAClC,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,2EAA2E;QAC3E,mEAAmE;QACnE,IAAI,OAAO,IAAI,CAAC,cAAc,KAAK,UAAU,EAAE,CAAC;YAC9C,yFAAyF;YACzF,2FAA2F;YAC3F,YAAY;YACZ,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,QAAkB,EAAE,EAAE;gBAC5D,2FAA2F;gBAC3F,2FAA2F;gBAC3F,yFAAyF;gBACzF,wFAAwF;gBACxF,4FAA4F;gBAC5F,qFAAqF;gBACrF,IAAI,QAAQ,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;oBACvD,MAAM,iBAAiB,GAAG,QAAQ,CAAC,cAAc,CAAC,CAAC;oBACnD,OAAO,CACL,gBAAgB,CAAC,OAAO,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;wBAClD,iBAAiB,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CACvC,CAAC;gBACJ,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;CACF;AAED,SAAS,iBAAiB,CAAC,OAAuB,EAAE,UAAoC;IACtF,IAAI,OAAO,EAAE,CAAC;QACZ,6CAA6C;QAC7C,IAAI,GAAG,GAAG,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QACzC,MAAM,aAAa,GAAQ,IAAI,CAAC,SAAS,CAAC;QAC1C,OAAO,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,aAAa,EAAE,CAAC;YAC7C,MAAM,WAAW,GAAG,MAAM,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC;YAC1D,KAAK,IAAI,GAAG,IAAI,WAAW,EAAE,CAAC;gBAC5B,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC;oBACnD,wDAAwD;oBACxD,wDAAwD;oBACxD,wDAAwD;oBACxD,MAAM,KAAK,GAAI,OAAe,CAAC,GAAG,CAAC,CAAC;oBACpC,IAAI,gBAAgB,CAAC,KAAK,CAAC,EAAE,CAAC;wBAC5B,UAAU,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;oBAC1B,CAAC;gBACH,CAAC;YACH,CAAC;YACD,GAAG,GAAG,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;AACH,CAAC;AAED,SAAS,gBAAgB,CAAC,KAAU;IAClC,OAAO,CACL,OAAO,KAAK,KAAK,QAAQ;QACzB,OAAO,KAAK,KAAK,SAAS;QAC1B,OAAO,KAAK,KAAK,QAAQ;QACzB,KAAK,KAAK,IAAI,CACf,CAAC;AACJ,CAAC;AAsBD,SAAS,SAAS,CAChB,aAA2B,EAC3B,SAAyD,EACzD,OAAqC,EACrC,YAAqB;IAErB,MAAM,OAAO,GAAG,WAAW,CAAC,aAAa,CAAC,UAAU,CAAE,CAAC;IACvD,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;IAC7C,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;QACnB,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAU,CAAC;QAClE,kBAAkB,CAChB,WAAW,EACX,KAAK,EACL,SAAS,EACT,OAAO,EACP,YAAY,EACZ,aAAa,CAAC,UAAU,CACzB,CAAC;IACJ,CAAC;SAAM,CAAC;QACN,+FAA+F;QAC/F,QAAQ;QACR,2BAA2B,CAAC,aAAa,CAAC,UAAU,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,CAAC,CAAC;IAC1F,CAAC;AACH,CAAC;AAED;;;;;;;;;GASG;AACH,SAAS,kBAAkB,CACzB,KAAY,EACZ,KAAY,EACZ,SAAyD,EACzD,OAAqC,EACrC,YAAqB,EACrB,cAAmB;IAEnB,SAAS,IAAI,mBAAmB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAC/C,MAAM,UAAU,GAAG,sBAAsB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IACxD,sDAAsD;IACtD,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,+DAA+C,CAAC,EAAE,CAAC;QACnE,kCAAkC;QAClC,qCAAqC;QACrC,cAAc,CAAC,UAAU,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;QAC7E,IAAI,eAAe,CAAC,KAAK,CAAC,EAAE,CAAC;YAC3B,8FAA8F;YAC9F,2FAA2F;YAC3F,MAAM,aAAa,GAAG,wBAAwB,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YACnE,IAAI,aAAa,IAAI,aAAa,CAAC,KAAK,CAAC,CAAC,UAAU,EAAE,CAAC;gBACrD,kBAAkB,CAChB,aAAa,CAAC,KAAK,CAAC,CAAC,UAAW,EAChC,aAAa,EACb,SAAS,EACT,OAAO,EACP,YAAY,EACZ,cAAc,CACf,CAAC;YACJ,CAAC;QACH,CAAC;aAAM,CAAC;YACN,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;gBAChB,gDAAgD;gBAChD,kBAAkB,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;YAC3F,CAAC;YAED,qFAAqF;YACrF,6FAA6F;YAC7F,wFAAwF;YACxF,sFAAsF;YACtF,sFAAsF;YACtF,yEAAyE;YACzE,4EAA4E;YAC5E,UAAU,IAAI,2BAA2B,CAAC,UAAU,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,CAAC,CAAC;QAC1F,CAAC;QACD,2FAA2F;QAC3F,aAAa;QACb,MAAM,eAAe,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAC3C,IAAI,YAAY,CAAC,eAAe,CAAC,EAAE,CAAC;YAClC,6BAA6B,CAC3B,eAAe,EACf,SAAS,EACT,OAAO,EACP,YAAY,EACZ,cAAc,CACf,CAAC;QACJ,CAAC;IACH,CAAC;SAAM,IAAI,KAAK,CAAC,IAAI,8BAAsB,EAAE,CAAC;QAC5C,mCAAmC;QACnC,qCAAqC;QACrC,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACtC,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;QACrF,sDAAsD;QACtD,6BAA6B,CAAC,UAAU,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;IAC9F,CAAC;SAAM,IAAI,KAAK,CAAC,IAAI,gCAAuB,EAAE,CAAC;QAC7C,2EAA2E;QAC3E,iEAAiE;QACjE,MAAM,aAAa,GAAG,KAAM,CAAC,0BAA0B,CAAC,CAAC;QACzD,MAAM,aAAa,GAAG,aAAa,CAAC,MAAM,CAAiB,CAAC;QAC5D,MAAM,IAAI,GAAkB,aAAa,CAAC,UAA+B,CACvE,KAAK,CAAC,UAAoB,CAC3B,CAAC;QAEF,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;YACxB,KAAK,IAAI,UAAU,IAAI,IAAI,EAAE,CAAC;gBAC5B,cAAc,CAAC,UAAU,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;YAC/E,CAAC;QACH,CAAC;aAAM,IAAI,IAAI,EAAE,CAAC;YAChB,MAAM,SAAS,GAAG,aAAa,CAAC,MAAM,CAAW,CAAC;YAClD,MAAM,SAAS,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAU,CAAC;YAC7D,kBAAkB,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;QAC7F,CAAC;IACH,CAAC;SAAM,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;QACvB,+BAA+B;QAC/B,kBAAkB,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;IAC3F,CAAC;IAED,4DAA4D;IAC5D,IAAI,cAAc,KAAK,UAAU,EAAE,CAAC;QAClC,4FAA4F;QAC5F,kEAAkE;QAClE,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,iCAAyB,CAAC,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC;QAC3F,IAAI,SAAS,EAAE,CAAC;YACd,kBAAkB,CAAC,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;QACzF,CAAC;IACH,CAAC;AACH,CAAC;AAED;;;;;;;;GAQG;AACH,SAAS,6BAA6B,CACpC,UAAsB,EACtB,SAAyD,EACzD,OAAqC,EACrC,YAAqB,EACrB,cAAmB;IAEnB,KAAK,IAAI,CAAC,GAAG,uBAAuB,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACjE,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC,CAAU,CAAC;QACzC,MAAM,UAAU,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC;QAC/C,IAAI,UAAU,EAAE,CAAC;YACf,kBAAkB,CAAC,UAAU,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;QAC9F,CAAC;IACH,CAAC;AACH,CAAC;AAED;;;;;;;;GAQG;AACH,SAAS,cAAc,CACrB,UAAe,EACf,SAAyD,EACzD,OAAqC,EACrC,YAAqB,EACrB,cAAmB;IAEnB,IAAI,cAAc,KAAK,UAAU,EAAE,CAAC;QAClC,MAAM,SAAS,GAAG,YAAY,CAAC,UAAU,CAAC,CAAC;QAC3C,IAAI,CAAC,SAAS,EAAE,CAAC;YACf,OAAO;QACT,CAAC;QACD,2EAA2E;QAC3E,+EAA+E;QAC/E,uEAAuE;QACvE,IACE,YAAY;YACZ,SAAS,YAAY,YAAY;YACjC,SAAS,CAAC,SAAS,CAAC;YACpB,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EACjC,CAAC;YACD,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC1B,CAAC;aAAM,IACL,CAAC,YAAY;YACZ,SAAkC,CAAC,SAAS,CAAC;YAC7C,OAAuB,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAClD,CAAC;YACA,OAAuB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC3C,CAAC;IACH,CAAC;AACH,CAAC;AAED;;;;;;;GAOG;AACH,SAAS,2BAA2B,CAClC,UAAe,EACf,SAAyD,EACzD,OAAqC,EACrC,YAAqB;IAErB,MAAM,KAAK,GAAG,UAAU,CAAC,UAAU,CAAC;IACpC,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;IAE5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAChC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,MAAM,SAAS,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QAErC,IAAI,SAAS,EAAE,CAAC;YACd,IACE,YAAY;gBACZ,SAAS,YAAY,YAAY;gBACjC,SAAS,CAAC,SAAS,CAAC;gBACpB,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EACjC,CAAC;gBACD,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC1B,CAAC;iBAAM,IACL,CAAC,YAAY;gBACZ,SAAkC,CAAC,SAAS,CAAC;gBAC7C,OAAuB,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAClD,CAAC;gBACA,OAAuB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC3C,CAAC;YAED,2BAA2B,CAAC,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,CAAC,CAAC;QACtE,CAAC;IACH,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,SAAS,uBAAuB,CAC9B,UAAmC,EACnC,KAAY,EACZ,KAAY,EACZ,KAAY;IAEZ,IAAI,cAAc,GAAG,KAAK,CAAC,gBAAgB,CAAC;IAE5C,IAAI,cAAc,KAAK,IAAI,EAAE,CAAC;QAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC/C,MAAM,YAAY,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;YACvC,MAAM,YAAY,GAAG,KAAK,CAAC,YAAY,CAAW,CAAC;YACnD,MAAM,aAAa,GAAG,YAAY,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAC;YAClE,MAAM,YAAY,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;YACtC,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC7B,IAAI,KAAK,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;gBAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;oBAClD,KAAK,IAAI,eAAe,CAAC,KAAK,CAAC,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC/E,CAAC;gBACD,UAAU,CAAC,YAAY,CAAC,GAAG,KAAK,CAAC;YACnC,CAAC;iBAAM,CAAC;gBACN,UAAU,CAAC,YAAY,CAAC,GAAG,KAAK,CAAC,YAAY,CAAC,CAAC;YACjD,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC;AAED,sFAAsF;AACtF,MAAM,sBAAsB,GAAG,IAAI,GAAG,EAAkB,CAAC;AAEzD,MAAM,iBAAiB,GAAG,cAAc,CAAC;AAEzC;;GAEG;AACH,MAAM,UAAU,YAAY,CAAC,UAAe;IAC1C,IAAI,UAAU,YAAY,IAAI,EAAE,CAAC;QAC/B,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,iBAAiB,CAAC,EAAE,CAAC;YACjD,UAAkB,CAAC,iBAAiB,CAAC;gBACpC,UAAU,CAAC,QAAQ,IAAI,IAAI,CAAC,YAAY;oBACtC,CAAC,CAAC,IAAI,YAAY,CAAC,UAAqB,CAAC;oBACzC,CAAC,CAAC,IAAI,SAAS,CAAC,UAAU,CAAC,CAAC;QAClC,CAAC;QACD,OAAQ,UAAkB,CAAC,iBAAiB,CAAC,CAAC;IAChD,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,UAAU,gBAAgB;IAC9B,OAAO,KAAK,CAAC,IAAI,CAAC,sBAAsB,CAAC,MAAM,EAAE,CAAC,CAAC;AACrD,CAAC;AAED,MAAM,UAAU,cAAc,CAAC,IAAe;IAC5C,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;AACpD,CAAC;AAED,MAAM,UAAU,wBAAwB,CAAC,IAAe;IACtD,sBAAsB,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AACjD,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector} from '../di/injector';\nimport {assertTNodeForLView} from '../render3/assert';\nimport {getLContext} from '../render3/context_discovery';\nimport {CONTAINER_HEADER_OFFSET, LContainer, NATIVE} from '../render3/interfaces/container';\nimport {TElementNode, TNode, TNodeFlags, TNodeType} from '../render3/interfaces/node';\nimport {isComponentHost, isLContainer} from '../render3/interfaces/type_checks';\nimport {\n  DECLARATION_COMPONENT_VIEW,\n  LView,\n  PARENT,\n  T_HOST,\n  TData,\n  TVIEW,\n} from '../render3/interfaces/view';\nimport {\n  getComponent,\n  getContext,\n  getInjectionTokens,\n  getInjector,\n  getListeners,\n  getLocalRefs,\n  getOwningComponent,\n} from '../render3/util/discovery_utils';\nimport {INTERPOLATION_DELIMITER} from '../render3/util/misc_utils';\nimport {renderStringify} from '../render3/util/stringify_utils';\nimport {getComponentLViewByIndex, getNativeByTNodeOrNull} from '../render3/util/view_utils';\nimport {assertDomNode} from '../util/assert';\n\n/**\n * @publicApi\n */\nexport class DebugEventListener {\n  constructor(\n    public name: string,\n    public callback: Function,\n  ) {}\n}\n\n/**\n * @publicApi\n */\nexport function asNativeElements(debugEls: DebugElement[]): any {\n  return debugEls.map((el) => el.nativeElement);\n}\n\n/**\n * @publicApi\n */\nexport class DebugNode {\n  /**\n   * The underlying DOM node.\n   */\n  readonly nativeNode: any;\n\n  constructor(nativeNode: Node) {\n    this.nativeNode = nativeNode;\n  }\n\n  /**\n   * The `DebugElement` parent. Will be `null` if this is the root element.\n   */\n  get parent(): DebugElement | null {\n    const parent = this.nativeNode.parentNode as Element;\n    return parent ? new DebugElement(parent) : null;\n  }\n\n  /**\n   * The host dependency injector. For example, the root element's component instance injector.\n   */\n  get injector(): Injector {\n    return getInjector(this.nativeNode);\n  }\n\n  /**\n   * The element's own component instance, if it has one.\n   */\n  get componentInstance(): any {\n    const nativeElement = this.nativeNode;\n    return (\n      nativeElement && (getComponent(nativeElement as Element) || getOwningComponent(nativeElement))\n    );\n  }\n\n  /**\n   * An object that provides parent context for this element. Often an ancestor component instance\n   * that governs this element.\n   *\n   * When an element is repeated within *ngFor, the context is an `NgForOf` whose `$implicit`\n   * property is the value of the row instance value. For example, the `hero` in `*ngFor=\"let hero\n   * of heroes\"`.\n   */\n  get context(): any {\n    return getComponent(this.nativeNode as Element) || getContext(this.nativeNode as Element);\n  }\n\n  /**\n   * The callbacks attached to the component's @Output properties and/or the element's event\n   * properties.\n   */\n  get listeners(): DebugEventListener[] {\n    return getListeners(this.nativeNode as Element).filter((listener) => listener.type === 'dom');\n  }\n\n  /**\n   * Dictionary of objects associated with template local variables (e.g. #foo), keyed by the local\n   * variable name.\n   */\n  get references(): {[key: string]: any} {\n    return getLocalRefs(this.nativeNode);\n  }\n\n  /**\n   * This component's injector lookup tokens. Includes the component itself plus the tokens that the\n   * component lists in its providers metadata.\n   */\n  get providerTokens(): any[] {\n    return getInjectionTokens(this.nativeNode as Element);\n  }\n}\n\n/**\n * @publicApi\n *\n * @see [Component testing scenarios](guide/testing/components-scenarios)\n * @see [Basics of testing components](guide/testing/components-basics)\n * @see [Testing utility APIs](guide/testing/utility-apis)\n */\nexport class DebugElement extends DebugNode {\n  constructor(nativeNode: Element) {\n    ngDevMode && assertDomNode(nativeNode);\n    super(nativeNode);\n  }\n\n  /**\n   * The underlying DOM element at the root of the component.\n   */\n  get nativeElement(): any {\n    return this.nativeNode.nodeType == Node.ELEMENT_NODE ? (this.nativeNode as Element) : null;\n  }\n\n  /**\n   * The element tag name, if it is an element.\n   */\n  get name(): string {\n    const context = getLContext(this.nativeNode)!;\n    const lView = context ? context.lView : null;\n\n    if (lView !== null) {\n      const tData = lView[TVIEW].data;\n      const tNode = tData[context.nodeIndex] as TNode;\n      return tNode.value!;\n    } else {\n      return this.nativeNode.nodeName;\n    }\n  }\n\n  /**\n   *  Gets a map of property names to property values for an element.\n   *\n   *  This map includes:\n   *  - Regular property bindings (e.g. `[id]=\"id\"`)\n   *  - Host property bindings (e.g. `host: { '[id]': \"id\" }`)\n   *  - Interpolated property bindings (e.g. `id=\"{{ value }}\")\n   *\n   *  It does not include:\n   *  - input property bindings (e.g. `[myCustomInput]=\"value\"`)\n   *  - attribute bindings (e.g. `[attr.role]=\"menu\"`)\n   */\n  get properties(): {[key: string]: any} {\n    const context = getLContext(this.nativeNode)!;\n    const lView = context ? context.lView : null;\n\n    if (lView === null) {\n      return {};\n    }\n\n    const tData = lView[TVIEW].data;\n    const tNode = tData[context.nodeIndex] as TNode;\n\n    const properties: {[key: string]: string} = {};\n    // Collect properties from the DOM.\n    copyDomProperties(this.nativeElement, properties);\n    // Collect properties from the bindings. This is needed for animation renderer which has\n    // synthetic properties which don't get reflected into the DOM.\n    collectPropertyBindings(properties, tNode, lView, tData);\n    return properties;\n  }\n\n  /**\n   *  A map of attribute names to attribute values for an element.\n   */\n  // TODO: replace null by undefined in the return type\n  get attributes(): {[key: string]: string | null} {\n    const attributes: {[key: string]: string | null} = {};\n    const element = this.nativeElement as Element | undefined;\n\n    if (!element) {\n      return attributes;\n    }\n\n    const context = getLContext(element)!;\n    const lView = context ? context.lView : null;\n\n    if (lView === null) {\n      return {};\n    }\n\n    const tNodeAttrs = (lView[TVIEW].data[context.nodeIndex] as TNode).attrs;\n    const lowercaseTNodeAttrs: string[] = [];\n\n    // For debug nodes we take the element's attribute directly from the DOM since it allows us\n    // to account for ones that weren't set via bindings (e.g. ViewEngine keeps track of the ones\n    // that are set through `Renderer2`). The problem is that the browser will lowercase all names,\n    // however since we have the attributes already on the TNode, we can preserve the case by going\n    // through them once, adding them to the `attributes` map and putting their lower-cased name\n    // into an array. Afterwards when we're going through the native DOM attributes, we can check\n    // whether we haven't run into an attribute already through the TNode.\n    if (tNodeAttrs) {\n      let i = 0;\n      while (i < tNodeAttrs.length) {\n        const attrName = tNodeAttrs[i];\n\n        // Stop as soon as we hit a marker. We only care about the regular attributes. Everything\n        // else will be handled below when we read the final attributes off the DOM.\n        if (typeof attrName !== 'string') break;\n\n        const attrValue = tNodeAttrs[i + 1];\n        attributes[attrName] = attrValue as string;\n        lowercaseTNodeAttrs.push(attrName.toLowerCase());\n\n        i += 2;\n      }\n    }\n\n    for (const attr of element.attributes) {\n      // Make sure that we don't assign the same attribute both in its\n      // case-sensitive form and the lower-cased one from the browser.\n      if (!lowercaseTNodeAttrs.includes(attr.name)) {\n        attributes[attr.name] = attr.value;\n      }\n    }\n\n    return attributes;\n  }\n\n  /**\n   * The inline styles of the DOM element.\n   */\n  // TODO: replace null by undefined in the return type\n  get styles(): {[key: string]: string | null} {\n    const element = this.nativeElement as HTMLElement | null;\n    return (element?.style ?? {}) as {[key: string]: string | null};\n  }\n\n  /**\n   * A map containing the class names on the element as keys.\n   *\n   * This map is derived from the `className` property of the DOM element.\n   *\n   * Note: The values of this object will always be `true`. The class key will not appear in the KV\n   * object if it does not exist on the element.\n   *\n   * @see [Element.className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className)\n   */\n  get classes(): {[key: string]: boolean} {\n    const result: {[key: string]: boolean} = {};\n    const element = this.nativeElement as HTMLElement | SVGElement;\n\n    // SVG elements return an `SVGAnimatedString` instead of a plain string for the `className`.\n    const className = element.className as string | SVGAnimatedString;\n    const classes =\n      typeof className !== 'string' ? className.baseVal.split(' ') : className.split(' ');\n\n    classes.forEach((value: string) => (result[value] = true));\n\n    return result;\n  }\n\n  /**\n   * The `childNodes` of the DOM element as a `DebugNode` array.\n   *\n   * @see [Node.childNodes](https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes)\n   */\n  get childNodes(): DebugNode[] {\n    const childNodes = this.nativeNode.childNodes;\n    const children: DebugNode[] = [];\n    for (let i = 0; i < childNodes.length; i++) {\n      const element = childNodes[i];\n      children.push(getDebugNode(element)!);\n    }\n    return children;\n  }\n\n  /**\n   * The immediate `DebugElement` children. Walk the tree by descending through `children`.\n   */\n  get children(): DebugElement[] {\n    const nativeElement = this.nativeElement;\n    if (!nativeElement) return [];\n    const childNodes = nativeElement.children;\n    const children: DebugElement[] = [];\n    for (let i = 0; i < childNodes.length; i++) {\n      const element = childNodes[i];\n      children.push(getDebugNode(element) as DebugElement);\n    }\n    return children;\n  }\n\n  /**\n   * @returns the first `DebugElement` that matches the predicate at any depth in the subtree.\n   */\n  query(predicate: Predicate<DebugElement>): DebugElement {\n    const results = this.queryAll(predicate);\n    return results[0] || null;\n  }\n\n  /**\n   * @returns All `DebugElement` matches for the predicate at any depth in the subtree.\n   */\n  queryAll(predicate: Predicate<DebugElement>): DebugElement[] {\n    const matches: DebugElement[] = [];\n    _queryAll(this, predicate, matches, true);\n    return matches;\n  }\n\n  /**\n   * @returns All `DebugNode` matches for the predicate at any depth in the subtree.\n   */\n  queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[] {\n    const matches: DebugNode[] = [];\n    _queryAll(this, predicate, matches, false);\n    return matches;\n  }\n\n  /**\n   * Triggers the event by its name if there is a corresponding listener in the element's\n   * `listeners` collection.\n   *\n   * If the event lacks a listener or there's some other problem, consider\n   * calling `nativeElement.dispatchEvent(eventObject)`.\n   *\n   * @param eventName The name of the event to trigger\n   * @param eventObj The _event object_ expected by the handler\n   *\n   * @see [Testing components scenarios](guide/testing/components-scenarios#trigger-event-handler)\n   */\n  triggerEventHandler(eventName: string, eventObj?: any): void {\n    const node = this.nativeNode as any;\n    const invokedListeners: Function[] = [];\n\n    this.listeners.forEach((listener) => {\n      if (listener.name === eventName) {\n        const callback = listener.callback;\n        callback.call(node, eventObj);\n        invokedListeners.push(callback);\n      }\n    });\n\n    // We need to check whether `eventListeners` exists, because it's something\n    // that Zone.js only adds to `EventTarget` in browser environments.\n    if (typeof node.eventListeners === 'function') {\n      // Note that in Ivy we wrap event listeners with a call to `event.preventDefault` in some\n      // cases. We use '__ngUnwrap__' as a special token that gives us access to the actual event\n      // listener.\n      node.eventListeners(eventName).forEach((listener: Function) => {\n        // In order to ensure that we can detect the special __ngUnwrap__ token described above, we\n        // use `toString` on the listener and see if it contains the token. We use this approach to\n        // ensure that it still worked with compiled code since it cannot remove or rename string\n        // literals. We also considered using a special function name (i.e. if(listener.name ===\n        // special)) but that was more cumbersome and we were also concerned the compiled code could\n        // strip the name, turning the condition in to (\"\" === \"\") and always returning true.\n        if (listener.toString().indexOf('__ngUnwrap__') !== -1) {\n          const unwrappedListener = listener('__ngUnwrap__');\n          return (\n            invokedListeners.indexOf(unwrappedListener) === -1 &&\n            unwrappedListener.call(node, eventObj)\n          );\n        }\n      });\n    }\n  }\n}\n\nfunction copyDomProperties(element: Element | null, properties: {[name: string]: string}): void {\n  if (element) {\n    // Skip own properties (as those are patched)\n    let obj = Object.getPrototypeOf(element);\n    const NodePrototype: any = Node.prototype;\n    while (obj !== null && obj !== NodePrototype) {\n      const descriptors = Object.getOwnPropertyDescriptors(obj);\n      for (let key in descriptors) {\n        if (!key.startsWith('__') && !key.startsWith('on')) {\n          // don't include properties starting with `__` and `on`.\n          // `__` are patched values which should not be included.\n          // `on` are listeners which also should not be included.\n          const value = (element as any)[key];\n          if (isPrimitiveValue(value)) {\n            properties[key] = value;\n          }\n        }\n      }\n      obj = Object.getPrototypeOf(obj);\n    }\n  }\n}\n\nfunction isPrimitiveValue(value: any): boolean {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'boolean' ||\n    typeof value === 'number' ||\n    value === null\n  );\n}\n\n/**\n * Walk the TNode tree to find matches for the predicate.\n *\n * @param parentElement the element from which the walk is started\n * @param predicate the predicate to match\n * @param matches the list of positive matches\n * @param elementsOnly whether only elements should be searched\n */\nfunction _queryAll(\n  parentElement: DebugElement,\n  predicate: Predicate<DebugElement>,\n  matches: DebugElement[],\n  elementsOnly: true,\n): void;\nfunction _queryAll(\n  parentElement: DebugElement,\n  predicate: Predicate<DebugNode>,\n  matches: DebugNode[],\n  elementsOnly: false,\n): void;\nfunction _queryAll(\n  parentElement: DebugElement,\n  predicate: Predicate<DebugElement> | Predicate<DebugNode>,\n  matches: DebugElement[] | DebugNode[],\n  elementsOnly: boolean,\n) {\n  const context = getLContext(parentElement.nativeNode)!;\n  const lView = context ? context.lView : null;\n  if (lView !== null) {\n    const parentTNode = lView[TVIEW].data[context.nodeIndex] as TNode;\n    _queryNodeChildren(\n      parentTNode,\n      lView,\n      predicate,\n      matches,\n      elementsOnly,\n      parentElement.nativeNode,\n    );\n  } else {\n    // If the context is null, then `parentElement` was either created with Renderer2 or native DOM\n    // APIs.\n    _queryNativeNodeDescendants(parentElement.nativeNode, predicate, matches, elementsOnly);\n  }\n}\n\n/**\n * Recursively match the current TNode against the predicate, and goes on with the next ones.\n *\n * @param tNode the current TNode\n * @param lView the LView of this TNode\n * @param predicate the predicate to match\n * @param matches the list of positive matches\n * @param elementsOnly whether only elements should be searched\n * @param rootNativeNode the root native node on which predicate should not be matched\n */\nfunction _queryNodeChildren(\n  tNode: TNode,\n  lView: LView,\n  predicate: Predicate<DebugElement> | Predicate<DebugNode>,\n  matches: DebugElement[] | DebugNode[],\n  elementsOnly: boolean,\n  rootNativeNode: any,\n) {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const nativeNode = getNativeByTNodeOrNull(tNode, lView);\n  // For each type of TNode, specific logic is executed.\n  if (tNode.type & (TNodeType.AnyRNode | TNodeType.ElementContainer)) {\n    // Case 1: the TNode is an element\n    // The native node has to be checked.\n    _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);\n    if (isComponentHost(tNode)) {\n      // If the element is the host of a component, then all nodes in its view have to be processed.\n      // Note: the component's content (tNode.child) will be processed from the insertion points.\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      if (componentView && componentView[TVIEW].firstChild) {\n        _queryNodeChildren(\n          componentView[TVIEW].firstChild!,\n          componentView,\n          predicate,\n          matches,\n          elementsOnly,\n          rootNativeNode,\n        );\n      }\n    } else {\n      if (tNode.child) {\n        // Otherwise, its children have to be processed.\n        _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);\n      }\n\n      // We also have to query the DOM directly in order to catch elements inserted through\n      // Renderer2. Note that this is __not__ optimal, because we're walking similar trees multiple\n      // times. ViewEngine could do it more efficiently, because all the insertions go through\n      // Renderer2, however that's not the case in Ivy. This approach is being used because:\n      // 1. Matching the ViewEngine behavior would mean potentially introducing a dependency\n      //    from `Renderer2` to Ivy which could bring Ivy code into ViewEngine.\n      // 2. It allows us to capture nodes that were inserted directly via the DOM.\n      nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);\n    }\n    // In all cases, if a dynamic container exists for this node, each view inside it has to be\n    // processed.\n    const nodeOrContainer = lView[tNode.index];\n    if (isLContainer(nodeOrContainer)) {\n      _queryNodeChildrenInContainer(\n        nodeOrContainer,\n        predicate,\n        matches,\n        elementsOnly,\n        rootNativeNode,\n      );\n    }\n  } else if (tNode.type & TNodeType.Container) {\n    // Case 2: the TNode is a container\n    // The native node has to be checked.\n    const lContainer = lView[tNode.index];\n    _addQueryMatch(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode);\n    // Each view inside the container has to be processed.\n    _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode);\n  } else if (tNode.type & TNodeType.Projection) {\n    // Case 3: the TNode is a projection insertion point (i.e. a <ng-content>).\n    // The nodes projected at this location all need to be processed.\n    const componentView = lView![DECLARATION_COMPONENT_VIEW];\n    const componentHost = componentView[T_HOST] as TElementNode;\n    const head: TNode | null = (componentHost.projection as (TNode | null)[])[\n      tNode.projection as number\n    ];\n\n    if (Array.isArray(head)) {\n      for (let nativeNode of head) {\n        _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);\n      }\n    } else if (head) {\n      const nextLView = componentView[PARENT]! as LView;\n      const nextTNode = nextLView[TVIEW].data[head.index] as TNode;\n      _queryNodeChildren(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);\n    }\n  } else if (tNode.child) {\n    // Case 4: the TNode is a view.\n    _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);\n  }\n\n  // We don't want to go to the next sibling of the root node.\n  if (rootNativeNode !== nativeNode) {\n    // To determine the next node to be processed, we need to use the next or the projectionNext\n    // link, depending on whether the current node has been projected.\n    const nextTNode = tNode.flags & TNodeFlags.isProjected ? tNode.projectionNext : tNode.next;\n    if (nextTNode) {\n      _queryNodeChildren(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);\n    }\n  }\n}\n\n/**\n * Process all TNodes in a given container.\n *\n * @param lContainer the container to be processed\n * @param predicate the predicate to match\n * @param matches the list of positive matches\n * @param elementsOnly whether only elements should be searched\n * @param rootNativeNode the root native node on which predicate should not be matched\n */\nfunction _queryNodeChildrenInContainer(\n  lContainer: LContainer,\n  predicate: Predicate<DebugElement> | Predicate<DebugNode>,\n  matches: DebugElement[] | DebugNode[],\n  elementsOnly: boolean,\n  rootNativeNode: any,\n) {\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const childView = lContainer[i] as LView;\n    const firstChild = childView[TVIEW].firstChild;\n    if (firstChild) {\n      _queryNodeChildren(firstChild, childView, predicate, matches, elementsOnly, rootNativeNode);\n    }\n  }\n}\n\n/**\n * Match the current native node against the predicate.\n *\n * @param nativeNode the current native node\n * @param predicate the predicate to match\n * @param matches the list of positive matches\n * @param elementsOnly whether only elements should be searched\n * @param rootNativeNode the root native node on which predicate should not be matched\n */\nfunction _addQueryMatch(\n  nativeNode: any,\n  predicate: Predicate<DebugElement> | Predicate<DebugNode>,\n  matches: DebugElement[] | DebugNode[],\n  elementsOnly: boolean,\n  rootNativeNode: any,\n) {\n  if (rootNativeNode !== nativeNode) {\n    const debugNode = getDebugNode(nativeNode);\n    if (!debugNode) {\n      return;\n    }\n    // Type of the \"predicate and \"matches\" array are set based on the value of\n    // the \"elementsOnly\" parameter. TypeScript is not able to properly infer these\n    // types with generics, so we manually cast the parameters accordingly.\n    if (\n      elementsOnly &&\n      debugNode instanceof DebugElement &&\n      predicate(debugNode) &&\n      matches.indexOf(debugNode) === -1\n    ) {\n      matches.push(debugNode);\n    } else if (\n      !elementsOnly &&\n      (predicate as Predicate<DebugNode>)(debugNode) &&\n      (matches as DebugNode[]).indexOf(debugNode) === -1\n    ) {\n      (matches as DebugNode[]).push(debugNode);\n    }\n  }\n}\n\n/**\n * Match all the descendants of a DOM node against a predicate.\n *\n * @param nativeNode the current native node\n * @param predicate the predicate to match\n * @param matches the list where matches are stored\n * @param elementsOnly whether only elements should be searched\n */\nfunction _queryNativeNodeDescendants(\n  parentNode: any,\n  predicate: Predicate<DebugElement> | Predicate<DebugNode>,\n  matches: DebugElement[] | DebugNode[],\n  elementsOnly: boolean,\n) {\n  const nodes = parentNode.childNodes;\n  const length = nodes.length;\n\n  for (let i = 0; i < length; i++) {\n    const node = nodes[i];\n    const debugNode = getDebugNode(node);\n\n    if (debugNode) {\n      if (\n        elementsOnly &&\n        debugNode instanceof DebugElement &&\n        predicate(debugNode) &&\n        matches.indexOf(debugNode) === -1\n      ) {\n        matches.push(debugNode);\n      } else if (\n        !elementsOnly &&\n        (predicate as Predicate<DebugNode>)(debugNode) &&\n        (matches as DebugNode[]).indexOf(debugNode) === -1\n      ) {\n        (matches as DebugNode[]).push(debugNode);\n      }\n\n      _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);\n    }\n  }\n}\n\n/**\n * Iterates through the property bindings for a given node and generates\n * a map of property names to values. This map only contains property bindings\n * defined in templates, not in host bindings.\n */\nfunction collectPropertyBindings(\n  properties: {[key: string]: string},\n  tNode: TNode,\n  lView: LView,\n  tData: TData,\n): void {\n  let bindingIndexes = tNode.propertyBindings;\n\n  if (bindingIndexes !== null) {\n    for (let i = 0; i < bindingIndexes.length; i++) {\n      const bindingIndex = bindingIndexes[i];\n      const propMetadata = tData[bindingIndex] as string;\n      const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);\n      const propertyName = metadataParts[0];\n      if (metadataParts.length > 1) {\n        let value = metadataParts[1];\n        for (let j = 1; j < metadataParts.length - 1; j++) {\n          value += renderStringify(lView[bindingIndex + j - 1]) + metadataParts[j + 1];\n        }\n        properties[propertyName] = value;\n      } else {\n        properties[propertyName] = lView[bindingIndex];\n      }\n    }\n  }\n}\n\n// Need to keep the nodes in a global Map so that multiple angular apps are supported.\nconst _nativeNodeToDebugNode = new Map<any, DebugNode>();\n\nconst NG_DEBUG_PROPERTY = '__ng_debug__';\n\n/**\n * @publicApi\n */\nexport function getDebugNode(nativeNode: any): DebugNode | null {\n  if (nativeNode instanceof Node) {\n    if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {\n      (nativeNode as any)[NG_DEBUG_PROPERTY] =\n        nativeNode.nodeType == Node.ELEMENT_NODE\n          ? new DebugElement(nativeNode as Element)\n          : new DebugNode(nativeNode);\n    }\n    return (nativeNode as any)[NG_DEBUG_PROPERTY];\n  }\n  return null;\n}\n\nexport function getAllDebugNodes(): DebugNode[] {\n  return Array.from(_nativeNodeToDebugNode.values());\n}\n\nexport function indexDebugNode(node: DebugNode) {\n  _nativeNodeToDebugNode.set(node.nativeNode, node);\n}\n\nexport function removeDebugNodeFromIndex(node: DebugNode) {\n  _nativeNodeToDebugNode.delete(node.nativeNode);\n}\n\n/**\n * A boolean-valued function over a value, possibly including context information\n * regarding that value's position in an array.\n *\n * @publicApi\n */\nexport type Predicate<T> = (value: T) => boolean;\n"]}