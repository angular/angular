{"version":3,"file":"zoneless_scheduling_impl.js","sourceRoot":"","sources":["zoneless_scheduling_impl.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Subscription} from 'rxjs';\n\nimport {ApplicationRef, ApplicationRefDirtyFlags} from '../../application/application_ref';\nimport {Injectable} from '../../di/injectable';\nimport {inject} from '../../di/injector_compatibility';\nimport {EnvironmentProviders, Provider} from '../../di/interface/provider';\nimport {makeEnvironmentProviders} from '../../di/provider_collection';\nimport {RuntimeError, RuntimeErrorCode, formatRuntimeError} from '../../errors';\nimport {PendingTasksInternal} from '../../pending_tasks_internal';\nimport {\n  scheduleCallbackWithMicrotask,\n  scheduleCallbackWithRafRace,\n} from '../../util/callback_scheduler';\nimport {performanceMarkFeature} from '../../util/performance';\nimport {NgZone, NgZonePrivate, NoopNgZone, angularZoneInstanceIdProperty} from '../../zone/ng_zone';\n\nimport {\n  ChangeDetectionScheduler,\n  NotificationSource,\n  PROVIDED_ZONELESS,\n  SCHEDULE_IN_ROOT_ZONE,\n  ZONELESS_ENABLED,\n} from './zoneless_scheduling';\nimport {TracingService} from '../../application/tracing';\nimport {INTERNAL_APPLICATION_ERROR_HANDLER} from '../../error_handler';\n\nconst CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;\nlet consecutiveMicrotaskNotifications = 0;\nlet stackFromLastFewNotifications: string[] = [];\n\nfunction trackMicrotaskNotificationForDebugging() {\n  consecutiveMicrotaskNotifications++;\n  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {\n    const stack = new Error().stack;\n    if (stack) {\n      stackFromLastFewNotifications.push(stack);\n    }\n  }\n\n  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INFINITE_CHANGE_DETECTION,\n      'Angular could not stabilize because there were endless change notifications within the browser event loop. ' +\n        'The stack from the last several notifications: \\n' +\n        stackFromLastFewNotifications.join('\\n'),\n    );\n  }\n}\n\n@Injectable({providedIn: 'root'})\nexport class ChangeDetectionSchedulerImpl implements ChangeDetectionScheduler {\n  private readonly applicationErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n  private readonly appRef = inject(ApplicationRef);\n  private readonly taskService = inject(PendingTasksInternal);\n  private readonly ngZone = inject(NgZone);\n  private readonly zonelessEnabled = inject(ZONELESS_ENABLED);\n  private readonly tracing = inject(TracingService, {optional: true});\n  private readonly zoneIsDefined = typeof Zone !== 'undefined' && !!Zone.root.run;\n  private readonly schedulerTickApplyArgs = [{data: {'__scheduler_tick__': true}}];\n  private readonly subscriptions = new Subscription();\n  private readonly angularZoneId = this.zoneIsDefined\n    ? (this.ngZone as NgZonePrivate)._inner?.get(angularZoneInstanceIdProperty)\n    : null;\n  private readonly scheduleInRootZone =\n    !this.zonelessEnabled &&\n    this.zoneIsDefined &&\n    (inject(SCHEDULE_IN_ROOT_ZONE, {optional: true}) ?? false);\n\n  private cancelScheduledCallback: null | (() => void) = null;\n  private useMicrotaskScheduler = false;\n  runningTick = false;\n  pendingRenderTaskId: number | null = null;\n\n  constructor() {\n    this.subscriptions.add(\n      this.appRef.afterTick.subscribe(() => {\n        // If the scheduler isn't running a tick but the application ticked, that means\n        // someone called ApplicationRef.tick manually. In this case, we should cancel\n        // any change detections that had been scheduled so we don't run an extra one.\n        if (!this.runningTick) {\n          this.cleanup();\n        }\n      }),\n    );\n    this.subscriptions.add(\n      this.ngZone.onUnstable.subscribe(() => {\n        // If the zone becomes unstable when we're not running tick (this happens from the zone.run),\n        // we should cancel any scheduled change detection here because at this point we\n        // know that the zone will stabilize at some point and run change detection itself.\n        if (!this.runningTick) {\n          this.cleanup();\n        }\n      }),\n    );\n  }\n\n  notify(source: NotificationSource): void {\n    if (!this.zonelessEnabled && source === NotificationSource.Listener) {\n      // When the notification comes from a listener, we skip the notification unless the\n      // application has enabled zoneless. Ideally, listeners wouldn't notify the scheduler at all\n      // automatically. We do not know that a developer made a change in the listener callback that\n      // requires an `ApplicationRef.tick` (synchronize templates / run render hooks). We do this\n      // only for an easier migration from OnPush components to zoneless. Because listeners are\n      // usually executed inside the Angular zone and listeners automatically call `markViewDirty`,\n      // developers never needed to manually use `ChangeDetectorRef.markForCheck` or some other API\n      // to make listener callbacks work correctly with `OnPush` components.\n      return;\n    }\n\n    switch (source) {\n      case NotificationSource.MarkAncestorsForTraversal: {\n        this.appRef.dirtyFlags |= ApplicationRefDirtyFlags.ViewTreeTraversal;\n        break;\n      }\n      case NotificationSource.DebugApplyChanges:\n      case NotificationSource.DeferBlockStateUpdate:\n      case NotificationSource.MarkForCheck:\n      case NotificationSource.Listener:\n      case NotificationSource.SetInput: {\n        this.appRef.dirtyFlags |= ApplicationRefDirtyFlags.ViewTreeCheck;\n        break;\n      }\n      case NotificationSource.CustomElement: {\n        // We use `ViewTreeTraversal` to ensure we refresh the element even if this is triggered\n        // during CD. In practice this is a no-op since the elements code also calls via a\n        // `markForRefresh()` API which sends `NotificationSource.MarkAncestorsForTraversal` anyway.\n        this.appRef.dirtyFlags |= ApplicationRefDirtyFlags.ViewTreeTraversal;\n        break;\n      }\n      case NotificationSource.RootEffect: {\n        this.appRef.dirtyFlags |= ApplicationRefDirtyFlags.RootEffects;\n        break;\n      }\n      case NotificationSource.ViewEffect: {\n        // This is technically a no-op, since view effects will also send a\n        // `MarkAncestorsForTraversal` notification. Still, we set this for logical consistency.\n        this.appRef.dirtyFlags |= ApplicationRefDirtyFlags.ViewTreeTraversal;\n        break;\n      }\n      case NotificationSource.PendingTaskRemoved: {\n        break;\n      }\n      case NotificationSource.ViewDetachedFromDOM:\n      case NotificationSource.ViewAttached:\n      case NotificationSource.RenderHook:\n      case NotificationSource.AsyncAnimationsLoaded:\n      default: {\n        // These notifications only schedule a tick but do not change whether we should refresh\n        // views. Instead, we only need to run render hooks unless another notification from the\n        // other set is also received before `tick` happens.\n        this.appRef.dirtyFlags |= ApplicationRefDirtyFlags.AfterRender;\n      }\n    }\n\n    // If not already defined, attempt to capture a tracing snapshot of this\n    // notification so that the resulting CD run can be attributed to the\n    // context which produced the notification.\n    this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null;\n\n    if (!this.shouldScheduleTick()) {\n      return;\n    }\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (this.useMicrotaskScheduler) {\n        trackMicrotaskNotificationForDebugging();\n      } else {\n        consecutiveMicrotaskNotifications = 0;\n        stackFromLastFewNotifications.length = 0;\n      }\n    }\n\n    const scheduleCallback = this.useMicrotaskScheduler\n      ? scheduleCallbackWithMicrotask\n      : scheduleCallbackWithRafRace;\n    this.pendingRenderTaskId = this.taskService.add();\n    if (this.scheduleInRootZone) {\n      this.cancelScheduledCallback = Zone.root.run(() => scheduleCallback(() => this.tick()));\n    } else {\n      this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() =>\n        scheduleCallback(() => this.tick()),\n      );\n    }\n  }\n\n  private shouldScheduleTick(): boolean {\n    if (this.appRef.destroyed) {\n      return false;\n    }\n    // already scheduled or running\n    if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {\n      return false;\n    }\n    // If we're inside the zone don't bother with scheduler. Zone will stabilize\n    // eventually and run change detection.\n    if (\n      !this.zonelessEnabled &&\n      this.zoneIsDefined &&\n      Zone.current.get(angularZoneInstanceIdProperty + this.angularZoneId)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Calls ApplicationRef._tick inside the `NgZone`.\n   *\n   * Calling `tick` directly runs change detection and cancels any change detection that had been\n   * scheduled previously.\n   *\n   * @param shouldRefreshViews Passed directly to `ApplicationRef._tick` and skips straight to\n   *     render hooks when `false`.\n   */\n  private tick(): void {\n    // When ngZone.run below exits, onMicrotaskEmpty may emit if the zone is\n    // stable. We want to prevent double ticking so we track whether the tick is\n    // already running and skip it if so.\n    if (this.runningTick || this.appRef.destroyed) {\n      return;\n    }\n\n    // If we reach the tick and there is no work to be done in ApplicationRef.tick,\n    // skip it altogether and clean up. There may be no work if, for example, the only\n    // event that notified the scheduler was the removal of a pending task.\n    if (this.appRef.dirtyFlags === ApplicationRefDirtyFlags.None) {\n      this.cleanup();\n      return;\n    }\n\n    // The scheduler used to pass \"whether to check views\" as a boolean flag instead of setting\n    // fine-grained dirtiness flags, and global checking was always used on the first pass. This\n    // created an interesting edge case: if a notification made a view dirty and then ticked via the\n    // scheduler (and not the zone) a global check was still performed.\n    //\n    // Ideally, this would not be the case, and only zone-based ticks would do global passes.\n    // However this is a breaking change and requires fixes in g3. Until this cleanup can be done,\n    // we add the `ViewTreeGlobal` flag to request a global check if any views are dirty in a\n    // scheduled tick (unless zoneless is enabled, in which case global checks aren't really a\n    // thing).\n    //\n    // TODO(alxhub): clean up and remove this workaround as a breaking change.\n    if (!this.zonelessEnabled && this.appRef.dirtyFlags & ApplicationRefDirtyFlags.ViewTreeAny) {\n      this.appRef.dirtyFlags |= ApplicationRefDirtyFlags.ViewTreeGlobal;\n    }\n\n    const task = this.taskService.add();\n    try {\n      this.ngZone.run(\n        () => {\n          this.runningTick = true;\n          this.appRef._tick();\n        },\n        undefined,\n        this.schedulerTickApplyArgs,\n      );\n    } catch (e: unknown) {\n      this.taskService.remove(task);\n      this.applicationErrorHandler(e);\n    } finally {\n      this.cleanup();\n    }\n    // If we're notified of a change within 1 microtask of running change\n    // detection, run another round in the same event loop. This allows code\n    // which uses Promise.resolve (see NgModel) to avoid\n    // ExpressionChanged...Error to still be reflected in a single browser\n    // paint, even if that spans multiple rounds of change detection.\n    this.useMicrotaskScheduler = true;\n    scheduleCallbackWithMicrotask(() => {\n      this.useMicrotaskScheduler = false;\n      this.taskService.remove(task);\n    });\n  }\n\n  ngOnDestroy() {\n    this.subscriptions.unsubscribe();\n    this.cleanup();\n  }\n\n  private cleanup() {\n    this.runningTick = false;\n    this.cancelScheduledCallback?.();\n    this.cancelScheduledCallback = null;\n    // If this is the last task, the service will synchronously emit a stable\n    // notification. If there is a subscriber that then acts in a way that\n    // tries to notify the scheduler again, we need to be able to respond to\n    // schedule a new change detection. Therefore, we should clear the task ID\n    // before removing it from the pending tasks (or the tasks service should\n    // not synchronously emit stable, similar to how Zone stableness only\n    // happens if it's still stable after a microtask).\n    if (this.pendingRenderTaskId !== null) {\n      const taskId = this.pendingRenderTaskId;\n      this.pendingRenderTaskId = null;\n      this.taskService.remove(taskId);\n    }\n  }\n}\n\n/**\n * Provides change detection without ZoneJS for the application bootstrapped using\n * `bootstrapApplication`.\n *\n * This function allows you to configure the application to not use the state/state changes of\n * ZoneJS to schedule change detection in the application. This will work when ZoneJS is not present\n * on the page at all or if it exists because something else is using it (either another Angular\n * application which uses ZoneJS for scheduling or some other library that relies on ZoneJS).\n *\n * This can also be added to the `TestBed` providers to configure the test environment to more\n * closely match production behavior. This will help give higher confidence that components are\n * compatible with zoneless change detection.\n *\n * ZoneJS uses browser events to trigger change detection. When using this provider, Angular will\n * instead use Angular APIs to schedule change detection. These APIs include:\n *\n * - `ChangeDetectorRef.markForCheck`\n * - `ComponentRef.setInput`\n * - updating a signal that is read in a template\n * - when bound host or template listeners are triggered\n * - attaching a view that was marked dirty by one of the above\n * - removing a view\n * - registering a render hook (templates are only refreshed if render hooks do one of the above)\n *\n * @usageNotes\n * ```ts\n * bootstrapApplication(MyApp, {providers: [\n *   provideZonelessChangeDetection(),\n * ]});\n * ```\n *\n * @publicApi 20.2\n *\n * @see {@link /api/platform-browser/bootstrapApplication bootstrapApplication}\n */\nexport function provideZonelessChangeDetection(): EnvironmentProviders {\n  performanceMarkFeature('NgZoneless');\n\n  if ((typeof ngDevMode === 'undefined' || ngDevMode) && typeof Zone !== 'undefined' && Zone) {\n    const message = formatRuntimeError(\n      RuntimeErrorCode.UNEXPECTED_ZONEJS_PRESENT_IN_ZONELESS_MODE,\n      `The application is using zoneless change detection, but is still loading Zone.js. ` +\n        `Consider removing Zone.js to get the full benefits of zoneless. ` +\n        `In applications using the Angular CLI, Zone.js is typically included in the \"polyfills\" section of the angular.json file.`,\n    );\n    console.warn(message);\n  }\n\n  return makeEnvironmentProviders([\n    ...provideZonelessChangeDetectionInternal(),\n    typeof ngDevMode === 'undefined' || ngDevMode\n      ? [{provide: PROVIDED_ZONELESS, useValue: true}]\n      : [],\n  ]);\n}\n\nexport function provideZonelessChangeDetectionInternal(): Provider[] {\n  return [\n    {provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl},\n    {provide: NgZone, useClass: NoopNgZone},\n    {provide: ZONELESS_ENABLED, useValue: true},\n  ];\n}\n"]}