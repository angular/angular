{"version":3,"file":"change_detector_ref.js","sourceRoot":"","sources":["change_detector_ref.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAIH,OAAO,EAAC,eAAe,EAAC,MAAM,mCAAmC,CAAC;AAClE,OAAO,EAAC,0BAA0B,EAAQ,MAAM,4BAA4B,CAAC;AAC7E,OAAO,EAAC,eAAe,EAAE,QAAQ,EAAC,MAAM,kBAAkB,CAAC;AAC3D,OAAO,EAAC,wBAAwB,EAAC,MAAM,4BAA4B,CAAC;AACpE,OAAO,EAAC,OAAO,EAAC,MAAM,qBAAqB,CAAC;AAE5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2CG;AACH,MAAM,OAAgB,iBAAiB;;AA4DrC;;;GAGG;AACI,mCAAiB,GACtB,uBAAuB,CAAC;AAG5B,qDAAqD;AACrD,MAAM,UAAU,uBAAuB,CAAC,KAA0B;IAChE,OAAO,aAAa,CAClB,eAAe,EAAG,EAClB,QAAQ,EAAE,EACV,CAAC,KAAK,uCAA8B,CAAC,yCAAgC,CACtE,CAAC;AACJ,CAAC;AAED;;;;;;;GAOG;AACH,SAAS,aAAa,CAAC,KAAY,EAAE,KAAY,EAAE,MAAe;IAChE,IAAI,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;QACtC,qEAAqE;QACrE,iFAAiF;QACjF,MAAM,aAAa,GAAG,wBAAwB,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,YAAY;QAChF,OAAO,IAAI,OAAO,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;IACnD,CAAC;SAAM,IACL,KAAK,CAAC,IAAI;QACV,CAAC,4DAA2C,yBAAgB,qCAA2B,CAAC,EACxF,CAAC;QACD,2EAA2E;QAC3E,yFAAyF;QACzF,MAAM,iBAAiB,GAAG,KAAK,CAAC,0BAA0B,CAAC,CAAC,CAAC,UAAU;QACvE,OAAO,IAAI,OAAO,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;IAC/C,CAAC;IACD,OAAO,IAAK,CAAC;AACf,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InternalInjectFlags} from '../di/interface/injector';\nimport {TNode, TNodeType} from '../render3/interfaces/node';\nimport {isComponentHost} from '../render3/interfaces/type_checks';\nimport {DECLARATION_COMPONENT_VIEW, LView} from '../render3/interfaces/view';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {getComponentLViewByIndex} from '../render3/util/view_utils';\nimport {ViewRef} from '../render3/view_ref';\n\n/**\n * Base class that provides change detection functionality.\n * A change-detection tree collects all views that are to be checked for changes.\n * Use the methods to add and remove views from the tree, initiate change-detection,\n * and explicitly mark views as _dirty_, meaning that they have changed and need to be re-rendered.\n *\n * @see [Using change detection hooks](guide/components/lifecycle#using-change-detection-hooks)\n * @see [Defining custom change detection](guide/components/lifecycle#defining-custom-change-detection)\n *\n * @usageNotes\n *\n * The following examples demonstrate how to modify default change-detection behavior\n * to perform explicit detection when needed.\n *\n * ### Use `markForCheck()` with `CheckOnce` strategy\n *\n * The following example sets the `OnPush` change-detection strategy for a component\n * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\n * after an interval.\n *\n * {@example core/ts/change_detect/change-detection.ts region='mark-for-check'}\n *\n * ### Detach change detector to limit how often check occurs\n *\n * The following example defines a component with a large list of read-only data\n * that is expected to change constantly, many times per second.\n * To improve performance, we want to check and update the list\n * less often than the changes actually occur. To do that, we detach\n * the component's change detector and perform an explicit local check every five seconds.\n *\n * {@example core/ts/change_detect/change-detection.ts region='detach'}\n *\n *\n * ### Reattaching a detached component\n *\n * The following example creates a component displaying live data.\n * The component detaches its change detector from the main change detector tree\n * when the `live` property is set to false, and reattaches it when the property\n * becomes true.\n *\n * {@example core/ts/change_detect/change-detection.ts region='reattach'}\n *\n * @publicApi\n */\nexport abstract class ChangeDetectorRef {\n  /**\n   * When a view uses the {@link ChangeDetectionStrategy#OnPush} (checkOnce)\n   * change detection strategy, explicitly marks the view as changed so that\n   * it can be checked again.\n   *\n   * Components are normally marked as dirty (in need of rerendering) when inputs\n   * have changed or events have fired in the view. Call this method to ensure that\n   * a component is checked even if these triggers have not occurred.\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   */\n  abstract markForCheck(): void;\n\n  /**\n   * Detaches this view from the change-detection tree.\n   * A detached view is  not checked until it is reattached.\n   * Use in combination with `detectChanges()` to implement local change detection checks.\n   *\n   * Detached views are not checked during change detection runs until they are\n   * re-attached, even if they are marked as dirty.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   */\n  abstract detach(): void;\n\n  /**\n   * Checks this view and its children. Use in combination with {@link ChangeDetectorRef#detach}\n   * to implement local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   */\n  abstract detectChanges(): void;\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * Use in development mode to verify that running change detection doesn't introduce\n   * other changes. Calling it in production mode is a noop.\n   *\n   * @deprecated This is a test-only API that does not have a place in production interface.\n   * `checkNoChanges` is already part of an `ApplicationRef` tick when the app is running in dev\n   * mode. For more granular `checkNoChanges` validation, use `ComponentFixture`.\n   */\n  abstract checkNoChanges(): void;\n\n  /**\n   * Re-attaches the previously detached view to the change detection tree.\n   * Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   */\n  abstract reattach(): void;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: (flags: InternalInjectFlags) => ChangeDetectorRef =\n    injectChangeDetectorRef;\n}\n\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\nexport function injectChangeDetectorRef(flags: InternalInjectFlags): ChangeDetectorRef {\n  return createViewRef(\n    getCurrentTNode()!,\n    getLView(),\n    (flags & InternalInjectFlags.ForPipe) === InternalInjectFlags.ForPipe,\n  );\n}\n\n/**\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\n *\n * @param tNode The node that is requesting a ChangeDetectorRef\n * @param lView The view to which the node belongs\n * @param isPipe Whether the view is being injected into a pipe.\n * @returns The ChangeDetectorRef to use\n */\nfunction createViewRef(tNode: TNode, lView: LView, isPipe: boolean): ChangeDetectorRef {\n  if (isComponentHost(tNode) && !isPipe) {\n    // The LView represents the location where the component is declared.\n    // Instead we want the LView for the component View and so we need to look it up.\n    const componentView = getComponentLViewByIndex(tNode.index, lView); // look down\n    return new ViewRef(componentView, componentView);\n  } else if (\n    tNode.type &\n    (TNodeType.AnyRNode | TNodeType.AnyContainer | TNodeType.Icu | TNodeType.LetDeclaration)\n  ) {\n    // The LView represents the location where the injection is requested from.\n    // We need to locate the containing LView (in case where the `lView` is an embedded view)\n    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW]; // look up\n    return new ViewRef(hostComponentView, lView);\n  }\n  return null!;\n}\n"]}