{"version":3,"file":"i18n.js","sourceRoot":"","sources":["i18n.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injector} from '../di';\nimport {isRootTemplateMessage} from '../render3/i18n/i18n_util';\nimport {createIcuIterator} from '../render3/i18n/i18n_icu_container_visitor';\nimport {I18nNode, I18nNodeKind, I18nPlaceholderType, TI18n, TIcu} from '../render3/interfaces/i18n';\nimport {isTNodeShape, TNode, TNodeType} from '../render3/interfaces/node';\nimport type {Renderer} from '../render3/interfaces/renderer';\nimport type {RNode} from '../render3/interfaces/renderer_dom';\nimport {HEADER_OFFSET, HYDRATION, LView, RENDERER, TView, TVIEW} from '../render3/interfaces/view';\nimport {getFirstNativeNode} from '../render3/node_manipulation';\nimport {nativeRemoveNode} from '../render3/dom_node_manipulation';\nimport {unwrapRNode} from '../render3/util/view_utils';\nimport {assertDefined, assertNotEqual} from '../util/assert';\n\nimport type {HydrationContext} from './annotate';\nimport {DehydratedIcuData, DehydratedView, I18N_DATA} from './interfaces';\nimport {isDisconnectedRNode, locateNextRNode, tryLocateRNodeByPath} from './node_lookup_utils';\nimport {isI18nInSkipHydrationBlock} from './skip_hydration';\nimport {IS_I18N_HYDRATION_ENABLED} from './tokens';\nimport {\n  getNgContainerSize,\n  initDisconnectedNodes,\n  isDisconnectedNode,\n  isSerializedElementContainer,\n  processTextNodeBeforeSerialization,\n} from './utils';\n\nlet _isI18nHydrationSupportEnabled = false;\n\nlet _prepareI18nBlockForHydrationImpl: typeof prepareI18nBlockForHydrationImpl = () => {\n  // noop unless `enablePrepareI18nBlockForHydrationImpl` is invoked.\n};\n\nexport function setIsI18nHydrationSupportEnabled(enabled: boolean) {\n  _isI18nHydrationSupportEnabled = enabled;\n}\n\nexport function isI18nHydrationSupportEnabled() {\n  return _isI18nHydrationSupportEnabled;\n}\n\n/**\n * Prepares an i18n block and its children, located at the given\n * view and instruction index, for hydration.\n *\n * @param lView lView with the i18n block\n * @param index index of the i18n block in the lView\n * @param parentTNode TNode of the parent of the i18n block\n * @param subTemplateIndex sub-template index, or -1 for the main template\n */\nexport function prepareI18nBlockForHydration(\n  lView: LView,\n  index: number,\n  parentTNode: TNode | null,\n  subTemplateIndex: number,\n): void {\n  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);\n}\n\nexport function enablePrepareI18nBlockForHydrationImpl() {\n  _prepareI18nBlockForHydrationImpl = prepareI18nBlockForHydrationImpl;\n}\n\nexport function isI18nHydrationEnabled(injector?: Injector) {\n  injector = injector ?? inject(Injector);\n  return injector.get(IS_I18N_HYDRATION_ENABLED, false);\n}\n\n/**\n * Collects, if not already cached, all of the indices in the\n * given TView which are children of an i18n block.\n *\n * Since i18n blocks don't introduce a parent TNode, this is necessary\n * in order to determine which indices in a LView are translated.\n */\nexport function getOrComputeI18nChildren(\n  tView: TView,\n  context: HydrationContext,\n): Set<number> | null {\n  let i18nChildren = context.i18nChildren.get(tView);\n  if (i18nChildren === undefined) {\n    i18nChildren = collectI18nChildren(tView);\n    context.i18nChildren.set(tView, i18nChildren);\n  }\n  return i18nChildren;\n}\n\nfunction collectI18nChildren(tView: TView): Set<number> | null {\n  const children = new Set<number>();\n\n  function collectI18nViews(node: I18nNode) {\n    children.add(node.index);\n\n    switch (node.kind) {\n      case I18nNodeKind.ELEMENT:\n      case I18nNodeKind.PLACEHOLDER: {\n        for (const childNode of node.children) {\n          collectI18nViews(childNode);\n        }\n        break;\n      }\n\n      case I18nNodeKind.ICU: {\n        for (const caseNodes of node.cases) {\n          for (const caseNode of caseNodes) {\n            collectI18nViews(caseNode);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  // Traverse through the AST of each i18n block in the LView,\n  // and collect every instruction index.\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    const tI18n = tView.data[i] as TI18n | undefined;\n    if (!tI18n || !tI18n.ast) {\n      continue;\n    }\n\n    for (const node of tI18n.ast) {\n      collectI18nViews(node);\n    }\n  }\n\n  return children.size === 0 ? null : children;\n}\n\n/**\n * Resulting data from serializing an i18n block.\n */\nexport interface SerializedI18nBlock {\n  /**\n   * A queue of active ICU cases from a depth-first traversal\n   * of the i18n AST. This is serialized to the client in order\n   * to correctly associate DOM nodes with i18n nodes during\n   * hydration.\n   */\n  caseQueue: Array<number>;\n\n  /**\n   * A set of indices in the lView of the block for nodes\n   * that are disconnected from the DOM. In i18n, this can\n   * happen when using content projection but some nodes are\n   * not selected by an <ng-content />.\n   */\n  disconnectedNodes: Set<number>;\n\n  /**\n   * A set of indices in the lView of the block for nodes\n   * considered \"disjoint\", indicating that we need to serialize\n   * a path to the node in order to hydrate it.\n   *\n   * A node is considered disjoint when its RNode does not\n   * directly follow the RNode of the previous i18n node, for\n   * example, because of content projection.\n   */\n  disjointNodes: Set<number>;\n}\n\n/**\n * Attempts to serialize i18n data for an i18n block, located at\n * the given view and instruction index.\n *\n * @param lView lView with the i18n block\n * @param index index of the i18n block in the lView\n * @param context the hydration context\n * @returns the i18n data, or null if there is no relevant data\n */\nexport function trySerializeI18nBlock(\n  lView: LView,\n  index: number,\n  context: HydrationContext,\n): SerializedI18nBlock | null {\n  if (!context.isI18nHydrationEnabled) {\n    return null;\n  }\n\n  const tView = lView[TVIEW];\n  const tI18n = tView.data[index] as TI18n | undefined;\n  if (!tI18n || !tI18n.ast) {\n    return null;\n  }\n\n  const parentTNode = tView.data[tI18n.parentTNodeIndex] as TNode;\n  if (parentTNode && isI18nInSkipHydrationBlock(parentTNode)) {\n    return null;\n  }\n\n  const serializedI18nBlock: SerializedI18nBlock = {\n    caseQueue: [],\n    disconnectedNodes: new Set(),\n    disjointNodes: new Set(),\n  };\n  serializeI18nBlock(lView, serializedI18nBlock, context, tI18n.ast);\n\n  return serializedI18nBlock.caseQueue.length === 0 &&\n    serializedI18nBlock.disconnectedNodes.size === 0 &&\n    serializedI18nBlock.disjointNodes.size === 0\n    ? null\n    : serializedI18nBlock;\n}\n\nfunction serializeI18nBlock(\n  lView: LView,\n  serializedI18nBlock: SerializedI18nBlock,\n  context: HydrationContext,\n  nodes: I18nNode[],\n): Node | null {\n  let prevRNode = null;\n  for (const node of nodes) {\n    const nextRNode = serializeI18nNode(lView, serializedI18nBlock, context, node);\n    if (nextRNode) {\n      if (isDisjointNode(prevRNode, nextRNode)) {\n        serializedI18nBlock.disjointNodes.add(node.index - HEADER_OFFSET);\n      }\n      prevRNode = nextRNode;\n    }\n  }\n  return prevRNode;\n}\n\n/**\n * Helper to determine whether the given nodes are \"disjoint\".\n *\n * The i18n hydration process walks through the DOM and i18n nodes\n * at the same time. It expects the sibling DOM node of the previous\n * i18n node to be the first node of the next i18n node.\n *\n * In cases of content projection, this won't always be the case. So\n * when we detect that, we mark the node as \"disjoint\", ensuring that\n * we will serialize the path to the node. This way, when we hydrate the\n * i18n node, we will be able to find the correct place to start.\n */\nfunction isDisjointNode(prevNode: Node | null, nextNode: Node) {\n  return prevNode && prevNode.nextSibling !== nextNode;\n}\n\n/**\n * Process the given i18n node for serialization.\n * Returns the first RNode for the i18n node to begin hydration.\n */\nfunction serializeI18nNode(\n  lView: LView,\n  serializedI18nBlock: SerializedI18nBlock,\n  context: HydrationContext,\n  node: I18nNode,\n): Node | null {\n  const maybeRNode = unwrapRNode(lView[node.index]!);\n  if (!maybeRNode || isDisconnectedRNode(maybeRNode)) {\n    serializedI18nBlock.disconnectedNodes.add(node.index - HEADER_OFFSET);\n    return null;\n  }\n\n  const rNode = maybeRNode as Node;\n  switch (node.kind) {\n    case I18nNodeKind.TEXT: {\n      processTextNodeBeforeSerialization(context, rNode);\n      break;\n    }\n\n    case I18nNodeKind.ELEMENT:\n    case I18nNodeKind.PLACEHOLDER: {\n      serializeI18nBlock(lView, serializedI18nBlock, context, node.children);\n      break;\n    }\n\n    case I18nNodeKind.ICU: {\n      const currentCase = lView[node.currentCaseLViewIndex] as number | null;\n      if (currentCase != null) {\n        // i18n uses a negative value to signal a change to a new case, so we\n        // need to invert it to get the proper value.\n        const caseIdx = currentCase < 0 ? ~currentCase : currentCase;\n        serializedI18nBlock.caseQueue.push(caseIdx);\n        serializeI18nBlock(lView, serializedI18nBlock, context, node.cases[caseIdx]);\n      }\n      break;\n    }\n  }\n\n  return getFirstNativeNodeForI18nNode(lView, node) as Node | null;\n}\n\n/**\n * Helper function to get the first native node to begin hydrating\n * the given i18n node.\n */\nfunction getFirstNativeNodeForI18nNode(lView: LView, node: I18nNode) {\n  const tView = lView[TVIEW];\n  const maybeTNode = tView.data[node.index];\n\n  if (isTNodeShape(maybeTNode)) {\n    // If the node is backed by an actual TNode, we can simply delegate.\n    return getFirstNativeNode(lView, maybeTNode);\n  } else if (node.kind === I18nNodeKind.ICU) {\n    // A nested ICU container won't have an actual TNode. In that case, we can use\n    // an iterator to find the first child.\n    const icuIterator = createIcuIterator(maybeTNode as TIcu, lView);\n    let rNode: RNode | null = icuIterator();\n\n    // If the ICU container has no nodes, then we use the ICU anchor as the node.\n    return rNode ?? unwrapRNode(lView[node.index]);\n  } else {\n    // Otherwise, the node is a text or trivial element in an ICU container,\n    // and we can just use the RNode directly.\n    return unwrapRNode(lView[node.index]) ?? null;\n  }\n}\n\n/**\n * Describes shared data available during the hydration process.\n */\ninterface I18nHydrationContext {\n  hydrationInfo: DehydratedView;\n  lView: LView;\n  i18nNodes: Map<number, RNode | null>;\n  disconnectedNodes: Set<number>;\n  caseQueue: number[];\n  dehydratedIcuData: Map<number, DehydratedIcuData>;\n}\n\n/**\n * Describes current hydration state.\n */\ninterface I18nHydrationState {\n  // The current node\n  currentNode: Node | null;\n\n  /**\n   * Whether the tree should be connected.\n   *\n   * During hydration, it can happen that we expect to have a\n   * current RNode, but we don't. In such cases, we still need\n   * to propagate the expectation to the corresponding LViews,\n   * so that the proper downstream error handling can provide\n   * the correct context for the error.\n   */\n  isConnected: boolean;\n}\n\nfunction setCurrentNode(state: I18nHydrationState, node: Node | null) {\n  state.currentNode = node;\n}\n\n/**\n * Marks the current RNode as the hydration root for the given\n * AST node.\n */\nfunction appendI18nNodeToCollection(\n  context: I18nHydrationContext,\n  state: I18nHydrationState,\n  astNode: I18nNode,\n) {\n  const noOffsetIndex = astNode.index - HEADER_OFFSET;\n  const {disconnectedNodes} = context;\n  const currentNode = state.currentNode;\n\n  if (state.isConnected) {\n    context.i18nNodes.set(noOffsetIndex, currentNode);\n\n    // We expect the node to be connected, so ensure that it\n    // is not in the set, regardless of whether we found it,\n    // so that the downstream error handling can provide the\n    // proper context.\n    disconnectedNodes.delete(noOffsetIndex);\n  } else {\n    disconnectedNodes.add(noOffsetIndex);\n  }\n\n  return currentNode;\n}\n\n/**\n * Skip over some sibling nodes during hydration.\n *\n * Note: we use this instead of `siblingAfter` as it's expected that\n * sometimes we might encounter null nodes. In those cases, we want to\n * defer to downstream error handling to provide proper context.\n */\nfunction skipSiblingNodes(state: I18nHydrationState, skip: number) {\n  let currentNode = state.currentNode;\n  for (let i = 0; i < skip; i++) {\n    if (!currentNode) {\n      break;\n    }\n    currentNode = currentNode?.nextSibling ?? null;\n  }\n  return currentNode;\n}\n\n/**\n * Fork the given state into a new state for hydrating children.\n */\nfunction forkHydrationState(state: I18nHydrationState, nextNode: Node | null) {\n  return {currentNode: nextNode, isConnected: state.isConnected};\n}\n\nfunction prepareI18nBlockForHydrationImpl(\n  lView: LView,\n  index: number,\n  parentTNode: TNode | null,\n  subTemplateIndex: number,\n) {\n  const hydrationInfo = lView[HYDRATION];\n  if (!hydrationInfo) {\n    return;\n  }\n\n  if (\n    !isI18nHydrationSupportEnabled() ||\n    (parentTNode &&\n      (isI18nInSkipHydrationBlock(parentTNode) ||\n        isDisconnectedNode(hydrationInfo, parentTNode.index - HEADER_OFFSET)))\n  ) {\n    return;\n  }\n\n  const tView = lView[TVIEW];\n  const tI18n = tView.data[index] as TI18n;\n  ngDevMode &&\n    assertDefined(tI18n, 'Expected i18n data to be present in a given TView slot during hydration');\n\n  function findHydrationRoot() {\n    if (isRootTemplateMessage(subTemplateIndex)) {\n      // This is the root of an i18n block. In this case, our hydration root will\n      // depend on where our parent TNode (i.e. the block with i18n applied) is\n      // in the DOM.\n      ngDevMode && assertDefined(parentTNode, 'Expected parent TNode while hydrating i18n root');\n      const rootNode = locateNextRNode(hydrationInfo!, tView, lView, parentTNode!) as Node;\n\n      // If this i18n block is attached to an <ng-container>, then we want to begin\n      // hydrating directly with the RNode. Otherwise, for a TNode with a physical DOM\n      // element, we want to recurse into the first child and begin there.\n      return parentTNode!.type & TNodeType.ElementContainer ? rootNode : rootNode.firstChild;\n    }\n\n    // This is a nested template in an i18n block. In this case, the entire view\n    // is translated, and part of a dehydrated view in a container. This means that\n    // we can simply begin hydration with the first dehydrated child.\n    return hydrationInfo?.firstChild as Node;\n  }\n\n  const currentNode = findHydrationRoot();\n  ngDevMode && assertDefined(currentNode, 'Expected root i18n node during hydration');\n\n  const disconnectedNodes = initDisconnectedNodes(hydrationInfo) ?? new Set();\n  const i18nNodes = (hydrationInfo.i18nNodes ??= new Map<number, RNode | null>());\n  const caseQueue = hydrationInfo.data[I18N_DATA]?.[index - HEADER_OFFSET] ?? [];\n  const dehydratedIcuData = (hydrationInfo.dehydratedIcuData ??= new Map<\n    number,\n    DehydratedIcuData\n  >());\n\n  collectI18nNodesFromDom(\n    {hydrationInfo, lView, i18nNodes, disconnectedNodes, caseQueue, dehydratedIcuData},\n    {currentNode, isConnected: true},\n    tI18n.ast,\n  );\n\n  // Nodes from inactive ICU cases should be considered disconnected. We track them above\n  // because they aren't (and shouldn't be) serialized. Since we may mutate or create a\n  // new set, we need to be sure to write the expected value back to the DehydratedView.\n  hydrationInfo.disconnectedNodes = disconnectedNodes.size === 0 ? null : disconnectedNodes;\n}\n\nfunction collectI18nNodesFromDom(\n  context: I18nHydrationContext,\n  state: I18nHydrationState,\n  nodeOrNodes: I18nNode | I18nNode[],\n) {\n  if (Array.isArray(nodeOrNodes)) {\n    let nextState = state;\n    for (const node of nodeOrNodes) {\n      // Whenever a node doesn't directly follow the previous RNode, it\n      // is given a path. We need to resume collecting nodes from that location\n      // until and unless we find another disjoint node.\n      const targetNode = tryLocateRNodeByPath(\n        context.hydrationInfo,\n        context.lView,\n        node.index - HEADER_OFFSET,\n      );\n      if (targetNode) {\n        nextState = forkHydrationState(state, targetNode as Node);\n      }\n      collectI18nNodesFromDom(context, nextState, node);\n    }\n  } else {\n    if (context.disconnectedNodes.has(nodeOrNodes.index - HEADER_OFFSET)) {\n      // i18n nodes can be considered disconnected if e.g. they were projected.\n      // In that case, we have to make sure to skip over them.\n      return;\n    }\n\n    switch (nodeOrNodes.kind) {\n      case I18nNodeKind.TEXT: {\n        // Claim a text node for hydration\n        const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);\n        setCurrentNode(state, currentNode?.nextSibling ?? null);\n        break;\n      }\n\n      case I18nNodeKind.ELEMENT: {\n        // Recurse into the current element's children...\n        collectI18nNodesFromDom(\n          context,\n          forkHydrationState(state, state.currentNode?.firstChild ?? null),\n          nodeOrNodes.children,\n        );\n\n        // And claim the parent element itself.\n        const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);\n        setCurrentNode(state, currentNode?.nextSibling ?? null);\n        break;\n      }\n\n      case I18nNodeKind.PLACEHOLDER: {\n        const noOffsetIndex = nodeOrNodes.index - HEADER_OFFSET;\n        const {hydrationInfo} = context;\n        const containerSize = getNgContainerSize(hydrationInfo, noOffsetIndex);\n\n        switch (nodeOrNodes.type) {\n          case I18nPlaceholderType.ELEMENT: {\n            // Hydration expects to find the head of the element.\n            const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);\n\n            // A TNode for the node may not yet if we're hydrating during the first pass,\n            // so use the serialized data to determine if this is an <ng-container>.\n            if (isSerializedElementContainer(hydrationInfo, noOffsetIndex)) {\n              // An <ng-container> doesn't have a physical DOM node, so we need to\n              // continue hydrating from siblings.\n              collectI18nNodesFromDom(context, state, nodeOrNodes.children);\n\n              // Skip over the anchor element. It will be claimed by the\n              // downstream container hydration.\n              const nextNode = skipSiblingNodes(state, 1);\n              setCurrentNode(state, nextNode);\n            } else {\n              // Non-container elements represent an actual node in the DOM, so we\n              // need to continue hydration with the children, and claim the node.\n              collectI18nNodesFromDom(\n                context,\n                forkHydrationState(state, state.currentNode?.firstChild ?? null),\n                nodeOrNodes.children,\n              );\n              setCurrentNode(state, currentNode?.nextSibling ?? null);\n\n              // Elements can also be the anchor of a view container, so there may\n              // be elements after this node that we need to skip.\n              if (containerSize !== null) {\n                // `+1` stands for an anchor node after all of the views in the container.\n                const nextNode = skipSiblingNodes(state, containerSize + 1);\n                setCurrentNode(state, nextNode);\n              }\n            }\n            break;\n          }\n\n          case I18nPlaceholderType.SUBTEMPLATE: {\n            ngDevMode &&\n              assertNotEqual(\n                containerSize,\n                null,\n                'Expected a container size while hydrating i18n subtemplate',\n              );\n\n            // Hydration expects to find the head of the template.\n            appendI18nNodeToCollection(context, state, nodeOrNodes);\n\n            // Skip over all of the template children, as well as the anchor\n            // node, since the template itself will handle them instead.\n            const nextNode = skipSiblingNodes(state, containerSize! + 1);\n            setCurrentNode(state, nextNode);\n            break;\n          }\n        }\n        break;\n      }\n\n      case I18nNodeKind.ICU: {\n        // If the current node is connected, we need to pop the next case from the\n        // queue, so that the active case is also considered connected.\n        const selectedCase = state.isConnected ? context.caseQueue.shift()! : null;\n        const childState = {currentNode: null, isConnected: false};\n\n        // We traverse through each case, even if it's not active,\n        // so that we correctly populate disconnected nodes.\n        for (let i = 0; i < nodeOrNodes.cases.length; i++) {\n          collectI18nNodesFromDom(\n            context,\n            i === selectedCase ? state : childState,\n            nodeOrNodes.cases[i],\n          );\n        }\n\n        if (selectedCase !== null) {\n          // ICUs represent a branching state, and the selected case could be different\n          // than what it was on the server. In that case, we need to be able to clean\n          // up the nodes from the original case. To do that, we store the selected case.\n          context.dehydratedIcuData.set(nodeOrNodes.index, {case: selectedCase, node: nodeOrNodes});\n        }\n\n        // Hydration expects to find the ICU anchor element.\n        const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);\n        setCurrentNode(state, currentNode?.nextSibling ?? null);\n        break;\n      }\n    }\n  }\n}\n\nlet _claimDehydratedIcuCaseImpl: typeof claimDehydratedIcuCaseImpl = () => {\n  // noop unless `enableClaimDehydratedIcuCaseImpl` is invoked\n};\n\n/**\n * Mark the case for the ICU node at the given index in the view as claimed,\n * allowing its nodes to be hydrated and not cleaned up.\n */\nexport function claimDehydratedIcuCase(lView: LView, icuIndex: number, caseIndex: number) {\n  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);\n}\n\nexport function enableClaimDehydratedIcuCaseImpl() {\n  _claimDehydratedIcuCaseImpl = claimDehydratedIcuCaseImpl;\n}\n\nfunction claimDehydratedIcuCaseImpl(lView: LView, icuIndex: number, caseIndex: number) {\n  const dehydratedIcuDataMap = lView[HYDRATION]?.dehydratedIcuData;\n  if (dehydratedIcuDataMap) {\n    const dehydratedIcuData = dehydratedIcuDataMap.get(icuIndex);\n    if (dehydratedIcuData?.case === caseIndex) {\n      // If the case we're attempting to claim matches the dehydrated one,\n      // we remove it from the map to mark it as \"claimed.\"\n      dehydratedIcuDataMap.delete(icuIndex);\n    }\n  }\n}\n\n/**\n * Clean up all i18n hydration data associated with the given view.\n */\nexport function cleanupI18nHydrationData(lView: LView) {\n  const hydrationInfo = lView[HYDRATION];\n  if (hydrationInfo) {\n    const {i18nNodes, dehydratedIcuData: dehydratedIcuDataMap} = hydrationInfo;\n    if (i18nNodes && dehydratedIcuDataMap) {\n      const renderer = lView[RENDERER];\n      for (const dehydratedIcuData of dehydratedIcuDataMap.values()) {\n        cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData);\n      }\n    }\n\n    hydrationInfo.i18nNodes = undefined;\n    hydrationInfo.dehydratedIcuData = undefined;\n  }\n}\n\nfunction cleanupDehydratedIcuData(\n  renderer: Renderer,\n  i18nNodes: Map<number, RNode | null>,\n  dehydratedIcuData: DehydratedIcuData,\n) {\n  for (const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]) {\n    const rNode = i18nNodes.get(node.index - HEADER_OFFSET);\n    if (rNode) {\n      nativeRemoveNode(renderer, rNode, false);\n    }\n  }\n}\n"]}