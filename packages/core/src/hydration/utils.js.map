{"version":3,"file":"utils.js","sourceRoot":"","sources":["utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector} from '../di/injector';\nimport type {ViewRef} from '../linker/view_ref';\nimport {getComponent} from '../render3/util/discovery_utils';\nimport {LContainer} from '../render3/interfaces/container';\nimport {getDocument} from '../render3/interfaces/document';\nimport {RElement, RNode} from '../render3/interfaces/renderer_dom';\nimport {isRootView} from '../render3/interfaces/type_checks';\nimport {HEADER_OFFSET, HYDRATION, LView, TVIEW, TViewType} from '../render3/interfaces/view';\nimport {makeStateKey, StateKey, TransferState} from '../transfer_state';\nimport {assertDefined, assertEqual} from '../util/assert';\nimport type {HydrationContext} from './annotate';\n\nimport {\n  BlockSummary,\n  CONTAINERS,\n  DEFER_HYDRATE_TRIGGERS,\n  DEFER_PARENT_BLOCK_ID,\n  DehydratedView,\n  DISCONNECTED_NODES,\n  ELEMENT_CONTAINERS,\n  MULTIPLIER,\n  NUM_ROOT_NODES,\n  SerializedContainerView,\n  SerializedDeferBlock,\n  SerializedTriggerDetails,\n  SerializedView,\n} from './interfaces';\nimport {IS_INCREMENTAL_HYDRATION_ENABLED, JSACTION_BLOCK_ELEMENT_MAP} from './tokens';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {DeferBlockTrigger, HydrateTriggerDetails} from '../defer/interfaces';\nimport {hoverEventNames, interactionEventNames} from '../../primitives/defer/src/triggers';\nimport {DEHYDRATED_BLOCK_REGISTRY} from '../defer/registry';\nimport {sharedMapFunction} from '../event_delegation_utils';\nimport {isDetachedByI18n} from '../i18n/utils';\nimport {isInSkipHydrationBlock} from '../render3/state';\nimport {TNode} from '../render3/interfaces/node';\n\n/**\n * The name of the key used in the TransferState collection,\n * where hydration information is located.\n */\nconst TRANSFER_STATE_TOKEN_ID = '__nghData__';\n\n/**\n * Lookup key used to reference DOM hydration data (ngh) in `TransferState`.\n */\nexport const NGH_DATA_KEY: StateKey<SerializedView[]> =\n  makeStateKey<Array<SerializedView>>(TRANSFER_STATE_TOKEN_ID);\n\n/**\n * The name of the key used in the TransferState collection,\n * where serialized defer block information is located.\n */\nexport const TRANSFER_STATE_DEFER_BLOCKS_INFO = '__nghDeferData__';\n\n/**\n * Lookup key used to retrieve defer block datain `TransferState`.\n */\nexport const NGH_DEFER_BLOCKS_KEY: StateKey<{[key: string]: SerializedDeferBlock}> = makeStateKey<{\n  [key: string]: SerializedDeferBlock;\n}>(TRANSFER_STATE_DEFER_BLOCKS_INFO);\n\n/**\n * Checks whether a given key is used by the framework for transferring hydration data.\n */\nexport function isInternalHydrationTransferStateKey(key: string): boolean {\n  return key === TRANSFER_STATE_TOKEN_ID || key === TRANSFER_STATE_DEFER_BLOCKS_INFO;\n}\n\n/**\n * The name of the attribute that would be added to host component\n * nodes and contain a reference to a particular slot in transferred\n * state that contains the necessary hydration info for this component.\n */\nexport const NGH_ATTR_NAME = 'ngh';\n\n/**\n * Marker used in a comment node to ensure hydration content integrity\n */\nexport const SSR_CONTENT_INTEGRITY_MARKER = 'nghm';\n\nexport const enum TextNodeMarker {\n  /**\n   * The contents of the text comment added to nodes that would otherwise be\n   * empty when serialized by the server and passed to the client. The empty\n   * node is lost when the browser parses it otherwise. This comment node will\n   * be replaced during hydration in the client to restore the lost empty text\n   * node.\n   */\n  EmptyNode = 'ngetn',\n\n  /**\n   * The contents of the text comment added in the case of adjacent text nodes.\n   * When adjacent text nodes are serialized by the server and sent to the\n   * client, the browser loses reference to the amount of nodes and assumes\n   * just one text node. This separator is replaced during hydration to restore\n   * the proper separation and amount of text nodes that should be present.\n   */\n  Separator = 'ngtns',\n}\n\n/**\n * Reference to a function that reads `ngh` attribute value from a given RNode\n * and retrieves hydration information from the TransferState using that value\n * as an index. Returns `null` by default, when hydration is not enabled.\n *\n * @param rNode Component's host element.\n * @param injector Injector that this component has access to.\n * @param isRootView Specifies whether we trying to read hydration info for the root view.\n */\nlet _retrieveHydrationInfoImpl: typeof retrieveHydrationInfoImpl = () => null;\n\nexport function retrieveHydrationInfoImpl(\n  rNode: RElement,\n  injector: Injector,\n  isRootView = false,\n): DehydratedView | null {\n  let nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);\n  if (nghAttrValue == null) return null;\n\n  // For cases when a root component also acts as an anchor node for a ViewContainerRef\n  // (for example, when ViewContainerRef is injected in a root component), there is a need\n  // to serialize information about the component itself, as well as an LContainer that\n  // represents this ViewContainerRef. Effectively, we need to serialize 2 pieces of info:\n  // (1) hydration info for the root component itself and (2) hydration info for the\n  // ViewContainerRef instance (an LContainer). Each piece of information is included into\n  // the hydration data (in the TransferState object) separately, thus we end up with 2 ids.\n  // Since we only have 1 root element, we encode both bits of info into a single string:\n  // ids are separated by the `|` char (e.g. `10|25`, where `10` is the ngh for a component view\n  // and 25 is the `ngh` for a root view which holds LContainer).\n  const [componentViewNgh, rootViewNgh] = nghAttrValue.split('|');\n  nghAttrValue = isRootView ? rootViewNgh : componentViewNgh;\n  if (!nghAttrValue) return null;\n\n  // We've read one of the ngh ids, keep the remaining one, so that\n  // we can set it back on the DOM element.\n  const rootNgh = rootViewNgh ? `|${rootViewNgh}` : '';\n  const remainingNgh = isRootView ? componentViewNgh : rootNgh;\n\n  let data: SerializedView = {};\n  // An element might have an empty `ngh` attribute value (e.g. `<comp ngh=\"\" />`),\n  // which means that no special annotations are required. Do not attempt to read\n  // from the TransferState in this case.\n  if (nghAttrValue !== '') {\n    const transferState = injector.get(TransferState, null, {optional: true});\n    if (transferState !== null) {\n      const nghData = transferState.get(NGH_DATA_KEY, []);\n\n      // The nghAttrValue is always a number referencing an index\n      // in the hydration TransferState data.\n      data = nghData[Number(nghAttrValue)];\n\n      // If the `ngh` attribute exists and has a non-empty value,\n      // the hydration info *must* be present in the TransferState.\n      // If there is no data for some reasons, this is an error.\n      ngDevMode && assertDefined(data, 'Unable to retrieve hydration info from the TransferState.');\n    }\n  }\n  const dehydratedView: DehydratedView = {\n    data,\n    firstChild: rNode.firstChild ?? null,\n  };\n\n  if (isRootView) {\n    // If there is hydration info present for the root view, it means that there was\n    // a ViewContainerRef injected in the root component. The root component host element\n    // acted as an anchor node in this scenario. As a result, the DOM nodes that represent\n    // embedded views in this ViewContainerRef are located as siblings to the host node,\n    // i.e. `<app-root /><#VIEW1><#VIEW2>...<!--container-->`. In this case, the current\n    // node becomes the first child of this root view and the next sibling is the first\n    // element in the DOM segment.\n    dehydratedView.firstChild = rNode;\n\n    // We use `0` here, since this is the slot (right after the HEADER_OFFSET)\n    // where a component LView or an LContainer is located in a root LView.\n    setSegmentHead(dehydratedView, 0, rNode.nextSibling);\n  }\n\n  if (remainingNgh) {\n    // If we have only used one of the ngh ids, store the remaining one\n    // back on this RNode.\n    rNode.setAttribute(NGH_ATTR_NAME, remainingNgh);\n  } else {\n    // The `ngh` attribute is cleared from the DOM node now\n    // that the data has been retrieved for all indices.\n    rNode.removeAttribute(NGH_ATTR_NAME);\n  }\n\n  // Note: don't check whether this node was claimed for hydration,\n  // because this node might've been previously claimed while processing\n  // template instructions.\n  ngDevMode && markRNodeAsClaimedByHydration(rNode, /* checkIfAlreadyClaimed */ false);\n  ngDevMode && ngDevMode.hydratedComponents++;\n\n  return dehydratedView;\n}\n\n/**\n * Sets the implementation for the `retrieveHydrationInfo` function.\n */\nexport function enableRetrieveHydrationInfoImpl() {\n  _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;\n}\n\n/**\n * Retrieves hydration info by reading the value from the `ngh` attribute\n * and accessing a corresponding slot in TransferState storage.\n */\nexport function retrieveHydrationInfo(\n  rNode: RElement,\n  injector: Injector,\n  isRootView = false,\n): DehydratedView | null {\n  return _retrieveHydrationInfoImpl(rNode, injector, isRootView);\n}\n\n/**\n * Retrieves the necessary object from a given ViewRef to serialize:\n *  - an LView for component views\n *  - an LContainer for cases when component acts as a ViewContainerRef anchor\n *  - `null` in case of an embedded view\n */\nexport function getLNodeForHydration(viewRef: ViewRef): LView | LContainer | null {\n  // Reading an internal field from `ViewRef` instance.\n  let lView = (viewRef as any)._lView as LView;\n  const tView = lView[TVIEW];\n  // A registered ViewRef might represent an instance of an\n  // embedded view, in which case we do not need to annotate it.\n  if (tView.type === TViewType.Embedded) {\n    return null;\n  }\n  // Check if it's a root view and if so, retrieve component's\n  // LView from the first slot after the header.\n  if (isRootView(lView)) {\n    lView = lView[HEADER_OFFSET];\n  }\n\n  return lView;\n}\n\nfunction getTextNodeContent(node: Node): string | undefined {\n  return node.textContent?.replace(/\\s/gm, '');\n}\n\n/**\n * Restores text nodes and separators into the DOM that were lost during SSR\n * serialization. The hydration process replaces empty text nodes and text\n * nodes that are immediately adjacent to other text nodes with comment nodes\n * that this method filters on to restore those missing nodes that the\n * hydration process is expecting to be present.\n *\n * @param node The app's root HTML Element\n */\nexport function processTextNodeMarkersBeforeHydration(node: HTMLElement) {\n  const doc = getDocument();\n  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n    acceptNode(node) {\n      const content = getTextNodeContent(node);\n      const isTextNodeMarker =\n        content === TextNodeMarker.EmptyNode || content === TextNodeMarker.Separator;\n      return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n    },\n  });\n  let currentNode: Comment;\n  // We cannot modify the DOM while using the commentIterator,\n  // because it throws off the iterator state.\n  // So we collect all marker nodes first and then follow up with\n  // applying the changes to the DOM: either inserting an empty node\n  // or just removing the marker if it was used as a separator.\n  const nodes = [];\n  while ((currentNode = commentNodesIterator.nextNode() as Comment)) {\n    nodes.push(currentNode);\n  }\n  for (const node of nodes) {\n    if (node.textContent === TextNodeMarker.EmptyNode) {\n      node.replaceWith(doc.createTextNode(''));\n    } else {\n      node.remove();\n    }\n  }\n}\n\n/**\n * Internal type that represents a claimed node.\n * Only used in dev mode.\n */\nexport enum HydrationStatus {\n  Hydrated = 'hydrated',\n  Skipped = 'skipped',\n  Mismatched = 'mismatched',\n}\n\nexport type HydrationInfo =\n  | {\n      status: HydrationStatus.Hydrated | HydrationStatus.Skipped;\n    }\n  | {\n      status: HydrationStatus.Mismatched;\n      actualNodeDetails: string | null;\n      expectedNodeDetails: string | null;\n    };\n\nconst HYDRATION_INFO_KEY = '__ngDebugHydrationInfo__';\n\nexport type HydratedNode = {\n  [HYDRATION_INFO_KEY]?: HydrationInfo;\n} & Element;\n\nfunction patchHydrationInfo(node: RNode, info: HydrationInfo) {\n  (node as HydratedNode)[HYDRATION_INFO_KEY] = info;\n}\n\nexport function readHydrationInfo(node: RNode): HydrationInfo | null {\n  return (node as HydratedNode)[HYDRATION_INFO_KEY] ?? null;\n}\n\n/**\n * Marks a node as \"claimed\" by hydration process.\n * This is needed to make assessments in tests whether\n * the hydration process handled all nodes.\n */\nexport function markRNodeAsClaimedByHydration(node: RNode, checkIfAlreadyClaimed = true) {\n  if (!ngDevMode) {\n    throw new Error(\n      'Calling `markRNodeAsClaimedByHydration` in prod mode ' +\n        'is not supported and likely a mistake.',\n    );\n  }\n  if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {\n    throw new Error('Trying to claim a node, which was claimed already.');\n  }\n  patchHydrationInfo(node, {status: HydrationStatus.Hydrated});\n  ngDevMode.hydratedNodes++;\n}\n\nexport function markRNodeAsSkippedByHydration(node: RNode) {\n  if (!ngDevMode) {\n    throw new Error(\n      'Calling `markRNodeAsSkippedByHydration` in prod mode ' +\n        'is not supported and likely a mistake.',\n    );\n  }\n  patchHydrationInfo(node, {status: HydrationStatus.Skipped});\n  ngDevMode.componentsSkippedHydration++;\n}\n\nexport function countBlocksSkippedByHydration(injector: Injector) {\n  const transferState = injector.get(TransferState);\n  const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});\n  if (ngDevMode) {\n    ngDevMode.deferBlocksWithIncrementalHydration = Object.keys(nghDeferData).length;\n  }\n}\n\nexport function markRNodeAsHavingHydrationMismatch(\n  node: RNode,\n  expectedNodeDetails: string | null = null,\n  actualNodeDetails: string | null = null,\n) {\n  if (!ngDevMode) {\n    throw new Error(\n      'Calling `markRNodeAsMismatchedByHydration` in prod mode ' +\n        'is not supported and likely a mistake.',\n    );\n  }\n\n  // The RNode can be a standard HTMLElement (not an Angular component or directive)\n  // The devtools component tree only displays Angular components & directives\n  // Therefore we attach the debug info to the closest component/directive\n  while (node && !getComponent(node as Element)) {\n    node = node?.parentNode as RNode;\n  }\n\n  if (node) {\n    patchHydrationInfo(node, {\n      status: HydrationStatus.Mismatched,\n      expectedNodeDetails,\n      actualNodeDetails,\n    });\n  }\n}\n\nexport function isRNodeClaimedForHydration(node: RNode): boolean {\n  return readHydrationInfo(node)?.status === HydrationStatus.Hydrated;\n}\n\nexport function setSegmentHead(\n  hydrationInfo: DehydratedView,\n  index: number,\n  node: RNode | null,\n): void {\n  hydrationInfo.segmentHeads ??= {};\n  hydrationInfo.segmentHeads[index] = node;\n}\n\nexport function getSegmentHead(hydrationInfo: DehydratedView, index: number): RNode | null {\n  return hydrationInfo.segmentHeads?.[index] ?? null;\n}\n\nexport function isIncrementalHydrationEnabled(injector: Injector): boolean {\n  return injector.get(IS_INCREMENTAL_HYDRATION_ENABLED, false, {\n    optional: true,\n  });\n}\n\n/** Throws an error if the incremental hydration is not enabled */\nexport function assertIncrementalHydrationIsConfigured(injector: Injector) {\n  if (!isIncrementalHydrationEnabled(injector)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISCONFIGURED_INCREMENTAL_HYDRATION,\n      'Angular has detected that some `@defer` blocks use `hydrate` triggers, ' +\n        'but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` ' +\n        'call is added as an argument for the `provideClientHydration()` function call ' +\n        'in your application config.',\n    );\n  }\n}\n\n/** Throws an error if the ssrUniqueId on the LDeferBlockDetails is not present  */\nexport function assertSsrIdDefined(ssrUniqueId: unknown) {\n  assertDefined(\n    ssrUniqueId,\n    'Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present',\n  );\n}\n\n/**\n * Returns the size of an <ng-container>, using either the information\n * serialized in `ELEMENT_CONTAINERS` (element container size) or by\n * computing the sum of root nodes in all dehydrated views in a given\n * container (in case this `<ng-container>` was also used as a view\n * container host node, e.g. <ng-container *ngIf>).\n */\nexport function getNgContainerSize(hydrationInfo: DehydratedView, index: number): number | null {\n  const data = hydrationInfo.data;\n  let size = data[ELEMENT_CONTAINERS]?.[index] ?? null;\n  // If there is no serialized information available in the `ELEMENT_CONTAINERS` slot,\n  // check if we have info about view containers at this location (e.g.\n  // `<ng-container *ngIf>`) and use container size as a number of root nodes in this\n  // element container.\n  if (size === null && data[CONTAINERS]?.[index]) {\n    size = calcSerializedContainerSize(hydrationInfo, index);\n  }\n  return size;\n}\n\nexport function isSerializedElementContainer(\n  hydrationInfo: DehydratedView,\n  index: number,\n): boolean {\n  return hydrationInfo.data[ELEMENT_CONTAINERS]?.[index] !== undefined;\n}\n\nexport function getSerializedContainerViews(\n  hydrationInfo: DehydratedView,\n  index: number,\n): SerializedContainerView[] | null {\n  return hydrationInfo.data[CONTAINERS]?.[index] ?? null;\n}\n\n/**\n * Computes the size of a serialized container (the number of root nodes)\n * by calculating the sum of root nodes in all dehydrated views in this container.\n */\nexport function calcSerializedContainerSize(hydrationInfo: DehydratedView, index: number): number {\n  const views = getSerializedContainerViews(hydrationInfo, index) ?? [];\n  let numNodes = 0;\n  for (let view of views) {\n    numNodes += view[NUM_ROOT_NODES] * (view[MULTIPLIER] ?? 1);\n  }\n  return numNodes;\n}\n\n/**\n * Attempt to initialize the `disconnectedNodes` field of the given\n * `DehydratedView`. Returns the initialized value.\n */\nexport function initDisconnectedNodes(hydrationInfo: DehydratedView): Set<number> | null {\n  // Check if we are processing disconnected info for the first time.\n  if (typeof hydrationInfo.disconnectedNodes === 'undefined') {\n    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];\n    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;\n  }\n  return hydrationInfo.disconnectedNodes;\n}\n\n/**\n * Checks whether a node is annotated as \"disconnected\", i.e. not present\n * in the DOM at serialization time. We should not attempt hydration for\n * such nodes and instead, use a regular \"creation mode\".\n */\nexport function isDisconnectedNode(hydrationInfo: DehydratedView, index: number): boolean {\n  // Check if we are processing disconnected info for the first time.\n  if (typeof hydrationInfo.disconnectedNodes === 'undefined') {\n    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];\n    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;\n  }\n  return !!initDisconnectedNodes(hydrationInfo)?.has(index);\n}\n\n/**\n * Checks whether a node can be hydrated.\n * @param lView View in which the node instance is placed.\n * @param tNode Node to be checked.\n */\nexport function canHydrateNode(lView: LView, tNode: TNode): boolean {\n  const hydrationInfo = lView[HYDRATION];\n\n  return (\n    hydrationInfo !== null &&\n    !isInSkipHydrationBlock() &&\n    !isDetachedByI18n(tNode) &&\n    !isDisconnectedNode(hydrationInfo, tNode.index - HEADER_OFFSET)\n  );\n}\n\n/**\n * Helper function to prepare text nodes for serialization by ensuring\n * that seperate logical text blocks in the DOM remain separate after\n * serialization.\n */\nexport function processTextNodeBeforeSerialization(context: HydrationContext, node: RNode) {\n  // Handle cases where text nodes can be lost after DOM serialization:\n  //  1. When there is an *empty text node* in DOM: in this case, this\n  //     node would not make it into the serialized string and as a result,\n  //     this node wouldn't be created in a browser. This would result in\n  //     a mismatch during the hydration, where the runtime logic would expect\n  //     a text node to be present in live DOM, but no text node would exist.\n  //     Example: `<span>{{ name }}</span>` when the `name` is an empty string.\n  //     This would result in `<span></span>` string after serialization and\n  //     in a browser only the `span` element would be created. To resolve that,\n  //     an extra comment node is appended in place of an empty text node and\n  //     that special comment node is replaced with an empty text node *before*\n  //     hydration.\n  //  2. When there are 2 consecutive text nodes present in the DOM.\n  //     Example: `<div>Hello <ng-container *ngIf=\"true\">world</ng-container></div>`.\n  //     In this scenario, the live DOM would look like this:\n  //       <div>#text('Hello ') #text('world') #comment('container')</div>\n  //     Serialized string would look like this: `<div>Hello world<!--container--></div>`.\n  //     The live DOM in a browser after that would be:\n  //       <div>#text('Hello world') #comment('container')</div>\n  //     Notice how 2 text nodes are now \"merged\" into one. This would cause hydration\n  //     logic to fail, since it'd expect 2 text nodes being present, not one.\n  //     To fix this, we insert a special comment node in between those text nodes, so\n  //     serialized representation is: `<div>Hello <!--ngtns-->world<!--container--></div>`.\n  //     This forces browser to create 2 text nodes separated by a comment node.\n  //     Before running a hydration process, this special comment node is removed, so the\n  //     live DOM has exactly the same state as it was before serialization.\n\n  // Collect this node as required special annotation only when its\n  // contents is empty. Otherwise, such text node would be present on\n  // the client after server-side rendering and no special handling needed.\n  const el = node as HTMLElement;\n  const corruptedTextNodes = context.corruptedTextNodes;\n  if (el.textContent === '') {\n    corruptedTextNodes.set(el, TextNodeMarker.EmptyNode);\n  } else if (el.nextSibling?.nodeType === Node.TEXT_NODE) {\n    corruptedTextNodes.set(el, TextNodeMarker.Separator);\n  }\n}\n\nexport function convertHydrateTriggersToJsAction(\n  triggers: Map<DeferBlockTrigger, HydrateTriggerDetails | null> | null,\n): string[] {\n  let actionList: string[] = [];\n  if (triggers !== null) {\n    if (triggers.has(DeferBlockTrigger.Hover)) {\n      actionList.push(...hoverEventNames);\n    }\n    if (triggers.has(DeferBlockTrigger.Interaction)) {\n      actionList.push(...interactionEventNames);\n    }\n  }\n  return actionList;\n}\n\n/**\n * Builds a queue of blocks that need to be hydrated, looking up the\n * tree to the topmost defer block that exists in the tree that hasn't\n * been hydrated, but exists in the registry. This queue is in top down\n * hierarchical order as a list of defer block ids.\n * Note: This is utilizing serialized information to navigate up the tree\n */\nexport function getParentBlockHydrationQueue(\n  deferBlockId: string,\n  injector: Injector,\n): {parentBlockPromise: Promise<void> | null; hydrationQueue: string[]} {\n  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n  const transferState = injector.get(TransferState);\n  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});\n\n  let isTopMostDeferBlock = false;\n  let currentBlockId: string | undefined = deferBlockId;\n  let parentBlockPromise: Promise<void> | null = null;\n  const hydrationQueue: string[] = [];\n\n  while (!isTopMostDeferBlock && currentBlockId) {\n    ngDevMode &&\n      assertEqual(\n        hydrationQueue.indexOf(currentBlockId),\n        -1,\n        'Internal error: defer block hierarchy has a cycle.',\n      );\n\n    isTopMostDeferBlock = dehydratedBlockRegistry.has(currentBlockId);\n    const hydratingParentBlock = dehydratedBlockRegistry.hydrating.get(currentBlockId);\n    if (parentBlockPromise === null && hydratingParentBlock != null) {\n      parentBlockPromise = hydratingParentBlock.promise;\n      break;\n    }\n    hydrationQueue.unshift(currentBlockId);\n    currentBlockId = deferBlockParents[currentBlockId][DEFER_PARENT_BLOCK_ID];\n  }\n  return {parentBlockPromise, hydrationQueue};\n}\n\nfunction gatherDeferBlocksByJSActionAttribute(doc: Document): Set<HTMLElement> {\n  const jsactionNodes = doc.body.querySelectorAll('[jsaction]');\n  const blockMap = new Set<HTMLElement>();\n  const eventTypes = [hoverEventNames.join(':;'), interactionEventNames.join(':;')].join('|');\n  for (let node of jsactionNodes) {\n    const attr = node.getAttribute('jsaction');\n    const blockId = node.getAttribute('ngb');\n    if (attr?.match(eventTypes) && blockId !== null) {\n      blockMap.add(node as HTMLElement);\n    }\n  }\n  return blockMap;\n}\n\nexport function appendDeferBlocksToJSActionMap(doc: Document, injector: Injector) {\n  const blockMap = gatherDeferBlocksByJSActionAttribute(doc);\n  const jsActionMap = injector.get(JSACTION_BLOCK_ELEMENT_MAP);\n  for (let rNode of blockMap) {\n    sharedMapFunction(rNode, jsActionMap);\n  }\n}\n\n/**\n * Retrieves defer block hydration information from the TransferState.\n *\n * @param injector Injector that this component has access to.\n */\nlet _retrieveDeferBlockDataImpl: typeof retrieveDeferBlockDataImpl = () => {\n  return {};\n};\n\nexport function retrieveDeferBlockDataImpl(injector: Injector): {\n  [key: string]: SerializedDeferBlock;\n} {\n  const transferState = injector.get(TransferState, null, {optional: true});\n  if (transferState !== null) {\n    const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});\n\n    ngDevMode &&\n      assertDefined(nghDeferData, 'Unable to retrieve defer block info from the TransferState.');\n    return nghDeferData;\n  }\n\n  return {};\n}\n\n/**\n * Sets the implementation for the `retrieveDeferBlockData` function.\n */\nexport function enableRetrieveDeferBlockDataImpl() {\n  _retrieveDeferBlockDataImpl = retrieveDeferBlockDataImpl;\n}\n\n/**\n * Retrieves defer block data from TransferState storage\n */\nexport function retrieveDeferBlockData(injector: Injector): {[key: string]: SerializedDeferBlock} {\n  return _retrieveDeferBlockDataImpl(injector);\n}\n\nfunction isTimerTrigger(triggerInfo: DeferBlockTrigger | SerializedTriggerDetails): boolean {\n  return typeof triggerInfo === 'object' && triggerInfo.trigger === DeferBlockTrigger.Timer;\n}\n\nfunction getHydrateTimerTrigger(blockData: SerializedDeferBlock): number | null {\n  const trigger = blockData[DEFER_HYDRATE_TRIGGERS]?.find((t) => isTimerTrigger(t));\n  return (trigger as SerializedTriggerDetails)?.delay ?? null;\n}\n\nfunction hasHydrateTrigger(blockData: SerializedDeferBlock, trigger: DeferBlockTrigger): boolean {\n  return blockData[DEFER_HYDRATE_TRIGGERS]?.includes(trigger) ?? false;\n}\n\n/**\n * Creates a summary of the given serialized defer block, which is used later to properly initialize\n * specific triggers.\n */\nfunction createBlockSummary(blockInfo: SerializedDeferBlock): BlockSummary {\n  return {\n    data: blockInfo,\n    hydrate: {\n      idle: hasHydrateTrigger(blockInfo, DeferBlockTrigger.Idle),\n      immediate: hasHydrateTrigger(blockInfo, DeferBlockTrigger.Immediate),\n      timer: getHydrateTimerTrigger(blockInfo),\n      viewport: hasHydrateTrigger(blockInfo, DeferBlockTrigger.Viewport),\n    },\n  };\n}\n\n/**\n * Processes all of the defer block data in the transfer state and creates a map of the summaries\n */\nexport function processBlockData(injector: Injector): Map<string, BlockSummary> {\n  const blockData = retrieveDeferBlockData(injector);\n  let blockDetails = new Map<string, BlockSummary>();\n  for (let blockId in blockData) {\n    blockDetails.set(blockId, createBlockSummary(blockData[blockId]));\n  }\n  return blockDetails;\n}\n\nfunction isSsrContentsIntegrity(node: ChildNode | null): boolean {\n  return (\n    !!node &&\n    node.nodeType === Node.COMMENT_NODE &&\n    node.textContent?.trim() === SSR_CONTENT_INTEGRITY_MARKER\n  );\n}\n\nfunction skipTextNodes(node: ChildNode | null): ChildNode | null {\n  // Ignore whitespace. Before the <body>, we shouldn't find text nodes that aren't whitespace.\n  while (node && node.nodeType === Node.TEXT_NODE) {\n    node = node.previousSibling;\n  }\n  return node;\n}\n\n/**\n * Verifies whether the DOM contains a special marker added during SSR time to make sure\n * there is no SSR'ed contents transformations happen after SSR is completed. Typically that\n * happens either by CDN or during the build process as an optimization to remove comment nodes.\n * Hydration process requires comment nodes produced by Angular to locate correct DOM segments.\n * When this special marker is *not* present - throw an error and do not proceed with hydration,\n * since it will not be able to function correctly.\n *\n * Note: this function is invoked only on the client, so it's safe to use DOM APIs.\n */\nexport function verifySsrContentsIntegrity(doc: Document): void {\n  for (const node of doc.body.childNodes) {\n    if (isSsrContentsIntegrity(node)) {\n      return;\n    }\n  }\n\n  // Check if the HTML parser may have moved the marker to just before the <body> tag,\n  // e.g. because the body tag was implicit and not present in the markup. An implicit body\n  // tag is unlikely to interfer with whitespace/comments inside of the app's root element.\n\n  // Case 1: Implicit body. Example:\n  //   <!doctype html><head><title>Hi</title></head><!--nghm--><app-root></app-root>\n  const beforeBody = skipTextNodes(doc.body.previousSibling);\n  if (isSsrContentsIntegrity(beforeBody)) {\n    return;\n  }\n\n  // Case 2: Implicit body & head. Example:\n  //   <!doctype html><head><title>Hi</title><!--nghm--><app-root></app-root>\n  let endOfHead = skipTextNodes(doc.head.lastChild);\n  if (isSsrContentsIntegrity(endOfHead)) {\n    return;\n  }\n\n  throw new RuntimeError(\n    RuntimeErrorCode.MISSING_SSR_CONTENT_INTEGRITY_MARKER,\n    typeof ngDevMode !== 'undefined' &&\n      ngDevMode &&\n      'Angular hydration logic detected that HTML content of this page was modified after it ' +\n        'was produced during server side rendering. Make sure that there are no optimizations ' +\n        'that remove comment nodes from HTML enabled on your CDN. Angular hydration ' +\n        'relies on HTML produced by the server, including whitespaces and comment nodes.',\n  );\n}\n"]}