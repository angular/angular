/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
import { TNode } from '../render3/interfaces/node';
import { RNode } from '../render3/interfaces/renderer_dom';
import { LView, TView } from '../render3/interfaces/view';
import { DehydratedView, NodeNavigationStep } from './interfaces';
/**
 * Check whether a given node exists, but is disconnected from the DOM.
 */
export declare function isDisconnectedNode(tNode: TNode, lView: LView): boolean;
/**
 * Check whether the given node exists, but is disconnected from the DOM.
 *
 * Note: we leverage the fact that we have this information available in the DOM emulation
 * layer (in Domino) for now. Longer-term solution should not rely on the DOM emulation and
 * only use internal data structures and state to compute this information.
 */
export declare function isDisconnectedRNode(rNode: RNode | null): boolean;
/**
 * Locate a node in an i18n tree that corresponds to a given instruction index.
 *
 * @param hydrationInfo The hydration annotation data
 * @param noOffsetIndex the instruction index
 * @returns an RNode that corresponds to the instruction index
 */
export declare function locateI18nRNodeByIndex<T extends RNode>(hydrationInfo: DehydratedView, noOffsetIndex: number): T | null | undefined;
/**
 * Attempt to locate an RNode by a path, if it exists.
 *
 * @param hydrationInfo The hydration annotation data
 * @param lView the current lView
 * @param noOffsetIndex the instruction index
 * @returns an RNode that corresponds to the instruction index or null if no path exists
 */
export declare function tryLocateRNodeByPath(hydrationInfo: DehydratedView, lView: LView<unknown>, noOffsetIndex: number): RNode | null;
/**
 * Locate a node in DOM tree that corresponds to a given TNode.
 *
 * @param hydrationInfo The hydration annotation data
 * @param tView the current tView
 * @param lView the current lView
 * @param tNode the current tNode
 * @returns an RNode that represents a given tNode
 */
export declare function locateNextRNode<T extends RNode>(hydrationInfo: DehydratedView, tView: TView, lView: LView<unknown>, tNode: TNode): T | null;
/**
 * Skips over a specified number of nodes and returns the next sibling node after that.
 */
export declare function siblingAfter<T extends RNode>(skip: number, from: RNode): T | null;
/**
 * Generate a list of DOM navigation operations to get from node `start` to node `finish`.
 *
 * Note: assumes that node `start` occurs before node `finish` in an in-order traversal of the DOM
 * tree. That is, we should be able to get from `start` to `finish` purely by using `.firstChild`
 * and `.nextSibling` operations.
 */
export declare function navigateBetween(start: Node, finish: Node): NodeNavigationStep[] | null;
/**
 * Calculates a path between 2 nodes in terms of `nextSibling` and `firstChild`
 * navigations:
 * - the `from` node is a known node, used as an starting point for the lookup
 *   (the `fromNodeName` argument is a string representation of the node).
 * - the `to` node is a node that the runtime logic would be looking up,
 *   using the path generated by this function.
 */
export declare function calcPathBetween(from: Node, to: Node, fromNodeName: string): string | null;
/**
 * Invoked at serialization time (on the server) when a set of navigation
 * instructions needs to be generated for a TNode.
 */
export declare function calcPathForNode(tNode: TNode, lView: LView, excludedParentNodes: Set<number> | null): string;
/**
 * Retrieves all comments nodes that contain ngh comments referring to a defer block
 */
export declare function gatherDeferBlocksCommentNodes(doc: Document, node: HTMLElement): Map<string, Comment>;
