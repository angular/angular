{"version":3,"file":"cleanup.js","sourceRoot":"","sources":["cleanup.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ApplicationRef} from '../application/application_ref';\nimport {DehydratedDeferBlock} from '../defer/interfaces';\nimport {DehydratedBlockRegistry} from '../defer/registry';\nimport {\n  CONTAINER_HEADER_OFFSET,\n  DEHYDRATED_VIEWS,\n  LContainer,\n} from '../render3/interfaces/container';\nimport {Renderer} from '../render3/interfaces/renderer';\nimport {RNode} from '../render3/interfaces/renderer_dom';\nimport {isLContainer, isLView} from '../render3/interfaces/type_checks';\nimport {HEADER_OFFSET, HOST, LView, PARENT, RENDERER, TVIEW} from '../render3/interfaces/view';\nimport {nativeRemoveNode} from '../render3/dom_node_manipulation';\n\nimport {validateSiblingNodeExists} from './error_handling';\nimport {cleanupI18nHydrationData} from './i18n';\nimport {DEFER_BLOCK_ID, DehydratedContainerView, NUM_ROOT_NODES} from './interfaces';\nimport {getLNodeForHydration} from './utils';\n\n/**\n * Removes all dehydrated views from a given LContainer:\n * both in internal data structure, as well as removing\n * corresponding DOM nodes that belong to that dehydrated view.\n */\nexport function removeDehydratedViews(lContainer: LContainer) {\n  const views = lContainer[DEHYDRATED_VIEWS] ?? [];\n  const parentLView = lContainer[PARENT];\n  const renderer = parentLView[RENDERER];\n  const retainedViews = [];\n  for (const view of views) {\n    // Do not clean up contents of `@defer` blocks.\n    // The cleanup for this content would happen once a given block\n    // is triggered and hydrated.\n    if (view.data[DEFER_BLOCK_ID] !== undefined) {\n      retainedViews.push(view);\n    } else {\n      removeDehydratedView(view, renderer);\n      ngDevMode && ngDevMode.dehydratedViewsRemoved++;\n    }\n  }\n  // Reset the value to an array to indicate that no\n  // further processing of dehydrated views is needed for\n  // this view container (i.e. do not trigger the lookup process\n  // once again in case a `ViewContainerRef` is created later).\n  lContainer[DEHYDRATED_VIEWS] = retainedViews;\n}\n\nexport function removeDehydratedViewList(deferBlock: DehydratedDeferBlock) {\n  const {lContainer} = deferBlock;\n  const dehydratedViews = lContainer[DEHYDRATED_VIEWS];\n  if (dehydratedViews === null) return;\n  const parentLView = lContainer[PARENT];\n  const renderer = parentLView[RENDERER];\n  for (const view of dehydratedViews) {\n    removeDehydratedView(view, renderer);\n    ngDevMode && ngDevMode.dehydratedViewsRemoved++;\n  }\n}\n\n/**\n * Helper function to remove all nodes from a dehydrated view.\n */\nfunction removeDehydratedView(dehydratedView: DehydratedContainerView, renderer: Renderer) {\n  let nodesRemoved = 0;\n  let currentRNode = dehydratedView.firstChild;\n  if (currentRNode) {\n    const numNodes = dehydratedView.data[NUM_ROOT_NODES];\n    while (nodesRemoved < numNodes) {\n      ngDevMode && validateSiblingNodeExists(currentRNode);\n      const nextSibling: RNode = currentRNode.nextSibling!;\n      nativeRemoveNode(renderer, currentRNode, false);\n      currentRNode = nextSibling;\n      nodesRemoved++;\n    }\n  }\n}\n\n/**\n * Walks over all views within this LContainer invokes dehydrated views\n * cleanup function for each one.\n */\nexport function cleanupLContainer(lContainer: LContainer) {\n  removeDehydratedViews(lContainer);\n\n  // The host could be an LView if this container is on a component node.\n  // In this case, descend into host LView for further cleanup. See also\n  // LContainer[HOST] docs for additional information.\n  const hostLView = lContainer[HOST];\n  if (isLView(hostLView)) {\n    cleanupLView(hostLView);\n  }\n\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    cleanupLView(lContainer[i] as LView);\n  }\n}\n\n/**\n * Walks over `LContainer`s and components registered within\n * this LView and invokes dehydrated views cleanup function for each one.\n */\nfunction cleanupLView(lView: LView) {\n  cleanupI18nHydrationData(lView);\n\n  const tView = lView[TVIEW];\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    if (isLContainer(lView[i])) {\n      const lContainer = lView[i];\n      cleanupLContainer(lContainer);\n    } else if (isLView(lView[i])) {\n      // This is a component, enter the `cleanupLView` recursively.\n      cleanupLView(lView[i]);\n    }\n  }\n}\n\n/**\n * Walks over all views registered within the ApplicationRef and removes\n * all dehydrated views from all `LContainer`s along the way.\n */\nexport function cleanupDehydratedViews(appRef: ApplicationRef) {\n  const viewRefs = appRef._views;\n  for (const viewRef of viewRefs) {\n    const lNode = getLNodeForHydration(viewRef);\n    // An `lView` might be `null` if a `ViewRef` represents\n    // an embedded view (not a component view).\n    if (lNode !== null && lNode[HOST] !== null) {\n      if (isLView(lNode)) {\n        cleanupLView(lNode);\n      } else {\n        // Cleanup in all views within this view container\n        cleanupLContainer(lNode);\n      }\n      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;\n    }\n  }\n}\n\n/**\n * post hydration cleanup handling for defer blocks that were incrementally\n * hydrated. This removes all the jsaction attributes, timers, observers,\n * dehydrated views and containers\n */\nexport function cleanupHydratedDeferBlocks(\n  deferBlock: DehydratedDeferBlock | null,\n  hydratedBlocks: string[],\n  registry: DehydratedBlockRegistry,\n  appRef: ApplicationRef,\n): void {\n  if (deferBlock !== null) {\n    registry.cleanup(hydratedBlocks);\n    cleanupLContainer(deferBlock.lContainer);\n    cleanupDehydratedViews(appRef);\n  }\n}\n"]}