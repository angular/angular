{"version":3,"file":"views.js","sourceRoot":"","sources":["views.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DEHYDRATED_VIEWS, LContainer} from '../render3/interfaces/container';\nimport {TNode, TNodeFlags} from '../render3/interfaces/node';\nimport {RNode} from '../render3/interfaces/renderer_dom';\nimport {isLContainer} from '../render3/interfaces/type_checks';\nimport {LView, TVIEW} from '../render3/interfaces/view';\n\nimport {removeDehydratedViews} from './cleanup';\nimport {\n  DehydratedContainerView,\n  MULTIPLIER,\n  NUM_ROOT_NODES,\n  SerializedContainerView,\n  TEMPLATE_ID,\n} from './interfaces';\nimport {siblingAfter} from './node_lookup_utils';\n\n/**\n * Given a current DOM node and a serialized information about the views\n * in a container, walks over the DOM structure, collecting the list of\n * dehydrated views.\n */\nexport function locateDehydratedViewsInContainer(\n  currentRNode: RNode,\n  serializedViews: SerializedContainerView[],\n): [RNode, DehydratedContainerView[]] {\n  const dehydratedViews: DehydratedContainerView[] = [];\n  for (const serializedView of serializedViews) {\n    // Repeats a view multiple times as needed, based on the serialized information\n    // (for example, for *ngFor-produced views).\n    for (let i = 0; i < (serializedView[MULTIPLIER] ?? 1); i++) {\n      const view: DehydratedContainerView = {\n        data: serializedView,\n        firstChild: null,\n      };\n      if (serializedView[NUM_ROOT_NODES] > 0) {\n        // Keep reference to the first node in this view,\n        // so it can be accessed while invoking template instructions.\n        view.firstChild = currentRNode as HTMLElement;\n\n        // Move over to the next node after this view, which can\n        // either be a first node of the next view or an anchor comment\n        // node after the last view in a container.\n        currentRNode = siblingAfter(serializedView[NUM_ROOT_NODES], currentRNode)!;\n      }\n      dehydratedViews.push(view);\n    }\n  }\n\n  return [currentRNode, dehydratedViews];\n}\n\n/**\n * Reference to a function that searches for a matching dehydrated views\n * stored on a given lContainer.\n * Returns `null` by default, when hydration is not enabled.\n */\nlet _findMatchingDehydratedViewImpl: typeof findMatchingDehydratedViewImpl = () => null;\n\n/**\n * Reference to a function that searches for a matching dehydrated view\n * stored on a control flow lContainer and removes the dehydrated content\n * once found.\n * Returns `null` by default, when hydration is not enabled.\n */\nlet _findAndReconcileMatchingDehydratedViewsImpl: typeof findAndReconcileMatchingDehydratedViewsImpl =\n  () => null;\n\nexport function enableFindMatchingDehydratedViewImpl() {\n  _findMatchingDehydratedViewImpl = findMatchingDehydratedViewImpl;\n  _findAndReconcileMatchingDehydratedViewsImpl = findAndReconcileMatchingDehydratedViewsImpl;\n}\n\n/**\n * Retrieves the next dehydrated view from the LContainer and verifies that\n * it matches a given template id (from the TView that was used to create this\n * instance of a view). If the id doesn't match, that means that we are in an\n * unexpected state and can not complete the reconciliation process. Thus,\n * all dehydrated views from this LContainer are removed (including corresponding\n * DOM nodes) and the rendering is performed as if there were no dehydrated views\n * in this container.\n */\nfunction findMatchingDehydratedViewImpl(\n  lContainer: LContainer,\n  template: string | null,\n): DehydratedContainerView | null {\n  if (hasMatchingDehydratedView(lContainer, template)) {\n    return lContainer[DEHYDRATED_VIEWS]!.shift()!;\n  } else {\n    // Otherwise, we are at the state when reconciliation can not be completed,\n    // thus we remove all dehydrated views within this container (remove them\n    // from internal data structures as well as delete associated elements from\n    // the DOM tree).\n    removeDehydratedViews(lContainer);\n    return null;\n  }\n}\n\nexport function findMatchingDehydratedView(\n  lContainer: LContainer,\n  template: string | null,\n): DehydratedContainerView | null {\n  return _findMatchingDehydratedViewImpl(lContainer, template);\n}\n\nexport function findAndReconcileMatchingDehydratedViewsImpl(\n  lContainer: LContainer,\n  templateTNode: TNode,\n  hostLView: LView,\n): DehydratedContainerView | null {\n  if (templateTNode.tView!.ssrId === null) return null;\n  const dehydratedView = findMatchingDehydratedView(lContainer, templateTNode.tView!.ssrId);\n\n  // we know that an ssrId was generated, but we were unable to match it to\n  // a dehydrated view, which means that we may have changed branches\n  // between server and client. We'll need to find and remove those\n  // stale dehydrated views.\n  if (hostLView[TVIEW].firstUpdatePass && dehydratedView === null) {\n    removeStaleDehydratedBranch(hostLView, templateTNode);\n  }\n  return dehydratedView;\n}\n\nexport function findAndReconcileMatchingDehydratedViews(\n  lContainer: LContainer,\n  templateTNode: TNode,\n  hostLView: LView,\n): DehydratedContainerView | null {\n  return _findAndReconcileMatchingDehydratedViewsImpl(lContainer, templateTNode, hostLView);\n}\n\n/**\n * In the case that we have control flow that changes branches between server and\n * client, we're left with dehydrated content that will not be used. We need to find\n * it and clean it up at the right time so that we don't see duplicate content for\n * a few moments before the application reaches stability. This navigates the\n * control flow containers by looking at the TNodeFlags to find the matching\n * dehydrated content for the branch that is now stale from the server and removes it.\n */\nfunction removeStaleDehydratedBranch(hostLView: LView, tNode: TNode): void {\n  let currentTNode: TNode | null = tNode;\n  while (currentTNode) {\n    // We can return here if we've found the dehydrated view and cleaned it up.\n    // Otherwise we continue on until we either find it or reach the start of\n    // the control flow.\n    if (cleanupMatchingDehydratedViews(hostLView, currentTNode)) return;\n\n    if ((currentTNode.flags & TNodeFlags.isControlFlowStart) === TNodeFlags.isControlFlowStart) {\n      // we've hit the top of the control flow loop\n      break;\n    }\n\n    currentTNode = currentTNode.prev;\n  }\n\n  currentTNode = tNode.next; // jump to place we started so we can navigate down from there\n\n  while (currentTNode) {\n    if ((currentTNode.flags & TNodeFlags.isInControlFlow) !== TNodeFlags.isInControlFlow) {\n      // we've exited control flow and need to exit the loop.\n      break;\n    }\n\n    // Similar to above, we can return here if we've found the dehydrated view\n    // and cleaned it up. Otherwise we continue on until we either find it or\n    // reach the end of the control flow.\n    if (cleanupMatchingDehydratedViews(hostLView, currentTNode)) return;\n\n    currentTNode = currentTNode.next;\n  }\n}\n\nfunction hasMatchingDehydratedView(lContainer: LContainer, template: string | null): boolean {\n  const views = lContainer[DEHYDRATED_VIEWS];\n  if (!template || views === null || views.length === 0) {\n    return false;\n  }\n  // Verify whether the first dehydrated view in the container matches\n  // the template id passed to this function (that originated from a TView\n  // that was used to create an instance of an embedded or component views.\n  return views[0].data[TEMPLATE_ID] === template;\n}\n\nfunction cleanupMatchingDehydratedViews(hostLView: LView, currentTNode: TNode): boolean {\n  const ssrId = currentTNode.tView?.ssrId;\n  if (ssrId == null /* check both `null` and `undefined` */) return false;\n\n  const container = hostLView[currentTNode.index];\n  // if we can find the dehydrated view in this container, we know we've found the stale view\n  // and we can remove it.\n  if (isLContainer(container) && hasMatchingDehydratedView(container, ssrId)) {\n    removeDehydratedViews(container);\n    return true;\n  }\n  return false;\n}\n"]}