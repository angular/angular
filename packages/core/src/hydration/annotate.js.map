{"version":3,"file":"annotate.js","sourceRoot":"","sources":["annotate.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ApplicationRef} from '../application/application_ref';\nimport {APP_ID} from '../application/application_tokens';\nimport {\n  DEFER_BLOCK_STATE as CURRENT_DEFER_BLOCK_STATE,\n  DeferBlockTrigger,\n  HydrateTriggerDetails,\n  TDeferBlockDetails,\n} from '../defer/interfaces';\nimport {getLDeferBlockDetails, getTDeferBlockDetails, isDeferBlock} from '../defer/utils';\nimport {isDetachedByI18n} from '../i18n/utils';\nimport {ViewEncapsulation} from '../metadata';\nimport {Renderer2} from '../render';\nimport {assertTNode} from '../render3/assert';\nimport {collectNativeNodes, collectNativeNodesInLContainer} from '../render3/collect_native_nodes';\nimport {getComponentDef} from '../render3/def_getters';\nimport {CONTAINER_HEADER_OFFSET, LContainer} from '../render3/interfaces/container';\nimport {isLetDeclaration, isTNodeShape, TNode, TNodeType} from '../render3/interfaces/node';\nimport {RComment, RElement} from '../render3/interfaces/renderer_dom';\nimport {\n  hasI18n,\n  isComponentHost,\n  isLContainer,\n  isProjectionTNode,\n  isRootView,\n} from '../render3/interfaces/type_checks';\nimport {\n  CONTEXT,\n  HEADER_OFFSET,\n  HOST,\n  INJECTOR,\n  LView,\n  PARENT,\n  RENDERER,\n  TView,\n  TVIEW,\n  TViewType,\n} from '../render3/interfaces/view';\nimport {unwrapLView, unwrapRNode} from '../render3/util/view_utils';\nimport {TransferState} from '../transfer_state';\n\nimport {\n  unsupportedProjectionOfDomNodes,\n  validateMatchingNode,\n  validateNodeExists,\n} from './error_handling';\nimport {collectDomEventsInfo} from './event_replay';\nimport {setJSActionAttributes} from '../event_delegation_utils';\nimport {\n  getOrComputeI18nChildren,\n  isI18nHydrationEnabled,\n  isI18nHydrationSupportEnabled,\n  trySerializeI18nBlock,\n} from './i18n';\nimport {\n  CONTAINERS,\n  DEFER_BLOCK_ID,\n  DEFER_BLOCK_STATE,\n  DEFER_HYDRATE_TRIGGERS,\n  DEFER_PARENT_BLOCK_ID,\n  DISCONNECTED_NODES,\n  ELEMENT_CONTAINERS,\n  I18N_DATA,\n  MULTIPLIER,\n  NODES,\n  NUM_ROOT_NODES,\n  SerializedContainerView,\n  SerializedDeferBlock,\n  SerializedTriggerDetails,\n  SerializedView,\n  TEMPLATE_ID,\n  TEMPLATES,\n} from './interfaces';\nimport {calcPathForNode, isDisconnectedNode} from './node_lookup_utils';\nimport {isInSkipHydrationBlock, SKIP_HYDRATION_ATTR_NAME} from './skip_hydration';\nimport {EVENT_REPLAY_ENABLED_DEFAULT, IS_EVENT_REPLAY_ENABLED} from './tokens';\nimport {\n  convertHydrateTriggersToJsAction,\n  getLNodeForHydration,\n  isIncrementalHydrationEnabled,\n  NGH_ATTR_NAME,\n  NGH_DATA_KEY,\n  NGH_DEFER_BLOCKS_KEY,\n  processTextNodeBeforeSerialization,\n  TextNodeMarker,\n} from './utils';\nimport {Injector} from '../di';\n\n/**\n * A collection that tracks all serialized views (`ngh` DOM annotations)\n * to avoid duplication. An attempt to add a duplicate view results in the\n * collection returning the index of the previously collected serialized view.\n * This reduces the number of annotations needed for a given page.\n */\nclass SerializedViewCollection {\n  private views: SerializedView[] = [];\n  private indexByContent = new Map<string, number>();\n\n  add(serializedView: SerializedView): number {\n    const viewAsString = JSON.stringify(serializedView);\n    if (!this.indexByContent.has(viewAsString)) {\n      const index = this.views.length;\n      this.views.push(serializedView);\n      this.indexByContent.set(viewAsString, index);\n      return index;\n    }\n    return this.indexByContent.get(viewAsString)!;\n  }\n\n  getAll(): SerializedView[] {\n    return this.views;\n  }\n}\n\n/**\n * Global counter that is used to generate a unique id for TViews\n * during the serialization process.\n */\nlet tViewSsrId = 0;\n\n/**\n * Generates a unique id for a given TView and returns this id.\n * The id is also stored on this instance of a TView and reused in\n * subsequent calls.\n *\n * This id is needed to uniquely identify and pick up dehydrated views\n * at runtime.\n */\nfunction getSsrId(tView: TView): string {\n  if (!tView.ssrId) {\n    tView.ssrId = `t${tViewSsrId++}`;\n  }\n  return tView.ssrId;\n}\n\n/**\n * Describes a context available during the serialization\n * process. The context is used to share and collect information\n * during the serialization.\n */\nexport interface HydrationContext {\n  serializedViewCollection: SerializedViewCollection;\n  corruptedTextNodes: Map<HTMLElement, TextNodeMarker>;\n  isI18nHydrationEnabled: boolean;\n  isIncrementalHydrationEnabled: boolean;\n  i18nChildren: Map<TView, Set<number> | null>;\n  eventTypesToReplay: {regular: Set<string>; capture: Set<string>};\n  shouldReplayEvents: boolean;\n  appId: string; // the value of `APP_ID`\n  deferBlocks: Map<string /* defer block id, e.g. `d0` */, SerializedDeferBlock>;\n}\n\n/**\n * Computes the number of root nodes in a given view\n * (or child nodes in a given container if a tNode is provided).\n */\nfunction calcNumRootNodes(tView: TView, lView: LView, tNode: TNode | null): number {\n  const rootNodes: unknown[] = [];\n  collectNativeNodes(tView, lView, tNode, rootNodes);\n  return rootNodes.length;\n}\n\n/**\n * Computes the number of root nodes in all views in a given LContainer.\n */\nfunction calcNumRootNodesInLContainer(lContainer: LContainer): number {\n  const rootNodes: unknown[] = [];\n  collectNativeNodesInLContainer(lContainer, rootNodes);\n  return rootNodes.length;\n}\n\n/**\n * Annotates root level component's LView for hydration,\n * see `annotateHostElementForHydration` for additional information.\n */\nfunction annotateComponentLViewForHydration(\n  lView: LView,\n  context: HydrationContext,\n  injector: Injector,\n): number | null {\n  const hostElement = lView[HOST];\n  // Root elements might also be annotated with the `ngSkipHydration` attribute,\n  // check if it's present before starting the serialization process.\n  if (hostElement && !(hostElement as HTMLElement).hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {\n    return annotateHostElementForHydration(hostElement as HTMLElement, lView, null, context);\n  }\n  return null;\n}\n\n/**\n * Annotates root level LContainer for hydration. This happens when a root component\n * injects ViewContainerRef, thus making the component an anchor for a view container.\n * This function serializes the component itself as well as all views from the view\n * container.\n */\nfunction annotateLContainerForHydration(\n  lContainer: LContainer,\n  context: HydrationContext,\n  injector: Injector,\n) {\n  const componentLView = unwrapLView(lContainer[HOST]) as LView<unknown>;\n\n  // Serialize the root component itself.\n  const componentLViewNghIndex = annotateComponentLViewForHydration(\n    componentLView,\n    context,\n    injector,\n  );\n\n  if (componentLViewNghIndex === null) {\n    // Component was not serialized (for example, if hydration was skipped by adding\n    // the `ngSkipHydration` attribute or this component uses i18n blocks in the template,\n    // but `withI18nSupport()` was not added), avoid annotating host element with the `ngh`\n    // attribute.\n    return;\n  }\n\n  const hostElement = unwrapRNode(componentLView[HOST]!) as HTMLElement;\n\n  // Serialize all views within this view container.\n  const rootLView = lContainer[PARENT];\n  const rootLViewNghIndex = annotateHostElementForHydration(hostElement, rootLView, null, context);\n\n  const renderer = componentLView[RENDERER] as Renderer2;\n\n  // For cases when a root component also acts as an anchor node for a ViewContainerRef\n  // (for example, when ViewContainerRef is injected in a root component), there is a need\n  // to serialize information about the component itself, as well as an LContainer that\n  // represents this ViewContainerRef. Effectively, we need to serialize 2 pieces of info:\n  // (1) hydration info for the root component itself and (2) hydration info for the\n  // ViewContainerRef instance (an LContainer). Each piece of information is included into\n  // the hydration data (in the TransferState object) separately, thus we end up with 2 ids.\n  // Since we only have 1 root element, we encode both bits of info into a single string:\n  // ids are separated by the `|` char (e.g. `10|25`, where `10` is the ngh for a component view\n  // and 25 is the `ngh` for a root view which holds LContainer).\n  const finalIndex = `${componentLViewNghIndex}|${rootLViewNghIndex}`;\n  renderer.setAttribute(hostElement, NGH_ATTR_NAME, finalIndex);\n}\n\n/**\n * Annotates all components bootstrapped in a given ApplicationRef\n * with info needed for hydration.\n *\n * @param appRef An instance of an ApplicationRef.\n * @param doc A reference to the current Document instance.\n * @return event types that need to be replayed\n */\nexport function annotateForHydration(appRef: ApplicationRef, doc: Document) {\n  const injector = appRef.injector;\n  const isI18nHydrationEnabledVal = isI18nHydrationEnabled(injector);\n  const isIncrementalHydrationEnabledVal = isIncrementalHydrationEnabled(injector);\n  const serializedViewCollection = new SerializedViewCollection();\n  const corruptedTextNodes = new Map<HTMLElement, TextNodeMarker>();\n  const viewRefs = appRef._views;\n  const shouldReplayEvents = injector.get(IS_EVENT_REPLAY_ENABLED, EVENT_REPLAY_ENABLED_DEFAULT);\n  const eventTypesToReplay = {\n    regular: new Set<string>(),\n    capture: new Set<string>(),\n  };\n  const deferBlocks = new Map<string, SerializedDeferBlock>();\n  const appId = appRef.injector.get(APP_ID);\n  for (const viewRef of viewRefs) {\n    const lNode = getLNodeForHydration(viewRef);\n\n    // An `lView` might be `null` if a `ViewRef` represents\n    // an embedded view (not a component view).\n    if (lNode !== null) {\n      const context: HydrationContext = {\n        serializedViewCollection,\n        corruptedTextNodes,\n        isI18nHydrationEnabled: isI18nHydrationEnabledVal,\n        isIncrementalHydrationEnabled: isIncrementalHydrationEnabledVal,\n        i18nChildren: new Map(),\n        eventTypesToReplay,\n        shouldReplayEvents,\n        appId,\n        deferBlocks,\n      };\n      if (isLContainer(lNode)) {\n        annotateLContainerForHydration(lNode, context, injector);\n      } else {\n        annotateComponentLViewForHydration(lNode, context, injector);\n      }\n      insertCorruptedTextNodeMarkers(corruptedTextNodes, doc);\n    }\n  }\n\n  // Note: we *always* include hydration info key and a corresponding value\n  // into the TransferState, even if the list of serialized views is empty.\n  // This is needed as a signal to the client that the server part of the\n  // hydration logic was setup and enabled correctly. Otherwise, if a client\n  // hydration doesn't find a key in the transfer state - an error is produced.\n  const serializedViews = serializedViewCollection.getAll();\n  const transferState = injector.get(TransferState);\n  transferState.set(NGH_DATA_KEY, serializedViews);\n\n  if (deferBlocks.size > 0) {\n    const blocks: {[key: string]: SerializedDeferBlock} = {};\n    for (const [id, info] of deferBlocks.entries()) {\n      blocks[id] = info;\n    }\n    transferState.set(NGH_DEFER_BLOCKS_KEY, blocks);\n  }\n\n  return eventTypesToReplay;\n}\n\n/**\n * Serializes the lContainer data into a list of SerializedView objects,\n * that represent views within this lContainer.\n *\n * @param lContainer the lContainer we are serializing\n * @param tNode the TNode that contains info about this LContainer\n * @param lView that hosts this LContainer\n * @param parentDeferBlockId the defer block id of the parent if it exists\n * @param context the hydration context\n * @returns an array of the `SerializedView` objects\n */\nfunction serializeLContainer(\n  lContainer: LContainer,\n  tNode: TNode,\n  lView: LView,\n  parentDeferBlockId: string | null,\n  context: HydrationContext,\n): SerializedContainerView[] {\n  const views: SerializedContainerView[] = [];\n  let lastViewAsString = '';\n\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    let childLView = lContainer[i] as LView;\n\n    let template: string;\n    let numRootNodes: number;\n    let serializedView: SerializedContainerView | undefined;\n\n    if (isRootView(childLView)) {\n      // If this is a root view, get an LView for the underlying component,\n      // because it contains information about the view to serialize.\n      childLView = childLView[HEADER_OFFSET];\n\n      // If we have an LContainer at this position, this indicates that the\n      // host element was used as a ViewContainerRef anchor (e.g. a `ViewContainerRef`\n      // was injected within the component class). This case requires special handling.\n      if (isLContainer(childLView)) {\n        // Calculate the number of root nodes in all views in a given container\n        // and increment by one to account for an anchor node itself, i.e. in this\n        // scenario we'll have a layout that would look like this:\n        // `<app-root /><#VIEW1><#VIEW2>...<!--container-->`\n        // The `+1` is to capture the `<app-root />` element.\n        numRootNodes = calcNumRootNodesInLContainer(childLView) + 1;\n\n        annotateLContainerForHydration(childLView, context, lView[INJECTOR]);\n\n        const componentLView = unwrapLView(childLView[HOST]) as LView<unknown>;\n\n        serializedView = {\n          [TEMPLATE_ID]: componentLView[TVIEW].ssrId!,\n          [NUM_ROOT_NODES]: numRootNodes,\n        };\n      }\n    }\n\n    if (!serializedView) {\n      const childTView = childLView[TVIEW];\n\n      if (childTView.type === TViewType.Component) {\n        template = childTView.ssrId!;\n\n        // This is a component view, thus it has only 1 root node: the component\n        // host node itself (other nodes would be inside that host node).\n        numRootNodes = 1;\n      } else {\n        template = getSsrId(childTView);\n        numRootNodes = calcNumRootNodes(childTView, childLView, childTView.firstChild);\n      }\n\n      serializedView = {\n        [TEMPLATE_ID]: template,\n        [NUM_ROOT_NODES]: numRootNodes,\n      };\n\n      let isHydrateNeverBlock = false;\n\n      // If this is a defer block, serialize extra info.\n      if (isDeferBlock(lView[TVIEW], tNode)) {\n        const lDetails = getLDeferBlockDetails(lView, tNode);\n        const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);\n\n        if (context.isIncrementalHydrationEnabled && tDetails.hydrateTriggers !== null) {\n          const deferBlockId = `d${context.deferBlocks.size}`;\n\n          if (tDetails.hydrateTriggers.has(DeferBlockTrigger.Never)) {\n            isHydrateNeverBlock = true;\n          }\n\n          let rootNodes: any[] = [];\n          collectNativeNodesInLContainer(lContainer, rootNodes);\n\n          // Add defer block into info context.deferBlocks\n          const deferBlockInfo: SerializedDeferBlock = {\n            [NUM_ROOT_NODES]: rootNodes.length,\n            [DEFER_BLOCK_STATE]: lDetails[CURRENT_DEFER_BLOCK_STATE],\n          };\n\n          const serializedTriggers = serializeHydrateTriggers(tDetails.hydrateTriggers);\n          if (serializedTriggers.length > 0) {\n            deferBlockInfo[DEFER_HYDRATE_TRIGGERS] = serializedTriggers;\n          }\n\n          if (parentDeferBlockId !== null) {\n            // Serialize parent id only when it's present.\n            deferBlockInfo[DEFER_PARENT_BLOCK_ID] = parentDeferBlockId;\n          }\n\n          context.deferBlocks.set(deferBlockId, deferBlockInfo);\n\n          const node = unwrapRNode(lContainer);\n          if (node !== undefined) {\n            if ((node as Node).nodeType === Node.COMMENT_NODE) {\n              annotateDeferBlockAnchorForHydration(node as RComment, deferBlockId);\n            }\n          } else {\n            ngDevMode && validateNodeExists(node, childLView, tNode);\n            ngDevMode &&\n              validateMatchingNode(node, Node.COMMENT_NODE, null, childLView, tNode, true);\n\n            annotateDeferBlockAnchorForHydration(node as RComment, deferBlockId);\n          }\n\n          if (!isHydrateNeverBlock) {\n            // Add JSAction attributes for root nodes that use some hydration triggers\n            annotateDeferBlockRootNodesWithJsAction(tDetails, rootNodes, deferBlockId, context);\n          }\n\n          // Use current block id as parent for nested routes.\n          parentDeferBlockId = deferBlockId;\n\n          // Serialize extra info into the view object.\n          // TODO(incremental-hydration): this should be serialized and included at a different level\n          // (not at the view level).\n          serializedView[DEFER_BLOCK_ID] = deferBlockId;\n        }\n        // DEFER_BLOCK_STATE is used for reconciliation in hydration, both regular and incremental.\n        // We need to know which template is rendered when hydrating. So we serialize this state\n        // regardless of hydration type.\n        serializedView[DEFER_BLOCK_STATE] = lDetails[CURRENT_DEFER_BLOCK_STATE];\n      }\n\n      if (!isHydrateNeverBlock) {\n        Object.assign(\n          serializedView,\n          serializeLView(lContainer[i] as LView, parentDeferBlockId, context),\n        );\n      }\n    }\n\n    // Check if the previous view has the same shape (for example, it was\n    // produced by the *ngFor), in which case bump the counter on the previous\n    // view instead of including the same information again.\n    const currentViewAsString = JSON.stringify(serializedView);\n    if (views.length > 0 && currentViewAsString === lastViewAsString) {\n      const previousView = views[views.length - 1];\n      previousView[MULTIPLIER] ??= 1;\n      previousView[MULTIPLIER]++;\n    } else {\n      // Record this view as most recently added.\n      lastViewAsString = currentViewAsString;\n      views.push(serializedView);\n    }\n  }\n  return views;\n}\n\nfunction serializeHydrateTriggers(\n  triggerMap: Map<DeferBlockTrigger, HydrateTriggerDetails | null>,\n): (DeferBlockTrigger | SerializedTriggerDetails)[] {\n  const serializableDeferBlockTrigger = new Set<DeferBlockTrigger>([\n    DeferBlockTrigger.Idle,\n    DeferBlockTrigger.Immediate,\n    DeferBlockTrigger.Viewport,\n    DeferBlockTrigger.Timer,\n  ]);\n  let triggers: (DeferBlockTrigger | SerializedTriggerDetails)[] = [];\n  for (let [trigger, details] of triggerMap) {\n    if (serializableDeferBlockTrigger.has(trigger)) {\n      if (details === null) {\n        triggers.push(trigger);\n      } else {\n        triggers.push({trigger, delay: details.delay});\n      }\n    }\n  }\n  return triggers;\n}\n\n/**\n * Helper function to produce a node path (which navigation steps runtime logic\n * needs to take to locate a node) and stores it in the `NODES` section of the\n * current serialized view.\n */\nfunction appendSerializedNodePath(\n  ngh: SerializedView,\n  tNode: TNode,\n  lView: LView,\n  excludedParentNodes: Set<number> | null,\n) {\n  const noOffsetIndex = tNode.index - HEADER_OFFSET;\n  ngh[NODES] ??= {};\n  // Ensure we don't calculate the path multiple times.\n  ngh[NODES][noOffsetIndex] ??= calcPathForNode(tNode, lView, excludedParentNodes);\n}\n\n/**\n * Helper function to append information about a disconnected node.\n * This info is needed at runtime to avoid DOM lookups for this element\n * and instead, the element would be created from scratch.\n */\nfunction appendDisconnectedNodeIndex(ngh: SerializedView, tNodeOrNoOffsetIndex: TNode | number) {\n  const noOffsetIndex =\n    typeof tNodeOrNoOffsetIndex === 'number'\n      ? tNodeOrNoOffsetIndex\n      : tNodeOrNoOffsetIndex.index - HEADER_OFFSET;\n  ngh[DISCONNECTED_NODES] ??= [];\n  if (!ngh[DISCONNECTED_NODES].includes(noOffsetIndex)) {\n    ngh[DISCONNECTED_NODES].push(noOffsetIndex);\n  }\n}\n\n/**\n * Serializes the lView data into a SerializedView object that will later be added\n * to the TransferState storage and referenced using the `ngh` attribute on a host\n * element.\n *\n * @param lView the lView we are serializing\n * @param context the hydration context\n * @returns the `SerializedView` object containing the data to be added to the host node\n */\nfunction serializeLView(\n  lView: LView,\n  parentDeferBlockId: string | null = null,\n  context: HydrationContext,\n): SerializedView {\n  const ngh: SerializedView = {};\n  const tView = lView[TVIEW];\n  const i18nChildren = getOrComputeI18nChildren(tView, context);\n  const nativeElementsToEventTypes = context.shouldReplayEvents\n    ? collectDomEventsInfo(tView, lView, context.eventTypesToReplay)\n    : null;\n  // Iterate over DOM element references in an LView.\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    const tNode = tView.data[i];\n    const noOffsetIndex = i - HEADER_OFFSET;\n\n    // Attempt to serialize any i18n data for the given slot. We do this first, as i18n\n    // has its own process for serialization.\n    const i18nData = trySerializeI18nBlock(lView, i, context);\n    if (i18nData) {\n      ngh[I18N_DATA] ??= {};\n      ngh[I18N_DATA][noOffsetIndex] = i18nData.caseQueue;\n\n      for (const nodeNoOffsetIndex of i18nData.disconnectedNodes) {\n        appendDisconnectedNodeIndex(ngh, nodeNoOffsetIndex);\n      }\n\n      for (const nodeNoOffsetIndex of i18nData.disjointNodes) {\n        const tNode = tView.data[nodeNoOffsetIndex + HEADER_OFFSET] as TNode;\n        ngDevMode && assertTNode(tNode);\n        appendSerializedNodePath(ngh, tNode, lView, i18nChildren);\n      }\n\n      continue;\n    }\n\n    // Skip processing of a given slot in the following cases:\n    // - Local refs (e.g. <div #localRef>) take up an extra slot in LViews\n    //   to store the same element. In this case, there is no information in\n    //   a corresponding slot in TNode data structure.\n    // - When a slot contains something other than a TNode. For example, there\n    //   might be some metadata information about a defer block or a control flow block.\n    if (!isTNodeShape(tNode)) {\n      continue;\n    }\n\n    // Skip any nodes that are in an i18n block but are considered detached (i.e. not\n    // present in the template). These nodes are disconnected from the DOM tree, and\n    // so we don't want to serialize any information about them.\n    if (isDetachedByI18n(tNode)) {\n      continue;\n    }\n\n    // Serialize information about template.\n    if (isLContainer(lView[i]) && tNode.tView) {\n      ngh[TEMPLATES] ??= {};\n      ngh[TEMPLATES][noOffsetIndex] = getSsrId(tNode.tView!);\n    }\n\n    // Check if a native node that represents a given TNode is disconnected from the DOM tree.\n    // Such nodes must be excluded from the hydration (since the hydration won't be able to\n    // find them), so the TNode ids are collected and used at runtime to skip the hydration.\n    // This situation may happen during the content projection, when some nodes don't make it\n    // into one of the content projection slots (for example, when there is no default\n    // <ng-content /> slot in projector component's template).\n    if (isDisconnectedNode(tNode, lView) && isContentProjectedNode(tNode)) {\n      appendDisconnectedNodeIndex(ngh, tNode);\n      continue;\n    }\n\n    if (Array.isArray(tNode.projection)) {\n      for (const projectionHeadTNode of tNode.projection) {\n        // We may have `null`s in slots with no projected content.\n        if (!projectionHeadTNode) continue;\n\n        if (!Array.isArray(projectionHeadTNode)) {\n          // If we process re-projected content (i.e. `<ng-content>`\n          // appears at projection location), skip annotations for this content\n          // since all DOM nodes in this projection were handled while processing\n          // a parent lView, which contains those nodes.\n          if (\n            !isProjectionTNode(projectionHeadTNode) &&\n            !isInSkipHydrationBlock(projectionHeadTNode)\n          ) {\n            if (isDisconnectedNode(projectionHeadTNode, lView)) {\n              // Check whether this node is connected, since we may have a TNode\n              // in the data structure as a projection segment head, but the\n              // content projection slot might be disabled (e.g.\n              // <ng-content *ngIf=\"false\" />).\n              appendDisconnectedNodeIndex(ngh, projectionHeadTNode);\n            } else {\n              appendSerializedNodePath(ngh, projectionHeadTNode, lView, i18nChildren);\n            }\n          }\n        } else {\n          // If a value is an array, it means that we are processing a projection\n          // where projectable nodes were passed in as DOM nodes (for example, when\n          // calling `ViewContainerRef.createComponent(CmpA, {projectableNodes: [...]})`).\n          //\n          // In this scenario, nodes can come from anywhere (either created manually,\n          // accessed via `document.querySelector`, etc) and may be in any state\n          // (attached or detached from the DOM tree). As a result, we can not reliably\n          // restore the state for such cases during hydration.\n\n          throw unsupportedProjectionOfDomNodes(unwrapRNode(lView[i]));\n        }\n      }\n    }\n\n    conditionallyAnnotateNodePath(ngh, tNode, lView, i18nChildren);\n    if (isLContainer(lView[i])) {\n      // Serialize views within this LContainer.\n      const hostNode = lView[i][HOST]!; // host node of this container\n\n      // LView[i][HOST] can be of 2 different types:\n      // - either a DOM node\n      // - or an array that represents an LView of a component\n      if (Array.isArray(hostNode)) {\n        // This is a component, serialize info about it.\n        const targetNode = unwrapRNode(hostNode as LView) as RElement;\n        if (!(targetNode as HTMLElement).hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {\n          annotateHostElementForHydration(\n            targetNode,\n            hostNode as LView,\n            parentDeferBlockId,\n            context,\n          );\n        }\n      }\n\n      ngh[CONTAINERS] ??= {};\n      ngh[CONTAINERS][noOffsetIndex] = serializeLContainer(\n        lView[i],\n        tNode,\n        lView,\n        parentDeferBlockId,\n        context,\n      );\n    } else if (Array.isArray(lView[i]) && !isLetDeclaration(tNode)) {\n      // This is a component, annotate the host node with an `ngh` attribute.\n      // Note: Let declarations that return an array are also storing an array in the LView,\n      // we need to exclude them.\n      const targetNode = unwrapRNode(lView[i][HOST]!);\n      if (!(targetNode as HTMLElement).hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {\n        annotateHostElementForHydration(\n          targetNode as RElement,\n          lView[i],\n          parentDeferBlockId,\n          context,\n        );\n      }\n    } else {\n      // <ng-container> case\n      if (tNode.type & TNodeType.ElementContainer) {\n        // An <ng-container> is represented by the number of\n        // top-level nodes. This information is needed to skip over\n        // those nodes to reach a corresponding anchor node (comment node).\n        ngh[ELEMENT_CONTAINERS] ??= {};\n        ngh[ELEMENT_CONTAINERS][noOffsetIndex] = calcNumRootNodes(tView, lView, tNode.child);\n      } else if (tNode.type & (TNodeType.Projection | TNodeType.LetDeclaration)) {\n        // Current TNode represents an `<ng-content>` slot or `@let` declaration,\n        // thus it has no DOM elements associated with it, so the **next sibling**\n        // node would not be able to find an anchor. In this case, use full path instead.\n        let nextTNode = tNode.next;\n        // Skip over all `<ng-content>` slots and `@let` declarations in a row.\n        while (\n          nextTNode !== null &&\n          nextTNode.type & (TNodeType.Projection | TNodeType.LetDeclaration)\n        ) {\n          nextTNode = nextTNode.next;\n        }\n        if (nextTNode && !isInSkipHydrationBlock(nextTNode)) {\n          // Handle a tNode after the `<ng-content>` slot.\n          appendSerializedNodePath(ngh, nextTNode, lView, i18nChildren);\n        }\n      } else if (tNode.type & TNodeType.Text) {\n        const rNode = unwrapRNode(lView[i]);\n        processTextNodeBeforeSerialization(context, rNode);\n      }\n    }\n\n    // Attach `jsaction` attribute to elements that have registered listeners,\n    // thus potentially having a need to do an event replay.\n    if (nativeElementsToEventTypes && tNode.type & TNodeType.Element) {\n      const nativeElement = unwrapRNode(lView[i]) as Element;\n      if (nativeElementsToEventTypes.has(nativeElement)) {\n        setJSActionAttributes(\n          nativeElement,\n          nativeElementsToEventTypes.get(nativeElement)!,\n          parentDeferBlockId,\n        );\n      }\n    }\n  }\n  return ngh;\n}\n\n/**\n * Serializes node location in cases when it's needed, specifically:\n *\n *  1. If `tNode.projectionNext` is different from `tNode.next` - it means that\n *     the next `tNode` after projection is different from the one in the original\n *     template. Since hydration relies on `tNode.next`, this serialized info\n *     is required to help runtime code find the node at the correct location.\n *  2. In certain content projection-based use-cases, it's possible that only\n *     a content of a projected element is rendered. In this case, content nodes\n *     require an extra annotation, since runtime logic can't rely on parent-child\n *     connection to identify the location of a node.\n */\nfunction conditionallyAnnotateNodePath(\n  ngh: SerializedView,\n  tNode: TNode,\n  lView: LView<unknown>,\n  excludedParentNodes: Set<number> | null,\n) {\n  if (isProjectionTNode(tNode)) {\n    // Do not annotate projection nodes (<ng-content />), since\n    // they don't have a corresponding DOM node representing them.\n    return;\n  }\n\n  // Handle case #1 described above.\n  if (\n    tNode.projectionNext &&\n    tNode.projectionNext !== tNode.next &&\n    !isInSkipHydrationBlock(tNode.projectionNext)\n  ) {\n    appendSerializedNodePath(ngh, tNode.projectionNext, lView, excludedParentNodes);\n  }\n\n  // Handle case #2 described above.\n  // Note: we only do that for the first node (i.e. when `tNode.prev === null`),\n  // the rest of the nodes would rely on the current node location, so no extra\n  // annotation is needed.\n  if (\n    tNode.prev === null &&\n    tNode.parent !== null &&\n    isDisconnectedNode(tNode.parent, lView) &&\n    !isDisconnectedNode(tNode, lView)\n  ) {\n    appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes);\n  }\n}\n\n/**\n * Determines whether a component instance that is represented\n * by a given LView uses `ViewEncapsulation.ShadowDom`.\n */\nfunction componentUsesShadowDomEncapsulation(lView: LView): boolean {\n  const instance = lView[CONTEXT];\n  if (!instance?.constructor) return false;\n  const def = getComponentDef(instance.constructor);\n  return (\n    def?.encapsulation === ViewEncapsulation.ShadowDom ||\n    def?.encapsulation === ViewEncapsulation.IsolatedShadowDom\n  );\n}\n\n/**\n * Annotates component host element for hydration:\n * - by either adding the `ngh` attribute and collecting hydration-related info\n *   for the serialization and transferring to the client\n * - or by adding the `ngSkipHydration` attribute in case Angular detects that\n *   component contents is not compatible with hydration.\n *\n * @param element The Host element to be annotated\n * @param lView The associated LView\n * @param context The hydration context\n * @returns An index of serialized view from the transfer state object\n *          or `null` when a given component can not be serialized.\n */\nfunction annotateHostElementForHydration(\n  element: RElement,\n  lView: LView,\n  parentDeferBlockId: string | null,\n  context: HydrationContext,\n): number | null {\n  const renderer = lView[RENDERER];\n  if (\n    (hasI18n(lView) && !isI18nHydrationSupportEnabled()) ||\n    componentUsesShadowDomEncapsulation(lView)\n  ) {\n    // Attach the skip hydration attribute if this component:\n    // - either has i18n blocks, since hydrating such blocks is not yet supported\n    // - or uses ShadowDom view encapsulation, since Domino doesn't support\n    //   shadow DOM, so we can not guarantee that client and server representations\n    //   would exactly match\n    renderer.setAttribute(element, SKIP_HYDRATION_ATTR_NAME, '');\n    return null;\n  } else {\n    const ngh = serializeLView(lView, parentDeferBlockId, context);\n    const index = context.serializedViewCollection.add(ngh);\n    renderer.setAttribute(element, NGH_ATTR_NAME, index.toString());\n    return index;\n  }\n}\n\n/**\n * Annotates defer block comment node for hydration:\n *\n * @param comment The Host element to be annotated\n * @param deferBlockId the id of the target defer block\n */\nfunction annotateDeferBlockAnchorForHydration(comment: RComment, deferBlockId: string): void {\n  comment.textContent = `ngh=${deferBlockId}`;\n}\n\n/**\n * Physically inserts the comment nodes to ensure empty text nodes and adjacent\n * text node separators are preserved after server serialization of the DOM.\n * These get swapped back for empty text nodes or separators once hydration happens\n * on the client.\n *\n * @param corruptedTextNodes The Map of text nodes to be replaced with comments\n * @param doc The document\n */\nfunction insertCorruptedTextNodeMarkers(\n  corruptedTextNodes: Map<HTMLElement, string>,\n  doc: Document,\n) {\n  for (const [textNode, marker] of corruptedTextNodes) {\n    textNode.after(doc.createComment(marker));\n  }\n}\n\n/**\n * Detects whether a given TNode represents a node that\n * is being content projected.\n */\nfunction isContentProjectedNode(tNode: TNode): boolean {\n  let currentTNode = tNode;\n  while (currentTNode != null) {\n    // If we come across a component host node in parent nodes -\n    // this TNode is in the content projection section.\n    if (isComponentHost(currentTNode)) {\n      return true;\n    }\n    currentTNode = currentTNode.parent as TNode;\n  }\n  return false;\n}\n\n/**\n * Incremental hydration requires that any defer block root node\n * with interaction or hover triggers have all of their root nodes\n * trigger hydration with those events. So we need to make sure all\n * the root nodes of that block have the proper jsaction attribute\n * to ensure hydration is triggered, since the content is dehydrated\n */\nfunction annotateDeferBlockRootNodesWithJsAction(\n  tDetails: TDeferBlockDetails,\n  rootNodes: any[],\n  parentDeferBlockId: string,\n  context: HydrationContext,\n) {\n  const actionList = convertHydrateTriggersToJsAction(tDetails.hydrateTriggers);\n  for (let et of actionList) {\n    context.eventTypesToReplay.regular.add(et);\n  }\n\n  if (actionList.length > 0) {\n    const elementNodes = (rootNodes as HTMLElement[]).filter(\n      (rn) => rn.nodeType === Node.ELEMENT_NODE,\n    );\n    for (let rNode of elementNodes) {\n      setJSActionAttributes(rNode, actionList, parentDeferBlockId);\n    }\n  }\n}\n"]}