{"version":3,"file":"node_lookup_utils.js","sourceRoot":"","sources":["node_lookup_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {TNode, TNodeType} from '../render3/interfaces/node';\nimport {RElement, RNode} from '../render3/interfaces/renderer_dom';\nimport {\n  DECLARATION_COMPONENT_VIEW,\n  HEADER_OFFSET,\n  HOST,\n  LView,\n  TView,\n} from '../render3/interfaces/view';\nimport {getFirstNativeNode} from '../render3/node_manipulation';\nimport {ɵɵresolveBody} from '../render3/util/misc_utils';\nimport {renderStringify} from '../render3/util/stringify_utils';\nimport {getNativeByTNode, unwrapRNode} from '../render3/util/view_utils';\nimport {assertDefined, assertEqual} from '../util/assert';\n\nimport {compressNodeLocation, decompressNodeLocation} from './compression';\nimport {\n  nodeNotFoundAtPathError,\n  nodeNotFoundError,\n  validateSiblingNodeExists,\n} from './error_handling';\nimport {\n  DehydratedView,\n  NODE_NAVIGATION_STEP_FIRST_CHILD,\n  NODE_NAVIGATION_STEP_NEXT_SIBLING,\n  NodeNavigationStep,\n  NODES,\n  REFERENCE_NODE_BODY,\n  REFERENCE_NODE_HOST,\n} from './interfaces';\nimport {calcSerializedContainerSize, getSegmentHead} from './utils';\n\n/** Whether current TNode is a first node in an <ng-container>. */\nfunction isFirstElementInNgContainer(tNode: TNode): boolean {\n  return !tNode.prev && tNode.parent?.type === TNodeType.ElementContainer;\n}\n\n/** Returns an instruction index (subtracting HEADER_OFFSET). */\nfunction getNoOffsetIndex(tNode: TNode): number {\n  return tNode.index - HEADER_OFFSET;\n}\n\n/**\n * Check whether a given node exists, but is disconnected from the DOM.\n */\nexport function isDisconnectedNode(tNode: TNode, lView: LView) {\n  return (\n    !(tNode.type & (TNodeType.Projection | TNodeType.LetDeclaration)) &&\n    !!lView[tNode.index] &&\n    isDisconnectedRNode(unwrapRNode(lView[tNode.index]))\n  );\n}\n\n/**\n * Check whether the given node exists, but is disconnected from the DOM.\n *\n * Note: we leverage the fact that we have this information available in the DOM emulation\n * layer (in Domino) for now. Longer-term solution should not rely on the DOM emulation and\n * only use internal data structures and state to compute this information.\n */\nexport function isDisconnectedRNode(rNode: RNode | null) {\n  return !!rNode && !(rNode as Node).isConnected;\n}\n\n/**\n * Locate a node in an i18n tree that corresponds to a given instruction index.\n *\n * @param hydrationInfo The hydration annotation data\n * @param noOffsetIndex the instruction index\n * @returns an RNode that corresponds to the instruction index\n */\nexport function locateI18nRNodeByIndex<T extends RNode>(\n  hydrationInfo: DehydratedView,\n  noOffsetIndex: number,\n): T | null | undefined {\n  const i18nNodes = hydrationInfo.i18nNodes;\n  if (i18nNodes) {\n    return i18nNodes.get(noOffsetIndex) as T | null | undefined;\n  }\n  return undefined;\n}\n\n/**\n * Attempt to locate an RNode by a path, if it exists.\n *\n * @param hydrationInfo The hydration annotation data\n * @param lView the current lView\n * @param noOffsetIndex the instruction index\n * @returns an RNode that corresponds to the instruction index or null if no path exists\n */\nexport function tryLocateRNodeByPath(\n  hydrationInfo: DehydratedView,\n  lView: LView<unknown>,\n  noOffsetIndex: number,\n): RNode | null {\n  const nodes = hydrationInfo.data[NODES];\n  const path = nodes?.[noOffsetIndex];\n  return path ? locateRNodeByPath(path, lView) : null;\n}\n\n/**\n * Locate a node in DOM tree that corresponds to a given TNode.\n *\n * @param hydrationInfo The hydration annotation data\n * @param tView the current tView\n * @param lView the current lView\n * @param tNode the current tNode\n * @returns an RNode that represents a given tNode\n */\nexport function locateNextRNode<T extends RNode>(\n  hydrationInfo: DehydratedView,\n  tView: TView,\n  lView: LView<unknown>,\n  tNode: TNode,\n): T | null {\n  const noOffsetIndex = getNoOffsetIndex(tNode);\n  let native = locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex);\n\n  if (native === undefined) {\n    const nodes = hydrationInfo.data[NODES];\n    if (nodes?.[noOffsetIndex]) {\n      // We know the exact location of the node.\n      native = locateRNodeByPath(nodes[noOffsetIndex], lView);\n    } else if (tView.firstChild === tNode) {\n      // We create a first node in this view, so we use a reference\n      // to the first child in this DOM segment.\n      native = hydrationInfo.firstChild;\n    } else {\n      // Locate a node based on a previous sibling or a parent node.\n      const previousTNodeParent = tNode.prev === null;\n      const previousTNode = (tNode.prev ?? tNode.parent)!;\n      ngDevMode &&\n        assertDefined(\n          previousTNode,\n          'Unexpected state: current TNode does not have a connection ' +\n            'to the previous node or a parent node.',\n        );\n      if (isFirstElementInNgContainer(tNode)) {\n        const noOffsetParentIndex = getNoOffsetIndex(tNode.parent!);\n        native = getSegmentHead(hydrationInfo, noOffsetParentIndex);\n      } else {\n        let previousRElement = getNativeByTNode(previousTNode, lView);\n        if (previousTNodeParent) {\n          native = (previousRElement as RElement).firstChild;\n        } else {\n          // If the previous node is an element, but it also has container info,\n          // this means that we are processing a node like `<div #vcrTarget>`, which is\n          // represented in the DOM as `<div></div>...<!--container-->`.\n          // In this case, there are nodes *after* this element and we need to skip\n          // all of them to reach an element that we are looking for.\n          const noOffsetPrevSiblingIndex = getNoOffsetIndex(previousTNode);\n          const segmentHead = getSegmentHead(hydrationInfo, noOffsetPrevSiblingIndex);\n          if (previousTNode.type === TNodeType.Element && segmentHead) {\n            const numRootNodesToSkip = calcSerializedContainerSize(\n              hydrationInfo,\n              noOffsetPrevSiblingIndex,\n            );\n            // `+1` stands for an anchor comment node after all the views in this container.\n            const nodesToSkip = numRootNodesToSkip + 1;\n            // First node after this segment.\n            native = siblingAfter(nodesToSkip, segmentHead);\n          } else {\n            native = previousRElement.nextSibling;\n          }\n        }\n      }\n    }\n  }\n  return native as T;\n}\n\n/**\n * Skips over a specified number of nodes and returns the next sibling node after that.\n */\nexport function siblingAfter<T extends RNode>(skip: number, from: RNode): T | null {\n  let currentNode = from;\n  for (let i = 0; i < skip; i++) {\n    ngDevMode && validateSiblingNodeExists(currentNode);\n    currentNode = currentNode.nextSibling!;\n  }\n  return currentNode as T;\n}\n\n/**\n * Helper function to produce a string representation of the navigation steps\n * (in terms of `nextSibling` and `firstChild` navigations). Used in error\n * messages in dev mode.\n */\nfunction stringifyNavigationInstructions(instructions: (number | NodeNavigationStep)[]): string {\n  const container = [];\n  for (let i = 0; i < instructions.length; i += 2) {\n    const step = instructions[i];\n    const repeat = instructions[i + 1] as number;\n    for (let r = 0; r < repeat; r++) {\n      container.push(step === NODE_NAVIGATION_STEP_FIRST_CHILD ? 'firstChild' : 'nextSibling');\n    }\n  }\n  return container.join('.');\n}\n\n/**\n * Helper function that navigates from a starting point node (the `from` node)\n * using provided set of navigation instructions (within `path` argument).\n */\nfunction navigateToNode(from: Node, instructions: (number | NodeNavigationStep)[]): RNode {\n  let node = from;\n  for (let i = 0; i < instructions.length; i += 2) {\n    const step = instructions[i];\n    const repeat = instructions[i + 1] as number;\n    for (let r = 0; r < repeat; r++) {\n      if (ngDevMode && !node) {\n        throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));\n      }\n      switch (step) {\n        case NODE_NAVIGATION_STEP_FIRST_CHILD:\n          node = node.firstChild!;\n          break;\n        case NODE_NAVIGATION_STEP_NEXT_SIBLING:\n          node = node.nextSibling!;\n          break;\n      }\n    }\n  }\n  if (ngDevMode && !node) {\n    throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));\n  }\n  return node as RNode;\n}\n\n/**\n * Locates an RNode given a set of navigation instructions (which also contains\n * a starting point node info).\n */\nfunction locateRNodeByPath(path: string, lView: LView): RNode {\n  const [referenceNode, ...navigationInstructions] = decompressNodeLocation(path);\n  let ref: Element;\n  if (referenceNode === REFERENCE_NODE_HOST) {\n    ref = lView[DECLARATION_COMPONENT_VIEW][HOST] as unknown as Element;\n  } else if (referenceNode === REFERENCE_NODE_BODY) {\n    ref = ɵɵresolveBody(\n      lView[DECLARATION_COMPONENT_VIEW][HOST] as RElement & {ownerDocument: Document},\n    );\n  } else {\n    const parentElementId = Number(referenceNode);\n    ref = unwrapRNode((lView as any)[parentElementId + HEADER_OFFSET]) as Element;\n  }\n  return navigateToNode(ref, navigationInstructions);\n}\n\n/**\n * Generate a list of DOM navigation operations to get from node `start` to node `finish`.\n *\n * Note: assumes that node `start` occurs before node `finish` in an in-order traversal of the DOM\n * tree. That is, we should be able to get from `start` to `finish` purely by using `.firstChild`\n * and `.nextSibling` operations.\n */\nexport function navigateBetween(start: Node, finish: Node): NodeNavigationStep[] | null {\n  if (start === finish) {\n    return [];\n  } else if (start.parentElement == null || finish.parentElement == null) {\n    return null;\n  } else if (start.parentElement === finish.parentElement) {\n    return navigateBetweenSiblings(start, finish);\n  } else {\n    // `finish` is a child of its parent, so the parent will always have a child.\n    const parent = finish.parentElement!;\n\n    const parentPath = navigateBetween(start, parent);\n    const childPath = navigateBetween(parent.firstChild!, finish);\n    if (!parentPath || !childPath) return null;\n\n    return [\n      // First navigate to `finish`'s parent\n      ...parentPath,\n      // Then to its first child.\n      NODE_NAVIGATION_STEP_FIRST_CHILD,\n      // And finally from that node to `finish` (maybe a no-op if we're already there).\n      ...childPath,\n    ];\n  }\n}\n\n/**\n * Calculates a path between 2 sibling nodes (generates a number of `NextSibling` navigations).\n * Returns `null` if no such path exists between the given nodes.\n */\nfunction navigateBetweenSiblings(start: Node, finish: Node): NodeNavigationStep[] | null {\n  const nav: NodeNavigationStep[] = [];\n  let node: Node | null = null;\n  for (node = start; node != null && node !== finish; node = node.nextSibling) {\n    nav.push(NODE_NAVIGATION_STEP_NEXT_SIBLING);\n  }\n  // If the `node` becomes `null` or `undefined` at the end, that means that we\n  // didn't find the `end` node, thus return `null` (which would trigger serialization\n  // error to be produced).\n  return node == null ? null : nav;\n}\n\n/**\n * Calculates a path between 2 nodes in terms of `nextSibling` and `firstChild`\n * navigations:\n * - the `from` node is a known node, used as an starting point for the lookup\n *   (the `fromNodeName` argument is a string representation of the node).\n * - the `to` node is a node that the runtime logic would be looking up,\n *   using the path generated by this function.\n */\nexport function calcPathBetween(from: Node, to: Node, fromNodeName: string): string | null {\n  const path = navigateBetween(from, to);\n  return path === null ? null : compressNodeLocation(fromNodeName, path);\n}\n\n/**\n * Invoked at serialization time (on the server) when a set of navigation\n * instructions needs to be generated for a TNode.\n */\nexport function calcPathForNode(\n  tNode: TNode,\n  lView: LView,\n  excludedParentNodes: Set<number> | null,\n): string {\n  let parentTNode = tNode.parent;\n  let parentIndex: number | string;\n  let parentRNode: RNode;\n  let referenceNodeName: string;\n\n  // Skip over all parent nodes that are disconnected from the DOM, such nodes\n  // can not be used as anchors.\n  //\n  // This might happen in certain content projection-based use-cases, where\n  // a content of an element is projected and used, when a parent element\n  // itself remains detached from DOM. In this scenario we try to find a parent\n  // element that is attached to DOM and can act as an anchor instead.\n  //\n  // It can also happen that the parent node should be excluded, for example,\n  // because it belongs to an i18n block, which requires paths which aren't\n  // relative to other views in an i18n block.\n  while (\n    parentTNode !== null &&\n    (isDisconnectedNode(parentTNode, lView) || excludedParentNodes?.has(parentTNode.index))\n  ) {\n    parentTNode = parentTNode.parent;\n  }\n\n  if (parentTNode === null || !(parentTNode.type & TNodeType.AnyRNode)) {\n    // If there is no parent TNode or a parent TNode does not represent an RNode\n    // (i.e. not a DOM node), use component host element as a reference node.\n    parentIndex = referenceNodeName = REFERENCE_NODE_HOST;\n    parentRNode = lView[DECLARATION_COMPONENT_VIEW][HOST]!;\n  } else {\n    // Use parent TNode as a reference node.\n    parentIndex = parentTNode.index;\n    parentRNode = unwrapRNode(lView[parentIndex]);\n    referenceNodeName = renderStringify(parentIndex - HEADER_OFFSET);\n  }\n  let rNode = unwrapRNode(lView[tNode.index]);\n  if (tNode.type & (TNodeType.AnyContainer | TNodeType.Icu)) {\n    // For <ng-container> nodes, instead of serializing a reference\n    // to the anchor comment node, serialize a location of the first\n    // DOM element. Paired with the container size (serialized as a part\n    // of `ngh.containers`), it should give enough information for runtime\n    // to hydrate nodes in this container.\n    const firstRNode = getFirstNativeNode(lView, tNode);\n\n    // If container is not empty, use a reference to the first element,\n    // otherwise, rNode would point to an anchor comment node.\n    if (firstRNode) {\n      rNode = firstRNode;\n    }\n  }\n  let path: string | null = calcPathBetween(parentRNode as Node, rNode as Node, referenceNodeName);\n  if (path === null && parentRNode !== rNode) {\n    // Searching for a path between elements within a host node failed.\n    // Trying to find a path to an element starting from the `document.body` instead.\n    //\n    // Important note: this type of reference is relatively unstable, since Angular\n    // may not be able to control parts of the page that the runtime logic navigates\n    // through. This is mostly needed to cover \"portals\" use-case (like menus, dialog boxes,\n    // etc), where nodes are content-projected (including direct DOM manipulations) outside\n    // of the host node. The better solution is to provide APIs to work with \"portals\",\n    // at which point this code path would not be needed.\n    const body = (parentRNode as Node).ownerDocument!.body as Node;\n    path = calcPathBetween(body, rNode as Node, REFERENCE_NODE_BODY);\n\n    if (path === null) {\n      // If the path is still empty, it's likely that this node is detached and\n      // won't be found during hydration.\n      throw nodeNotFoundError(lView, tNode);\n    }\n  }\n  return path!;\n}\n\n/**\n * Retrieves all comments nodes that contain ngh comments referring to a defer block\n */\nexport function gatherDeferBlocksCommentNodes(\n  doc: Document,\n  node: HTMLElement,\n): Map<string, Comment> {\n  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {acceptNode});\n  let currentNode: Comment;\n\n  const nodesByBlockId = new Map<string, Comment>();\n  while ((currentNode = commentNodesIterator.nextNode() as Comment)) {\n    const nghPattern = 'ngh=';\n    const content = currentNode?.textContent;\n    const nghIdx = content?.indexOf(nghPattern) ?? -1;\n    if (nghIdx > -1) {\n      const nghValue = content!.substring(nghIdx + nghPattern.length).trim();\n      // Make sure the value has an expected format.\n      ngDevMode &&\n        assertEqual(\n          nghValue.startsWith('d'),\n          true,\n          'Invalid defer block id found in a comment node.',\n        );\n      nodesByBlockId.set(nghValue, currentNode);\n    }\n  }\n  return nodesByBlockId;\n}\n\nfunction acceptNode(node: HTMLElement) {\n  return node.textContent?.trimStart().startsWith('ngh=')\n    ? NodeFilter.FILTER_ACCEPT\n    : NodeFilter.FILTER_REJECT;\n}\n"]}