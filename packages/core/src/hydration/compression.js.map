{"version":3,"file":"compression.js","sourceRoot":"","sources":["compression.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAqB,mBAAmB,EAAE,mBAAmB,EAAC,MAAM,cAAc,CAAC;AAE1F;;;;;;GAMG;AACH,MAAM,oBAAoB,GAAG,eAAe,CAAC,IAAI,MAAM,CACrD,YAAY,mBAAmB,IAAI,mBAAmB,QAAQ,CAC/D,CAAC;AAEF;;;;;;;GAOG;AACH,MAAM,UAAU,oBAAoB,CAAC,aAAqB,EAAE,IAA0B;IACpF,MAAM,MAAM,GAA2B,CAAC,aAAa,CAAC,CAAC;IACvD,KAAK,MAAM,OAAO,IAAI,IAAI,EAAE,CAAC;QAC3B,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;QAClC,IAAI,OAAO,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC,KAAK,OAAO,EAAE,CAAC;YACnD,6EAA6E;YAC7E,MAAM,KAAK,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAW,CAAC;YAC/C,MAAM,CAAC,OAAO,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC;QAC9B,CAAC;aAAM,CAAC;YACN,oCAAoC;YACpC,kEAAkE;YAClE,mEAAmE;YACnE,kDAAkD;YAClD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;QAC3B,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACzB,CAAC;AAED;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,sBAAsB,CACpC,IAAY;IAEZ,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAE,CAAC;IAClD,MAAM,CAAC,CAAC,EAAE,SAAS,EAAE,WAAW,EAAE,IAAI,CAAC,GAAG,OAAO,CAAC;IAClD,4EAA4E;IAC5E,MAAM,GAAG,GAAG,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;IAC9D,MAAM,KAAK,GAAoC,EAAE,CAAC;IAClD,gCAAgC;IAChC,KAAK,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE,CAAC;QAC5D,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC;QACxC,KAAK,CAAC,IAAI,CAAC,IAA0B,EAAE,MAAM,CAAC,CAAC;IACjD,CAAC;IACD,OAAO,CAAC,GAAG,EAAE,GAAG,KAAK,CAAC,CAAC;AACzB,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NodeNavigationStep, REFERENCE_NODE_BODY, REFERENCE_NODE_HOST} from './interfaces';\n\n/**\n * Regexp that extracts a reference node information from the compressed node location.\n * The reference node is represented as either:\n *  - a number which points to an LView slot\n *  - the `b` char which indicates that the lookup should start from the `document.body`\n *  - the `h` char to start lookup from the component host node (`lView[HOST]`)\n */\nconst REF_EXTRACTOR_REGEXP = /* @__PURE__ */ new RegExp(\n  `^(\\\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`,\n);\n\n/**\n * Helper function that takes a reference node location and a set of navigation steps\n * (from the reference node) to a target node and outputs a string that represents\n * a location.\n *\n * For example, given: referenceNode = 'b' (body) and path = ['firstChild', 'firstChild',\n * 'nextSibling'], the function returns: `bf2n`.\n */\nexport function compressNodeLocation(referenceNode: string, path: NodeNavigationStep[]): string {\n  const result: Array<string | number> = [referenceNode];\n  for (const segment of path) {\n    const lastIdx = result.length - 1;\n    if (lastIdx > 0 && result[lastIdx - 1] === segment) {\n      // An empty string in a count slot represents 1 occurrence of an instruction.\n      const value = (result[lastIdx] || 1) as number;\n      result[lastIdx] = value + 1;\n    } else {\n      // Adding a new segment to the path.\n      // Using an empty string in a counter field to avoid encoding `1`s\n      // into the path, since they are implicit (e.g. `f1n1` vs `fn`), so\n      // it's enough to have a single char in this case.\n      result.push(segment, '');\n    }\n  }\n  return result.join('');\n}\n\n/**\n * Helper function that reverts the `compressNodeLocation` and transforms a given\n * string into an array where at 0th position there is a reference node info and\n * after that it contains information (in pairs) about a navigation step and the\n * number of repetitions.\n *\n * For example, the path like 'bf2n' will be transformed to:\n * ['b', 'firstChild', 2, 'nextSibling', 1].\n *\n * This information is later consumed by the code that navigates the DOM to find\n * a given node by its location.\n */\nexport function decompressNodeLocation(\n  path: string,\n): [string | number, ...(number | NodeNavigationStep)[]] {\n  const matches = path.match(REF_EXTRACTOR_REGEXP)!;\n  const [_, refNodeId, refNodeName, rest] = matches;\n  // If a reference node is represented by an index, transform it to a number.\n  const ref = refNodeId ? parseInt(refNodeId, 10) : refNodeName;\n  const steps: (number | NodeNavigationStep)[] = [];\n  // Match all segments in a path.\n  for (const [_, step, count] of rest.matchAll(/(f|n)(\\d*)/g)) {\n    const repeat = parseInt(count, 10) || 1;\n    steps.push(step as NodeNavigationStep, repeat);\n  }\n  return [ref, ...steps];\n}\n"]}