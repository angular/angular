{"version":3,"file":"interfaces.js","sourceRoot":"","sources":["interfaces.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAMH,sFAAsF;AACtF,MAAM,CAAC,MAAM,mBAAmB,GAAG,GAAG,CAAC;AAEvC,6EAA6E;AAC7E,MAAM,CAAC,MAAM,mBAAmB,GAAG,GAAG,CAAC;AAYvC,MAAM,CAAC,MAAM,gCAAgC,GAAG,GAAG,CAAC;AACpD,MAAM,CAAC,MAAM,iCAAiC,GAAG,GAAG,CAAC;AAErD;;;GAGG;AACH,MAAM,CAAC,MAAM,kBAAkB,GAAG,GAAG,CAAC;AACtC,MAAM,CAAC,MAAM,SAAS,GAAG,GAAG,CAAC;AAC7B,MAAM,CAAC,MAAM,UAAU,GAAG,GAAG,CAAC;AAC9B,MAAM,CAAC,MAAM,UAAU,GAAG,GAAG,CAAC;AAC9B,MAAM,CAAC,MAAM,cAAc,GAAG,GAAG,CAAC;AAClC,MAAM,CAAC,MAAM,WAAW,GAAG,GAAG,CAAC,CAAC,uBAAuB;AACvD,MAAM,CAAC,MAAM,KAAK,GAAG,GAAG,CAAC;AACzB,MAAM,CAAC,MAAM,kBAAkB,GAAG,GAAG,CAAC;AACtC,MAAM,CAAC,MAAM,SAAS,GAAG,GAAG,CAAC;AAC7B,MAAM,CAAC,MAAM,cAAc,GAAG,IAAI,CAAC;AACnC,MAAM,CAAC,MAAM,iBAAiB,GAAG,GAAG,CAAC;AACrC,MAAM,CAAC,MAAM,qBAAqB,GAAG,GAAG,CAAC;AACzC,MAAM,CAAC,MAAM,sBAAsB,GAAG,GAAG,CAAC;AAC1C,MAAM,CAAC,MAAM,uBAAuB,GAAG,IAAI,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {DeferBlockTrigger} from '../defer/interfaces';\nimport type {I18nICUNode} from '../render3/interfaces/i18n';\nimport {RNode} from '../render3/interfaces/renderer_dom';\n\n/** Encodes that the node lookup should start from the host node of this component. */\nexport const REFERENCE_NODE_HOST = 'h';\n\n/** Encodes that the node lookup should start from the document body node. */\nexport const REFERENCE_NODE_BODY = 'b';\n\n/**\n * Describes navigation steps that the runtime logic need to perform,\n * starting from a given (known) element.\n * We're not using enum `NodeNavigationStep` because it produces more code overhead;\n * thus, using plain `const` eliminates extra bytes. We can't use `const enum` due\n * to single-file compilation restrictions.\n */\n\nexport type NodeNavigationStep = 'f' | 'n';\n\nexport const NODE_NAVIGATION_STEP_FIRST_CHILD = 'f';\nexport const NODE_NAVIGATION_STEP_NEXT_SIBLING = 'n';\n\n/**\n * Keys within serialized view data structure to represent various\n * parts. See the `SerializedView` interface below for additional information.\n */\nexport const ELEMENT_CONTAINERS = 'e';\nexport const TEMPLATES = 't';\nexport const CONTAINERS = 'c';\nexport const MULTIPLIER = 'x';\nexport const NUM_ROOT_NODES = 'r';\nexport const TEMPLATE_ID = 'i'; // as it's also an \"id\"\nexport const NODES = 'n';\nexport const DISCONNECTED_NODES = 'd';\nexport const I18N_DATA = 'l';\nexport const DEFER_BLOCK_ID = 'di';\nexport const DEFER_BLOCK_STATE = 's';\nexport const DEFER_PARENT_BLOCK_ID = 'p';\nexport const DEFER_HYDRATE_TRIGGERS = 't';\nexport const DEFER_PREFETCH_TRIGGERS = 'pt';\n\n/**\n * Represents element containers within this view, stored as key-value pairs\n * where key is an index of a container in an LView (also used in the\n * `elementContainerStart` instruction), the value is the number of root nodes\n * in this container. This information is needed to locate an anchor comment\n * node that goes after all container nodes.\n */\nexport interface SerializedElementContainers {\n  [key: number]: number;\n}\n\n/**\n * Serialized data structure that contains relevant hydration\n * annotation information that describes a given hydration boundary\n * (e.g. a component).\n */\nexport interface SerializedView {\n  /**\n   * Serialized information about <ng-container>s.\n   */\n  [ELEMENT_CONTAINERS]?: SerializedElementContainers;\n\n  /**\n   * Serialized information about templates.\n   * Key-value pairs where a key is an index of the corresponding\n   * `template` instruction and the value is a unique id that can\n   * be used during hydration to identify that template.\n   */\n  [TEMPLATES]?: Record<number, string>;\n\n  /**\n   * Serialized information about view containers.\n   * Key-value pairs where a key is an index of the corresponding\n   * LContainer entry within an LView, and the value is a list\n   * of serialized information about views within this container.\n   */\n  [CONTAINERS]?: Record<number, SerializedContainerView[]>;\n\n  /**\n   * Serialized information about nodes in a template.\n   * Key-value pairs where a key is an index of the corresponding\n   * DOM node in an LView and the value is a path that describes\n   * the location of this node (as a set of navigation instructions).\n   */\n  [NODES]?: Record<number, string>;\n\n  /**\n   * A list of ids which represents a set of nodes disconnected\n   * from the DOM tree at the serialization time, but otherwise\n   * present in the internal data structures.\n   *\n   * This information is used to avoid triggering the hydration\n   * logic for such nodes and instead use a regular \"creation mode\".\n   */\n  [DISCONNECTED_NODES]?: number[];\n\n  /**\n   * Serialized information about i18n blocks in a template.\n   * Key-value pairs where a key is an index of the corresponding\n   * i18n entry within an LView, and the value is a list of\n   * active ICU cases.\n   */\n  [I18N_DATA]?: Record<number, number[]>;\n\n  /**\n   * If this view represents a `@defer` block, this field contains\n   * unique id of the block.\n   */\n  [DEFER_BLOCK_ID]?: string;\n\n  /**\n   * This field represents a status, based on the `DeferBlockState` enum.\n   */\n  [DEFER_BLOCK_STATE]?: number;\n}\n\n/**\n * Serialized data structure that contains relevant hydration\n * annotation information about a view that is a part of a\n * ViewContainer collection.\n */\nexport interface SerializedContainerView extends SerializedView {\n  /**\n   * Unique id that represents a TView that was used to create\n   * a given instance of a view:\n   *  - TViewType.Embedded: a unique id generated during serialization on the server\n   *  - TViewType.Component: an id generated based on component properties\n   *                        (see `getComponentId` function for details)\n   */\n  [TEMPLATE_ID]: string;\n\n  /**\n   * Number of root nodes that belong to this view.\n   * This information is needed to effectively traverse the DOM tree\n   * and identify segments that belong to different views.\n   */\n  [NUM_ROOT_NODES]: number;\n\n  /**\n   * Number of times this view is repeated.\n   * This is used to avoid serializing and sending the same hydration\n   * information about similar views (for example, produced by *ngFor).\n   */\n  [MULTIPLIER]?: number;\n}\n\n/**\n * Serialized data structure that contains relevant defer block\n * information that describes a given incremental hydration boundary\n */\nexport interface SerializedDeferBlock {\n  /**\n   * This contains the unique id of this defer block's parent, if it exists.\n   */\n  [DEFER_PARENT_BLOCK_ID]?: string;\n\n  /**\n   * This field represents a status, based on the `DeferBlockState` enum.\n   */\n  [DEFER_BLOCK_STATE]?: number;\n\n  /**\n   * Number of root nodes that belong to this defer block's template.\n   * This information is needed to effectively traverse the DOM tree\n   * and add jsaction attributes to root nodes appropriately for\n   * incremental hydration.\n   */\n  [NUM_ROOT_NODES]: number;\n\n  /**\n   * The list of triggers that exist for incremental hydration, based on the\n   * `Trigger` enum.\n   */\n  [DEFER_HYDRATE_TRIGGERS]?: (DeferBlockTrigger | SerializedTriggerDetails)[];\n}\n\nexport interface SerializedTriggerDetails {\n  trigger: DeferBlockTrigger;\n  delay?: number;\n}\n\n/**\n * An object that contains hydration-related information serialized\n * on the server, as well as the necessary references to segments of\n * the DOM, to facilitate the hydration process for a given hydration\n * boundary on the client.\n */\nexport interface DehydratedView {\n  /**\n   * The readonly hydration annotation data.\n   */\n  data: Readonly<SerializedView>;\n\n  /**\n   * A reference to the first child in a DOM segment associated\n   * with a given hydration boundary.\n   *\n   * Once a view becomes hydrated, the value is set to `null`, which\n   * indicates that further detaching/attaching view actions should result\n   * in invoking corresponding DOM actions (attaching DOM nodes action is\n   * skipped when we hydrate, since nodes are already in the DOM).\n   */\n  firstChild: RNode | null;\n\n  /**\n   * Stores references to first nodes in DOM segments that\n   * represent either an <ng-container> or a view container.\n   */\n  segmentHeads?: {[index: number]: RNode | null};\n\n  /**\n   * An instance of a Set that represents nodes disconnected from\n   * the DOM tree at the serialization time, but otherwise present\n   * in the internal data structures.\n   *\n   * The Set is based on the `SerializedView[DISCONNECTED_NODES]` data\n   * and is needed to have constant-time lookups.\n   *\n   * If the value is `null`, it means that there were no disconnected\n   * nodes detected in this view at serialization time.\n   */\n  disconnectedNodes?: Set<number> | null;\n\n  /**\n   * A mapping from a view to the first child to begin claiming nodes.\n   *\n   * This mapping is generated by an i18n block, and is the source of\n   * truth for the nodes inside of it.\n   */\n  i18nNodes?: Map<number, RNode | null>;\n\n  /**\n   * A mapping from the index of an ICU node to dehydrated data for it.\n   *\n   * This information is used during the hydration process on the client.\n   * ICU cases that were active during server-side rendering will be added\n   * to the map. The hydration logic will \"claim\" matching cases, removing\n   * them from the map. The remaining entries are \"unclaimed\", and will be\n   * removed from the DOM during hydration cleanup.\n   */\n  dehydratedIcuData?: Map<number, DehydratedIcuData>;\n}\n\n/**\n * An object that contains hydration-related information serialized\n * on the server, as well as the necessary references to segments of\n * the DOM, to facilitate the hydration process for a given view\n * inside a view container (either an embedded view or a view created\n * for a component).\n */\nexport interface DehydratedContainerView extends DehydratedView {\n  data: Readonly<SerializedContainerView>;\n}\n\n/**\n * An object that contains information about a dehydrated ICU case,\n * to facilitate cleaning up ICU cases that were active during\n * server-side rendering, but not during hydration.\n */\nexport interface DehydratedIcuData {\n  /**\n   * The case index that this data represents.\n   */\n  case: number;\n\n  /**\n   * A reference back to the AST for the ICU node. This allows the\n   * AST to be used to clean up dehydrated nodes.\n   */\n  node: I18nICUNode;\n}\n\n/**\n * Summarizes the presence of specific types of triggers anywhere in the DOM\n */\nexport interface BlockSummary {\n  data: SerializedDeferBlock;\n  hydrate: {idle: boolean; immediate: boolean; viewport: boolean; timer: number | null};\n}\n\n/**\n * The details of a specific element's trigger and how it is associated to a block\n */\nexport interface ElementTrigger {\n  el: HTMLElement;\n  blockName: string;\n  delay?: number;\n}\n"]}