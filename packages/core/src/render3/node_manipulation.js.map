{"version":3,"file":"node_manipulation.js","sourceRoot":"","sources":["node_manipulation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {consumerDestroy, setActiveConsumer} from '../../primitives/signals';\n\nimport {NotificationSource} from '../change_detection/scheduling/zoneless_scheduling';\nimport {hasInSkipHydrationBlockFlag} from '../hydration/skip_hydration';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {RendererStyleFlags2} from '../render/api_flags';\nimport {\n  assertDefined,\n  assertEqual,\n  assertFunction,\n  assertNotReactive,\n  assertNumber,\n} from '../util/assert';\n\nimport {isDetachedByI18n} from '../i18n/utils';\nimport {\n  assertLContainer,\n  assertParentView,\n  assertProjectionSlots,\n  assertTNodeForLView,\n} from './assert';\nimport {attachPatchData} from './context_discovery';\nimport {\n  nativeAppendChild,\n  nativeAppendOrInsertBefore,\n  nativeInsertBefore,\n  nativeRemoveNode,\n} from './dom_node_manipulation';\nimport {icuContainerIterate} from './i18n/i18n_tree_shaking';\nimport {CONTAINER_HEADER_OFFSET, LContainer, MOVED_VIEWS, NATIVE} from './interfaces/container';\nimport {ComponentDef} from './interfaces/definition';\nimport {NodeInjectorFactory} from './interfaces/injector';\nimport {unregisterLView} from './interfaces/lview_tracking';\nimport {\n  TElementNode,\n  TIcuContainerNode,\n  TNode,\n  TNodeFlags,\n  TNodeType,\n  TProjectionNode,\n} from './interfaces/node';\nimport {Renderer} from './interfaces/renderer';\nimport {RElement, RNode} from './interfaces/renderer_dom';\nimport {isComponentHost, isDestroyed, isLContainer, isLView} from './interfaces/type_checks';\nimport {\n  CHILD_HEAD,\n  CLEANUP,\n  DECLARATION_COMPONENT_VIEW,\n  DECLARATION_LCONTAINER,\n  DestroyHookData,\n  EFFECTS,\n  ENVIRONMENT,\n  FLAGS,\n  HookData,\n  HookFn,\n  HOST,\n  ANIMATIONS,\n  LView,\n  LViewFlags,\n  NEXT,\n  ON_DESTROY_HOOKS,\n  PARENT,\n  QUERIES,\n  REACTIVE_TEMPLATE_CONSUMER,\n  RENDERER,\n  T_HOST,\n  TVIEW,\n  TView,\n  TViewType,\n} from './interfaces/view';\nimport {assertTNodeType} from './node_assert';\nimport {profiler} from './profiler';\nimport {ProfilerEvent} from './profiler_types';\nimport {getLViewParent, getNativeByTNode, unwrapRNode} from './util/view_utils';\nimport {allLeavingAnimations} from '../animation/longest_animation';\n\nconst enum WalkTNodeTreeAction {\n  /** node create in the native environment. Run on initial creation. */\n  Create = 0,\n\n  /**\n   * node insert in the native environment.\n   * Run when existing node has been detached and needs to be re-attached.\n   */\n  Insert = 1,\n\n  /** node detach from the native environment */\n  Detach = 2,\n\n  /** node destruction using the renderer's API */\n  Destroy = 3,\n}\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(\n  action: WalkTNodeTreeAction,\n  renderer: Renderer,\n  parent: RElement | null,\n  lNodeToHandle: RNode | LContainer | LView,\n  beforeNode?: RNode | null,\n  parentLView?: LView,\n) {\n  // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n  // won't be created until i18nApply() in the update block, so this node should be skipped.\n  // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n  // in `i18n_spec.ts`.\n  if (lNodeToHandle != null) {\n    let lContainer: LContainer | undefined;\n    let isComponent = false;\n    // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n    // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n    // it has LContainer so that we can process all of those cases appropriately.\n    if (isLContainer(lNodeToHandle)) {\n      lContainer = lNodeToHandle;\n    } else if (isLView(lNodeToHandle)) {\n      isComponent = true;\n      ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n      lNodeToHandle = lNodeToHandle[HOST]!;\n    }\n    const rNode: RNode = unwrapRNode(lNodeToHandle);\n\n    if (action === WalkTNodeTreeAction.Create && parent !== null) {\n      if (beforeNode == null) {\n        nativeAppendChild(renderer, parent, rNode);\n      } else {\n        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n      }\n    } else if (action === WalkTNodeTreeAction.Insert && parent !== null) {\n      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n    } else if (action === WalkTNodeTreeAction.Detach) {\n      runLeaveAnimationsWithCallback(parentLView, (nodeHasLeaveAnimations: boolean) => {\n        // the nodeHasLeaveAnimations indicates to the renderer that the element needs to\n        // be removed synchronously and sets the requireSynchronousElementRemoval flag in\n        // the renderer.\n        nativeRemoveNode(renderer, rNode, isComponent, nodeHasLeaveAnimations);\n      });\n    } else if (action === WalkTNodeTreeAction.Destroy) {\n      runLeaveAnimationsWithCallback(parentLView, () => {\n        renderer.destroyNode!(rNode);\n      });\n    }\n    if (lContainer != null) {\n      applyContainer(renderer, action, lContainer, parent, beforeNode);\n    }\n  }\n}\n\n/**\n * Removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n */\nexport function removeViewFromDOM(tView: TView, lView: LView): void {\n  detachViewFromDOM(tView, lView);\n  lView[HOST] = null;\n  lView[T_HOST] = null;\n}\n\n/**\n * Adds all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to add all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param parentTNode The `TNode` where the `LView` should be attached to.\n * @param renderer Current renderer to use for DOM manipulations.\n * @param lView The view from which elements should be added or removed\n * @param parentNativeNode The parent `RElement` where it should be inserted into.\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addViewToDOM(\n  tView: TView,\n  parentTNode: TNode,\n  renderer: Renderer,\n  lView: LView,\n  parentNativeNode: RElement,\n  beforeNode: RNode | null,\n): void {\n  lView[HOST] = parentNativeNode;\n  lView[T_HOST] = parentTNode;\n  applyView(tView, lView, renderer, WalkTNodeTreeAction.Insert, parentNativeNode, beforeNode);\n}\n\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\nexport function detachViewFromDOM(tView: TView, lView: LView) {\n  // When we remove a view from the DOM, we need to rerun afterRender hooks\n  // We don't necessarily needs to run change detection. DOM removal only requires\n  // change detection if animations are enabled (this notification is handled by animations).\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(NotificationSource.ViewDetachedFromDOM);\n  applyView(tView, lView, lView[RENDERER], WalkTNodeTreeAction.Detach, null, null);\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LView): void {\n  // If the view has no children, we can clean it up and return early.\n  let lViewOrLContainer = rootView[CHILD_HEAD];\n  if (!lViewOrLContainer) {\n    return cleanUpView(rootView[TVIEW], rootView);\n  }\n\n  while (lViewOrLContainer) {\n    let next: LView | LContainer | null = null;\n\n    if (isLView(lViewOrLContainer)) {\n      // If LView, traverse down to child.\n      next = lViewOrLContainer[CHILD_HEAD];\n    } else {\n      ngDevMode && assertLContainer(lViewOrLContainer);\n      // If container, traverse down to its first LView.\n      const firstView: LView | undefined = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n      if (firstView) next = firstView;\n    }\n\n    if (!next) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (lViewOrLContainer && !lViewOrLContainer![NEXT] && lViewOrLContainer !== rootView) {\n        if (isLView(lViewOrLContainer)) {\n          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n        }\n        lViewOrLContainer = lViewOrLContainer[PARENT];\n      }\n      if (lViewOrLContainer === null) lViewOrLContainer = rootView;\n      if (isLView(lViewOrLContainer)) {\n        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n      }\n      next = lViewOrLContainer && lViewOrLContainer![NEXT];\n    }\n    lViewOrLContainer = next;\n  }\n}\n\nexport function detachMovedView(declarationContainer: LContainer, lView: LView) {\n  ngDevMode && assertLContainer(declarationContainer);\n  ngDevMode &&\n    assertDefined(\n      declarationContainer[MOVED_VIEWS],\n      'A projected view should belong to a non-empty projected views collection',\n    );\n  const movedViews = declarationContainer[MOVED_VIEWS]!;\n  const declarationViewIndex = movedViews.indexOf(lView);\n  movedViews.splice(declarationViewIndex, 1);\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\nexport function destroyLView(tView: TView, lView: LView) {\n  if (isDestroyed(lView)) {\n    return;\n  }\n  const renderer = lView[RENDERER];\n\n  if (renderer.destroyNode) {\n    applyView(tView, lView, renderer, WalkTNodeTreeAction.Destroy, null, null);\n  }\n  destroyViewTree(lView);\n}\n\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\nfunction cleanUpView(tView: TView, lView: LView): void {\n  if (isDestroyed(lView)) {\n    return;\n  }\n\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    // Usually the Attached flag is removed when the view is detached from its parent, however\n    // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n    lView[FLAGS] &= ~LViewFlags.Attached;\n\n    // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n    // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n    // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n    // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n    // really more of an \"afterDestroy\" hook if you think about it.\n    lView[FLAGS] |= LViewFlags.Destroyed;\n\n    lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);\n\n    executeOnDestroys(tView, lView);\n    processCleanups(tView, lView);\n    // For component views only, the local renderer is destroyed at clean up time.\n    if (lView[TVIEW].type === TViewType.Component) {\n      lView[RENDERER].destroy();\n    }\n\n    const declarationContainer = lView[DECLARATION_LCONTAINER];\n    // we are dealing with an embedded view that is still inserted into a container\n    if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n      // and this is a projected view\n      if (declarationContainer !== lView[PARENT]) {\n        detachMovedView(declarationContainer, lView);\n      }\n\n      // For embedded views still attached to a container: remove query result from this view.\n      const lQueries = lView[QUERIES];\n      if (lQueries !== null) {\n        lQueries.detachView(tView);\n      }\n    }\n\n    // Unregister the view once everything else has been cleaned up.\n    unregisterLView(lView);\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n\nfunction hasLeaveAnimations(lView: LView | undefined): boolean {\n  return lView !== undefined && lView[ANIMATIONS] !== null && lView[ANIMATIONS].leave !== undefined;\n}\n\nfunction runLeaveAnimationsWithCallback(lView: LView | undefined, callback: Function) {\n  if (lView && lView[ANIMATIONS] && lView[ANIMATIONS].leave) {\n    if (lView[ANIMATIONS].skipLeaveAnimations) {\n      lView[ANIMATIONS].skipLeaveAnimations = false;\n    } else {\n      const leaveAnimations = lView[ANIMATIONS].leave;\n      const runningAnimations = [];\n      for (let index = 0; index < leaveAnimations.length; index++) {\n        const animateFn = leaveAnimations[index];\n        runningAnimations.push(animateFn());\n      }\n      lView[ANIMATIONS].running = Promise.allSettled(runningAnimations);\n      lView[ANIMATIONS].leave = undefined;\n    }\n  }\n  runAfterLeaveAnimations(lView, callback);\n}\n\nfunction runAfterLeaveAnimations(lView: LView | undefined, callback: Function) {\n  if (lView && lView[ANIMATIONS] && lView[ANIMATIONS].running) {\n    lView[ANIMATIONS].running.then(() => {\n      if (lView[ANIMATIONS] && lView[ANIMATIONS].running) {\n        lView[ANIMATIONS].running = undefined;\n      }\n      allLeavingAnimations.delete(lView);\n      callback(true);\n    });\n    return;\n  }\n  callback(false);\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction processCleanups(tView: TView, lView: LView): void {\n  ngDevMode && assertNotReactive(processCleanups.name);\n  const tCleanup = tView.cleanup;\n  const lCleanup = lView[CLEANUP]!;\n  if (tCleanup !== null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a native DOM listener. It will occupy 4 entries in the TCleanup array (hence i +=\n        // 2 at the end of this block).\n        const targetIdx = tCleanup[i + 3];\n        ngDevMode && assertNumber(targetIdx, 'cleanup target must be a number');\n        if (targetIdx >= 0) {\n          // Destroy anything whose teardown is a function call (e.g. QueryList, ModelSignal).\n          lCleanup[targetIdx]();\n        } else {\n          // Subscription\n          lCleanup[-targetIdx].unsubscribe();\n        }\n        i += 2;\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n  }\n  if (lCleanup !== null) {\n    lView[CLEANUP] = null;\n  }\n  const destroyHooks = lView[ON_DESTROY_HOOKS];\n  if (destroyHooks !== null) {\n    // Reset the ON_DESTROY_HOOKS array before iterating over it to prevent hooks that unregister\n    // themselves from mutating the array during iteration.\n    lView[ON_DESTROY_HOOKS] = null;\n    for (let i = 0; i < destroyHooks.length; i++) {\n      const destroyHooksFn = destroyHooks[i];\n      ngDevMode && assertFunction(destroyHooksFn, 'Expecting destroy hook to be a function.');\n      destroyHooksFn();\n    }\n  }\n\n  // Destroy effects registered to the view. Many of these will have been processed above.\n  const effects = lView[EFFECTS];\n  if (effects !== null) {\n    lView[EFFECTS] = null;\n    for (const effect of effects) {\n      effect.destroy();\n    }\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(tView: TView, lView: LView): void {\n  ngDevMode && assertNotReactive(executeOnDestroys.name);\n  let destroyHooks: DestroyHookData | null;\n\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    for (let i = 0; i < destroyHooks.length; i += 2) {\n      const context = lView[destroyHooks[i] as number];\n\n      // Only call the destroy hook if the context has been requested.\n      if (!(context instanceof NodeInjectorFactory)) {\n        const toCall = destroyHooks[i + 1] as HookFn | HookData;\n\n        if (Array.isArray(toCall)) {\n          for (let j = 0; j < toCall.length; j += 2) {\n            const callContext = context[toCall[j] as number];\n            const hook = toCall[j + 1] as HookFn;\n            profiler(ProfilerEvent.LifecycleHookStart, callContext, hook);\n            try {\n              hook.call(callContext);\n            } finally {\n              profiler(ProfilerEvent.LifecycleHookEnd, callContext, hook);\n            }\n          }\n        } else {\n          profiler(ProfilerEvent.LifecycleHookStart, context, toCall);\n          try {\n            toCall.call(context);\n          } finally {\n            profiler(ProfilerEvent.LifecycleHookEnd, context, toCall);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve render parent.\n * @param lView: Current `LView`.\n */\nexport function getParentRElement(tView: TView, tNode: TNode, lView: LView): RElement | null {\n  return getClosestRElement(tView, tNode.parent, lView);\n}\n\n/**\n * Get closest `RElement` or `null` if it can't be found.\n *\n * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n * If `TNode` is `null` then return host `RElement`:\n *   - return `null` if projection\n *   - return `null` if parent container is disconnected (we have no parent.)\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n *     needed).\n * @param lView: Current `LView`.\n * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n */\nexport function getClosestRElement(\n  tView: TView,\n  tNode: TNode | null,\n  lView: LView,\n): RElement | null {\n  let parentTNode: TNode | null = tNode;\n  // Skip over element and ICU containers as those are represented by a comment node and\n  // can't be used as a render parent. Also skip let declarations since they don't have a\n  // corresponding DOM node at all.\n  while (\n    parentTNode !== null &&\n    parentTNode.type & (TNodeType.ElementContainer | TNodeType.Icu | TNodeType.LetDeclaration)\n  ) {\n    tNode = parentTNode;\n    parentTNode = tNode.parent;\n  }\n\n  // If the parent tNode is null, then we are inserting across views: either into an embedded view\n  // or a component view.\n  if (parentTNode === null) {\n    // We are inserting a root element of the component view into the component host element and\n    // it should always be eager.\n    return lView[HOST];\n  } else {\n    ngDevMode && assertTNodeType(parentTNode, TNodeType.AnyRNode | TNodeType.Container);\n    if (isComponentHost(parentTNode)) {\n      ngDevMode && assertTNodeForLView(parentTNode, lView);\n      const {encapsulation} = tView.data[\n        parentTNode.directiveStart + parentTNode.componentOffset\n      ] as ComponentDef<unknown>;\n      // We've got a parent which is an element in the current view. We just need to verify if the\n      // parent element is not a component. Component's content nodes are not inserted immediately\n      // because they will be projected, and so doing insert at this point would be wasteful.\n      // Since the projection would then move it to its final destination. Note that we can't\n      // make this assumption when using the Shadow DOM, because the native projection placeholders\n      // (<content> or <slot>) have to be in place as elements are being inserted.\n      if (\n        encapsulation === ViewEncapsulation.None ||\n        encapsulation === ViewEncapsulation.Emulated\n      ) {\n        return null;\n      }\n    }\n\n    return getNativeByTNode(parentTNode, lView) as RElement;\n  }\n}\n\n/**\n * Find a node in front of which `currentTNode` should be inserted.\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account if i18n code has been invoked.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNode(\n  parentTNode: TNode,\n  currentTNode: TNode,\n  lView: LView,\n): RNode | null {\n  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\n\n/**\n * Find a node in front of which `currentTNode` should be inserted. (Does not take i18n into\n * account)\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * does not take `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nexport function getInsertInFrontOfRNodeWithNoI18n(\n  parentTNode: TNode,\n  currentTNode: TNode,\n  lView: LView,\n): RNode | null {\n  if (parentTNode.type & (TNodeType.ElementContainer | TNodeType.Icu)) {\n    return getNativeByTNode(parentTNode, lView);\n  }\n  return null;\n}\n\n/**\n * Tree shakable boundary for `getInsertInFrontOfRNodeWithI18n` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _getInsertInFrontOfRNodeWithI18n: (\n  parentTNode: TNode,\n  currentTNode: TNode,\n  lView: LView,\n) => RNode | null = getInsertInFrontOfRNodeWithNoI18n;\n\n/**\n * Tree shakable boundary for `processI18nInsertBefore` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _processI18nInsertBefore: (\n  renderer: Renderer,\n  childTNode: TNode,\n  lView: LView,\n  childRNode: RNode | RNode[],\n  parentRElement: RElement | null,\n) => void;\n\nexport function setI18nHandling(\n  getInsertInFrontOfRNodeWithI18n: (\n    parentTNode: TNode,\n    currentTNode: TNode,\n    lView: LView,\n  ) => RNode | null,\n  processI18nInsertBefore: (\n    renderer: Renderer,\n    childTNode: TNode,\n    lView: LView,\n    childRNode: RNode | RNode[],\n    parentRElement: RElement | null,\n  ) => void,\n) {\n  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;\n  _processI18nInsertBefore = processI18nInsertBefore;\n}\n\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * @param tView The `TView' to be appended\n * @param lView The current LView\n * @param childRNode The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n */\nexport function appendChild(\n  tView: TView,\n  lView: LView,\n  childRNode: RNode | RNode[],\n  childTNode: TNode,\n): void {\n  const parentRNode = getParentRElement(tView, childTNode, lView);\n  const renderer = lView[RENDERER];\n  const parentTNode: TNode = childTNode.parent || lView[T_HOST]!;\n  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n  if (parentRNode != null) {\n    if (Array.isArray(childRNode)) {\n      for (let i = 0; i < childRNode.length; i++) {\n        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n      }\n    } else {\n      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n    }\n  }\n\n  _processI18nInsertBefore !== undefined &&\n    _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\n\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\nexport function getFirstNativeNode(lView: LView, tNode: TNode | null): RNode | null {\n  if (tNode !== null) {\n    ngDevMode &&\n      assertTNodeType(\n        tNode,\n        TNodeType.AnyRNode |\n          TNodeType.AnyContainer |\n          TNodeType.Icu |\n          TNodeType.Projection |\n          TNodeType.LetDeclaration,\n      );\n\n    const tNodeType = tNode.type;\n    if (tNodeType & TNodeType.AnyRNode) {\n      return getNativeByTNode(tNode, lView);\n    } else if (tNodeType & TNodeType.Container) {\n      return getBeforeNodeForView(-1, lView[tNode.index]);\n    } else if (tNodeType & TNodeType.ElementContainer) {\n      const elIcuContainerChild = tNode.child;\n      if (elIcuContainerChild !== null) {\n        return getFirstNativeNode(lView, elIcuContainerChild);\n      } else {\n        const rNodeOrLContainer = lView[tNode.index];\n        if (isLContainer(rNodeOrLContainer)) {\n          return getBeforeNodeForView(-1, rNodeOrLContainer);\n        } else {\n          return unwrapRNode(rNodeOrLContainer);\n        }\n      }\n    } else if (tNodeType & TNodeType.LetDeclaration) {\n      return getFirstNativeNode(lView, tNode.next);\n    } else if (tNodeType & TNodeType.Icu) {\n      let nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n      let rNode: RNode | null = nextRNode();\n      // If the ICU container has no nodes, than we use the ICU anchor as the node.\n      return rNode || unwrapRNode(lView[tNode.index]);\n    } else {\n      const projectionNodes = getProjectionNodes(lView, tNode);\n      if (projectionNodes !== null) {\n        if (Array.isArray(projectionNodes)) {\n          return projectionNodes[0];\n        }\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        return getFirstNativeNode(parentView!, projectionNodes);\n      } else {\n        return getFirstNativeNode(lView, tNode.next);\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function getProjectionNodes(lView: LView, tNode: TNode | null): TNode | RNode[] | null {\n  if (tNode !== null) {\n    const componentView = lView[DECLARATION_COMPONENT_VIEW];\n    const componentHost = componentView[T_HOST] as TElementNode;\n    const slotIdx = tNode.projection as number;\n    ngDevMode && assertProjectionSlots(lView);\n    return componentHost.projection![slotIdx];\n  }\n  return null;\n}\n\nexport function getBeforeNodeForView(\n  viewIndexInContainer: number,\n  lContainer: LContainer,\n): RNode | null {\n  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n  if (nextViewIndex < lContainer.length) {\n    const lView = lContainer[nextViewIndex] as LView;\n    const firstTNodeOfView = lView[TVIEW].firstChild;\n    if (firstTNodeOfView !== null) {\n      return getFirstNativeNode(lView, firstTNodeOfView);\n    }\n  }\n\n  return lContainer[NATIVE];\n}\n\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\nfunction applyNodes(\n  renderer: Renderer,\n  action: WalkTNodeTreeAction,\n  tNode: TNode | null,\n  lView: LView,\n  parentRElement: RElement | null,\n  beforeNode: RNode | null,\n  isProjection: boolean,\n) {\n  while (tNode != null) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n\n    // Let declarations don't have corresponding DOM nodes so we skip over them.\n    if (tNode.type === TNodeType.LetDeclaration) {\n      tNode = tNode.next;\n      continue;\n    }\n\n    ngDevMode &&\n      assertTNodeType(\n        tNode,\n        TNodeType.AnyRNode | TNodeType.AnyContainer | TNodeType.Projection | TNodeType.Icu,\n      );\n    const rawSlotValue = lView[tNode.index];\n    const tNodeType = tNode.type;\n    if (isProjection) {\n      if (action === WalkTNodeTreeAction.Create) {\n        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n        tNode.flags |= TNodeFlags.isProjected;\n      }\n    }\n    if (!isDetachedByI18n(tNode)) {\n      if (tNodeType & TNodeType.ElementContainer) {\n        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n        applyToElementOrContainer(\n          action,\n          renderer,\n          parentRElement,\n          rawSlotValue,\n          beforeNode,\n          lView,\n        );\n      } else if (tNodeType & TNodeType.Icu) {\n        const nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n        let rNode: RNode | null;\n        while ((rNode = nextRNode())) {\n          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode, lView);\n        }\n        applyToElementOrContainer(\n          action,\n          renderer,\n          parentRElement,\n          rawSlotValue,\n          beforeNode,\n          lView,\n        );\n      } else if (tNodeType & TNodeType.Projection) {\n        applyProjectionRecursive(\n          renderer,\n          action,\n          lView,\n          tNode as TProjectionNode,\n          parentRElement,\n          beforeNode,\n        );\n      } else {\n        ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode | TNodeType.Container);\n        applyToElementOrContainer(\n          action,\n          renderer,\n          parentRElement,\n          rawSlotValue,\n          beforeNode,\n          lView,\n        );\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n}\n\n/**\n * `applyView` performs operation on the view as specified in `action` (insert, detach, destroy)\n *\n * Inserting a view without projection or containers at top level is simple. Just iterate over the\n * root nodes of the View, and for each node perform the `action`.\n *\n * Things get more complicated with containers and projections. That is because coming across:\n * - Container: implies that we have to insert/remove/destroy the views of that container as well\n *              which in turn can have their own Containers at the View roots.\n * - Projection: implies that we have to insert/remove/destroy the nodes of the projection. The\n *               complication is that the nodes we are projecting can themselves have Containers\n *               or other Projections.\n *\n * As you can see this is a very recursive problem. Yes recursion is not most efficient but the\n * code is complicated enough that trying to implemented with recursion becomes unmaintainable.\n *\n * @param tView The `TView' which needs to be inserted, detached, destroyed\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param parentRElement parent DOM element for insertion (Removal does not need it).\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyView(\n  tView: TView,\n  lView: LView,\n  renderer: Renderer,\n  action: WalkTNodeTreeAction.Destroy,\n  parentRElement: null,\n  beforeNode: null,\n): void;\nfunction applyView(\n  tView: TView,\n  lView: LView,\n  renderer: Renderer,\n  action: WalkTNodeTreeAction,\n  parentRElement: RElement | null,\n  beforeNode: RNode | null,\n): void;\nfunction applyView(\n  tView: TView,\n  lView: LView,\n  renderer: Renderer,\n  action: WalkTNodeTreeAction,\n  parentRElement: RElement | null,\n  beforeNode: RNode | null,\n): void {\n  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\n\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param tView The `TView` of `LView` which needs to be inserted, detached, destroyed\n * @param lView The `LView` which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\nexport function applyProjection(tView: TView, lView: LView, tProjectionNode: TProjectionNode) {\n  const renderer = lView[RENDERER];\n  const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n  const parentTNode = tProjectionNode.parent || lView[T_HOST]!;\n  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n  applyProjectionRecursive(\n    renderer,\n    WalkTNodeTreeAction.Create,\n    lView,\n    tProjectionNode,\n    parentRNode,\n    beforeNode,\n  );\n}\n\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyProjectionRecursive(\n  renderer: Renderer,\n  action: WalkTNodeTreeAction,\n  lView: LView,\n  tProjectionNode: TProjectionNode,\n  parentRElement: RElement | null,\n  beforeNode: RNode | null,\n) {\n  const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n  const componentNode = componentLView[T_HOST] as TElementNode;\n  ngDevMode &&\n    assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n  const nodeToProjectOrRNodes = componentNode.projection![tProjectionNode.projection]!;\n  if (Array.isArray(nodeToProjectOrRNodes)) {\n    // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n    // need to support passing projectable nodes, so we cheat and put them in the TNode\n    // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n    // because we know that TView is not shared and therefore it will not be a problem.\n    // This should be refactored and cleaned up.\n    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n      const rNode = nodeToProjectOrRNodes[i];\n      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode, lView);\n    }\n  } else {\n    let nodeToProject: TNode | null = nodeToProjectOrRNodes;\n    const projectedComponentLView = componentLView[PARENT] as LView;\n    // If a parent <ng-content> is located within a skip hydration block,\n    // annotate an actual node that is being projected with the same flag too.\n    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {\n      nodeToProject.flags |= TNodeFlags.inSkipHydrationBlock;\n    }\n    applyNodes(\n      renderer,\n      action,\n      nodeToProject,\n      projectedComponentLView,\n      parentRElement,\n      beforeNode,\n      true,\n    );\n  }\n}\n\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyContainer(\n  renderer: Renderer,\n  action: WalkTNodeTreeAction,\n  lContainer: LContainer,\n  parentRElement: RElement | null,\n  beforeNode: RNode | null | undefined,\n) {\n  ngDevMode && assertLContainer(lContainer);\n  const anchor = lContainer[NATIVE]; // LContainer has its own before node.\n  const native = unwrapRNode(lContainer);\n  // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n  // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n  // node (comment in the DOM) that will be different from the LContainer's host node. In this\n  // particular case we need to execute action on 2 nodes:\n  // - container's host node (this is done in the executeActionOnElementOrContainer)\n  // - container's host node (this is done here)\n  if (anchor !== native) {\n    // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n    // don't see a reason why they should be different, but they are.\n    //\n    // If they are we need to process the second anchor as well.\n    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n  }\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lView = lContainer[i] as LView;\n    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n  }\n}\n\n/**\n * Writes class/style to element.\n *\n * @param renderer Renderer to use.\n * @param isClassBased `true` if it should be written to `class` (`false` to write to `style`)\n * @param rNode The Node to write to.\n * @param prop Property to write to. This would be the class/style name.\n * @param value Value to write. If `null`/`undefined`/`false` this is considered a remove (set/add\n *        otherwise).\n */\nexport function applyStyling(\n  renderer: Renderer,\n  isClassBased: boolean,\n  rNode: RElement,\n  prop: string,\n  value: any,\n) {\n  if (isClassBased) {\n    // We actually want JS true/false here because any truthy value should add the class\n    if (!value) {\n      renderer.removeClass(rNode, prop);\n    } else {\n      renderer.addClass(rNode, prop);\n    }\n  } else {\n    let flags = prop.indexOf('-') === -1 ? undefined : (RendererStyleFlags2.DashCase as number);\n    if (value == null /** || value === undefined */) {\n      renderer.removeStyle(rNode, prop, flags);\n    } else {\n      // A value is important if it ends with `!important`. The style\n      // parser strips any semicolons at the end of the value.\n      const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;\n\n      if (isImportant) {\n        // !important has to be stripped from the value for it to be valid.\n        value = value.slice(0, -10);\n        flags! |= RendererStyleFlags2.Important;\n      }\n\n      renderer.setStyle(rNode, prop, value, flags);\n    }\n  }\n}\n"]}