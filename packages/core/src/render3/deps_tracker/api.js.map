{"version":3,"file":"api.js","sourceRoot":"","sources":["api.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../../interface/type';\nimport {NgModuleType} from '../../metadata/ng_module_def';\nimport {\n  ComponentType,\n  DependencyTypeList,\n  DirectiveType,\n  NgModuleScopeInfoFromDecorator,\n  PipeType,\n} from '../interfaces/definition';\n\n/**\n * Represents the set of dependencies of a type in a certain context.\n */\ninterface ScopeData {\n  pipes: Set<PipeType<any>>;\n  directives: Set<DirectiveType<any> | ComponentType<any> | Type<any>>;\n\n  /**\n   * If true it indicates that calculating this scope somehow was not successful. The consumers\n   * should interpret this as empty dependencies. The application of this flag is when calculating\n   * scope recursively, the presence of this flag in a scope dependency implies that the scope is\n   * also poisoned and thus we can return immediately without having to continue the recursion. The\n   * reason for this error is displayed as an error message in the console as per JIT behavior\n   * today. In addition to that, in local compilation the other build/compilations run in parallel\n   * with local compilation may or may not reveal some details about the error as well.\n   */\n  isPoisoned?: boolean;\n}\n\n/**\n * Represents scope data for standalone components as calculated during runtime by the deps\n * tracker.\n */\ninterface StandaloneCompScopeData extends ScopeData {\n  // Standalone components include the imported NgModules in their dependencies in order to\n  // determine their injector info. The following field stores the set of such NgModules.\n  ngModules: Set<NgModuleType<any>>;\n}\n\n/** Represents scope data for NgModule as calculated during runtime by the deps tracker. */\nexport interface NgModuleScope {\n  compilation: ScopeData;\n  exported: ScopeData;\n}\n\n/**\n * Represents scope data for standalone component as calculated during runtime by the deps tracker.\n */\nexport interface StandaloneComponentScope {\n  compilation: StandaloneCompScopeData;\n}\n\n/** Component dependencies info as calculated during runtime by the deps tracker. */\nexport interface ComponentDependencies {\n  dependencies: DependencyTypeList;\n}\n\n/**\n * Public API for runtime deps tracker (RDT).\n *\n * All downstream tools should only use these methods.\n */\nexport interface DepsTrackerApi {\n  /**\n   * Computes the component dependencies, i.e., a set of components/directive/pipes that could be\n   * present in the component's template (This set might contain directives/components/pipes not\n   * necessarily used in the component's template depending on the implementation).\n   *\n   * Standalone components should specify `rawImports` as this information is not available from\n   * their type. The consumer (e.g., {@link getStandaloneDefFunctions}) is expected to pass this\n   * parameter.\n   *\n   * The implementation is expected to use some caching mechanism in order to optimize the resources\n   * needed to do this computation.\n   */\n  getComponentDependencies(\n    cmp: ComponentType<any>,\n    rawImports?: (Type<any> | (() => Type<any>))[],\n  ): ComponentDependencies;\n\n  /**\n   * Registers an NgModule into the tracker with the given scope info.\n   *\n   * This method should be called for every NgModule whether it is compiled in local mode or not.\n   * This is needed in order to compute component's dependencies as some dependencies might be in\n   * different compilation units with different compilation mode.\n   */\n  registerNgModule(type: Type<any>, scopeInfo: NgModuleScopeInfoFromDecorator): void;\n\n  /**\n   * Clears the scope cache for NgModule or standalone component. This will force re-calculation of\n   * the scope, which could be an expensive operation as it involves aggregating transitive closure.\n   *\n   * The main application of this method is for test beds where we want to clear the cache to\n   * enforce scope update after overriding.\n   */\n  clearScopeCacheFor(type: Type<any>): void;\n\n  /**\n   * Returns the scope of NgModule. Mainly to be used by JIT and test bed.\n   *\n   * The scope value here is memoized. To enforce a new calculation bust the cache by using\n   * `clearScopeCacheFor` method.\n   */\n  getNgModuleScope(type: NgModuleType<any>): NgModuleScope;\n\n  /**\n   * Returns the scope of standalone component. Mainly to be used by JIT. This method should be\n   * called lazily after the initial parsing so that all the forward refs can be resolved.\n   *\n   * @param rawImports the imports statement as appears on the component decorate which consists of\n   *     Type as well as forward refs.\n   *\n   * The scope value here is memoized. To enforce a new calculation bust the cache by using\n   * `clearScopeCacheFor` method.\n   */\n  getStandaloneComponentScope(\n    type: ComponentType<any>,\n    rawImports: (Type<any> | (() => Type<any>))[],\n  ): StandaloneComponentScope;\n\n  /**\n   * Checks if the NgModule declaring the component is not loaded into the browser yet. Always\n   * returns false for standalone components.\n   */\n  isOrphanComponent(cmp: ComponentType<any>): boolean;\n}\n"]}