{"version":3,"file":"deps_tracker.js","sourceRoot":"","sources":["deps_tracker.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {resolveForwardRef} from '../../di';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {NgModuleType} from '../../metadata/ng_module_def';\nimport {flatten} from '../../util/array_utils';\nimport type {\n  ComponentType,\n  NgModuleScopeInfoFromDecorator,\n  RawScopeInfoFromDecorator,\n} from '../interfaces/definition';\nimport {isComponent, isDirective, isNgModule, isPipe, verifyStandaloneImport} from '../jit/util';\nimport {getComponentDef, getNgModuleDef, getNgModuleDefOrThrow, isStandalone} from '../def_getters';\nimport {maybeUnwrapFn} from '../util/misc_utils';\n\nimport {\n  ComponentDependencies,\n  DepsTrackerApi,\n  NgModuleScope,\n  StandaloneComponentScope,\n} from './api';\n\n/**\n * An implementation of DepsTrackerApi which will be used for JIT and local compilation.\n */\nclass DepsTracker implements DepsTrackerApi {\n  private ownerNgModule = new Map<ComponentType<any>, NgModuleType<any>>();\n  private ngModulesWithSomeUnresolvedDecls = new Set<NgModuleType<any>>();\n  private ngModulesScopeCache = new Map<NgModuleType<any>, NgModuleScope>();\n  private standaloneComponentsScopeCache = new Map<ComponentType<any>, StandaloneComponentScope>();\n\n  /**\n   * Attempts to resolve ng module's forward ref declarations as much as possible and add them to\n   * the `ownerNgModule` map. This method normally should be called after the initial parsing when\n   * all the forward refs are resolved (e.g., when trying to render a component)\n   */\n  private resolveNgModulesDecls(): void {\n    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {\n      return;\n    }\n\n    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {\n      const def = getNgModuleDef(moduleType);\n      if (def?.declarations) {\n        for (const decl of maybeUnwrapFn(def.declarations)) {\n          if (isComponent(decl)) {\n            this.ownerNgModule.set(decl, moduleType);\n          }\n        }\n      }\n    }\n\n    this.ngModulesWithSomeUnresolvedDecls.clear();\n  }\n\n  /** @override */\n  getComponentDependencies(\n    type: ComponentType<any>,\n    rawImports?: RawScopeInfoFromDecorator[],\n  ): ComponentDependencies {\n    this.resolveNgModulesDecls();\n\n    const def = getComponentDef(type);\n    if (def === null) {\n      throw new Error(\n        `Attempting to get component dependencies for a type that is not a component: ${type}`,\n      );\n    }\n\n    if (def.standalone) {\n      const scope = this.getStandaloneComponentScope(type, rawImports);\n\n      if (scope.compilation.isPoisoned) {\n        return {dependencies: []};\n      }\n\n      return {\n        dependencies: [\n          ...scope.compilation.directives,\n          ...scope.compilation.pipes,\n          ...scope.compilation.ngModules,\n        ],\n      };\n    } else {\n      if (!this.ownerNgModule.has(type)) {\n        // This component is orphan! No need to handle the error since the component rendering\n        // pipeline (e.g., view_container_ref) will check for this error based on configs.\n        return {dependencies: []};\n      }\n\n      const scope = this.getNgModuleScope(this.ownerNgModule.get(type)!);\n\n      if (scope.compilation.isPoisoned) {\n        return {dependencies: []};\n      }\n\n      return {\n        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes],\n      };\n    }\n  }\n\n  /**\n   * @override\n   * This implementation does not make use of param scopeInfo since it assumes the scope info is\n   * already added to the type itself through methods like {@link ɵɵsetNgModuleScope}\n   */\n  registerNgModule(type: Type<any>, scopeInfo: NgModuleScopeInfoFromDecorator): void {\n    if (!isNgModule(type)) {\n      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);\n    }\n\n    // Lazily process the NgModules later when needed.\n    this.ngModulesWithSomeUnresolvedDecls.add(type);\n  }\n\n  /** @override */\n  clearScopeCacheFor(type: Type<any>): void {\n    this.ngModulesScopeCache.delete(type as NgModuleType);\n    this.standaloneComponentsScopeCache.delete(type as ComponentType<any>);\n  }\n\n  /** @override */\n  getNgModuleScope(type: NgModuleType<any>): NgModuleScope {\n    if (this.ngModulesScopeCache.has(type)) {\n      return this.ngModulesScopeCache.get(type)!;\n    }\n\n    const scope = this.computeNgModuleScope(type);\n    this.ngModulesScopeCache.set(type, scope);\n\n    return scope;\n  }\n\n  /** Compute NgModule scope afresh. */\n  private computeNgModuleScope(type: NgModuleType<any>): NgModuleScope {\n    const def = getNgModuleDefOrThrow(type);\n    const scope: NgModuleScope = {\n      exported: {directives: new Set(), pipes: new Set()},\n      compilation: {directives: new Set(), pipes: new Set()},\n    };\n\n    // Analyzing imports\n    for (const imported of maybeUnwrapFn(def.imports)) {\n      if (isNgModule(imported)) {\n        const importedScope = this.getNgModuleScope(imported);\n\n        // When this module imports another, the imported module's exported directives and pipes\n        // are added to the compilation scope of this module.\n        addSet(importedScope.exported.directives, scope.compilation.directives);\n        addSet(importedScope.exported.pipes, scope.compilation.pipes);\n      } else if (isStandalone(imported)) {\n        if (isDirective(imported) || isComponent(imported)) {\n          scope.compilation.directives.add(imported);\n        } else if (isPipe(imported)) {\n          scope.compilation.pipes.add(imported);\n        } else {\n          // The standalone thing is neither a component nor a directive nor a pipe ... (what?)\n          throw new RuntimeError(\n            RuntimeErrorCode.RUNTIME_DEPS_INVALID_IMPORTED_TYPE,\n            'The standalone imported type is neither a component nor a directive nor a pipe',\n          );\n        }\n      } else {\n        // The import is neither a module nor a module-with-providers nor a standalone thing. This\n        // is going to be an error. So we short circuit.\n        scope.compilation.isPoisoned = true;\n        break;\n      }\n    }\n\n    // Analyzing declarations\n    if (!scope.compilation.isPoisoned) {\n      for (const decl of maybeUnwrapFn(def.declarations)) {\n        // Cannot declare another NgModule or a standalone thing\n        if (isNgModule(decl) || isStandalone(decl)) {\n          scope.compilation.isPoisoned = true;\n          break;\n        }\n\n        if (isPipe(decl)) {\n          scope.compilation.pipes.add(decl);\n        } else {\n          // decl is either a directive or a component. The component may not yet have the ɵcmp due\n          // to async compilation.\n          scope.compilation.directives.add(decl);\n        }\n      }\n    }\n\n    // Analyzing exports\n    for (const exported of maybeUnwrapFn(def.exports)) {\n      if (isNgModule(exported)) {\n        // When this module exports another, the exported module's exported directives and pipes\n        // are added to both the compilation and exported scopes of this module.\n        const exportedScope = this.getNgModuleScope(exported);\n\n        // Based on the current logic there is no way to have poisoned exported scope. So no need to\n        // check for it.\n        addSet(exportedScope.exported.directives, scope.exported.directives);\n        addSet(exportedScope.exported.pipes, scope.exported.pipes);\n\n        // Some test toolings which run in JIT mode depend on this behavior that the exported scope\n        // should also be present in the compilation scope, even though AoT does not support this\n        // and it is also in odds with NgModule metadata definitions. Without this some tests in\n        // Google will fail.\n        addSet(exportedScope.exported.directives, scope.compilation.directives);\n        addSet(exportedScope.exported.pipes, scope.compilation.pipes);\n      } else if (isPipe(exported)) {\n        scope.exported.pipes.add(exported);\n      } else {\n        scope.exported.directives.add(exported);\n      }\n    }\n\n    return scope;\n  }\n\n  /** @override */\n  getStandaloneComponentScope(\n    type: ComponentType<any>,\n    rawImports?: RawScopeInfoFromDecorator[],\n  ): StandaloneComponentScope {\n    if (this.standaloneComponentsScopeCache.has(type)) {\n      return this.standaloneComponentsScopeCache.get(type)!;\n    }\n\n    const ans = this.computeStandaloneComponentScope(type, rawImports);\n    this.standaloneComponentsScopeCache.set(type, ans);\n\n    return ans;\n  }\n\n  private computeStandaloneComponentScope(\n    type: ComponentType<any>,\n    rawImports?: RawScopeInfoFromDecorator[],\n  ): StandaloneComponentScope {\n    const ans: StandaloneComponentScope = {\n      compilation: {\n        // Standalone components are always able to self-reference.\n        directives: new Set([type]),\n        pipes: new Set(),\n        ngModules: new Set(),\n      },\n    };\n\n    for (const rawImport of flatten(rawImports ?? [])) {\n      const imported = resolveForwardRef(rawImport) as Type<any>;\n\n      try {\n        verifyStandaloneImport(imported, type);\n      } catch (e) {\n        // Short-circuit if an import is not valid\n        ans.compilation.isPoisoned = true;\n        return ans;\n      }\n\n      if (isNgModule(imported)) {\n        ans.compilation.ngModules.add(imported);\n        const importedScope = this.getNgModuleScope(imported);\n\n        // Short-circuit if an imported NgModule has corrupted exported scope.\n        if (importedScope.exported.isPoisoned) {\n          ans.compilation.isPoisoned = true;\n          return ans;\n        }\n\n        addSet(importedScope.exported.directives, ans.compilation.directives);\n        addSet(importedScope.exported.pipes, ans.compilation.pipes);\n      } else if (isPipe(imported)) {\n        ans.compilation.pipes.add(imported);\n      } else if (isDirective(imported) || isComponent(imported)) {\n        ans.compilation.directives.add(imported);\n      } else {\n        // The imported thing is not module/pipe/directive/component, so we error and short-circuit\n        // here\n        ans.compilation.isPoisoned = true;\n        return ans;\n      }\n    }\n\n    return ans;\n  }\n\n  /** @override */\n  isOrphanComponent(cmp: Type<any>): boolean {\n    const def = getComponentDef(cmp);\n\n    if (!def || def.standalone) {\n      return false;\n    }\n\n    this.resolveNgModulesDecls();\n\n    return !this.ownerNgModule.has(cmp as ComponentType<any>);\n  }\n}\n\nfunction addSet<T>(sourceSet: Set<T>, targetSet: Set<T>): void {\n  for (const m of sourceSet) {\n    targetSet.add(m);\n  }\n}\n\n/** The deps tracker to be used in the current Angular app in dev mode. */\nexport const depsTracker = new DepsTracker();\n\nexport const TEST_ONLY = {DepsTracker};\n"]}