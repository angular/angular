{"version":3,"file":"definition_factory.js","sourceRoot":"","sources":["definition_factory.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,SAAS,EAAC,MAAM,mBAAmB,CAAC;AAC5C,OAAO,EAAC,cAAc,EAAC,MAAM,UAAU,CAAC;AAoBxC,MAAM,UAAU,aAAa,CAAI,IAAS,EAAE,aAAuB;IACjE,MAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;IAC1D,IAAI,CAAC,aAAa,IAAI,aAAa,KAAK,IAAI,IAAI,SAAS,EAAE,CAAC;QAC1D,MAAM,IAAI,KAAK,CAAC,QAAQ,SAAS,CAAC,IAAI,CAAC,iCAAiC,CAAC,CAAC;IAC5E,CAAC;IACD,OAAO,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;AACrD,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../interface/type';\nimport {stringify} from '../util/stringify';\nimport {NG_FACTORY_DEF} from './fields';\n\n/**\n * Definition of what a factory function should look like.\n */\nexport type FactoryFn<T> = {\n  /**\n   * Subclasses without an explicit constructor call through to the factory of their base\n   * definition, providing it with their own constructor to instantiate.\n   */\n  <U extends T>(t?: Type<U>): U;\n\n  /**\n   * If no constructor to instantiate is provided, an instance of type T itself is created.\n   */\n  (t?: undefined): T;\n};\n\nexport function getFactoryDef<T>(type: any, throwNotFound: true): FactoryFn<T>;\nexport function getFactoryDef<T>(type: any): FactoryFn<T> | null;\nexport function getFactoryDef<T>(type: any, throwNotFound?: boolean): FactoryFn<T> | null {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'Éµfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n"]}