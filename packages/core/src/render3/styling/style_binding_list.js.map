{"version":3,"file":"style_binding_list.js","sourceRoot":"","sources":["style_binding_list.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {KeyValueArray, keyValueArrayIndexOf} from '../../util/array_utils';\nimport {assertEqual, assertIndexInRange, assertNotEqual} from '../../util/assert';\nimport {assertFirstUpdatePass} from '../assert';\nimport {TNode} from '../interfaces/node';\nimport {\n  getTStylingRangeNext,\n  getTStylingRangePrev,\n  setTStylingRangeNext,\n  setTStylingRangeNextDuplicate,\n  setTStylingRangePrev,\n  setTStylingRangePrevDuplicate,\n  toTStylingRange,\n  TStylingKey,\n  TStylingKeyPrimitive,\n  TStylingRange,\n} from '../interfaces/styling';\nimport {TData} from '../interfaces/view';\nimport {getTView} from '../state';\n\n/**\n * NOTE: The word `styling` is used interchangeably as style or class styling.\n *\n * This file contains code to link styling instructions together so that they can be replayed in\n * priority order. The file exists because Ivy styling instruction execution order does not match\n * that of the priority order. The purpose of this code is to create a linked list so that the\n * instructions can be traversed in priority order when computing the styles.\n *\n * Assume we are dealing with the following code:\n * ```angular-ts\n * @Component({\n *   template: `\n *     <my-cmp [style]=\" {color: '#001'} \"\n *             [style.color]=\" #002 \"\n *             dir-style-color-1\n *             dir-style-color-2> `\n * })\n * class ExampleComponent {\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#001'});\n *     ɵɵstyleProp('color', '#002');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-1]',\n * })\n * class Style1Directive {\n *   @HostBinding('style') style = {color: '#005'};\n *   @HostBinding('style.color') color = '#006';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#005'});\n *     ɵɵstyleProp('color', '#006');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-2]',\n * })\n * class Style2Directive {\n *   @HostBinding('style') style = {color: '#007'};\n *   @HostBinding('style.color') color = '#008';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#007'});\n *     ɵɵstyleProp('color', '#008');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `my-cmp',\n * })\n * class MyComponent {\n *   @HostBinding('style') style = {color: '#003'};\n *   @HostBinding('style.color') color = '#004';\n *\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#003'});\n *     ɵɵstyleProp('color', '#004');\n *     ...\n *   }\n * }\n * ```\n *\n * The Order of instruction execution is:\n *\n * NOTE: the comment binding location is for illustrative purposes only.\n *\n * ```ts\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * ```\n *\n * The correct priority order of concatenation is:\n *\n * ```ts\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * ```\n *\n * What color should be rendered?\n *\n * Once the items are correctly sorted in the list, the answer is simply the last item in the\n * concatenation list which is `#002`.\n *\n * To do so we keep a linked list of all of the bindings which pertain to this element.\n * Notice that the bindings are inserted in the order of execution, but the `TView.data` allows\n * us to traverse them in the order of priority.\n *\n * |Idx|`TView.data`|`LView`          | Notes\n * |---|------------|-----------------|--------------\n * |...|            |                 |\n * |10 |`null`      |`{color: '#001'}`| `ɵɵstyleMap('color', {color: '#001'})`\n * |11 |`30 | 12`   | ...             |\n * |12 |`color`     |`'#002'`         | `ɵɵstyleProp('color', '#002')`\n * |13 |`10 | 0`    | ...             |\n * |...|            |                 |\n * |20 |`null`      |`{color: '#003'}`| `ɵɵstyleMap('color', {color: '#003'})`\n * |21 |`0 | 22`    | ...             |\n * |22 |`color`     |`'#004'`         | `ɵɵstyleProp('color', '#004')`\n * |23 |`20 | 24`   | ...             |\n * |24 |`null`      |`{color: '#005'}`| `ɵɵstyleMap('color', {color: '#005'})`\n * |25 |`22 | 26`   | ...             |\n * |26 |`color`     |`'#006'`         | `ɵɵstyleProp('color', '#006')`\n * |27 |`24 | 28`   | ...             |\n * |28 |`null`      |`{color: '#007'}`| `ɵɵstyleMap('color', {color: '#007'})`\n * |29 |`26 | 30`   | ...             |\n * |30 |`color`     |`'#008'`         | `ɵɵstyleProp('color', '#008')`\n * |31 |`28 | 10`   | ...             |\n *\n * The above data structure allows us to re-concatenate the styling no matter which data binding\n * changes.\n *\n * NOTE: in addition to keeping track of next/previous index the `TView.data` also stores prev/next\n * duplicate bit. The duplicate bit if true says there either is a binding with the same name or\n * there is a map (which may contain the name). This information is useful in knowing if other\n * styles with higher priority need to be searched for overwrites.\n *\n * NOTE: See `should support example in 'tnode_linked_list.ts' documentation` in\n * `tnode_linked_list_spec.ts` for working example.\n */\nlet __unused_const_as_closure_does_not_like_standalone_comment_blocks__: undefined;\n\n/**\n * Insert new `tStyleValue` at `TData` and link existing style bindings such that we maintain linked\n * list of styles and compute the duplicate flag.\n *\n * Note: this function is executed during `firstUpdatePass` only to populate the `TView.data`.\n *\n * The function works by keeping track of `tStylingRange` which contains two pointers pointing to\n * the head/tail of the template portion of the styles.\n *  - if `isHost === false` (we are template) then insertion is at tail of `TStylingRange`\n *  - if `isHost === true` (we are host binding) then insertion is at head of `TStylingRange`\n *\n * @param tData The `TData` to insert into.\n * @param tNode `TNode` associated with the styling element.\n * @param tStylingKey See `TStylingKey`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isHostBinding `true` if the insertion is for a `hostBinding`. (insertion is in front of\n *               template.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nexport function insertTStylingBinding(\n  tData: TData,\n  tNode: TNode,\n  tStylingKeyWithStatic: TStylingKey,\n  index: number,\n  isHostBinding: boolean,\n  isClassBinding: boolean,\n): void {\n  ngDevMode && assertFirstUpdatePass(getTView());\n  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;\n  let tmplHead = getTStylingRangePrev(tBindings);\n  let tmplTail = getTStylingRangeNext(tBindings);\n\n  tData[index] = tStylingKeyWithStatic;\n  let isKeyDuplicateOfStatic = false;\n  let tStylingKey: TStylingKeyPrimitive;\n  if (Array.isArray(tStylingKeyWithStatic)) {\n    // We are case when the `TStylingKey` contains static fields as well.\n    const staticKeyValueArray = tStylingKeyWithStatic as KeyValueArray<any>;\n    tStylingKey = staticKeyValueArray[1]; // unwrap.\n    // We need to check if our key is present in the static so that we can mark it as duplicate.\n    if (\n      tStylingKey === null ||\n      keyValueArrayIndexOf(staticKeyValueArray, tStylingKey as string) > 0\n    ) {\n      // tStylingKey is present in the statics, need to mark it as duplicate.\n      isKeyDuplicateOfStatic = true;\n    }\n  } else {\n    tStylingKey = tStylingKeyWithStatic;\n  }\n  if (isHostBinding) {\n    // We are inserting host bindings\n\n    // If we don't have template bindings then `tail` is 0.\n    const hasTemplateBindings = tmplTail !== 0;\n    // This is important to know because that means that the `head` can't point to the first\n    // template bindings (there are none.) Instead the head points to the tail of the template.\n    if (hasTemplateBindings) {\n      // template head's \"prev\" will point to last host binding or to 0 if no host bindings yet\n      const previousNode = getTStylingRangePrev(tData[tmplHead + 1] as TStylingRange);\n      tData[index + 1] = toTStylingRange(previousNode, tmplHead);\n      // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n      if (previousNode !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[previousNode + 1] = setTStylingRangeNext(\n          tData[previousNode + 1] as TStylingRange,\n          index,\n        );\n      }\n      // The \"previous\" of the template binding head should point to this host binding\n      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1] as TStylingRange, index);\n    } else {\n      tData[index + 1] = toTStylingRange(tmplHead, 0);\n      // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n      if (tmplHead !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1] as TStylingRange, index);\n      }\n      // if we don't have template, the head points to template-tail, and needs to be advanced.\n      tmplHead = index;\n    }\n  } else {\n    // We are inserting in template section.\n    // We need to set this binding's \"previous\" to the current template tail\n    tData[index + 1] = toTStylingRange(tmplTail, 0);\n    ngDevMode &&\n      assertEqual(\n        tmplHead !== 0 && tmplTail === 0,\n        false,\n        'Adding template bindings after hostBindings is not allowed.',\n      );\n    if (tmplHead === 0) {\n      tmplHead = index;\n    } else {\n      // We need to update the previous value \"next\" to point to this binding\n      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1] as TStylingRange, index);\n    }\n    tmplTail = index;\n  }\n\n  // Now we need to update / compute the duplicates.\n  // Starting with our location search towards head (least priority)\n  if (isKeyDuplicateOfStatic) {\n    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1] as TStylingRange);\n  }\n  markDuplicates(tData, tStylingKey, index, true);\n  markDuplicates(tData, tStylingKey, index, false);\n  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);\n\n  tBindings = toTStylingRange(tmplHead, tmplTail);\n  if (isClassBinding) {\n    tNode.classBindings = tBindings;\n  } else {\n    tNode.styleBindings = tBindings;\n  }\n}\n\n/**\n * Look into the residual styling to see if the current `tStylingKey` is duplicate of residual.\n *\n * @param tNode `TNode` where the residual is stored.\n * @param tStylingKey `TStylingKey` to store.\n * @param tData `TData` associated with the current `LView`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction markDuplicateOfResidualStyling(\n  tNode: TNode,\n  tStylingKey: TStylingKey,\n  tData: TData,\n  index: number,\n  isClassBinding: boolean,\n) {\n  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;\n  if (\n    residual != null /* or undefined */ &&\n    typeof tStylingKey == 'string' &&\n    keyValueArrayIndexOf(residual, tStylingKey) >= 0\n  ) {\n    // We have duplicate in the residual so mark ourselves as duplicate.\n    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1] as TStylingRange);\n  }\n}\n\n/**\n * Marks `TStyleValue`s as duplicates if another style binding in the list has the same\n * `TStyleValue`.\n *\n * NOTE: this function is intended to be called twice once with `isPrevDir` set to `true` and once\n * with it set to `false` to search both the previous as well as next items in the list.\n *\n * No duplicate case\n * ```\n *   [style.color]\n *   [style.width.px] <<- index\n *   [style.height.px]\n * ```\n *\n * In the above case adding `[style.width.px]` to the existing `[style.color]` produces no\n * duplicates because `width` is not found in any other part of the linked list.\n *\n * Duplicate case\n * ```\n *   [style.color]\n *   [style.width.em]\n *   [style.width.px] <<- index\n * ```\n * In the above case adding `[style.width.px]` will produce a duplicate with `[style.width.em]`\n * because `width` is found in the chain.\n *\n * Map case 1\n * ```\n *   [style.width.px]\n *   [style.color]\n *   [style]  <<- index\n * ```\n * In the above case adding `[style]` will produce a duplicate with any other bindings because\n * `[style]` is a Map and as such is fully dynamic and could produce `color` or `width`.\n *\n * Map case 2\n * ```\n *   [style]\n *   [style.width.px]\n *   [style.color]  <<- index\n * ```\n * In the above case adding `[style.color]` will produce a duplicate because there is already a\n * `[style]` binding which is a Map and as such is fully dynamic and could produce `color` or\n * `width`.\n *\n * NOTE: Once `[style]` (Map) is added into the system all things are mapped as duplicates.\n * NOTE: We use `style` as example, but same logic is applied to `class`es as well.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tStylingKey `TStylingKeyPrimitive` which contains the value to compare to other keys in\n *        the linked list.\n * @param index Starting location in the linked list to search from\n * @param isPrevDir Direction.\n *        - `true` for previous (lower priority);\n *        - `false` for next (higher priority).\n */\nfunction markDuplicates(\n  tData: TData,\n  tStylingKey: TStylingKeyPrimitive,\n  index: number,\n  isPrevDir: boolean,\n) {\n  const tStylingAtIndex = tData[index + 1] as TStylingRange;\n  const isMap = tStylingKey === null;\n  let cursor = isPrevDir\n    ? getTStylingRangePrev(tStylingAtIndex)\n    : getTStylingRangeNext(tStylingAtIndex);\n  let foundDuplicate = false;\n  // We keep iterating as long as we have a cursor\n  // AND either:\n  // - we found what we are looking for, OR\n  // - we are a map in which case we have to continue searching even after we find what we were\n  //   looking for since we are a wild card and everything needs to be flipped to duplicate.\n  while (cursor !== 0 && (foundDuplicate === false || isMap)) {\n    ngDevMode && assertIndexInRange(tData, cursor);\n    const tStylingValueAtCursor = tData[cursor] as TStylingKey;\n    const tStyleRangeAtCursor = tData[cursor + 1] as TStylingRange;\n    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {\n      foundDuplicate = true;\n      tData[cursor + 1] = isPrevDir\n        ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor)\n        : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);\n    }\n    cursor = isPrevDir\n      ? getTStylingRangePrev(tStyleRangeAtCursor)\n      : getTStylingRangeNext(tStyleRangeAtCursor);\n  }\n  if (foundDuplicate) {\n    // if we found a duplicate, than mark ourselves.\n    tData[index + 1] = isPrevDir\n      ? setTStylingRangePrevDuplicate(tStylingAtIndex)\n      : setTStylingRangeNextDuplicate(tStylingAtIndex);\n  }\n}\n\n/**\n * Determines if two `TStylingKey`s are a match.\n *\n * When computing whether a binding contains a duplicate, we need to compare if the instruction\n * `TStylingKey` has a match.\n *\n * Here are examples of `TStylingKey`s which match given `tStylingKeyCursor` is:\n * - `color`\n *    - `color`    // Match another color\n *    - `null`     // That means that `tStylingKey` is a `classMap`/`styleMap` instruction\n *    - `['', 'color', 'other', true]` // wrapped `color` so match\n *    - `['', null, 'other', true]`       // wrapped `null` so match\n *    - `['', 'width', 'color', 'value']` // wrapped static value contains a match on `'color'`\n * - `null`       // `tStylingKeyCursor` always match as it is `classMap`/`styleMap` instruction\n *\n * @param tStylingKeyCursor\n * @param tStylingKey\n */\nfunction isStylingMatch(tStylingKeyCursor: TStylingKey, tStylingKey: TStylingKeyPrimitive) {\n  ngDevMode &&\n    assertNotEqual(\n      Array.isArray(tStylingKey),\n      true,\n      \"Expected that 'tStylingKey' has been unwrapped\",\n    );\n  if (\n    tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that\n    // location so we must assume that we have a match.\n    tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it\n    // contains a match.\n    (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey // If the keys match explicitly than we are a match.\n  ) {\n    return true;\n  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {\n    // if we did not find a match, but `tStylingKeyCursor` is `KeyValueArray` that means cursor has\n    // statics and we need to check those as well.\n    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0; // see if we are matching the key\n  }\n  return false;\n}\n"]}