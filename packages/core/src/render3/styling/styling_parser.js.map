{"version":3,"file":"styling_parser.js","sourceRoot":"","sources":["styling_parser.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,WAAW,EAAE,UAAU,EAAC,MAAM,mBAAmB,CAAC;AAkC1D,0FAA0F;AAC1F,MAAM,WAAW,GAAgB;IAC/B,OAAO,EAAE,CAAC;IACV,GAAG,EAAE,CAAC;IACN,MAAM,EAAE,CAAC;IACT,KAAK,EAAE,CAAC;IACR,QAAQ,EAAE,CAAC;CACZ,CAAC;AAEF;;;GAGG;AACH,MAAM,UAAU,gBAAgB,CAAC,IAAY;IAC3C,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC;AAC7D,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,kBAAkB,CAAC,IAAY;IAC7C,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,KAAK,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC;AACjE,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,cAAc,CAAC,IAAY;IACzC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACvB,OAAO,kBAAkB,CAAC,IAAI,EAAE,iBAAiB,CAAC,IAAI,EAAE,CAAC,EAAE,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;AACnF,CAAC;AAED;;;;;;;;;;;;;;GAcG;AACH,MAAM,UAAU,kBAAkB,CAAC,IAAY,EAAE,KAAa;IAC5D,MAAM,GAAG,GAAG,WAAW,CAAC,OAAO,CAAC;IAChC,IAAI,GAAG,KAAK,KAAK,EAAE,CAAC;QAClB,OAAO,CAAC,CAAC,CAAC;IACZ,CAAC;IACD,KAAK,GAAG,WAAW,CAAC,MAAM,GAAG,iBAAiB,CAAC,IAAI,EAAE,CAAC,WAAW,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE,GAAG,CAAC,CAAC;IACrF,OAAO,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;AAC7C,CAAC;AAED;;;;;;;;;;;;;GAaG;AACH,MAAM,UAAU,UAAU,CAAC,IAAY;IACrC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACvB,OAAO,cAAc,CAAC,IAAI,EAAE,iBAAiB,CAAC,IAAI,EAAE,CAAC,EAAE,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;AAC/E,CAAC;AAED;;;;;;;;;;;;;;GAcG;AACH,MAAM,UAAU,cAAc,CAAC,IAAY,EAAE,UAAkB;IAC7D,MAAM,GAAG,GAAG,WAAW,CAAC,OAAO,CAAC;IAChC,IAAI,KAAK,GAAG,CAAC,WAAW,CAAC,GAAG,GAAG,iBAAiB,CAAC,IAAI,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC,CAAC;IACzE,IAAI,GAAG,KAAK,KAAK,EAAE,CAAC;QAClB,iCAAiC;QACjC,OAAO,CAAC,CAAC,CAAC;IACZ,CAAC;IACD,KAAK,GAAG,WAAW,CAAC,MAAM,GAAG,eAAe,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;IAC/D,KAAK,GAAG,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,0BAAiB,CAAC;IAC3D,KAAK,GAAG,WAAW,CAAC,KAAK,GAAG,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;IAChE,KAAK,GAAG,WAAW,CAAC,QAAQ,GAAG,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;IACnE,OAAO,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,+BAAsB,CAAC;AACjE,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,gBAAgB,CAAC,IAAY;IAC3C,WAAW,CAAC,GAAG,GAAG,CAAC,CAAC;IACpB,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;IACvB,WAAW,CAAC,KAAK,GAAG,CAAC,CAAC;IACtB,WAAW,CAAC,QAAQ,GAAG,CAAC,CAAC;IACzB,WAAW,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC;AACpC,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,iBAAiB,CAAC,IAAY,EAAE,UAAkB,EAAE,QAAgB;IAClF,OAAO,UAAU,GAAG,QAAQ,IAAI,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,2BAAkB,EAAE,CAAC;QAC9E,UAAU,EAAE,CAAC;IACf,CAAC;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,iBAAiB,CAAC,IAAY,EAAE,UAAkB,EAAE,QAAgB;IAClF,OAAO,UAAU,GAAG,QAAQ,IAAI,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,0BAAiB,EAAE,CAAC;QAC7E,UAAU,EAAE,CAAC;IACf,CAAC;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,eAAe,CAAC,IAAY,EAAE,UAAkB,EAAE,QAAgB;IAChF,IAAI,EAAU,CAAC;IACf,OACE,UAAU,GAAG,QAAQ;QACrB,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,2BAAkB;YACnD,EAAE,iCAAwB;YAC1B,CAAC,CAAC,EAAE,gCAAsB,CAAC,uBAAc,IAAI,CAAC,EAAE,gCAAsB,CAAC,uBAAc,CAAC;YACtF,CAAC,EAAE,0BAAiB,IAAI,EAAE,0BAAiB,CAAC,CAAC,EAC/C,CAAC;QACD,UAAU,EAAE,CAAC;IACf,CAAC;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,gBAAgB,CAC9B,IAAY,EACZ,UAAkB,EAClB,QAAgB,EAChB,SAAiB;IAEjB,UAAU,GAAG,iBAAiB,CAAC,IAAI,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;IAC3D,IAAI,UAAU,GAAG,QAAQ,EAAE,CAAC;QAC1B,IAAI,SAAS,IAAI,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,KAAK,SAAS,EAAE,CAAC;YAC3D,mBAAmB,CAAC,IAAI,EAAE,MAAM,CAAC,YAAY,CAAC,SAAS,CAAC,EAAE,UAAU,CAAC,CAAC;QACxE,CAAC;QACD,UAAU,EAAE,CAAC;IACf,CAAC;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,iBAAiB,CAAC,IAAY,EAAE,UAAkB,EAAE,QAAgB;IAClF,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,yBAAyB;IACvC,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,yBAAyB;IACvC,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,yBAAyB;IACvC,IAAI,CAAC,GAAG,UAAU,CAAC;IACnB,IAAI,WAAW,GAAG,CAAC,CAAC;IACpB,OAAO,CAAC,GAAG,QAAQ,EAAE,CAAC;QACpB,MAAM,EAAE,GAAW,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC;QACxC,IAAI,EAAE,iCAAwB,EAAE,CAAC;YAC/B,OAAO,WAAW,CAAC;QACrB,CAAC;aAAM,IAAI,EAAE,mCAA0B,IAAI,EAAE,mCAA0B,EAAE,CAAC;YACxE,WAAW,GAAG,CAAC,GAAG,iBAAiB,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;QAC7D,CAAC;aAAM,IACL,UAAU,KAAK,CAAC,GAAG,CAAC,IAAI,oEAAoE;YAC5F,GAAG,wBAAe;YAClB,GAAG,wBAAe;YAClB,GAAG,wBAAe;YAClB,EAAE,iCAAwB,EAC1B,CAAC;YACD,WAAW,GAAG,CAAC,GAAG,iBAAiB,CAAC,IAAI,iCAAwB,CAAC,EAAE,QAAQ,CAAC,CAAC;QAC/E,CAAC;aAAM,IAAI,EAAE,0BAAiB,EAAE,CAAC;YAC/B,kEAAkE;YAClE,WAAW,GAAG,CAAC,CAAC;QAClB,CAAC;QACD,GAAG,GAAG,GAAG,CAAC;QACV,GAAG,GAAG,GAAG,CAAC;QACV,GAAG,GAAG,EAAE,gCAAsB,CAAC;IACjC,CAAC;IACD,OAAO,WAAW,CAAC;AACrB,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,iBAAiB,CAC/B,IAAY,EACZ,aAAqB,EACrB,UAAkB,EAClB,QAAgB;IAEhB,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,yBAAyB;IACvC,IAAI,KAAK,GAAG,UAAU,CAAC;IACvB,OAAO,KAAK,GAAG,QAAQ,EAAE,CAAC;QACxB,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC;QACpC,IAAI,EAAE,IAAI,aAAa,IAAI,GAAG,iCAAwB,EAAE,CAAC;YACvD,OAAO,KAAK,CAAC;QACf,CAAC;QACD,IAAI,EAAE,gCAAuB,IAAI,GAAG,iCAAwB,EAAE,CAAC;YAC7D,qFAAqF;YACrF,kEAAkE;YAClE,GAAG,GAAG,CAAC,CAAC;QACV,CAAC;aAAM,CAAC;YACN,GAAG,GAAG,EAAE,CAAC;QACX,CAAC;IACH,CAAC;IACD,MAAM,SAAS;QACb,CAAC,CAAC,mBAAmB,CAAC,IAAI,EAAE,MAAM,CAAC,YAAY,CAAC,aAAa,CAAC,EAAE,QAAQ,CAAC;QACzE,CAAC,CAAC,IAAI,KAAK,EAAE,CAAC;AAClB,CAAC;AAED,SAAS,mBAAmB,CAAC,IAAY,EAAE,SAAiB,EAAE,KAAa;IACzE,SAAS,IAAI,WAAW,CAAC,OAAO,IAAI,KAAK,QAAQ,EAAE,IAAI,EAAE,sBAAsB,CAAC,CAAC;IACjF,MAAM,UAAU,CACd,+BAA+B,KAAK,cAAc;QAChD,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;QACxB,KAAK;QACL,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC;QAChC,KAAK;QACL,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;QACrB,iBAAiB,SAAS,IAAI,CACjC,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertEqual, throwError} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\n\n/**\n * Stores the locations of key/value indexes while parsing styling.\n *\n * In case of `cssText` parsing the indexes are like so:\n * ```\n *   \"key1: value1; key2: value2; key3: value3\"\n *                  ^   ^ ^     ^             ^\n *                  |   | |     |             +-- textEnd\n *                  |   | |     +---------------- valueEnd\n *                  |   | +---------------------- value\n *                  |   +------------------------ keyEnd\n *                  +---------------------------- key\n * ```\n *\n * In case of `className` parsing the indexes are like so:\n * ```\n *   \"key1 key2 key3\"\n *         ^   ^    ^\n *         |   |    +-- textEnd\n *         |   +------------------------ keyEnd\n *         +---------------------------- key\n * ```\n * NOTE: `value` and `valueEnd` are used only for styles, not classes.\n */\ninterface ParserState {\n  textEnd: number;\n  key: number;\n  keyEnd: number;\n  value: number;\n  valueEnd: number;\n}\n// Global state of the parser. (This makes parser non-reentrant, but that is not an issue)\nconst parserState: ParserState = {\n  textEnd: 0,\n  key: 0,\n  keyEnd: 0,\n  value: 0,\n  valueEnd: 0,\n};\n\n/**\n * Retrieves the last parsed `key` of style.\n * @param text the text to substring the key from.\n */\nexport function getLastParsedKey(text: string): string {\n  return text.substring(parserState.key, parserState.keyEnd);\n}\n\n/**\n * Retrieves the last parsed `value` of style.\n * @param text the text to substring the key from.\n */\nexport function getLastParsedValue(text: string): string {\n  return text.substring(parserState.value, parserState.valueEnd);\n}\n\n/**\n * Initializes `className` string for parsing and parses the first token.\n *\n * This function is intended to be used in this format:\n * ```ts\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n * @param text `className` to parse\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nexport function parseClassName(text: string): number {\n  resetParserState(text);\n  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n\n/**\n * Parses next `className` token.\n *\n * This function is intended to be used in this format:\n * ```ts\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n *\n * @param text `className` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nexport function parseClassNameNext(text: string, index: number): number {\n  const end = parserState.textEnd;\n  if (end === index) {\n    return -1;\n  }\n  index = parserState.keyEnd = consumeClassToken(text, (parserState.key = index), end);\n  return consumeWhitespace(text, index, end);\n}\n\n/**\n * Initializes `cssText` string for parsing and parses the first key/values.\n *\n * This function is intended to be used in this format:\n * ```ts\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n * ```\n * @param text `cssText` to parse\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nexport function parseStyle(text: string): number {\n  resetParserState(text);\n  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n\n/**\n * Parses the next `cssText` key/values.\n *\n * This function is intended to be used in this format:\n * ```ts\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n *\n * @param text `cssText` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nexport function parseStyleNext(text: string, startIndex: number): number {\n  const end = parserState.textEnd;\n  let index = (parserState.key = consumeWhitespace(text, startIndex, end));\n  if (end === index) {\n    // we reached an end so just quit\n    return -1;\n  }\n  index = parserState.keyEnd = consumeStyleKey(text, index, end);\n  index = consumeSeparator(text, index, end, CharCode.COLON);\n  index = parserState.value = consumeWhitespace(text, index, end);\n  index = parserState.valueEnd = consumeStyleValue(text, index, end);\n  return consumeSeparator(text, index, end, CharCode.SEMI_COLON);\n}\n\n/**\n * Reset the global state of the styling parser.\n * @param text The styling text to parse.\n */\nexport function resetParserState(text: string): void {\n  parserState.key = 0;\n  parserState.keyEnd = 0;\n  parserState.value = 0;\n  parserState.valueEnd = 0;\n  parserState.textEnd = text.length;\n}\n\n/**\n * Returns index of next non-whitespace character.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index of next non-whitespace character (May be the same as `start` if no whitespace at\n *          that location.)\n */\nexport function consumeWhitespace(text: string, startIndex: number, endIndex: number): number {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) <= CharCode.SPACE) {\n    startIndex++;\n  }\n  return startIndex;\n}\n\n/**\n * Returns index of last char in class token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last char in class token.\n */\nexport function consumeClassToken(text: string, startIndex: number, endIndex: number): number {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) > CharCode.SPACE) {\n    startIndex++;\n  }\n  return startIndex;\n}\n\n/**\n * Consumes all of the characters belonging to style key and token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style key character.\n */\nexport function consumeStyleKey(text: string, startIndex: number, endIndex: number): number {\n  let ch: number;\n  while (\n    startIndex < endIndex &&\n    ((ch = text.charCodeAt(startIndex)) === CharCode.DASH ||\n      ch === CharCode.UNDERSCORE ||\n      ((ch & CharCode.UPPER_CASE) >= CharCode.A && (ch & CharCode.UPPER_CASE) <= CharCode.Z) ||\n      (ch >= CharCode.ZERO && ch <= CharCode.NINE))\n  ) {\n    startIndex++;\n  }\n  return startIndex;\n}\n\n/**\n * Consumes all whitespace and the separator `:` after the style key.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after separator and surrounding whitespace.\n */\nexport function consumeSeparator(\n  text: string,\n  startIndex: number,\n  endIndex: number,\n  separator: number,\n): number {\n  startIndex = consumeWhitespace(text, startIndex, endIndex);\n  if (startIndex < endIndex) {\n    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {\n      malformedStyleError(text, String.fromCharCode(separator), startIndex);\n    }\n    startIndex++;\n  }\n  return startIndex;\n}\n\n/**\n * Consumes style value honoring `url()` and `\"\"` text.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style value character.\n */\nexport function consumeStyleValue(text: string, startIndex: number, endIndex: number): number {\n  let ch1 = -1; // 1st previous character\n  let ch2 = -1; // 2nd previous character\n  let ch3 = -1; // 3rd previous character\n  let i = startIndex;\n  let lastChIndex = i;\n  while (i < endIndex) {\n    const ch: number = text.charCodeAt(i++);\n    if (ch === CharCode.SEMI_COLON) {\n      return lastChIndex;\n    } else if (ch === CharCode.DOUBLE_QUOTE || ch === CharCode.SINGLE_QUOTE) {\n      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);\n    } else if (\n      startIndex === i - 4 && // We have seen only 4 characters so far \"URL(\" (Ignore \"foo_URL()\")\n      ch3 === CharCode.U &&\n      ch2 === CharCode.R &&\n      ch1 === CharCode.L &&\n      ch === CharCode.OPEN_PAREN\n    ) {\n      lastChIndex = i = consumeQuotedText(text, CharCode.CLOSE_PAREN, i, endIndex);\n    } else if (ch > CharCode.SPACE) {\n      // if we have a non-whitespace character then capture its location\n      lastChIndex = i;\n    }\n    ch3 = ch2;\n    ch2 = ch1;\n    ch1 = ch & CharCode.UPPER_CASE;\n  }\n  return lastChIndex;\n}\n\n/**\n * Consumes all of the quoted characters.\n *\n * @param text Text to scan\n * @param quoteCharCode CharCode of either `\"` or `'` quote or `)` for `url(...)`.\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after quoted characters.\n */\nexport function consumeQuotedText(\n  text: string,\n  quoteCharCode: number,\n  startIndex: number,\n  endIndex: number,\n): number {\n  let ch1 = -1; // 1st previous character\n  let index = startIndex;\n  while (index < endIndex) {\n    const ch = text.charCodeAt(index++);\n    if (ch == quoteCharCode && ch1 !== CharCode.BACK_SLASH) {\n      return index;\n    }\n    if (ch == CharCode.BACK_SLASH && ch1 === CharCode.BACK_SLASH) {\n      // two back slashes cancel each other out. For example `\"\\\\\"` should properly end the\n      // quotation. (It should not assume that the last `\"` is escaped.)\n      ch1 = 0;\n    } else {\n      ch1 = ch;\n    }\n  }\n  throw ngDevMode\n    ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex)\n    : new Error();\n}\n\nfunction malformedStyleError(text: string, expecting: string, index: number): never {\n  ngDevMode && assertEqual(typeof text === 'string', true, 'String expected here');\n  throw throwError(\n    `Malformed style at location ${index} in string '` +\n      text.substring(0, index) +\n      '[>>' +\n      text.substring(index, index + 1) +\n      '<<]' +\n      text.slice(index + 1) +\n      `'. Expecting '${expecting}'.`,\n  );\n}\n"]}