{"version":3,"file":"definition.js","sourceRoot":"","sources":["definition.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InputSignalNode} from '../../authoring/input/input_signal_node';\nimport {ModuleWithProviders, ProcessProvidersFunction} from '../../di/interface/provider';\nimport {EnvironmentInjector} from '../../di/r3_injector';\nimport {Type} from '../../interface/type';\nimport {SchemaMetadata} from '../../metadata/schema';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {FactoryFn} from '../definition_factory';\n\nimport {TAttributes, TConstantsOrFactory} from './node';\nimport {CssSelectorList} from './projection';\nimport type {TView} from './view';\nimport {InputFlags} from './input_flags';\n\n/**\n * Definition of what a template rendering function should look like for a component.\n */\nexport type ComponentTemplate<T> = {\n  // Note: the ctx parameter is typed as T|U, as using only U would prevent a template with\n  // e.g. ctx: {} from being assigned to ComponentTemplate<any> as TypeScript won't infer U = any\n  // in that scenario. By including T this incompatibility is resolved.\n  <U extends T>(rf: RenderFlags, ctx: T | U): void;\n};\n\n/**\n * Definition of what a view queries function should look like.\n */\nexport type ViewQueriesFunction<T> = <U extends T>(rf: RenderFlags, ctx: U) => void;\n\n/**\n * Definition of what a content queries function should look like.\n */\nexport type ContentQueriesFunction<T> = <U extends T>(\n  rf: RenderFlags,\n  ctx: U,\n  directiveIndex: number,\n) => void;\n\nexport interface ClassDebugInfo {\n  className: string;\n  filePath?: string;\n  lineNumber?: number;\n  forbidOrphanRendering?: boolean;\n}\n\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10,\n}\n\n/**\n * A subclass of `Type` which has a static `ɵcmp`:`ComponentDef` field making it\n * consumable for rendering.\n */\nexport interface ComponentType<T> extends Type<T> {\n  ɵcmp: unknown;\n}\n\n/**\n * A subclass of `Type` which has a static `ɵdir`:`DirectiveDef` field making it\n * consumable for rendering.\n */\nexport interface DirectiveType<T> extends Type<T> {\n  ɵdir: unknown;\n  ɵfac: unknown;\n}\n\n/**\n * A subclass of `Type` which has a static `ɵpipe`:`PipeDef` field making it\n * consumable for rendering.\n */\nexport interface PipeType<T> extends Type<T> {\n  ɵpipe: unknown;\n}\n\n/**\n * Runtime link information for Directives.\n *\n * This is an internal data structure used by the render to link\n * directives into templates.\n *\n * NOTE: Always use `defineDirective` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * @param Selector type metadata specifying the selector of the directive or component\n *\n * See: {@link defineDirective}\n */\nexport interface DirectiveDef<T> {\n  /**\n   * A dictionary mapping the inputs' public name to their minified property names\n   * (along with flags if there are any).\n   */\n  readonly inputs: Record<\n    string,\n    [minifiedName: string, flags: InputFlags, transform: InputTransformFunction | null]\n  >;\n\n  /**\n   * Contains the raw input information produced by the compiler. Can be\n   * used to do further processing after the `inputs` have been inverted.\n   */\n  readonly inputConfig: {\n    [P in keyof T]?: string | [InputFlags, string, string?, InputTransformFunction?];\n  };\n\n  /**\n   * @deprecated This is only here because `NgOnChanges` incorrectly uses declared name instead of\n   * public or minified name.\n   */\n  readonly declaredInputs: Record<string, string>;\n\n  /**\n   * A dictionary mapping the outputs' minified property names to their public API names, which\n   * are their aliases if any, or their original unminified property names\n   * (as in `@Output('alias') propertyName: any;`).\n   */\n  readonly outputs: Record<string, string>;\n\n  /**\n   * Function to create and refresh content queries associated with a given directive.\n   */\n  contentQueries: ContentQueriesFunction<T> | null;\n\n  /**\n   * Query-related instructions for a directive. Note that while directives don't have a\n   * view and as such view queries won't necessarily do anything, there might be\n   * components that extend the directive.\n   */\n  viewQuery: ViewQueriesFunction<T> | null;\n\n  /**\n   * Refreshes host bindings on the associated directive.\n   */\n  readonly hostBindings: HostBindingsFunction<T> | null;\n\n  /**\n   * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n   *\n   * Used to calculate the length of the component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  readonly hostVars: number;\n\n  /**\n   * Assign static attribute values to a host element.\n   *\n   * This property will assign static attribute values as well as class and style\n   * values to a host element. Since attribute values can consist of different types of values, the\n   * `hostAttrs` array must include the values in the following format:\n   *\n   * attrs = [\n   *   // static attributes (like `title`, `name`, `id`...)\n   *   attr1, value1, attr2, value,\n   *\n   *   // a single namespace value (like `x:id`)\n   *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n   *\n   *   // another single namespace value (like `x:name`)\n   *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n   *\n   *   // a series of CSS classes that will be applied to the element (no spaces)\n   *   CLASSES_MARKER, class1, class2, class3,\n   *\n   *   // a series of CSS styles (property + value) that will be applied to the element\n   *   STYLES_MARKER, prop1, value1, prop2, value2\n   * ]\n   *\n   * All non-class and non-style attributes must be defined at the start of the list\n   * first before all class and style values are set. When there is a change in value\n   * type (like when classes and styles are introduced) a marker must be used to separate\n   * the entries. The marker values themselves are set via entries found in the\n   * [AttributeMarker] enum.\n   */\n  readonly hostAttrs: TAttributes | null;\n\n  /** Token representing the directive. Used by DI. */\n  readonly type: Type<T>;\n\n  /** Function that resolves providers and publishes them into the DI system. */\n  providersResolver:\n    | (<U extends T>(def: DirectiveDef<U>, processProvidersFn?: ProcessProvidersFunction) => void)\n    | null;\n\n  /** The selectors that will be used to match nodes to this directive. */\n  readonly selectors: CssSelectorList;\n\n  /**\n   * Name under which the directive is exported (for use with local references in template)\n   */\n  readonly exportAs: string[] | null;\n\n  /**\n   * Whether this directive (or component) is standalone.\n   */\n  readonly standalone: boolean;\n\n  /**\n   * Whether this directive (or component) uses the signals authoring experience.\n   */\n  readonly signals: boolean;\n\n  /**\n   * Factory function used to create a new directive instance. Will be null initially.\n   * Populated when the factory is first requested by directive instantiation logic.\n   */\n  readonly factory: FactoryFn<T> | null;\n\n  /**\n   * The features applied to this directive\n   */\n  readonly features: DirectiveDefFeature[] | null;\n\n  /**\n   * Info related to debugging/troubleshooting for this component. This info is only available in\n   * dev mode.\n   */\n  debugInfo: ClassDebugInfo | null;\n\n  /**\n   * Function inteded to be called after template selector matching is done\n   * in order to resolve information about their host directives. Patched\n   * onto the definition by the `ɵɵHostDirectivesFeature`.\n   */\n  resolveHostDirectives: ((matches: DirectiveDef<unknown>[]) => HostDirectiveResolution) | null;\n\n  /**\n   * Additional directives to be applied whenever the directive has been matched.\n   *\n   * `HostDirectiveConfig` objects represent a host directive that can be resolved eagerly and were\n   * already pre-processed when the definition was created. A function needs to be resolved lazily\n   * during directive matching, because it's a forward reference.\n   *\n   * **Note:** we can't use `HostDirectiveConfig` in the array, because there's no way to\n   * distinguish if a function in the array is a `Type` or a `() => HostDirectiveConfig[]`.\n   */\n  hostDirectives: (HostDirectiveDef | (() => HostDirectiveConfig[]))[] | null;\n\n  setInput:\n    | (<U extends T>(\n        this: DirectiveDef<U>,\n        instance: U,\n        inputSignalNode: null | InputSignalNode<unknown, unknown>,\n        value: any,\n        publicName: string,\n        privateName: string,\n      ) => void)\n    | null;\n}\n\n/**\n * Runtime link information for Components.\n *\n * This is an internal data structure used by the render to link\n * components into templates.\n *\n * NOTE: Always use `defineComponent` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link defineComponent}\n */\nexport interface ComponentDef<T> extends DirectiveDef<T> {\n  /**\n   * Unique ID for the component. Used in view encapsulation and\n   * to keep track of the injector in standalone components.\n   */\n  readonly id: string;\n\n  /**\n   * The View template of the component.\n   */\n  readonly template: ComponentTemplate<T>;\n\n  /** Constants associated with the component's view. */\n  readonly consts: TConstantsOrFactory | null;\n\n  /**\n   * An array of `ngContent[selector]` values that were found in the template.\n   */\n  readonly ngContentSelectors?: string[];\n\n  /**\n   * A set of styles that the component needs to be present for component to render correctly.\n   */\n  readonly styles: string[];\n\n  /**\n   * The number of nodes, local refs, and pipes in this component template.\n   *\n   * Used to calculate the length of the component's LView array, so we\n   * can pre-fill the array and set the binding start index.\n   */\n  // TODO(kara): remove queries from this count\n  readonly decls: number;\n\n  /**\n   * The number of bindings in this component template (including pure fn bindings).\n   *\n   * Used to calculate the length of the component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  readonly vars: number;\n\n  /**\n   * Query-related instructions for a component.\n   */\n  viewQuery: ViewQueriesFunction<T> | null;\n\n  /**\n   * The view encapsulation type, which determines how styles are applied to\n   * DOM elements. One of\n   * - `Emulated` (default): Emulate native scoping of styles.\n   * - `Native`: Use the native encapsulation mechanism of the renderer.\n   * - `ShadowDom`: Use modern [ShadowDOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   *   create a ShadowRoot for component's host element.\n   * - `None`: Do not provide any template or style encapsulation.\n   */\n  readonly encapsulation: ViewEncapsulation;\n\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   */\n  readonly data: {\n    [kind: string]: any;\n    animation?: any[];\n  };\n\n  /** Whether or not this component's ChangeDetectionStrategy is OnPush */\n  readonly onPush: boolean;\n\n  /** Whether or not this component is signal-based. */\n  readonly signals: boolean;\n\n  /**\n   * Registry of directives and components that may be found in this view.\n   *\n   * The property is either an array of `DirectiveDef`s or a function which returns the array of\n   * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n   */\n  directiveDefs: DirectiveDefListOrFactory | null;\n\n  /**\n   * Registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   */\n  pipeDefs: PipeDefListOrFactory | null;\n\n  /**\n   * Unfiltered list of all dependencies of a component, or `null` if none.\n   */\n  dependencies: TypeOrFactory<DependencyTypeList> | null;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the component's template.\n   */\n  schemas: SchemaMetadata[] | null;\n\n  /**\n   * Ivy runtime uses this place to store the computed tView for the component. This gets filled on\n   * the first run of component.\n   */\n  tView: TView | null;\n\n  /**\n   * A function used by the framework to create standalone injectors.\n   */\n  getStandaloneInjector:\n    | ((parentInjector: EnvironmentInjector) => EnvironmentInjector | null)\n    | null;\n\n  /**\n   * A function used by the framework to create the list of external runtime style URLs.\n   */\n  getExternalStyles: ((encapsulationId?: string) => string[]) | null;\n\n  /**\n   * Used to store the result of `noSideEffects` function so that it is not removed by closure\n   * compiler. The property should never be read.\n   */\n  readonly _?: unknown;\n}\n\n/**\n * Runtime link information for Pipes.\n *\n * This is an internal data structure used by the renderer to link\n * pipes into templates.\n *\n * NOTE: Always use `definePipe` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link definePipe}\n */\nexport interface PipeDef<T> {\n  /** Token representing the pipe. */\n  type: Type<T>;\n\n  /**\n   * Pipe name.\n   *\n   * Used to resolve pipe in templates.\n   */\n  readonly name: string;\n\n  /**\n   * Factory function used to create a new pipe instance. Will be null initially.\n   * Populated when the factory is first requested by pipe instantiation logic.\n   */\n  factory: FactoryFn<T> | null;\n\n  /**\n   * Whether or not the pipe is pure.\n   *\n   * Pure pipes result only depends on the pipe input and not on internal\n   * state of the pipe.\n   */\n  readonly pure: boolean;\n\n  /**\n   * Whether this pipe is standalone.\n   */\n  readonly standalone: boolean;\n\n  /* The following are lifecycle hooks for this pipe */\n  onDestroy: (() => void) | null;\n}\n\nexport interface DirectiveDefFeature {\n  <T>(directiveDef: DirectiveDef<T>): void;\n  /**\n   * Marks a feature as something that {@link InheritDefinitionFeature} will execute\n   * during inheritance.\n   *\n   * NOTE: DO NOT SET IN ROOT OF MODULE! Doing so will result in tree-shakers/bundlers\n   * identifying the change as a side effect, and the feature will be included in\n   * every bundle.\n   */\n  ngInherit?: true;\n}\n\n/** Data produced after host directives are resolved for a node. */\nexport type HostDirectiveResolution = [\n  matches: DirectiveDef<unknown>[],\n  hostDirectiveDefs: HostDirectiveDefs | null,\n  hostDirectiveRanges: HostDirectiveRanges | null,\n];\n\n/**\n * Map that tracks a selector-matched directive to the range within which its host directives\n * are declared. Host directives for a specific directive are always contiguous within the runtime.\n * Note that both the start and end are inclusive and they're both **after** `tNode.directiveStart`.\n */\nexport type HostDirectiveRanges = Map<DirectiveDef<unknown>, [start: number, end: number]>;\n\n/** Runtime information used to configure a host directive. */\nexport interface HostDirectiveDef<T = unknown> {\n  /** Class representing the host directive. */\n  directive: Type<T>;\n\n  /** Directive inputs that have been exposed. */\n  inputs: HostDirectiveBindingMap;\n\n  /** Directive outputs that have been exposed. */\n  outputs: HostDirectiveBindingMap;\n}\n\n/**\n * Mapping between the public aliases of directive bindings and the underlying inputs/outputs that\n * they represent. Also serves as an allowlist of the inputs/outputs from the host directive that\n * the author has decided to expose.\n */\nexport type HostDirectiveBindingMap = {\n  [publicName: string]: string;\n};\n\n/**\n * Mapping between a directive that was used as a host directive\n * and the configuration that was used to define it as such.\n */\nexport type HostDirectiveDefs = Map<DirectiveDef<unknown>, HostDirectiveDef>;\n\n/** Value that can be used to configure a host directive. */\nexport type HostDirectiveConfig =\n  | Type<unknown>\n  | {\n      directive: Type<unknown>;\n      inputs?: string[];\n      outputs?: string[];\n    };\n\nexport interface ComponentDefFeature {\n  <T>(componentDef: ComponentDef<T>): void;\n  /**\n   * Marks a feature as something that {@link InheritDefinitionFeature} will execute\n   * during inheritance.\n   *\n   * NOTE: DO NOT SET IN ROOT OF MODULE! Doing so will result in tree-shakers/bundlers\n   * identifying the change as a side effect, and the feature will be included in\n   * every bundle.\n   */\n  ngInherit?: true;\n}\n\n/** Function that can be used to transform incoming input values. */\nexport type InputTransformFunction = (value: any) => any;\n\n/**\n * Type used for directiveDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\nexport type DirectiveDefListOrFactory = (() => DirectiveDefList) | DirectiveDefList;\n\nexport type DirectiveDefList = (DirectiveDef<any> | ComponentDef<any>)[];\n\nexport type DependencyDef = DirectiveDef<unknown> | ComponentDef<unknown> | PipeDef<unknown>;\n\nexport type DirectiveTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;\n\nexport type DirectiveTypeList = (\n  | DirectiveType<any>\n  | ComponentType<any>\n  | Type<any>\n) /* Type as workaround for: Microsoft/TypeScript/issues/4881 */[];\n\nexport type DependencyType = DirectiveType<any> | ComponentType<any> | PipeType<any> | Type<any>;\n\nexport type DependencyTypeList = Array<DependencyType>;\n\nexport type TypeOrFactory<T> = T | (() => T);\n\nexport type HostBindingsFunction<T> = <U extends T>(rf: RenderFlags, ctx: U) => void;\n\n/**\n * Type used for PipeDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\nexport type PipeDefListOrFactory = (() => PipeDefList) | PipeDefList;\n\nexport type PipeDefList = PipeDef<any>[];\n\nexport type PipeTypesOrFactory = (() => PipeTypeList) | PipeTypeList;\n\nexport type PipeTypeList = (\n  | PipeType<any>\n  | Type<any>\n) /* Type as workaround for: Microsoft/TypeScript/issues/4881 */[];\n\n/**\n * NgModule scope info as provided by AoT compiler\n *\n * In full compilation Ivy resolved all the \"module with providers\" and forward refs the whole array\n * if at least one element is forward refed. So we end up with type `Type<any>[]|(() =>\n * Type<any>[])`.\n *\n * In local mode the compiler passes the raw info as they are to the runtime functions as it is not\n * possible to resolve them any further due to limited info at compile time. So we end up with type\n * `RawScopeInfoFromDecorator[]`.\n */\nexport interface NgModuleScopeInfoFromDecorator {\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[] | (() => Type<any>[]) | RawScopeInfoFromDecorator[];\n\n  /** List of modules or `ModuleWithProviders` or standalone components imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]) | RawScopeInfoFromDecorator[];\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]) | RawScopeInfoFromDecorator[];\n\n  /**\n   * The set of components that are bootstrapped when this module is bootstrapped. This field is\n   * only available in local compilation mode. In full compilation mode bootstrap info is passed\n   * directly to the module def runtime after statically analyzed and resolved.\n   */\n  bootstrap?: Type<any>[] | (() => Type<any>[]) | RawScopeInfoFromDecorator[];\n}\n\n/**\n * The array element type passed to:\n *  - NgModule's annotation imports/exports/declarations fields\n *  - standalone component annotation imports field\n */\nexport type RawScopeInfoFromDecorator =\n  | Type<any>\n  | ModuleWithProviders<any>\n  | (() => Type<any>)\n  | (() => ModuleWithProviders<any>)\n  | any[];\n"]}