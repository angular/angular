{"version":3,"file":"styling.js","sourceRoot":"","sources":["styling.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,YAAY,EAAE,mBAAmB,EAAC,MAAM,mBAAmB,CAAC;AAsJpE,MAAM,UAAU,eAAe,CAAC,IAAY,EAAE,IAAY;IACxD,SAAS,IAAI,mBAAmB,CAAC,IAAI,EAAE,CAAC,yCAA6B,CAAC;IACtE,SAAS,IAAI,mBAAmB,CAAC,IAAI,EAAE,CAAC,yCAA6B,CAAC;IACtE,OAAO,CAAC,CAAC,IAAI,oCAA2B,CAAC,GAAG,CAAC,IAAI,mCAA2B,CAAC,CAAkB,CAAC;AAClG,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAC,aAA4B;IAC/D,SAAS,IAAI,YAAY,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC5D,OAAO,CAAC,aAAa,oCAA2B,CAAC,yCAA6B,CAAC;AACjF,CAAC;AAED,MAAM,UAAU,6BAA6B,CAAC,aAA4B;IACxE,SAAS,IAAI,YAAY,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC5D,OAAO,CAAC,aAAa,sCAA8B,CAAC,uCAA+B,CAAC;AACtF,CAAC;AAED,MAAM,UAAU,oBAAoB,CAClC,aAA4B,EAC5B,QAAgB;IAEhB,SAAS,IAAI,YAAY,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC5D,SAAS,IAAI,mBAAmB,CAAC,QAAQ,EAAE,CAAC,yCAA6B,CAAC;IAC1E,OAAO,CAAC,CAAC,aAAa,GAAG,wCAAuB,CAAC;QAC/C,CAAC,QAAQ,oCAA2B,CAAC,CAAkB,CAAC;AAC5D,CAAC;AAED,MAAM,UAAU,6BAA6B,CAAC,aAA4B;IACxE,SAAS,IAAI,YAAY,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC5D,OAAO,CAAC,aAAa,sCAA8B,CAAkB,CAAC;AACxE,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAC,aAA4B;IAC/D,SAAS,IAAI,YAAY,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC5D,OAAO,CAAC,aAAa,sCAAyB,CAAC,mCAA2B,CAAC;AAC7E,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAC,aAA4B,EAAE,IAAY;IAC7E,SAAS,IAAI,YAAY,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC5D,SAAS,IAAI,mBAAmB,CAAC,IAAI,EAAE,CAAC,yCAA6B,CAAC;IACtE,OAAO,CAAC,CAAC,aAAa,GAAG,oCAAuB,CAAC,GAAG,EAAE;QACpD,CAAC,IAAI,mCAA2B,CAAC,CAAkB,CAAC;AACxD,CAAC;AAED,MAAM,UAAU,6BAA6B,CAAC,aAA4B;IACxE,SAAS,IAAI,YAAY,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC5D,OAAO,CAAC,aAAa,sCAA8B,CAAC,wCAAgC,CAAC;AACvF,CAAC;AAED,MAAM,UAAU,6BAA6B,CAAC,aAA4B;IACxE,SAAS,IAAI,YAAY,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC5D,OAAO,CAAC,aAAa,sCAA8B,CAAkB,CAAC;AACxE,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAC,aAA4B;IAC/D,SAAS,IAAI,YAAY,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;IAC5D,MAAM,IAAI,GAAG,oBAAoB,CAAC,aAAa,CAAC,CAAC;IACjD,OAAO,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,oBAAoB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;AACjE,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {KeyValueArray} from '../../util/array_utils';\nimport {assertNumber, assertNumberInRange} from '../../util/assert';\n\n/**\n * Value stored in the `TData` which is needed to re-concatenate the styling.\n *\n * See: `TStylingKeyPrimitive` and `TStylingStatic`\n */\nexport type TStylingKey = TStylingKeyPrimitive | TStylingStatic;\n\n/**\n * The primitive portion (`TStylingStatic` removed) of the value stored in the `TData` which is\n * needed to re-concatenate the styling.\n *\n * - `string`: Stores the property name. Used with `ɵɵstyleProp`/`ɵɵclassProp` instruction.\n * - `null`: Represents map, so there is no name. Used with `ɵɵstyleMap`/`ɵɵclassMap`.\n * - `false`: Represents an ignore case. This happens when `ɵɵstyleProp`/`ɵɵclassProp` instruction\n *   is combined with directive which shadows its input `@Input('class')`. That way the binding\n *   should not participate in the styling resolution.\n */\nexport type TStylingKeyPrimitive = string | null | false;\n\n/**\n * Store the static values for the styling binding.\n *\n * The `TStylingStatic` is just `KeyValueArray` where key `\"\"` (stored at location 0) contains the\n * `TStylingKey` (stored at location 1). In other words this wraps the `TStylingKey` such that the\n * `\"\"` contains the wrapped value.\n *\n * When instructions are resolving styling they may need to look forward or backwards in the linked\n * list to resolve the value. For this reason we have to make sure that he linked list also contains\n * the static values. However the list only has space for one item per styling instruction. For this\n * reason we store the static values here as part of the `TStylingKey`. This means that the\n * resolution function when looking for a value needs to first look at the binding value, and than\n * at `TStylingKey` (if it exists).\n *\n * Imagine we have:\n *\n * ```angular-ts\n * <div class=\"TEMPLATE\" my-dir>\n *\n * @Directive({\n *   host: {\n *     class: 'DIR',\n *     '[class.dynamic]': 'exp' // ɵɵclassProp('dynamic', ctx.exp);\n *   }\n * })\n * ```\n *\n * In the above case the linked list will contain one item:\n *\n * ```ts\n *   // assume binding location: 10 for `ɵɵclassProp('dynamic', ctx.exp);`\n *   tData[10] = <TStylingStatic>[\n *     '': 'dynamic', // This is the wrapped value of `TStylingKey`\n *     'DIR': true,   // This is the default static value of directive binding.\n *   ];\n *   tData[10 + 1] = 0; // We don't have prev/next.\n *\n *   lView[10] = undefined;     // assume `ctx.exp` is `undefined`\n *   lView[10 + 1] = undefined; // Just normalized `lView[10]`\n * ```\n *\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into the static `TStylingStatic` too see if there is a default value for\n * `dynamic` (there is not). Therefore it is safe to remove it.\n *\n * If setting `true` case:\n * ```ts\n *   lView[10] = true;     // assume `ctx.exp` is `true`\n *   lView[10 + 1] = true; // Just normalized `lView[10]`\n * ```\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into `TNode.residualClass` (TNode.residualStyle) which contains\n * ```ts\n *   tNode.residualClass = [\n *     'TEMPLATE': true,\n *   ];\n * ```\n *\n * This means that it is safe to add class.\n */\nexport interface TStylingStatic extends KeyValueArray<any> {}\n\n/**\n * This is a branded number which contains previous and next index.\n *\n * When we come across styling instructions we need to store the `TStylingKey` in the correct\n * order so that we can re-concatenate the styling value in the desired priority.\n *\n * The insertion can happen either at the:\n * - end of template as in the case of coming across additional styling instruction in the template\n * - in front of the template in the case of coming across additional instruction in the\n *   `hostBindings`.\n *\n * We use `TStylingRange` to store the previous and next index into the `TData` where the template\n * bindings can be found.\n *\n * - bit 0 is used to mark that the previous index has a duplicate for current value.\n * - bit 1 is used to mark that the next index has a duplicate for the current value.\n * - bits 2-16 are used to encode the next/tail of the template.\n * - bits 17-32 are used to encode the previous/head of template.\n *\n * NODE: *duplicate* false implies that it is statically known that this binding will not collide\n * with other bindings and therefore there is no need to check other bindings. For example the\n * bindings in `<div [style.color]=\"exp\" [style.width]=\"exp\">` will never collide and will have\n * their bits set accordingly. Previous duplicate means that we may need to check previous if the\n * current binding is `null`. Next duplicate means that we may need to check next bindings if the\n * current binding is not `null`.\n *\n * NOTE: `0` has special significance and represents `null` as in no additional pointer.\n */\nexport type TStylingRange = number & {\n  __brand__: 'TStylingRange';\n};\n\n/**\n * Shift and masks constants for encoding two numbers into and duplicate info into a single number.\n */\nexport const enum StylingRange {\n  /// Number of bits to shift for the previous pointer\n  PREV_SHIFT = 17,\n  /// Previous pointer mask.\n  PREV_MASK = 0xfffe0000,\n\n  /// Number of bits to shift for the next pointer\n  NEXT_SHIFT = 2,\n  /// Next pointer mask.\n  NEXT_MASK = 0x001fffc,\n\n  // Mask to remove negative bit. (interpret number as positive)\n  UNSIGNED_MASK = 0x7fff,\n\n  /**\n   * This bit is set if the previous bindings contains a binding which could possibly cause a\n   * duplicate. For example: `<div [style]=\"map\" [style.width]=\"width\">`, the `width` binding will\n   * have previous duplicate set. The implication is that if `width` binding becomes `null`, it is\n   * necessary to defer the value to `map.width`. (Because `width` overwrites `map.width`.)\n   */\n  /* tslint:disable-next-line:no-duplicate-enum-values */\n  PREV_DUPLICATE = 0x02,\n\n  /**\n   * This bit is set to if the next binding contains a binding which could possibly cause a\n   * duplicate. For example: `<div [style]=\"map\" [style.width]=\"width\">`, the `map` binding will\n   * have next duplicate set. The implication is that if `map.width` binding becomes not `null`, it\n   * is necessary to defer the value to `width`. (Because `width` overwrites `map.width`.)\n   */\n  NEXT_DUPLICATE = 0x01,\n}\n\nexport function toTStylingRange(prev: number, next: number): TStylingRange {\n  ngDevMode && assertNumberInRange(prev, 0, StylingRange.UNSIGNED_MASK);\n  ngDevMode && assertNumberInRange(next, 0, StylingRange.UNSIGNED_MASK);\n  return ((prev << StylingRange.PREV_SHIFT) | (next << StylingRange.NEXT_SHIFT)) as TStylingRange;\n}\n\nexport function getTStylingRangePrev(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange >> StylingRange.PREV_SHIFT) & StylingRange.UNSIGNED_MASK;\n}\n\nexport function getTStylingRangePrevDuplicate(tStylingRange: TStylingRange): boolean {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange & StylingRange.PREV_DUPLICATE) == StylingRange.PREV_DUPLICATE;\n}\n\nexport function setTStylingRangePrev(\n  tStylingRange: TStylingRange,\n  previous: number,\n): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(previous, 0, StylingRange.UNSIGNED_MASK);\n  return ((tStylingRange & ~StylingRange.PREV_MASK) |\n    (previous << StylingRange.PREV_SHIFT)) as TStylingRange;\n}\n\nexport function setTStylingRangePrevDuplicate(tStylingRange: TStylingRange): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange | StylingRange.PREV_DUPLICATE) as TStylingRange;\n}\n\nexport function getTStylingRangeNext(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange & StylingRange.NEXT_MASK) >> StylingRange.NEXT_SHIFT;\n}\n\nexport function setTStylingRangeNext(tStylingRange: TStylingRange, next: number): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(next, 0, StylingRange.UNSIGNED_MASK);\n  return ((tStylingRange & ~StylingRange.NEXT_MASK) | //\n    (next << StylingRange.NEXT_SHIFT)) as TStylingRange;\n}\n\nexport function getTStylingRangeNextDuplicate(tStylingRange: TStylingRange): boolean {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange & StylingRange.NEXT_DUPLICATE) === StylingRange.NEXT_DUPLICATE;\n}\n\nexport function setTStylingRangeNextDuplicate(tStylingRange: TStylingRange): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange | StylingRange.NEXT_DUPLICATE) as TStylingRange;\n}\n\nexport function getTStylingRangeTail(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  const next = getTStylingRangeNext(tStylingRange);\n  return next === 0 ? getTStylingRangePrev(tStylingRange) : next;\n}\n"]}