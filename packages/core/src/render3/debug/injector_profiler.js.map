{"version":3,"file":"injector_profiler.js","sourceRoot":"","sources":["injector_profiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {FactoryProvider, ProviderToken} from '../../di';\nimport {resolveForwardRef} from '../../di/forward_ref';\nimport {InjectionToken} from '../../di/injection_token';\nimport type {Injector} from '../../di/injector';\nimport {InjectOptions, InternalInjectFlags} from '../../di/interface/injector';\nimport type {SingleProvider} from '../../di/provider_collection';\nimport {Type} from '../../interface/type';\nimport {throwError} from '../../util/assert';\nimport type {TNode} from '../interfaces/node';\nimport type {LView} from '../interfaces/view';\nimport type {EffectRef} from '../reactivity/effect';\n\n/**\n * An enum describing the types of events that can be emitted from the injector profiler\n */\nexport const enum InjectorProfilerEventType {\n  /**\n   * Emits when a service is injected.\n   */\n  Inject,\n\n  /**\n   * Emits when an Angular class instance is created by an injector.\n   */\n  InstanceCreatedByInjector,\n\n  /**\n   * Emits when an injector configures a provider.\n   */\n  ProviderConfigured,\n\n  /**\n   * Emits when an effect is created.\n   */\n  EffectCreated,\n\n  /**\n   * Emits when an Angular DI system is about to create an instance corresponding to a given token.\n   */\n  InjectorToCreateInstanceEvent,\n}\n\n/**\n * An object that defines an injection context for the injector profiler.\n */\nexport interface InjectorProfilerContext {\n  /**\n   *  The Injector that service is being injected into.\n   *      - Example: if ModuleA --provides--> ServiceA --injects--> ServiceB\n   *                 then inject(ServiceB) in ServiceA has ModuleA as an injector context\n   */\n  injector: Injector;\n\n  /**\n   *  The class where the constructor that is calling `inject` is located\n   *      - Example: if ModuleA --provides--> ServiceA --injects--> ServiceB\n   *                 then inject(ServiceB) in ServiceA has ServiceA as a construction context\n   */\n  token: Type<unknown> | null;\n}\n\nexport interface InjectedServiceEvent {\n  type: InjectorProfilerEventType.Inject;\n  context: InjectorProfilerContext;\n  service: InjectedService;\n}\n\nexport interface InjectorToCreateInstanceEvent {\n  type: InjectorProfilerEventType.InjectorToCreateInstanceEvent;\n  context: InjectorProfilerContext;\n  token: ProviderToken<unknown>;\n}\n\nexport interface InjectorCreatedInstanceEvent {\n  type: InjectorProfilerEventType.InstanceCreatedByInjector;\n  context: InjectorProfilerContext;\n  instance: InjectorCreatedInstance;\n}\n\nexport interface ProviderConfiguredEvent {\n  type: InjectorProfilerEventType.ProviderConfigured;\n  context: InjectorProfilerContext;\n  providerRecord: ProviderRecord;\n}\n\nexport interface EffectCreatedEvent {\n  type: InjectorProfilerEventType.EffectCreated;\n  context: InjectorProfilerContext;\n  effect: EffectRef;\n}\n\n/**\n * An object representing an event that is emitted through the injector profiler\n */\n\nexport type InjectorProfilerEvent =\n  | InjectedServiceEvent\n  | InjectorToCreateInstanceEvent\n  | InjectorCreatedInstanceEvent\n  | ProviderConfiguredEvent\n  | EffectCreatedEvent;\n\n/**\n * An object that contains information about a provider that has been configured\n *\n * TODO: rename to indicate that it is a debug structure eg. ProviderDebugInfo.\n */\nexport interface ProviderRecord {\n  /**\n   * DI token that this provider is configuring\n   */\n  token: Type<unknown> | InjectionToken<unknown>;\n\n  /**\n   * Determines if provider is configured as view provider.\n   */\n  isViewProvider: boolean;\n\n  /**\n   * The raw provider associated with this ProviderRecord.\n   */\n  provider: SingleProvider;\n\n  /**\n   * The path of DI containers that were followed to import this provider\n   */\n  importPath?: Type<unknown>[];\n}\n\n/**\n * An object that contains information about a value that has been constructed within an injector\n */\nexport interface InjectorCreatedInstance {\n  /**\n   * Value of the created instance\n   */\n  value: unknown;\n}\n\n/**\n * An object that contains information a service that has been injected within an\n * InjectorProfilerContext\n */\nexport interface InjectedService {\n  /**\n   * DI token of the Service that is injected\n   */\n  token?: Type<unknown> | InjectionToken<unknown>;\n\n  /**\n   * Value of the injected service\n   */\n  value: unknown;\n\n  /**\n   * Flags that this service was injected with\n   */\n  flags?: InternalInjectFlags | InjectOptions;\n\n  /**\n   * Injector that this service was provided in.\n   */\n  providedIn?: Injector;\n\n  /**\n   * In NodeInjectors, the LView and TNode that serviced this injection.\n   */\n  injectedIn?: {lView: LView; tNode: TNode};\n}\n\nexport interface InjectorProfiler {\n  (event: InjectorProfilerEvent): void;\n}\n\nlet _injectorProfilerContext: InjectorProfilerContext;\nexport function getInjectorProfilerContext() {\n  !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');\n  return _injectorProfilerContext;\n}\n\nexport function setInjectorProfilerContext(context: InjectorProfilerContext) {\n  !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');\n\n  const previous = _injectorProfilerContext;\n  _injectorProfilerContext = context;\n  return previous;\n}\n\nconst injectorProfilerCallbacks: InjectorProfiler[] = [];\n\nconst NOOP_PROFILER_REMOVAL = () => {};\n\nfunction removeProfiler(profiler: InjectorProfiler) {\n  const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);\n  if (profilerIdx !== -1) {\n    injectorProfilerCallbacks.splice(profilerIdx, 1);\n  }\n}\n\n/**\n * Adds a callback function which will be invoked during certain DI events within the\n * runtime (for example: injecting services, creating injectable instances, configuring providers).\n * Multiple profiler callbacks can be set: in this case profiling events are\n * reported to every registered callback.\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n * @returns a cleanup function that, when invoked, removes a given profiler callback.\n */\nexport function setInjectorProfiler(injectorProfiler: InjectorProfiler | null): () => void {\n  !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');\n\n  if (injectorProfiler !== null) {\n    if (!injectorProfilerCallbacks.includes(injectorProfiler)) {\n      injectorProfilerCallbacks.push(injectorProfiler);\n    }\n    return () => removeProfiler(injectorProfiler);\n  } else {\n    injectorProfilerCallbacks.length = 0;\n    return NOOP_PROFILER_REMOVAL;\n  }\n}\n\n/**\n * Injector profiler function which emits on DI events executed by the runtime.\n *\n * @param event InjectorProfilerEvent corresponding to the DI event being emitted\n */\nexport function injectorProfiler(event: InjectorProfilerEvent): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  for (let i = 0; i < injectorProfilerCallbacks.length; i++) {\n    const injectorProfilerCallback = injectorProfilerCallbacks[i];\n    injectorProfilerCallback(event);\n  }\n}\n\n/**\n * Emits an InjectorProfilerEventType.ProviderConfigured to the injector profiler. The data in the\n * emitted event includes the raw provider, as well as the token that provider is providing.\n *\n * @param eventProvider A provider object\n */\nexport function emitProviderConfiguredEvent(\n  eventProvider: SingleProvider,\n  isViewProvider: boolean = false,\n): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  let token;\n  // if the provider is a TypeProvider (typeof provider is function) then the token is the\n  // provider itself\n  if (typeof eventProvider === 'function') {\n    token = eventProvider;\n  }\n  // if the provider is an injection token, then the token is the injection token.\n  else if (eventProvider instanceof InjectionToken) {\n    token = eventProvider;\n  }\n  // in all other cases we can access the token via the `provide` property of the provider\n  else {\n    token = resolveForwardRef(eventProvider.provide);\n  }\n\n  let provider = eventProvider;\n  // Injection tokens may define their own default provider which gets attached to the token itself\n  // as `ɵprov`. In this case, we want to emit the provider that is attached to the token, not the\n  // token itself.\n  if (eventProvider instanceof InjectionToken) {\n    provider = (eventProvider.ɵprov as FactoryProvider) || eventProvider;\n  }\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.ProviderConfigured,\n    context: getInjectorProfilerContext(),\n    providerRecord: {token, provider, isViewProvider},\n  });\n}\n\n/**\n * Emits an event to the injector profiler when an instance corresponding to a given token is about to be created be an injector. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nexport function emitInjectorToCreateInstanceEvent(token: ProviderToken<unknown>): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.InjectorToCreateInstanceEvent,\n    context: getInjectorProfilerContext(),\n    token: token,\n  });\n}\n\n/**\n * Emits an event to the injector profiler with the instance that was created. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nexport function emitInstanceCreatedByInjectorEvent(instance: unknown): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.InstanceCreatedByInjector,\n    context: getInjectorProfilerContext(),\n    instance: {value: instance},\n  });\n}\n\n/**\n * @param token DI token associated with injected service\n * @param value the instance of the injected service (i.e the result of `inject(token)`)\n * @param flags the flags that the token was injected with\n */\nexport function emitInjectEvent(\n  token: Type<unknown>,\n  value: unknown,\n  flags: InternalInjectFlags,\n): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.Inject,\n    context: getInjectorProfilerContext(),\n    service: {token, value, flags},\n  });\n}\n\nexport function emitEffectCreatedEvent(effect: EffectRef): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.EffectCreated,\n    context: getInjectorProfilerContext(),\n    effect,\n  });\n}\n\nexport function runInInjectorProfilerContext(\n  injector: Injector,\n  token: Type<unknown>,\n  callback: () => void,\n): void {\n  !ngDevMode &&\n    throwError('runInInjectorProfilerContext should never be called in production mode');\n\n  const prevInjectContext = setInjectorProfilerContext({injector, token});\n  try {\n    callback();\n  } finally {\n    setInjectorProfilerContext(prevInjectContext);\n  }\n}\n"]}