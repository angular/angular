{"version":3,"file":"framework_injector_profiler.js","sourceRoot":"","sources":["framework_injector_profiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector} from '../../di/injector';\nimport {EnvironmentInjector} from '../../di/r3_injector';\nimport {Type} from '../../interface/type';\nimport {assertDefined, throwError} from '../../util/assert';\nimport {assertTNodeForLView} from '../assert';\nimport {getComponentDef} from '../def_getters';\nimport {getNodeInjectorLView, getNodeInjectorTNode, NodeInjector} from '../di';\nimport {TNode} from '../interfaces/node';\nimport {LView} from '../interfaces/view';\nimport {EffectRef} from '../reactivity/effect';\n\nimport {\n  InjectedService,\n  InjectorCreatedInstance,\n  InjectorProfiler,\n  InjectorProfilerContext,\n  InjectorProfilerEvent,\n  InjectorProfilerEventType,\n  ProviderRecord,\n  setInjectorProfiler,\n} from './injector_profiler';\n\n/**\n * These are the data structures that our framework injector profiler will fill with data in order\n * to support DI debugging APIs.\n *\n * resolverToTokenToDependencies: Maps an injector to a Map of tokens to an Array of\n * dependencies. Injector -> Token -> Dependencies This is used to support the\n * getDependenciesFromInjectable API, which takes in an injector and a token and returns it's\n * dependencies.\n *\n * resolverToProviders: Maps a DI resolver (an Injector or a TNode) to the providers configured\n * within it This is used to support the getInjectorProviders API, which takes in an injector and\n * returns the providers that it was configured with. Note that for the element injector case we\n * use the TNode instead of the LView as the DI resolver. This is because the registration of\n * providers happens only once per type of TNode. If an injector is created with an identical TNode,\n * the providers for that injector will not be reconfigured.\n *\n * standaloneInjectorToComponent: Maps the injector of a standalone component to the standalone\n * component that it is associated with. Used in the getInjectorProviders API, specificially in the\n * discovery of import paths for each provider. This is necessary because the imports array of a\n * standalone component is processed and configured in its standalone injector, but exists within\n * the component's definition. Because getInjectorProviders takes in an injector, if that injector\n * is the injector of a standalone component, we need to be able to discover the place where the\n * imports array is located (the component) in order to flatten the imports array within it to\n * discover all of it's providers.\n *\n *\n * All of these data structures are instantiated with WeakMaps. This will ensure that the presence\n * of any object in the keys of these maps does not prevent the garbage collector from collecting\n * those objects. Because of this property of WeakMaps, these data structures will never be the\n * source of a memory leak.\n *\n * An example of this advantage: When components are destroyed, we don't need to do\n * any additional work to remove that component from our mappings.\n *\n */\nclass DIDebugData {\n  resolverToTokenToDependencies = new WeakMap<\n    Injector | LView,\n    WeakMap<Type<unknown>, InjectedService[]>\n  >();\n  resolverToProviders = new WeakMap<Injector | TNode, ProviderRecord[]>();\n  resolverToEffects = new WeakMap<Injector | LView, EffectRef[]>();\n  standaloneInjectorToComponent = new WeakMap<Injector, Type<unknown>>();\n\n  reset() {\n    this.resolverToTokenToDependencies = new WeakMap<\n      Injector | LView,\n      WeakMap<Type<unknown>, InjectedService[]>\n    >();\n    this.resolverToProviders = new WeakMap<Injector | TNode, ProviderRecord[]>();\n    this.standaloneInjectorToComponent = new WeakMap<Injector, Type<unknown>>();\n  }\n}\n\nlet frameworkDIDebugData = new DIDebugData();\n\nexport function getFrameworkDIDebugData(): DIDebugData {\n  return frameworkDIDebugData;\n}\n\n/**\n * Initalize default handling of injector events. This handling parses events\n * as they are emitted and constructs the data structures necessary to support\n * some of debug APIs.\n *\n * See handleInjectEvent, handleCreateEvent and handleProviderConfiguredEvent\n * for descriptions of each handler\n *\n * Supported APIs:\n *               - getDependenciesFromInjectable\n *               - getInjectorProviders\n */\nexport function setupFrameworkInjectorProfiler(): void {\n  frameworkDIDebugData.reset();\n  setInjectorProfiler(injectorProfilerEventHandler);\n}\n\nfunction injectorProfilerEventHandler(injectorProfilerEvent: InjectorProfilerEvent): void {\n  const {context, type} = injectorProfilerEvent;\n\n  if (type === InjectorProfilerEventType.Inject) {\n    handleInjectEvent(context, injectorProfilerEvent.service);\n  } else if (type === InjectorProfilerEventType.InstanceCreatedByInjector) {\n    handleInstanceCreatedByInjectorEvent(context, injectorProfilerEvent.instance);\n  } else if (type === InjectorProfilerEventType.ProviderConfigured) {\n    handleProviderConfiguredEvent(context, injectorProfilerEvent.providerRecord);\n  } else if (type === InjectorProfilerEventType.EffectCreated) {\n    handleEffectCreatedEvent(context, injectorProfilerEvent.effect);\n  }\n}\n\nfunction handleEffectCreatedEvent(context: InjectorProfilerContext, effect: EffectRef): void {\n  const diResolver = getDIResolver(context.injector);\n  if (diResolver === null) {\n    throwError('An EffectCreated event must be run within an injection context.');\n  }\n\n  const {resolverToEffects} = frameworkDIDebugData;\n\n  if (!resolverToEffects.has(diResolver)) {\n    resolverToEffects.set(diResolver, []);\n  }\n\n  resolverToEffects.get(diResolver)!.push(effect);\n}\n\n/**\n *\n * Stores the injected service in frameworkDIDebugData.resolverToTokenToDependencies\n * based on it's injector and token.\n *\n * @param context InjectorProfilerContext the injection context that this event occurred in.\n * @param data InjectedService the service associated with this inject event.\n *\n */\nfunction handleInjectEvent(context: InjectorProfilerContext, data: InjectedService) {\n  const diResolver = getDIResolver(context.injector);\n  if (diResolver === null) {\n    throwError('An Inject event must be run within an injection context.');\n  }\n\n  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;\n\n  if (!diResolverToInstantiatedToken.has(diResolver)) {\n    diResolverToInstantiatedToken.set(diResolver, new WeakMap<Type<unknown>, InjectedService[]>());\n  }\n\n  // if token is a primitive type, ignore this event. We do this because we cannot keep track of\n  // non-primitive tokens in WeakMaps since they are not garbage collectable.\n  if (!canBeHeldWeakly(context.token)) {\n    return;\n  }\n\n  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver)!;\n  if (!instantiatedTokenToDependencies.has(context.token!)) {\n    instantiatedTokenToDependencies.set(context.token!, []);\n  }\n\n  const {token, value, flags} = data;\n\n  assertDefined(context.token, 'Injector profiler context token is undefined.');\n\n  const dependencies = instantiatedTokenToDependencies.get(context.token);\n  assertDefined(dependencies, 'Could not resolve dependencies for token.');\n\n  if (context.injector instanceof NodeInjector) {\n    dependencies.push({token, value, flags, injectedIn: getNodeInjectorContext(context.injector)});\n  } else {\n    dependencies.push({token, value, flags});\n  }\n}\n\n/**\n *\n * Returns the LView and TNode associated with a NodeInjector. Returns undefined if the injector\n * is not a NodeInjector.\n *\n * @param injector\n * @returns {lView: LView, tNode: TNode}|undefined\n */\nfunction getNodeInjectorContext(injector: Injector): {lView: LView; tNode: TNode} | undefined {\n  if (!(injector instanceof NodeInjector)) {\n    throwError('getNodeInjectorContext must be called with a NodeInjector');\n  }\n\n  const lView = getNodeInjectorLView(injector);\n  const tNode = getNodeInjectorTNode(injector);\n  if (tNode === null) {\n    return;\n  }\n\n  assertTNodeForLView(tNode, lView);\n\n  return {lView, tNode};\n}\n\n/**\n *\n * If the created instance is an instance of a standalone component, maps the injector to that\n * standalone component in frameworkDIDebugData.standaloneInjectorToComponent\n *\n * @param context InjectorProfilerContext the injection context that this event occurred in.\n * @param data InjectorCreatedInstance an object containing the instance that was just created\n *\n */\nfunction handleInstanceCreatedByInjectorEvent(\n  context: InjectorProfilerContext,\n  data: InjectorCreatedInstance,\n): void {\n  const {value} = data;\n\n  // It might happen that a DI token is requested but there is no corresponding value.\n  // The InstanceCreatedByInjectorEvent will be still emitted in this case (to mirror the InjectorToCreateInstanceEvent) but we don't want to do any particular processing for those situations.\n  if (data.value == null) {\n    return;\n  }\n\n  if (getDIResolver(context.injector) === null) {\n    throwError('An InjectorCreatedInstance event must be run within an injection context.');\n  }\n\n  // if our value is an instance of a standalone component, map the injector of that standalone\n  // component to the component class. Otherwise, this event is a noop.\n  let standaloneComponent: Type<unknown> | undefined | null = undefined;\n  if (typeof value === 'object') {\n    standaloneComponent = value?.constructor as Type<unknown> | undefined | null;\n  }\n\n  // We want to also cover if `standaloneComponent === null` in addition to `undefined`\n  if (standaloneComponent == undefined || !isStandaloneComponent(standaloneComponent)) {\n    return;\n  }\n\n  const environmentInjector: EnvironmentInjector | null = context.injector.get(\n    EnvironmentInjector,\n    null,\n    {optional: true},\n  );\n  // Standalone components should have an environment injector. If one cannot be\n  // found we may be in a test case for low level functionality that did not explicitly\n  // setup this injector. In those cases, we simply ignore this event.\n  if (environmentInjector === null) {\n    return;\n  }\n\n  const {standaloneInjectorToComponent} = frameworkDIDebugData;\n\n  // If our injector has already been mapped, as is the case\n  // when a standalone component imports another standalone component,\n  // we consider the original component (the component doing the importing)\n  // as the component connected to our injector.\n  if (standaloneInjectorToComponent.has(environmentInjector)) {\n    return;\n  }\n  // If our injector hasn't been mapped, then we map it to the standalone component\n  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);\n}\n\nfunction isStandaloneComponent(value: Type<unknown>): boolean {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\n\n/**\n *\n * Stores the emitted ProviderRecords from the InjectorProfilerEventType.ProviderConfigured\n * event in frameworkDIDebugData.resolverToProviders\n *\n * @param context InjectorProfilerContext the injection context that this event occurred in.\n * @param data ProviderRecord an object containing the instance that was just created\n *\n */\nfunction handleProviderConfiguredEvent(\n  context: InjectorProfilerContext,\n  data: ProviderRecord,\n): void {\n  const {resolverToProviders} = frameworkDIDebugData;\n\n  let diResolver: Injector | TNode;\n  if (context?.injector instanceof NodeInjector) {\n    diResolver = getNodeInjectorTNode(context.injector) as TNode;\n  } else {\n    diResolver = context.injector;\n  }\n\n  if (diResolver === null) {\n    throwError('A ProviderConfigured event must be run within an injection context.');\n  }\n\n  if (!resolverToProviders.has(diResolver)) {\n    resolverToProviders.set(diResolver, []);\n  }\n\n  resolverToProviders.get(diResolver)!.push(data);\n}\n\nfunction getDIResolver(injector: Injector | undefined): Injector | LView | null {\n  let diResolver: Injector | LView | null = null;\n\n  if (injector === undefined) {\n    return diResolver;\n  }\n\n  // We use the LView as the diResolver for NodeInjectors because they\n  // do not persist anywhere in the framework. They are simply wrappers around an LView and a TNode\n  // that do persist. Because of this, we rely on the LView of the NodeInjector in order to use\n  // as a concrete key to represent this injector. If we get the same LView back later, we know\n  // we're looking at the same injector.\n  if (injector instanceof NodeInjector) {\n    diResolver = getNodeInjectorLView(injector);\n  }\n  // Other injectors can be used a keys for a map because their instances\n  // persist\n  else {\n    diResolver = injector;\n  }\n\n  return diResolver;\n}\n\n// inspired by\n// https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#sec-canbeheldweakly\nfunction canBeHeldWeakly(value: any): boolean {\n  // we check for value !== null here because typeof null === 'object\n  return (\n    value !== null &&\n    (typeof value === 'object' || typeof value === 'function' || typeof value === 'symbol')\n  );\n}\n"]}