{"version":3,"file":"node_manipulation_i18n.js","sourceRoot":"","sources":["node_manipulation_i18n.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,aAAa,EAAE,kBAAkB,EAAC,MAAM,gBAAgB,CAAC;AAMjE,OAAO,EAAC,iCAAiC,EAAC,MAAM,qBAAqB,CAAC;AACtE,OAAO,EAAC,kBAAkB,EAAC,MAAM,yBAAyB,CAAC;AAC3D,OAAO,EAAC,WAAW,EAAC,MAAM,mBAAmB,CAAC;AAE9C;;;;;;;;;GASG;AACH,MAAM,UAAU,+BAA+B,CAC7C,WAAkB,EAClB,YAAmB,EACnB,KAAY;IAEZ,MAAM,sBAAsB,GAAG,YAAY,CAAC,iBAAiB,CAAC;IAC9D,MAAM,iBAAiB,GAAG,KAAK,CAAC,OAAO,CAAC,sBAAsB,CAAC;QAC7D,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC;QAC3B,CAAC,CAAC,sBAAsB,CAAC;IAC3B,IAAI,iBAAiB,KAAK,IAAI,EAAE,CAAC;QAC/B,OAAO,iCAAiC,CAAC,WAAW,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;IAC7E,CAAC;SAAM,CAAC;QACN,SAAS,IAAI,kBAAkB,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC;QAC1D,OAAO,WAAW,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;IAC/C,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,uBAAuB,CACrC,QAAkB,EAClB,UAAiB,EACjB,KAAY,EACZ,UAA2B,EAC3B,cAA+B;IAE/B,MAAM,sBAAsB,GAAG,UAAU,CAAC,iBAAiB,CAAC;IAC5D,IAAI,KAAK,CAAC,OAAO,CAAC,sBAAsB,CAAC,EAAE,CAAC;QAC1C,yFAAyF;QACzF,4FAA4F;QAC5F,4FAA4F;QAC5F,8FAA8F;QAC9F,gBAAgB;QAChB,SAAS,IAAI,aAAa,CAAC,UAAU,CAAC,CAAC;QACvC,IAAI,UAAU,GAAoB,UAAsB,CAAC;QACzD,IAAI,WAAW,GAAiB,IAAI,CAAC;QACrC,IAAI,CAAC,CAAC,UAAU,CAAC,IAAI,6BAAqB,CAAC,EAAE,CAAC;YAC5C,WAAW,GAAG,UAAU,CAAC;YACzB,UAAU,GAAG,cAAc,CAAC;QAC9B,CAAC;QACD,IAAI,UAAU,KAAK,IAAI,IAAI,UAAU,CAAC,eAAe,KAAK,CAAC,CAAC,EAAE,CAAC;YAC7D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,sBAAsB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACvD,gFAAgF;gBAChF,6BAA6B;gBAC7B,MAAM,SAAS,GAAG,KAAK,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,CAAC;gBACnD,kBAAkB,CAAC,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;YAC1E,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertDomNode, assertIndexInRange} from '../util/assert';\n\nimport {TNode, TNodeType} from './interfaces/node';\nimport {Renderer} from './interfaces/renderer';\nimport {RElement, RNode} from './interfaces/renderer_dom';\nimport {LView} from './interfaces/view';\nimport {getInsertInFrontOfRNodeWithNoI18n} from './node_manipulation';\nimport {nativeInsertBefore} from './dom_node_manipulation';\nimport {unwrapRNode} from './util/view_utils';\n\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nexport function getInsertInFrontOfRNodeWithI18n(\n  parentTNode: TNode,\n  currentTNode: TNode,\n  lView: LView,\n): RNode | null {\n  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex)\n    ? tNodeInsertBeforeIndex[0]\n    : tNodeInsertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n  } else {\n    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n    return unwrapRNode(lView[insertBeforeIndex]);\n  }\n}\n\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function processI18nInsertBefore(\n  renderer: Renderer,\n  childTNode: TNode,\n  lView: LView,\n  childRNode: RNode | RNode[],\n  parentRElement: RElement | null,\n): void {\n  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n  if (Array.isArray(tNodeInsertBeforeIndex)) {\n    // An array indicates that there are i18n nodes that need to be added as children of this\n    // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n    // only now can be added. The first element of the array is the normal index where we should\n    // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n    // `childRNode`.\n    ngDevMode && assertDomNode(childRNode);\n    let i18nParent: RElement | null = childRNode as RElement;\n    let anchorRNode: RNode | null = null;\n    if (!(childTNode.type & TNodeType.AnyRNode)) {\n      anchorRNode = i18nParent;\n      i18nParent = parentRElement;\n    }\n    if (i18nParent !== null && childTNode.componentOffset === -1) {\n      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n        // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n        // see `assertDomNode` below.\n        const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n      }\n    }\n  }\n}\n"]}