{"version":3,"file":"directive_outputs.js","sourceRoot":"","sources":["directive_outputs.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport type {EventCallback, WrappedEventCallback} from '../../event_delegation_utils';\nimport {assertIndexInRange} from '../../util/assert';\nimport {DirectiveDef} from '../interfaces/definition';\nimport {TNode} from '../interfaces/node';\nimport {LView, TVIEW} from '../interfaces/view';\nimport {stringifyForError} from '../util/stringify_utils';\nimport {storeListenerCleanup, wrapListener} from './listeners';\n\n/** Describes a subscribable output field value. */\ninterface SubscribableOutput<T> {\n  subscribe(listener: (v: T) => void): {\n    unsubscribe: () => void;\n  };\n}\n\nexport function createOutputListener(\n  tNode: TNode,\n  lView: LView<{} | null>,\n  listenerFn: EventCallback,\n  targetDef: DirectiveDef<unknown>,\n  eventName: string,\n) {\n  // TODO(pk): decouple checks from the actual binding\n  const wrappedListener = wrapListener(tNode, lView, listenerFn);\n  const hasBound = listenToDirectiveOutput(tNode, lView, targetDef, eventName, wrappedListener);\n\n  if (!hasBound && ngDevMode) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_BINDING_TARGET,\n      `${stringifyForError(targetDef.type)} does not have an output with a public name of \"${eventName}\".`,\n    );\n  }\n}\n\n/** Listens to an output on a specific directive. */\nfunction listenToDirectiveOutput(\n  tNode: TNode,\n  lView: LView,\n  target: DirectiveDef<unknown>,\n  eventName: string,\n  listenerFn: WrappedEventCallback,\n): boolean {\n  let hostIndex: number | null = null;\n  let hostDirectivesStart: number | null = null;\n  let hostDirectivesEnd: number | null = null;\n  let hasOutput = false;\n\n  if (ngDevMode && !tNode.directiveToIndex?.has(target.type)) {\n    throw new Error(`Node does not have a directive with type ${target.type.name}`);\n  }\n\n  const data = tNode.directiveToIndex!.get(target.type)!;\n\n  if (typeof data === 'number') {\n    hostIndex = data;\n  } else {\n    [hostIndex, hostDirectivesStart, hostDirectivesEnd] = data;\n  }\n\n  if (\n    hostDirectivesStart !== null &&\n    hostDirectivesEnd !== null &&\n    tNode.hostDirectiveOutputs?.hasOwnProperty(eventName)\n  ) {\n    const hostDirectiveOutputs = tNode.hostDirectiveOutputs[eventName];\n\n    for (let i = 0; i < hostDirectiveOutputs.length; i += 2) {\n      const index = hostDirectiveOutputs[i] as number;\n\n      if (index >= hostDirectivesStart && index <= hostDirectivesEnd) {\n        ngDevMode && assertIndexInRange(lView, index);\n        hasOutput = true;\n        listenToOutput(\n          tNode,\n          lView,\n          index,\n          hostDirectiveOutputs[i + 1] as string,\n          eventName,\n          listenerFn,\n        );\n      } else if (index > hostDirectivesEnd) {\n        break;\n      }\n    }\n  }\n\n  if (target.outputs.hasOwnProperty(eventName)) {\n    ngDevMode && assertIndexInRange(lView, hostIndex);\n    hasOutput = true;\n    listenToOutput(tNode, lView, hostIndex, eventName, eventName, listenerFn);\n  }\n\n  return hasOutput;\n}\n\nexport function listenToOutput(\n  tNode: TNode,\n  lView: LView,\n  directiveIndex: number,\n  lookupName: string,\n  eventName: string,\n  listenerFn: WrappedEventCallback,\n) {\n  ngDevMode && assertIndexInRange(lView, directiveIndex);\n  const instance = lView[directiveIndex];\n  const tView = lView[TVIEW];\n  const def = tView.data[directiveIndex] as DirectiveDef<unknown>;\n  const propertyName = def.outputs[lookupName];\n  const output = instance[propertyName];\n\n  if (ngDevMode && !isOutputSubscribable(output)) {\n    throw new Error(`@Output ${propertyName} not initialized in '${instance.constructor.name}'.`);\n  }\n\n  const subscription = (output as SubscribableOutput<unknown>).subscribe(listenerFn);\n  storeListenerCleanup(tNode.index, tView, lView, eventName, listenerFn, subscription, true);\n}\n\n/**\n * Whether the given value represents a subscribable output.\n *\n * For example, an `EventEmitter, a `Subject`, an `Observable` or an\n * `OutputEmitter`.\n */\nfunction isOutputSubscribable(value: unknown): value is SubscribableOutput<unknown> {\n  return (\n    value != null && typeof (value as Partial<SubscribableOutput<unknown>>).subscribe === 'function'\n  );\n}\n"]}