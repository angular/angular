{"version":3,"file":"listeners.js","sourceRoot":"","sources":["listeners.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {setActiveConsumer} from '@angular/core/primitives/signals';\n\nimport {NotificationSource} from '../../change_detection/scheduling/zoneless_scheduling';\nimport type {TNode} from '../interfaces/node';\nimport {isComponentHost, isDirectiveHost} from '../interfaces/type_checks';\nimport {CLEANUP, CONTEXT, type LView, type TView} from '../interfaces/view';\nimport {\n  getComponentLViewByIndex,\n  getNativeByTNode,\n  getOrCreateLViewCleanup,\n  getOrCreateTViewCleanup,\n  unwrapRNode,\n} from '../util/view_utils';\nimport {profiler} from '../profiler';\nimport {ProfilerEvent} from '../profiler_types';\nimport {markViewDirty} from '../instructions/mark_view_dirty';\nimport type {RElement} from '../interfaces/renderer_dom';\nimport type {GlobalTargetResolver, Renderer} from '../interfaces/renderer';\nimport {assertNotSame} from '../../util/assert';\nimport {handleUncaughtError} from '../instructions/shared';\nimport {\n  type EventCallback,\n  stashEventListenerImpl,\n  type WrappedEventCallback,\n} from '../../event_delegation_utils';\n\n/**\n * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\n * if applicable.\n *\n * @param tNode The TNode associated with this listener\n * @param lView The LView that contains this listener\n * @param listenerFn The listener function to call\n * @param wrapWithPreventDefault Whether or not to prevent default behavior\n * (the procedural renderer does this already, so in those cases, we should skip)\n */\nexport function wrapListener(\n  tNode: TNode,\n  lView: LView<{} | null>,\n  listenerFn: EventCallback,\n): WrappedEventCallback {\n  // Note: we are performing most of the work in the listener function itself\n  // to optimize listener registration.\n  return function wrapListenerIn_markDirtyAndPreventDefault(event: any) {\n    // In order to be backwards compatible with View Engine, events on component host nodes\n    // must also mark the component view itself dirty (i.e. the view that it owns).\n    const startView = isComponentHost(tNode) ? getComponentLViewByIndex(tNode.index, lView) : lView;\n    markViewDirty(startView, NotificationSource.Listener);\n\n    const context = lView[CONTEXT];\n    let result = executeListenerWithErrorHandling(lView, context, listenerFn, event);\n    // A just-invoked listener function might have coalesced listeners so we need to check for\n    // their presence and invoke as needed.\n    let nextListenerFn = (<any>wrapListenerIn_markDirtyAndPreventDefault).__ngNextListenerFn__;\n    while (nextListenerFn) {\n      // We should prevent default if any of the listeners explicitly return false\n      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, event) && result;\n      nextListenerFn = (<any>nextListenerFn).__ngNextListenerFn__;\n    }\n\n    return result;\n  } as WrappedEventCallback;\n}\n\nfunction executeListenerWithErrorHandling(\n  lView: LView,\n  context: {} | null,\n  listenerFn: EventCallback,\n  e: any,\n): boolean {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    profiler(ProfilerEvent.OutputStart, context, listenerFn);\n    // Only explicitly returning false from a listener should preventDefault\n    return listenerFn(e) !== false;\n  } catch (error) {\n    handleUncaughtError(lView, error);\n    return false;\n  } finally {\n    profiler(ProfilerEvent.OutputEnd, context, listenerFn);\n    setActiveConsumer(prevConsumer);\n  }\n}\n\n/**\n * Listen to a DOM event on a specific node.\n * @param tNode TNode on which to listen.\n * @param tView TView in which the node is placed.\n * @param lView LView in which the node instance is placed.\n * @param eventTargetResolver Resolver for global event targets.\n * @param renderer Renderer to use for listening to the event.\n * @param eventName Name of the event.\n * @param originalListener Original listener as it was created by the compiler. Necessary for event\n *   coalescing.\n * @param wrappedListener Listener wrapped with additional logic like marking for check and error\n *   handling.\n * @returns Boolean indicating whether the event was bound or was coalesced into an existing\n *   listener.\n */\nexport function listenToDomEvent(\n  tNode: TNode,\n  tView: TView,\n  lView: LView<{} | null>,\n  eventTargetResolver: GlobalTargetResolver | undefined,\n  renderer: Renderer,\n  eventName: string,\n  originalListener: EventCallback,\n  wrappedListener: WrappedEventCallback,\n): boolean {\n  ngDevMode &&\n    assertNotSame(\n      wrappedListener,\n      originalListener,\n      'Expected wrapped and original listeners to be different.',\n    );\n\n  const isTNodeDirectiveHost = isDirectiveHost(tNode);\n  let hasCoalesced = false;\n\n  // In order to match current behavior, native DOM event listeners must be added for all\n  // events (including outputs).\n  // There might be cases where multiple directives on the same element try to register an event\n  // handler function for the same event. In this situation we want to avoid registration of\n  // several native listeners as each registration would be intercepted by NgZone and\n  // trigger change detection. This would mean that a single user action would result in several\n  // change detections being invoked. To avoid this situation we want to have only one call to\n  // native handler registration (for the same element and same type of event).\n  //\n  // In order to have just one native event handler in presence of multiple handler functions,\n  // we just register a first handler function as a native event listener and then chain\n  // (coalesce) other handler functions on top of the first native handler function.\n  let existingListener: any = null;\n  // Please note that the coalescing described here doesn't happen for events specifying an\n  // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\n  // view engine.\n  // Also, we don't have to search for existing listeners if there are no directives\n  // matching on a given node as we can't register multiple event handlers for the same event in\n  // a template (this would mean having duplicate attributes).\n  if (!eventTargetResolver && isTNodeDirectiveHost) {\n    existingListener = findExistingListener(tView, lView, eventName, tNode.index);\n  }\n  if (existingListener !== null) {\n    // Attach a new listener to coalesced listeners list, maintaining the order in which\n    // listeners are registered. For performance reasons, we keep a reference to the last\n    // listener in that list (in `__ngLastListenerFn__` field), so we can avoid going through\n    // the entire set each time we need to add a new listener.\n    const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;\n    lastListenerFn.__ngNextListenerFn__ = originalListener;\n    existingListener.__ngLastListenerFn__ = originalListener;\n    hasCoalesced = true;\n  } else {\n    const native = getNativeByTNode(tNode, lView) as RElement;\n    const target = eventTargetResolver ? eventTargetResolver(native) : native;\n\n    stashEventListenerImpl(lView, target, eventName, wrappedListener);\n\n    const cleanupFn = renderer.listen(target as RElement, eventName, wrappedListener);\n\n    // We skip cleaning up animation event types to ensure leaving animation events can be used.\n    // These events should be automatically garbage collected anyway after the element is\n    // removed from the DOM.\n    if (!isAnimationEventType(eventName)) {\n      const idxOrTargetGetter = eventTargetResolver\n        ? (_lView: LView) => eventTargetResolver(unwrapRNode(_lView[tNode.index]))\n        : tNode.index;\n\n      storeListenerCleanup(\n        idxOrTargetGetter,\n        tView,\n        lView,\n        eventName,\n        wrappedListener,\n        cleanupFn,\n        false,\n      );\n    }\n  }\n  return hasCoalesced;\n}\n\nfunction isAnimationEventType(eventName: string): boolean {\n  return eventName.startsWith('animation') || eventName.startsWith('transition');\n}\n\n/**\n * A utility function that checks if a given element has already an event handler registered for an\n * event with a specified name. The TView.cleanup data structure is used to find out which events\n * are registered for a given element.\n */\nfunction findExistingListener(\n  tView: TView,\n  lView: LView,\n  eventName: string,\n  tNodeIndex: number,\n): EventCallback | null {\n  const tCleanup = tView.cleanup;\n  if (tCleanup != null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      const cleanupEventName = tCleanup[i];\n      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIndex) {\n        // We have found a matching event name on the same node but it might not have been\n        // registered yet, so we must explicitly verify entries in the LView cleanup data\n        // structures.\n        const lCleanup = lView[CLEANUP];\n        const listenerIdxInLCleanup = tCleanup[i + 2];\n        return lCleanup && lCleanup.length > listenerIdxInLCleanup\n          ? lCleanup[listenerIdxInLCleanup]\n          : null;\n      }\n      // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\n      // 2-element entries (for directive and queries destroy hooks). As such we can encounter\n      // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\n      // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\n      // documentation of TView.cleanup for more details of this data structure layout.\n      if (typeof cleanupEventName === 'string') {\n        i += 2;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Stores a cleanup function for an event listener.\n * @param indexOrTargetGetter Either the index of the TNode on which the event is bound or a\n *  function that when invoked will return the event target.\n * @param tView TView in which the event is bound.\n * @param lView LView in which the event is bound.\n * @param eventName Name of the event.\n * @param listenerFn Final callback of the event.\n * @param cleanup Function to invoke during cleanup.\n * @param isOutput Whether this is an output listener or a native DOM listener.\n */\nexport function storeListenerCleanup(\n  indexOrTargetGetter: number | ((lView: LView) => EventTarget),\n  tView: TView,\n  lView: LView,\n  eventName: string,\n  listenerFn: WrappedEventCallback,\n  cleanup: (() => void) | {unsubscribe: () => void},\n  isOutput: boolean,\n) {\n  const tCleanup = tView.firstCreatePass ? getOrCreateTViewCleanup(tView) : null;\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  const index = lCleanup.length;\n  lCleanup.push(listenerFn, cleanup);\n  tCleanup &&\n    tCleanup.push(eventName, indexOrTargetGetter, index, (index + 1) * (isOutput ? -1 : 1));\n}\n"]}