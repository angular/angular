{"version":3,"file":"view_manipulation.js","sourceRoot":"","sources":["view_manipulation.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,iBAAiB,EAAC,MAAM,0BAA0B,CAAC;AAI3D,OAAO,EAAC,2BAA2B,EAAC,MAAM,6BAA6B,CAAC;AACxE,OAAO,EAAC,aAAa,EAAC,MAAM,gBAAgB,CAAC;AAE7C,OAAO,EAAC,gBAAgB,EAAE,mBAAmB,EAAC,MAAM,UAAU,CAAC;AAC/D,OAAO,EAAC,UAAU,EAAC,MAAM,uBAAuB,CAAC;AAEjD,OAAO,EAAC,sBAAsB,EAAE,KAAK,EAAqB,OAAO,EAAC,MAAM,mBAAmB,CAAC;AAC5F,OAAO,EAAC,WAAW,EAAC,MAAM,qBAAqB,CAAC;AAEhD,MAAM,UAAU,4BAA4B,CAC1C,gBAAgC,EAChC,aAAoB,EACpB,OAAU,EACV,OAIC;IAED,MAAM,YAAY,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC7C,IAAI,CAAC;QACH,MAAM,aAAa,GAAG,aAAa,CAAC,KAAM,CAAC;QAC3C,SAAS,IAAI,aAAa,CAAC,aAAa,EAAE,4CAA4C,CAAC,CAAC;QACxF,SAAS,IAAI,mBAAmB,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC;QAElE,uFAAuF;QACvF,MAAM,YAAY,GAAG,gBAAgB,CAAC,KAAK,CAAC,mCAAwB,CAAC;QACrE,MAAM,SAAS,GAAG,YAAY,CAAC,CAAC,kCAAuB,CAAC,gCAAuB,CAAC;QAChF,MAAM,aAAa,GAAG,WAAW,CAC/B,gBAAgB,EAChB,aAAa,EACb,OAAO,EACP,SAAS,EACT,IAAI,EACJ,aAAa,EACb,IAAI,EACJ,IAAI,EACJ,OAAO,EAAE,QAAQ,IAAI,IAAI,EACzB,OAAO,EAAE,oBAAoB,IAAI,IAAI,EACrC,OAAO,EAAE,cAAc,IAAI,IAAI,CAChC,CAAC;QAEF,MAAM,qBAAqB,GAAG,gBAAgB,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QACpE,SAAS,IAAI,gBAAgB,CAAC,qBAAqB,CAAC,CAAC;QACrD,aAAa,CAAC,sBAAsB,CAAC,GAAG,qBAAqB,CAAC;QAE9D,MAAM,uBAAuB,GAAG,gBAAgB,CAAC,OAAO,CAAC,CAAC;QAC1D,IAAI,uBAAuB,KAAK,IAAI,EAAE,CAAC;YACrC,aAAa,CAAC,OAAO,CAAC,GAAG,uBAAuB,CAAC,kBAAkB,CAAC,aAAa,CAAC,CAAC;QACrF,CAAC;QAED,kCAAkC;QAClC,UAAU,CAAC,aAAa,EAAE,aAAa,EAAE,OAAO,CAAC,CAAC;QAElD,OAAO,aAAa,CAAC;IACvB,CAAC;YAAS,CAAC;QACT,iBAAiB,CAAC,YAAY,CAAC,CAAC;IAClC,CAAC;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,kBAAkB,CAChC,KAAY,EACZ,cAA+C;IAE/C,OAAO,CACL,CAAC,cAAc,IAAI,cAAc,CAAC,UAAU,KAAK,IAAI,IAAI,2BAA2B,CAAC,KAAK,CAAC,CAC5F,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {setActiveConsumer} from '../../primitives/signals';\n\nimport {Injector} from '../di/injector';\nimport {DehydratedContainerView} from '../hydration/interfaces';\nimport {hasInSkipHydrationBlockFlag} from '../hydration/skip_hydration';\nimport {assertDefined} from '../util/assert';\n\nimport {assertLContainer, assertTNodeForLView} from './assert';\nimport {renderView} from './instructions/render';\nimport {TNode} from './interfaces/node';\nimport {DECLARATION_LCONTAINER, FLAGS, LView, LViewFlags, QUERIES} from './interfaces/view';\nimport {createLView} from './view/construction';\n\nexport function createAndRenderEmbeddedLView<T>(\n  declarationLView: LView<unknown>,\n  templateTNode: TNode,\n  context: T,\n  options?: {\n    injector?: Injector;\n    embeddedViewInjector?: Injector;\n    dehydratedView?: DehydratedContainerView | null;\n  },\n): LView<T> {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    const embeddedTView = templateTNode.tView!;\n    ngDevMode && assertDefined(embeddedTView, 'TView must be defined for a template node.');\n    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);\n\n    // Embedded views follow the change detection strategy of the view they're declared in.\n    const isSignalView = declarationLView[FLAGS] & LViewFlags.SignalView;\n    const viewFlags = isSignalView ? LViewFlags.SignalView : LViewFlags.CheckAlways;\n    const embeddedLView = createLView<T>(\n      declarationLView,\n      embeddedTView,\n      context,\n      viewFlags,\n      null,\n      templateTNode,\n      null,\n      null,\n      options?.injector ?? null,\n      options?.embeddedViewInjector ?? null,\n      options?.dehydratedView ?? null,\n    );\n\n    const declarationLContainer = declarationLView[templateTNode.index];\n    ngDevMode && assertLContainer(declarationLContainer);\n    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;\n\n    const declarationViewLQueries = declarationLView[QUERIES];\n    if (declarationViewLQueries !== null) {\n      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n    }\n\n    // execute creation mode of a view\n    renderView(embeddedTView, embeddedLView, context);\n\n    return embeddedLView;\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n\n/**\n * Returns whether an elements that belong to a view should be\n * inserted into the DOM. For client-only cases, DOM elements are\n * always inserted. For hydration cases, we check whether serialized\n * info is available for a view and the view is not in a \"skip hydration\"\n * block (in which case view contents was re-created, thus needing insertion).\n */\nexport function shouldAddViewToDom(\n  tNode: TNode,\n  dehydratedView?: DehydratedContainerView | null,\n): boolean {\n  return (\n    !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode)\n  );\n}\n"]}