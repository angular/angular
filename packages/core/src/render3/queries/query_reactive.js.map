{"version":3,"file":"query_reactive.js","sourceRoot":"","sources":["query_reactive.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComputedNode, createComputed, SIGNAL} from '../../../primitives/signals';\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {unwrapElementRef} from '../../linker/element_ref';\nimport {QueryList} from '../../linker/query_list';\nimport {EMPTY_ARRAY} from '../../util/empty';\n\nimport {FLAGS, LView, LViewFlags} from '../interfaces/view';\nimport {Signal} from '../reactivity/api';\nimport {signal, WritableSignal} from '../reactivity/signal';\nimport {getLView} from '../state';\nimport {getQueryResults, loadQueryInternal} from './query';\n\ninterface QuerySignalNode<T> extends ComputedNode<T | ReadonlyArray<T>> {\n  _lView?: LView;\n  _queryIndex?: number;\n  _queryList?: QueryList<T>;\n  _dirtyCounter: WritableSignal<number>;\n  /**\n   * Stores the last seen, flattened results for a query. This is to avoid marking the signal result\n   * computed as dirty when there was view manipulation that didn't impact final results.\n   */\n  _flatValue?: T | ReadonlyArray<T>;\n}\n\n/**\n * A signal factory function in charge of creating a new computed signal capturing query\n * results. This centralized creation function is used by all types of queries (child / children,\n * required / optional).\n *\n * @param firstOnly indicates if all or only the first result should be returned\n * @param required indicates if at least one result is required\n * @returns a read-only signal with query results\n */\nfunction createQuerySignalFn<V>(\n  firstOnly: boolean,\n  required: boolean,\n  opts?: {debugName?: string},\n) {\n  let node: QuerySignalNode<V>;\n  const signalFn = createComputed(() => {\n    // A dedicated signal that increments its value every time a query changes its dirty status. By\n    // using this signal we can implement a query as computed and avoid creation of a specialized\n    // reactive node type. Please note that a query gets marked dirty under the following\n    // circumstances:\n    // - a view (where a query is active) finished its first creation pass;\n    // - a new view is inserted / deleted and it impacts query results.\n    node._dirtyCounter();\n\n    const value = refreshSignalQuery<V>(node, firstOnly);\n\n    if (required && value === undefined) {\n      throw new RuntimeError(\n        RuntimeErrorCode.REQUIRED_QUERY_NO_VALUE,\n        ngDevMode && 'Child query result is required but no value is available.',\n      );\n    }\n\n    return value;\n  });\n  node = signalFn[SIGNAL] as QuerySignalNode<V>;\n  node._dirtyCounter = signal(0);\n  node._flatValue = undefined;\n\n  if (ngDevMode) {\n    signalFn.toString = () => `[Query Signal]`;\n    node.debugName = opts?.debugName;\n  }\n\n  return signalFn;\n}\n\nexport function createSingleResultOptionalQuerySignalFn<ReadT>(opts?: {\n  debugName?: string;\n}): Signal<ReadT | undefined> {\n  return createQuerySignalFn(/* firstOnly */ true, /* required */ false, opts) as Signal<\n    ReadT | undefined\n  >;\n}\n\nexport function createSingleResultRequiredQuerySignalFn<ReadT>(opts?: {\n  debugName?: string;\n}): Signal<ReadT> {\n  return createQuerySignalFn(/* firstOnly */ true, /* required */ true, opts) as Signal<ReadT>;\n}\n\nexport function createMultiResultQuerySignalFn<ReadT>(opts?: {\n  debugName?: string;\n}): Signal<ReadonlyArray<ReadT>> {\n  return createQuerySignalFn(/* firstOnly */ false, /* required */ false, opts) as Signal<\n    ReadonlyArray<ReadT>\n  >;\n}\n\nexport function bindQueryToSignal(target: Signal<unknown>, queryIndex: number): void {\n  const node = target[SIGNAL] as QuerySignalNode<unknown>;\n  node._lView = getLView();\n  node._queryIndex = queryIndex;\n  node._queryList = loadQueryInternal(node._lView, queryIndex);\n  node._queryList.onDirty(() => node._dirtyCounter.update((v) => v + 1));\n}\n\nfunction refreshSignalQuery<V>(node: QuerySignalNode<V>, firstOnly: boolean): V | ReadonlyArray<V> {\n  const lView = node._lView;\n  const queryIndex = node._queryIndex;\n\n  // There are 2 conditions under which we want to return \"empty\" results instead of the ones\n  // collected by a query:\n  //\n  // 1) a given query wasn't created yet (this is a period of time between the directive creation\n  // and execution of the query creation function) - in this case a query doesn't exist yet and we\n  // don't have any results to return.\n  //\n  // 2) we are in the process of constructing a view (the first\n  // creation pass didn't finish) and a query might have partial results, but we don't want to\n  // return those - instead we do delay results collection until all nodes had a chance of matching\n  // and we can present consistent, \"atomic\" (on a view level) results.\n  if (lView === undefined || queryIndex === undefined || lView[FLAGS] & LViewFlags.CreationMode) {\n    return (firstOnly ? undefined : EMPTY_ARRAY) as V;\n  }\n\n  const queryList = loadQueryInternal<V>(lView, queryIndex);\n  const results = getQueryResults<V>(lView, queryIndex);\n\n  queryList.reset(results, unwrapElementRef);\n\n  if (firstOnly) {\n    return queryList.first;\n  } else {\n    // TODO: remove access to the private _changesDetected field by abstracting / removing usage of\n    // QueryList in the signal-based queries (perf follow-up)\n    const resultChanged = (queryList as any as {_changesDetected: boolean})._changesDetected;\n    if (resultChanged || node._flatValue === undefined) {\n      return (node._flatValue = queryList.toArray());\n    }\n    return node._flatValue;\n  }\n}\n"]}