{"version":3,"file":"profiler.js","sourceRoot":"","sources":["profiler.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAIH,MAAM,iBAAiB,GAAe,EAAE,CAAC;AAEzC,MAAM,qBAAqB,GAAG,GAAG,EAAE,GAAE,CAAC,CAAC;AAEvC,SAAS,cAAc,CAAC,QAAkB;IACxC,MAAM,WAAW,GAAG,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IACxD,IAAI,WAAW,KAAK,CAAC,CAAC,EAAE,CAAC;QACvB,iBAAiB,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;IAC3C,CAAC;AACH,CAAC;AAED;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,WAAW,CAAC,QAAyB;IACnD,IAAI,QAAQ,KAAK,IAAI,EAAE,CAAC;QACtB,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC1C,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACnC,CAAC;QACD,OAAO,GAAG,EAAE,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;IACxC,CAAC;SAAM,CAAC;QACN,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;QAC7B,OAAO,qBAAqB,CAAC;IAC/B,CAAC;AACH,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,CAAC,MAAM,QAAQ,GAAa,UAAU,KAAK,EAAE,QAAQ,GAAG,IAAI,EAAE,OAAO;IACzE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAClD,MAAM,gBAAgB,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;QAC9C,gBAAgB,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC7C,CAAC;AACH,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {type Profiler} from './profiler_types';\n\nconst profilerCallbacks: Profiler[] = [];\n\nconst NOOP_PROFILER_REMOVAL = () => {};\n\nfunction removeProfiler(profiler: Profiler) {\n  const profilerIdx = profilerCallbacks.indexOf(profiler);\n  if (profilerIdx !== -1) {\n    profilerCallbacks.splice(profilerIdx, 1);\n  }\n}\n\n/**\n * Adds a callback function which will be invoked before and after performing certain actions at\n * runtime (for example, before and after running change detection). Multiple profiler callbacks can be set:\n * in this case profiling events are reported to every registered callback.\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable all profilers.\n * @returns a cleanup function that, when invoked, removes a given profiler callback.\n */\nexport function setProfiler(profiler: Profiler | null): () => void {\n  if (profiler !== null) {\n    if (!profilerCallbacks.includes(profiler)) {\n      profilerCallbacks.push(profiler);\n    }\n    return () => removeProfiler(profiler);\n  } else {\n    profilerCallbacks.length = 0;\n    return NOOP_PROFILER_REMOVAL;\n  }\n}\n\n/**\n * Profiler function which wraps user code executed by the runtime.\n *\n * @param event ProfilerEvent corresponding to the execution context\n * @param instance component instance\n * @param eventFn function associated with event.\n *    For example a template function, lifecycle hook, or output listener.\n *    The value depends on the execution context\n */\nexport const profiler: Profiler = function (event, instance = null, eventFn): void {\n  for (let i = 0; i < profilerCallbacks.length; i++) {\n    const profilerCallback = profilerCallbacks[i];\n    profilerCallback(event, instance, eventFn);\n  }\n};\n"]}