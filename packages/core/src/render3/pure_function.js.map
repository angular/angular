{"version":3,"file":"pure_function.js","sourceRoot":"","sources":["pure_function.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertIndexInRange} from '../util/assert';\nimport {\n  bindingUpdated,\n  bindingUpdated2,\n  bindingUpdated3,\n  bindingUpdated4,\n  getBinding,\n  updateBinding,\n} from './bindings';\nimport {LView} from './interfaces/view';\nimport {getBindingRoot, getLView} from './state';\nimport {NO_CHANGE} from './tokens';\n\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |-------decls------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction0<T>(slotOffset: number, pureFn: () => T, thisArg?: any): T {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  return lView[bindingIndex] === NO_CHANGE\n    ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn())\n    : getBinding(lView, bindingIndex);\n}\n\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction1(\n  slotOffset: number,\n  pureFn: (v: any) => any,\n  exp: any,\n  thisArg?: any,\n): any {\n  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction2(\n  slotOffset: number,\n  pureFn: (v1: any, v2: any) => any,\n  exp1: any,\n  exp2: any,\n  thisArg?: any,\n): any {\n  return pureFunction2Internal(\n    getLView(),\n    getBindingRoot(),\n    slotOffset,\n    pureFn,\n    exp1,\n    exp2,\n    thisArg,\n  );\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction3(\n  slotOffset: number,\n  pureFn: (v1: any, v2: any, v3: any) => any,\n  exp1: any,\n  exp2: any,\n  exp3: any,\n  thisArg?: any,\n): any {\n  return pureFunction3Internal(\n    getLView(),\n    getBindingRoot(),\n    slotOffset,\n    pureFn,\n    exp1,\n    exp2,\n    exp3,\n    thisArg,\n  );\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction4(\n  slotOffset: number,\n  pureFn: (v1: any, v2: any, v3: any, v4: any) => any,\n  exp1: any,\n  exp2: any,\n  exp3: any,\n  exp4: any,\n  thisArg?: any,\n): any {\n  return pureFunction4Internal(\n    getLView(),\n    getBindingRoot(),\n    slotOffset,\n    pureFn,\n    exp1,\n    exp2,\n    exp3,\n    exp4,\n    thisArg,\n  );\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction5(\n  slotOffset: number,\n  pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any) => any,\n  exp1: any,\n  exp2: any,\n  exp3: any,\n  exp4: any,\n  exp5: any,\n  thisArg?: any,\n): any {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated(lView, bindingIndex + 4, exp5) || different\n    ? updateBinding(\n        lView,\n        bindingIndex + 5,\n        thisArg\n          ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5)\n          : pureFn(exp1, exp2, exp3, exp4, exp5),\n      )\n    : getBinding(lView, bindingIndex + 5);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction6(\n  slotOffset: number,\n  pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any) => any,\n  exp1: any,\n  exp2: any,\n  exp3: any,\n  exp4: any,\n  exp5: any,\n  exp6: any,\n  thisArg?: any,\n): any {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different\n    ? updateBinding(\n        lView,\n        bindingIndex + 6,\n        thisArg\n          ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6)\n          : pureFn(exp1, exp2, exp3, exp4, exp5, exp6),\n      )\n    : getBinding(lView, bindingIndex + 6);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction7(\n  slotOffset: number,\n  pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any) => any,\n  exp1: any,\n  exp2: any,\n  exp3: any,\n  exp4: any,\n  exp5: any,\n  exp6: any,\n  exp7: any,\n  thisArg?: any,\n): any {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different\n    ? updateBinding(\n        lView,\n        bindingIndex + 7,\n        thisArg\n          ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7)\n          : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7),\n      )\n    : getBinding(lView, bindingIndex + 7);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction8(\n  slotOffset: number,\n  pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any) => any,\n  exp1: any,\n  exp2: any,\n  exp3: any,\n  exp4: any,\n  exp5: any,\n  exp6: any,\n  exp7: any,\n  exp8: any,\n  thisArg?: any,\n): any {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different\n    ? updateBinding(\n        lView,\n        bindingIndex + 8,\n        thisArg\n          ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)\n          : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8),\n      )\n    : getBinding(lView, bindingIndex + 8);\n}\n\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunctionV(\n  slotOffset: number,\n  pureFn: (...v: any[]) => any,\n  exps: any[],\n  thisArg?: any,\n): any {\n  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);\n}\n\n/**\n * Results of a pure function invocation are stored in LView in a dedicated slot that is initialized\n * to NO_CHANGE. In rare situations a pure pipe might throw an exception on the very first\n * invocation and not produce any valid results. In this case LView would keep holding the NO_CHANGE\n * value. The NO_CHANGE is not something that we can use in expressions / bindings thus we convert\n * it to `undefined`.\n */\nfunction getPureFunctionReturnValue(lView: LView, returnValueIndex: number) {\n  ngDevMode && assertIndexInRange(lView, returnValueIndex);\n  const lastReturnValue = lView[returnValueIndex];\n  return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;\n}\n\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction1Internal(\n  lView: LView,\n  bindingRoot: number,\n  slotOffset: number,\n  pureFn: (v: any) => any,\n  exp: any,\n  thisArg?: any,\n): any {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated(lView, bindingIndex, exp)\n    ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp))\n    : getPureFunctionReturnValue(lView, bindingIndex + 1);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction2Internal(\n  lView: LView,\n  bindingRoot: number,\n  slotOffset: number,\n  pureFn: (v1: any, v2: any) => any,\n  exp1: any,\n  exp2: any,\n  thisArg?: any,\n): any {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated2(lView, bindingIndex, exp1, exp2)\n    ? updateBinding(\n        lView,\n        bindingIndex + 2,\n        thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2),\n      )\n    : getPureFunctionReturnValue(lView, bindingIndex + 2);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction3Internal(\n  lView: LView,\n  bindingRoot: number,\n  slotOffset: number,\n  pureFn: (v1: any, v2: any, v3: any) => any,\n  exp1: any,\n  exp2: any,\n  exp3: any,\n  thisArg?: any,\n): any {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3)\n    ? updateBinding(\n        lView,\n        bindingIndex + 3,\n        thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3),\n      )\n    : getPureFunctionReturnValue(lView, bindingIndex + 3);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n */\nexport function pureFunction4Internal(\n  lView: LView,\n  bindingRoot: number,\n  slotOffset: number,\n  pureFn: (v1: any, v2: any, v3: any, v4: any) => any,\n  exp1: any,\n  exp2: any,\n  exp3: any,\n  exp4: any,\n  thisArg?: any,\n): any {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4)\n    ? updateBinding(\n        lView,\n        bindingIndex + 4,\n        thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4),\n      )\n    : getPureFunctionReturnValue(lView, bindingIndex + 4);\n}\n\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunctionVInternal(\n  lView: LView,\n  bindingRoot: number,\n  slotOffset: number,\n  pureFn: (...v: any[]) => any,\n  exps: any[],\n  thisArg?: any,\n): any {\n  let bindingIndex = bindingRoot + slotOffset;\n  let different = false;\n  for (let i = 0; i < exps.length; i++) {\n    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\n  }\n  return different\n    ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps))\n    : getPureFunctionReturnValue(lView, bindingIndex);\n}\n"]}