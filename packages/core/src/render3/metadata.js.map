{"version":3,"file":"metadata.js","sourceRoot":"","sources":["metadata.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,aAAa,EAAC,MAAM,iBAAiB,CAAC;AAQ9C;;;;GAIG;AACH,MAAM,2BAA2B,GAAG,gCAAgC,CAAC;AAErE;;;;GAIG;AACH,MAAM,UAAU,uBAAuB,CACrC,IAAmB;IAEnB,MAAM,cAAc,GAAG,IAAW,CAAC,CAAC,4DAA4D;IAChG,OAAO,cAAc,CAAC,2BAA2B,CAAC,IAAI,IAAI,CAAC;AAC7D,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,qBAAqB,CACnC,IAAe,EACf,kBAAuD,EACvD,gBAAqD;IAErD,MAAM,cAAc,GAAG,IAAW,CAAC,CAAC,gDAAgD;IACpF,cAAc,CAAC,2BAA2B,CAAC,GAAG,GAAG,EAAE,CACjD,OAAO,CAAC,GAAG,CAAC,kBAAkB,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,YAAY,EAAE,EAAE;QACtD,gBAAgB,CAAC,GAAG,YAAY,CAAC,CAAC;QAClC,yEAAyE;QACzE,sCAAsC;QACtC,cAAc,CAAC,2BAA2B,CAAC,GAAG,IAAI,CAAC;QAEnD,OAAO,YAAY,CAAC;IACtB,CAAC,CAAC,CAAC;IACL,OAAO,cAAc,CAAC,2BAA2B,CAAC,CAAC;AACrD,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,gBAAgB,CAC9B,IAAe,EACf,UAAwB,EACxB,cAAoC,EACpC,cAA6C;IAE7C,OAAO,aAAa,CAAC,GAAG,EAAE;QACxB,MAAM,KAAK,GAAG,IAAwB,CAAC;QAEvC,IAAI,UAAU,KAAK,IAAI,EAAE,CAAC;YACxB,IAAI,KAAK,CAAC,cAAc,CAAC,YAAY,CAAC,IAAI,KAAK,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;gBACzE,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC;YACvC,CAAC;iBAAM,CAAC;gBACN,KAAK,CAAC,UAAU,GAAG,UAAU,CAAC;YAChC,CAAC;QACH,CAAC;QACD,IAAI,cAAc,KAAK,IAAI,EAAE,CAAC;YAC5B,sFAAsF;YACtF,kFAAkF;YAClF,kDAAkD;YAClD,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;QACxC,CAAC;QACD,IAAI,cAAc,KAAK,IAAI,EAAE,CAAC;YAC5B,oFAAoF;YACpF,qFAAqF;YACrF,+EAA+E;YAC/E,sEAAsE;YACtE,IAAI,KAAK,CAAC,cAAc,CAAC,gBAAgB,CAAC,IAAI,KAAK,CAAC,cAAc,KAAK,SAAS,EAAE,CAAC;gBACjF,KAAK,CAAC,cAAc,GAAG,EAAC,GAAG,KAAK,CAAC,cAAc,EAAE,GAAG,cAAc,EAAC,CAAC;YACtE,CAAC;iBAAM,CAAC;gBACN,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;YACxC,CAAC;QACH,CAAC;IACH,CAAC,CAAU,CAAC;AACd,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../interface/type';\nimport {noSideEffects} from '../util/closure';\n\ninterface TypeWithMetadata extends Type<any> {\n  decorators?: any[];\n  ctorParameters?: () => any[];\n  propDecorators?: {[field: string]: any};\n}\n\n/**\n * The name of a field that Angular monkey-patches onto a component\n * class to store a function that loads defer-loadable dependencies\n * and applies metadata to a class.\n */\nconst ASYNC_COMPONENT_METADATA_FN = '__ngAsyncComponentMetadataFn__';\n\n/**\n * If a given component has unresolved async metadata - returns a reference\n * to a function that applies component metadata after resolving defer-loadable\n * dependencies. Otherwise - this function returns `null`.\n */\nexport function getAsyncClassMetadataFn(\n  type: Type<unknown>,\n): (() => Promise<Array<Type<unknown>>>) | null {\n  const componentClass = type as any; // cast to `any`, so that we can read a monkey-patched field\n  return componentClass[ASYNC_COMPONENT_METADATA_FN] ?? null;\n}\n\n/**\n * Handles the process of applying metadata info to a component class in case\n * component template has defer blocks (thus some dependencies became deferrable).\n *\n * @param type Component class where metadata should be added\n * @param dependencyLoaderFn Function that loads dependencies\n * @param metadataSetterFn Function that forms a scope in which the `setClassMetadata` is invoked\n */\nexport function setClassMetadataAsync(\n  type: Type<any>,\n  dependencyLoaderFn: () => Array<Promise<Type<unknown>>>,\n  metadataSetterFn: (...types: Type<unknown>[]) => void,\n): () => Promise<Array<Type<unknown>>> {\n  const componentClass = type as any; // cast to `any`, so that we can monkey-patch it\n  componentClass[ASYNC_COMPONENT_METADATA_FN] = () =>\n    Promise.all(dependencyLoaderFn()).then((dependencies) => {\n      metadataSetterFn(...dependencies);\n      // Metadata is now set, reset field value to indicate that this component\n      // can by used/compiled synchronously.\n      componentClass[ASYNC_COMPONENT_METADATA_FN] = null;\n\n      return dependencies;\n    });\n  return componentClass[ASYNC_COMPONENT_METADATA_FN];\n}\n\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be guarded by ngDevMode, resulting in the metadata assignments\n * being tree-shaken away during production builds.\n */\nexport function setClassMetadata(\n  type: Type<any>,\n  decorators: any[] | null,\n  ctorParameters: (() => any[]) | null,\n  propDecorators: {[field: string]: any} | null,\n): void {\n  return noSideEffects(() => {\n    const clazz = type as TypeWithMetadata;\n\n    if (decorators !== null) {\n      if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) {\n        clazz.decorators.push(...decorators);\n      } else {\n        clazz.decorators = decorators;\n      }\n    }\n    if (ctorParameters !== null) {\n      // Rather than merging, clobber the existing parameters. If other projects exist which\n      // use tsickle-style annotations and reflect over them in the same way, this could\n      // cause issues, but that is vanishingly unlikely.\n      clazz.ctorParameters = ctorParameters;\n    }\n    if (propDecorators !== null) {\n      // The property decorator objects are merged as it is possible different fields have\n      // different decorator types. Decorators on individual fields are not merged, as it's\n      // also incredibly unlikely that a field will be decorated both with an Angular\n      // decorator and a non-Angular decorator that's also been downleveled.\n      if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) {\n        clazz.propDecorators = {...clazz.propDecorators, ...propDecorators};\n      } else {\n        clazz.propDecorators = propDecorators;\n      }\n    }\n  }) as never;\n}\n"]}