{"version":3,"file":"def_getters.js","sourceRoot":"","sources":["def_getters.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,YAAY,EAAmB,MAAM,WAAW,CAAC;AAGzD,OAAO,EAAC,SAAS,EAAC,MAAM,mBAAmB,CAAC;AAC5C,OAAO,EAAC,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAC,MAAM,UAAU,CAAC;AAG1E,MAAM,UAAU,cAAc,CAAI,IAAS;IACzC,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,qBAAqB,CAAI,IAAS;IAChD,MAAM,WAAW,GAAG,cAAc,CAAI,IAAI,CAAC,CAAC;IAC5C,IAAI,CAAC,WAAW,EAAE,CAAC;QACjB,MAAM,IAAI,YAAY,0DAEpB,CAAC,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,CAAC;YAC7C,QAAQ,SAAS,CAAC,IAAI,CAAC,iCAAiC,CAC3D,CAAC;IACJ,CAAC;IACD,OAAO,WAAW,CAAC;AACrB,CAAC;AAED;;;;GAIG;AAEH,MAAM,UAAU,eAAe,CAAI,IAAS;IAC1C,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,IAAI,CAAC;AACnC,CAAC;AAED,MAAM,UAAU,sBAAsB,CAAI,IAAS;IACjD,MAAM,GAAG,GAAG,eAAe,CAAI,IAAI,CAAC,CAAC;IACrC,IAAI,CAAC,GAAG,EAAE,CAAC;QACT,MAAM,IAAI,YAAY,0DAEpB,CAAC,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,CAAC;YAC7C,QAAQ,SAAS,CAAC,IAAI,CAAC,iCAAiC,CAC3D,CAAC;IACJ,CAAC;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED,MAAM,UAAU,eAAe,CAAI,IAAS;IAC1C,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,UAAU,CAAI,IAAS;IACrC,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,IAAI,CAAC;AACnC,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,YAAY,CAAC,IAAmB;IAC9C,MAAM,GAAG,GAAG,eAAe,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;IAC/E,OAAO,GAAG,KAAK,IAAI,IAAI,GAAG,CAAC,UAAU,CAAC;AACxC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport type {NgModuleDef} from '../r3_symbols';\nimport {stringify} from '../util/stringify';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_MOD_DEF, NG_PIPE_DEF} from './fields';\nimport type {ComponentDef, DirectiveDef, PipeDef} from './interfaces/definition';\n\nexport function getNgModuleDef<T>(type: any): NgModuleDef<T> | null {\n  return type[NG_MOD_DEF] || null;\n}\n\nexport function getNgModuleDefOrThrow<T>(type: any): NgModuleDef<T> | never {\n  const ngModuleDef = getNgModuleDef<T>(type);\n  if (!ngModuleDef) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISSING_NG_MODULE_DEFINITION,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Type ${stringify(type)} does not have 'ɵmod' property.`,\n    );\n  }\n  return ngModuleDef;\n}\n\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\n\nexport function getComponentDef<T>(type: any): ComponentDef<T> | null {\n  return type[NG_COMP_DEF] || null;\n}\n\nexport function getDirectiveDefOrThrow<T>(type: any): DirectiveDef<T> | never {\n  const def = getDirectiveDef<T>(type);\n  if (!def) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISSING_DIRECTIVE_DEFINITION,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Type ${stringify(type)} does not have 'ɵdir' property.`,\n    );\n  }\n  return def;\n}\n\nexport function getDirectiveDef<T>(type: any): DirectiveDef<T> | null {\n  return type[NG_DIR_DEF] || null;\n}\n\nexport function getPipeDef<T>(type: any): PipeDef<T> | null {\n  return type[NG_PIPE_DEF] || null;\n}\n\n/**\n * Checks whether a given Component, Directive or Pipe is marked as standalone.\n * This will return false if passed anything other than a Component, Directive, or Pipe class\n * See [this guide](guide/components/importing) for additional information:\n *\n * @param type A reference to a Component, Directive or Pipe.\n * @publicApi\n */\nexport function isStandalone(type: Type<unknown>): boolean {\n  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n  return def !== null && def.standalone;\n}\n"]}