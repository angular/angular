{"version":3,"file":"assert.js","sourceRoot":"","sources":["assert.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {\n  assertDefined,\n  assertEqual,\n  assertIndexInRange,\n  assertLessThan,\n  assertNumber,\n  throwError,\n} from '../util/assert';\n\nimport {getComponentDef, getNgModuleDef} from './def_getters';\nimport {LContainer} from './interfaces/container';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TIcu} from './interfaces/i18n';\nimport {NodeInjectorOffset} from './interfaces/injector';\nimport {TNode} from './interfaces/node';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {\n  DECLARATION_COMPONENT_VIEW,\n  FLAGS,\n  HEADER_OFFSET,\n  LView,\n  LViewFlags,\n  T_HOST,\n  TVIEW,\n  TView,\n} from './interfaces/view';\n\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\n\nexport function assertTNodeForLView(tNode: TNode, lView: LView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\n\nexport function assertTNodeCreationIndex(lView: LView, index: number) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  assertIndexInRange(lView, adjustedIndex);\n  assertLessThan(\n    adjustedIndex,\n    lView[TVIEW].bindingStartIndex,\n    'TNodes should be created before any bindings',\n  );\n}\n\nexport function assertTNodeForTView(tNode: TNode, tView: TView) {\n  assertTNode(tNode);\n  const tData = tView.data;\n  for (let i = HEADER_OFFSET; i < tData.length; i++) {\n    if (tData[i] === tNode) {\n      return;\n    }\n  }\n  throwError('This TNode does not belong to this TView.');\n}\n\nexport function assertTNode(tNode: TNode) {\n  assertDefined(tNode, 'TNode must be defined');\n  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n    throwError('Not of type TNode, got: ' + tNode);\n  }\n}\n\nexport function assertTIcu(tIcu: TIcu) {\n  assertDefined(tIcu, 'Expected TIcu to be defined');\n  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n    throwError('Object is not of TIcu type.');\n  }\n}\n\nexport function assertComponentType(\n  actual: any,\n  msg: string = \"Type passed in is not ComponentType, it does not have 'ɵcmp' property.\",\n) {\n  if (!getComponentDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertNgModuleType(\n  actual: any,\n  msg: string = \"Type passed in is not NgModuleType, it does not have 'ɵmod' property.\",\n) {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertCurrentTNodeIsParent(isParent: boolean) {\n  assertEqual(isParent, true, 'currentTNode should be a parent');\n}\n\nexport function assertHasParent(tNode: TNode | null) {\n  assertDefined(tNode, 'currentTNode should exist!');\n  assertDefined(tNode!.parent, 'currentTNode should have a parent');\n}\n\nexport function assertLContainer(value: any): asserts value is LContainer {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\n\nexport function assertLViewOrUndefined(value: any): asserts value is LView | null | undefined {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\n\nexport function assertLView(value: any): asserts value is LView {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\n\nexport function assertFirstCreatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n    tView.firstCreatePass,\n    true,\n    errMessage || 'Should only be called in first create pass.',\n  );\n}\n\nexport function assertFirstUpdatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n    tView.firstUpdatePass,\n    true,\n    errMessage || 'Should only be called in first update pass.',\n  );\n}\n\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nexport function assertDirectiveDef<T>(obj: any): asserts obj is DirectiveDef<T> {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(\n      `Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`,\n    );\n  }\n}\n\nexport function assertIndexInDeclRange(tView: TView, index: number) {\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\n\nexport function assertIndexInExpandoRange(lView: LView, index: number) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\n\nexport function assertBetween(lower: number, upper: number, index: number) {\n  if (!(lower <= index && index < upper)) {\n    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n  }\n}\n\nexport function assertProjectionSlots(lView: LView, errMessage?: string) {\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n  assertDefined(\n    lView[DECLARATION_COMPONENT_VIEW][T_HOST]!.projection,\n    errMessage ||\n      'Components with projection nodes (<ng-content>) must have projection slots defined.',\n  );\n}\n\nexport function assertParentView(lView: LView | null, errMessage?: string) {\n  assertDefined(\n    lView,\n    errMessage || \"Component views should always have a parent view (component's host view)\",\n  );\n}\n\nexport function assertNoDuplicateDirectives(directives: DirectiveDef<unknown>[]): void {\n  // The array needs at least two elements in order to have duplicates.\n  if (directives.length < 2) {\n    return;\n  }\n\n  const seenDirectives = new Set<DirectiveDef<unknown>>();\n\n  for (const current of directives) {\n    if (seenDirectives.has(current)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.DUPLICATE_DIRECTIVE,\n        `Directive ${current.type.name} matches multiple times on the same element. ` +\n          `Directives can only match an element once.`,\n      );\n    }\n    seenDirectives.add(current);\n  }\n}\n\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nexport function assertNodeInjector(lView: LView, injectorIndex: number) {\n  assertIndexInExpandoRange(lView, injectorIndex);\n  assertIndexInExpandoRange(lView, injectorIndex + NodeInjectorOffset.PARENT);\n  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n  assertNumber(\n    lView[injectorIndex + NodeInjectorOffset.PARENT],\n    'injectorIndex should point to parent injector',\n  );\n}\n"]}