{"version":3,"file":"pipe.js","sourceRoot":"","sources":["pipe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {PipeTransform} from '../change_detection/pipe_transform';\nimport {setInjectImplementation} from '../di/inject_switch';\nimport {formatRuntimeError, RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\n\nimport {InjectorProfilerContext, setInjectorProfilerContext} from './debug/injector_profiler';\nimport {getFactoryDef} from './definition_factory';\nimport {NodeInjector, setIncludeViewProviders} from './di';\nimport {ɵɵdirectiveInject} from './instructions/all';\nimport {isHostComponentStandalone} from './instructions/element_validation';\nimport {PipeDef, PipeDefList} from './interfaces/definition';\nimport {TTextNode} from './interfaces/node';\nimport {CONTEXT, DECLARATION_COMPONENT_VIEW, HEADER_OFFSET, LView, TVIEW} from './interfaces/view';\nimport {\n  pureFunction1Internal,\n  pureFunction2Internal,\n  pureFunction3Internal,\n  pureFunction4Internal,\n  pureFunctionVInternal,\n} from './pure_function';\nimport {getBindingRoot, getCurrentTNode, getLView, getTView} from './state';\nimport {load, store} from './util/view_utils';\n\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n *\n * @codeGenApi\n */\nexport function ɵɵpipe(index: number, pipeName: string): any {\n  const tView = getTView();\n  let pipeDef: PipeDef<any>;\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  if (tView.firstCreatePass) {\n    // The `getPipeDef` throws if a pipe with a given name is not found\n    // (so we use non-null assertion below).\n    pipeDef = getPipeDef(pipeName, tView.pipeRegistry)!;\n    tView.data[adjustedIndex] = pipeDef;\n    if (pipeDef.onDestroy) {\n      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);\n    }\n  } else {\n    pipeDef = tView.data[adjustedIndex] as PipeDef<any>;\n  }\n\n  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));\n\n  let previousInjectorProfilerContext: InjectorProfilerContext;\n  if (ngDevMode) {\n    previousInjectorProfilerContext = setInjectorProfilerContext({\n      injector: new NodeInjector(getCurrentTNode() as TTextNode, getLView()),\n      token: pipeDef.type,\n    });\n  }\n  const previousInjectImplementation = setInjectImplementation(ɵɵdirectiveInject);\n  try {\n    // DI for pipes is supposed to behave like directives when placed on a component\n    // host node, which means that we have to disable access to `viewProviders`.\n    const previousIncludeViewProviders = setIncludeViewProviders(false);\n    const pipeInstance = pipeFactory();\n    setIncludeViewProviders(previousIncludeViewProviders);\n    store(tView, getLView(), adjustedIndex, pipeInstance);\n    return pipeInstance;\n  } finally {\n    // we have to restore the injector implementation in finally, just in case the creation of the\n    // pipe throws an error.\n    setInjectImplementation(previousInjectImplementation);\n    ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext!);\n  }\n}\n\n/**\n * Searches the pipe registry for a pipe with the given name. If one is found,\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\n *\n * @param name Name of pipe to resolve\n * @param registry Full list of available pipes\n * @returns Matching PipeDef\n */\nfunction getPipeDef(name: string, registry: PipeDefList | null): PipeDef<any> | undefined {\n  if (registry) {\n    if (ngDevMode) {\n      const pipes = registry.filter((pipe) => pipe.name === name);\n      // TODO: Throw an error in the next major\n      if (pipes.length > 1) {\n        console.warn(\n          formatRuntimeError(\n            RuntimeErrorCode.MULTIPLE_MATCHING_PIPES,\n            getMultipleMatchingPipesMessage(name),\n          ),\n        );\n      }\n    }\n    for (let i = registry.length - 1; i >= 0; i--) {\n      const pipeDef = registry[i];\n      if (name === pipeDef.name) {\n        return pipeDef;\n      }\n    }\n  }\n  if (ngDevMode) {\n    throw new RuntimeError(RuntimeErrorCode.PIPE_NOT_FOUND, getPipeNotFoundErrorMessage(name));\n  }\n  return;\n}\n\n/**\n * Generates a helpful error message for the user when multiple pipes match the name.\n *\n * @param name Name of the pipe\n * @returns The error message\n */\nfunction getMultipleMatchingPipesMessage(name: string) {\n  const lView = getLView();\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW] as LView<Type<unknown>>;\n  const context = declarationLView[CONTEXT];\n  const hostIsStandalone = isHostComponentStandalone(lView);\n  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n  const verifyMessage = `check ${\n    hostIsStandalone ? \"'@Component.imports' of this component\" : 'the imports of this module'\n  }`;\n  const errorMessage = `Multiple pipes match the name \\`${name}\\`${componentInfoMessage}. ${verifyMessage}`;\n  return errorMessage;\n}\n\n/**\n * Generates a helpful error message for the user when a pipe is not found.\n *\n * @param name Name of the missing pipe\n * @returns The error message\n */\nfunction getPipeNotFoundErrorMessage(name: string) {\n  const lView = getLView();\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW] as LView<Type<unknown>>;\n  const context = declarationLView[CONTEXT];\n  const hostIsStandalone = isHostComponentStandalone(lView);\n  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n  const verifyMessage = `Verify that it is ${\n    hostIsStandalone\n      ? \"included in the '@Component.imports' of this component\"\n      : 'declared or imported in this module'\n  }`;\n  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;\n  return errorMessage;\n}\n\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param offset the binding offset\n * @param v1 1st argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBind1(index: number, offset: number, v1: any): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex)\n    ? pureFunction1Internal(\n        lView,\n        getBindingRoot(),\n        offset,\n        pipeInstance.transform,\n        v1,\n        pipeInstance,\n      )\n    : pipeInstance.transform(v1);\n}\n\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBind2(index: number, slotOffset: number, v1: any, v2: any): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex)\n    ? pureFunction2Internal(\n        lView,\n        getBindingRoot(),\n        slotOffset,\n        pipeInstance.transform,\n        v1,\n        v2,\n        pipeInstance,\n      )\n    : pipeInstance.transform(v1, v2);\n}\n\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBind3(index: number, slotOffset: number, v1: any, v2: any, v3: any): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex)\n    ? pureFunction3Internal(\n        lView,\n        getBindingRoot(),\n        slotOffset,\n        pipeInstance.transform,\n        v1,\n        v2,\n        v3,\n        pipeInstance,\n      )\n    : pipeInstance.transform(v1, v2, v3);\n}\n\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBind4(\n  index: number,\n  slotOffset: number,\n  v1: any,\n  v2: any,\n  v3: any,\n  v4: any,\n): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex)\n    ? pureFunction4Internal(\n        lView,\n        getBindingRoot(),\n        slotOffset,\n        pipeInstance.transform,\n        v1,\n        v2,\n        v3,\n        v4,\n        pipeInstance,\n      )\n    : pipeInstance.transform(v1, v2, v3, v4);\n}\n\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBindV(index: number, slotOffset: number, values: [any, ...any[]]): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex)\n    ? pureFunctionVInternal(\n        lView,\n        getBindingRoot(),\n        slotOffset,\n        pipeInstance.transform,\n        values,\n        pipeInstance,\n      )\n    : pipeInstance.transform.apply(pipeInstance, values);\n}\n\nfunction isPure(lView: LView, index: number): boolean {\n  return (<PipeDef<any>>lView[TVIEW].data[index]).pure;\n}\n"]}