{"version":3,"file":"attrs_utils.js","sourceRoot":"","sources":["attrs_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {CharCode} from '../../util/char_code';\nimport {AttributeMarker} from '../interfaces/attribute_marker';\nimport {TAttributes} from '../interfaces/node';\nimport {CssSelector} from '../interfaces/projection';\nimport {Renderer} from '../interfaces/renderer';\nimport {RElement} from '../interfaces/renderer_dom';\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nexport function setUpAttributes(renderer: Renderer, native: RElement, attrs: TAttributes): number {\n  let i = 0;\n  while (i < attrs.length) {\n    const value = attrs[i];\n    if (typeof value === 'number') {\n      // only namespaces are supported. Other value types (such as style/class\n      // entries) are not supported in this function.\n      if (value !== AttributeMarker.NamespaceURI) {\n        break;\n      }\n\n      // we just landed on the marker value ... therefore\n      // we should skip to the next entry\n      i++;\n\n      const namespaceURI = attrs[i++] as string;\n      const attrName = attrs[i++] as string;\n      const attrVal = attrs[i++] as string;\n      renderer.setAttribute(native, attrName, attrVal, namespaceURI);\n    } else {\n      // attrName is string;\n      const attrName = value as string;\n      const attrVal = attrs[++i];\n      // Standard attributes\n      if (isAnimationProp(attrName)) {\n        renderer.setProperty(native, attrName, attrVal);\n      } else {\n        renderer.setAttribute(native, attrName, attrVal as string);\n      }\n      i++;\n    }\n  }\n\n  // another piece of code may iterate over the same attributes array. Therefore\n  // it may be helpful to return the exact spot where the attributes array exited\n  // whether by running into an unsupported marker or if all the static values were\n  // iterated over.\n  return i;\n}\n\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nexport function isNameOnlyAttributeMarker(marker: string | AttributeMarker | CssSelector) {\n  return (\n    marker === AttributeMarker.Bindings ||\n    marker === AttributeMarker.Template ||\n    marker === AttributeMarker.I18n\n  );\n}\n\nexport function isAnimationProp(name: string): boolean {\n  // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n  // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n  // charCodeAt doesn't allocate memory to return a substring.\n  return name.charCodeAt(0) === CharCode.AT_SIGN;\n}\n\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\nexport function mergeHostAttrs(\n  dst: TAttributes | null,\n  src: TAttributes | null,\n): TAttributes | null {\n  if (src === null || src.length === 0) {\n    // do nothing\n  } else if (dst === null || dst.length === 0) {\n    // We have source, but dst is empty, just make a copy.\n    dst = src.slice();\n  } else {\n    let srcMarker: AttributeMarker = AttributeMarker.ImplicitAttributes;\n    for (let i = 0; i < src.length; i++) {\n      const item = src[i];\n      if (typeof item === 'number') {\n        srcMarker = item;\n      } else {\n        if (srcMarker === AttributeMarker.NamespaceURI) {\n          // Case where we need to consume `key1`, `key2`, `value` items.\n        } else if (\n          srcMarker === AttributeMarker.ImplicitAttributes ||\n          srcMarker === AttributeMarker.Styles\n        ) {\n          // Case where we have to consume `key1` and `value` only.\n          mergeHostAttribute(dst, srcMarker, item as string, null, src[++i] as string);\n        } else {\n          // Case where we have to consume `key1` only.\n          mergeHostAttribute(dst, srcMarker, item as string, null, null);\n        }\n      }\n    }\n  }\n  return dst;\n}\n\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\nexport function mergeHostAttribute(\n  dst: TAttributes,\n  marker: AttributeMarker,\n  key1: string,\n  key2: string | null,\n  value: string | null,\n): void {\n  let i = 0;\n  // Assume that new markers will be inserted at the end.\n  let markerInsertPosition = dst.length;\n  // scan until correct type.\n  if (marker === AttributeMarker.ImplicitAttributes) {\n    markerInsertPosition = -1;\n  } else {\n    while (i < dst.length) {\n      const dstValue = dst[i++];\n      if (typeof dstValue === 'number') {\n        if (dstValue === marker) {\n          markerInsertPosition = -1;\n          break;\n        } else if (dstValue > marker) {\n          // We need to save this as we want the markers to be inserted in specific order.\n          markerInsertPosition = i - 1;\n          break;\n        }\n      }\n    }\n  }\n\n  // search until you find place of insertion\n  while (i < dst.length) {\n    const item = dst[i];\n    if (typeof item === 'number') {\n      // since `i` started as the index after the marker, we did not find it if we are at the next\n      // marker\n      break;\n    } else if (item === key1) {\n      // We already have same token\n      if (key2 === null) {\n        if (value !== null) {\n          dst[i + 1] = value;\n        }\n        return;\n      } else if (key2 === dst[i + 1]) {\n        dst[i + 2] = value!;\n        return;\n      }\n    }\n    // Increment counter.\n    i++;\n    if (key2 !== null) i++;\n    if (value !== null) i++;\n  }\n\n  // insert at location.\n  if (markerInsertPosition !== -1) {\n    dst.splice(markerInsertPosition, 0, marker);\n    i = markerInsertPosition + 1;\n  }\n  dst.splice(i++, 0, key1);\n  if (key2 !== null) {\n    dst.splice(i++, 0, key2);\n  }\n  if (value !== null) {\n    dst.splice(i++, 0, value);\n  }\n}\n"]}