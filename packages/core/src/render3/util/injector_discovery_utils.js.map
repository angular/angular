{"version":3,"file":"injector_discovery_utils.js","sourceRoot":"","sources":["injector_discovery_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ENVIRONMENT_INITIALIZER} from '../../di/initializer_token';\nimport {InjectionToken} from '../../di/injection_token';\nimport {Injector} from '../../di/injector';\nimport {getInjectorDef, InjectorType} from '../../di/interface/defs';\nimport {InternalInjectFlags} from '../../di/interface/injector';\nimport {ValueProvider} from '../../di/interface/provider';\nimport {INJECTOR_DEF_TYPES} from '../../di/internal_tokens';\nimport {NullInjector} from '../../di/null_injector';\nimport {SingleProvider, walkProviderTree} from '../../di/provider_collection';\nimport {EnvironmentInjector, R3Injector} from '../../di/r3_injector';\nimport {Type} from '../../interface/type';\nimport {NgModuleRef as viewEngine_NgModuleRef} from '../../linker/ng_module_factory';\nimport {deepForEach} from '../../util/array_utils';\nimport {throwError} from '../../util/assert';\nimport {assertTNode, assertTNodeForLView} from '../assert';\nimport {ChainedInjector} from '../chained_injector';\nimport {getFrameworkDIDebugData} from '../debug/framework_injector_profiler';\nimport {InjectedService, ProviderRecord} from '../debug/injector_profiler';\nimport {getComponentDef} from '../def_getters';\nimport {\n  getNodeInjectorLView,\n  getNodeInjectorTNode,\n  getParentInjectorLocation,\n  NodeInjector,\n} from '../di';\nimport {NodeInjectorOffset} from '../interfaces/injector';\nimport {TContainerNode, TElementContainerNode, TElementNode, TNode} from '../interfaces/node';\nimport {RElement} from '../interfaces/renderer_dom';\nimport {INJECTOR, LView, TVIEW} from '../interfaces/view';\n\nimport {getParentInjectorIndex, getParentInjectorView, hasParentInjector} from './injector_utils';\nimport {getNativeByTNode} from './view_utils';\n\n/**\n * Discovers the dependencies of an injectable instance. Provides DI information about each\n * dependency that the injectable was instantiated with, including where they were provided from.\n *\n * @param injector An injector instance\n * @param token a DI token that was constructed by the given injector instance\n * @returns an object that contains the created instance of token as well as all of the dependencies\n * that it was instantiated with OR undefined if the token was not created within the given\n * injector.\n */\nexport function getDependenciesFromInjectable<T>(\n  injector: Injector,\n  token: Type<T> | InjectionToken<T>,\n): {instance: T; dependencies: Omit<InjectedService, 'injectedIn'>[]} | undefined {\n  // First we check to see if the token given maps to an actual instance in the injector given.\n  // We use `self: true` because we only want to look at the injector we were given.\n  // We use `optional: true` because it's possible that the token we were given was never\n  // constructed by the injector we were given.\n  const instance = injector.get(token, null, {self: true, optional: true});\n  if (instance === null) {\n    throw new Error(`Unable to determine instance of ${token} in given injector`);\n  }\n\n  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);\n  const resolutionPath = getInjectorResolutionPath(injector);\n\n  const dependencies = unformattedDependencies.map((dep) => {\n    // injectedIn contains private fields, so we omit it from the response\n    const formattedDependency: Omit<InjectedService, 'injectedIn'> = {\n      value: dep.value,\n    };\n\n    // convert injection flags to booleans\n    const flags = dep.flags as InternalInjectFlags;\n    formattedDependency.flags = {\n      optional: (InternalInjectFlags.Optional & flags) === InternalInjectFlags.Optional,\n      host: (InternalInjectFlags.Host & flags) === InternalInjectFlags.Host,\n      self: (InternalInjectFlags.Self & flags) === InternalInjectFlags.Self,\n      skipSelf: (InternalInjectFlags.SkipSelf & flags) === InternalInjectFlags.SkipSelf,\n    };\n\n    // find the injector that provided the dependency\n    for (let i = 0; i < resolutionPath.length; i++) {\n      const injectorToCheck = resolutionPath[i];\n\n      // if skipSelf is true we skip the first injector\n      if (i === 0 && formattedDependency.flags.skipSelf) {\n        continue;\n      }\n\n      // host only applies to NodeInjectors\n      if (formattedDependency.flags.host && injectorToCheck instanceof EnvironmentInjector) {\n        break;\n      }\n\n      const instance = injectorToCheck.get(dep.token as Type<unknown>, null, {\n        self: true,\n        optional: true,\n      });\n\n      if (instance !== null) {\n        // if host flag is true we double check that we can get the service from the first element\n        // in the resolution path by using the host flag. This is done to make sure that we've found\n        // the correct providing injector, and not a node injector that is connected to our path via\n        // a router outlet.\n        if (formattedDependency.flags.host) {\n          const firstInjector = resolutionPath[0];\n          const lookupFromFirstInjector = firstInjector.get(dep.token as Type<unknown>, null, {\n            ...formattedDependency.flags,\n            optional: true,\n          });\n\n          if (lookupFromFirstInjector !== null) {\n            formattedDependency.providedIn = injectorToCheck;\n          }\n\n          break;\n        }\n\n        formattedDependency.providedIn = injectorToCheck;\n        break;\n      }\n\n      // if self is true we stop after the first injector\n      if (i === 0 && formattedDependency.flags.self) {\n        break;\n      }\n    }\n\n    if (dep.token) formattedDependency.token = dep.token;\n\n    return formattedDependency;\n  });\n\n  return {instance, dependencies};\n}\n\nfunction getDependenciesForTokenInInjector<T>(\n  token: Type<T> | InjectionToken<T>,\n  injector: Injector,\n): InjectedService[] {\n  const {resolverToTokenToDependencies} = getFrameworkDIDebugData();\n\n  if (!(injector instanceof NodeInjector)) {\n    return resolverToTokenToDependencies.get(injector)?.get?.(token as Type<T>) ?? [];\n  }\n\n  const lView = getNodeInjectorLView(injector);\n  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);\n  const dependencies = tokenDependencyMap?.get(token as Type<T>) ?? [];\n\n  // In the NodeInjector case, all injections for every node are stored in the same lView.\n  // We use the injectedIn field of the dependency to filter out the dependencies that\n  // do not come from the same node as the instance we're looking at.\n  return dependencies.filter((dependency) => {\n    const dependencyNode = dependency.injectedIn?.tNode;\n    if (dependencyNode === undefined) {\n      return false;\n    }\n\n    const instanceNode = getNodeInjectorTNode(injector);\n    assertTNode(dependencyNode);\n    assertTNode(instanceNode!);\n\n    return dependencyNode === instanceNode;\n  });\n}\n\n/**\n * Gets the class associated with an injector that contains a provider `imports` array in it's\n * definition\n *\n * For Module Injectors this returns the NgModule constructor.\n *\n * For Standalone injectors this returns the standalone component constructor.\n *\n * @param injector Injector an injector instance\n * @returns the constructor where the `imports` array that configures this injector is located\n */\nfunction getProviderImportsContainer(injector: Injector): Type<unknown> | null {\n  const {standaloneInjectorToComponent} = getFrameworkDIDebugData();\n\n  // standalone components configure providers through a component def, so we have to\n  // use the standalone component associated with this injector if Injector represents\n  // a standalone components EnvironmentInjector\n  if (standaloneInjectorToComponent.has(injector)) {\n    return standaloneInjectorToComponent.get(injector)!;\n  }\n\n  // Module injectors configure providers through their NgModule def, so we use the\n  // injector to lookup its NgModuleRef and through that grab its instance\n  const defTypeRef = injector.get(viewEngine_NgModuleRef, null, {self: true, optional: true})!;\n\n  // If we can't find an associated imports container, return null.\n  // This could be the case if this function is called with an R3Injector that does not represent\n  // a standalone component or NgModule.\n  if (defTypeRef === null) {\n    return null;\n  }\n\n  // In standalone applications, the root environment injector created by bootstrapApplication\n  // may have no associated \"instance\".\n  if (defTypeRef.instance === null) {\n    return null;\n  }\n\n  return defTypeRef.instance.constructor;\n}\n\n/**\n * Gets the providers configured on a NodeInjector\n *\n * @param injector A NodeInjector instance\n * @returns ProviderRecord[] an array of objects representing the providers configured on this\n *     injector\n */\nfunction getNodeInjectorProviders(injector: NodeInjector): ProviderRecord[] {\n  const diResolver = getNodeInjectorTNode(injector);\n  const {resolverToProviders} = getFrameworkDIDebugData();\n  return resolverToProviders.get(diResolver as TNode) ?? [];\n}\n\n/**\n * Gets a mapping of providers configured on an injector to their import paths\n *\n * ModuleA -> imports ModuleB\n * ModuleB -> imports ModuleC\n * ModuleB -> provides MyServiceA\n * ModuleC -> provides MyServiceB\n *\n * getProviderImportPaths(ModuleA)\n * > Map(2) {\n *   MyServiceA => [ModuleA, ModuleB]\n *   MyServiceB => [ModuleA, ModuleB, ModuleC]\n *  }\n *\n * @param providerImportsContainer constructor of class that contains an `imports` array in it's\n *     definition\n * @returns A Map object that maps providers to an array of constructors representing it's import\n *     path\n *\n */\nfunction getProviderImportPaths(\n  providerImportsContainer: Type<unknown>,\n): Map<SingleProvider, (Type<unknown> | InjectorType<unknown>)[]> {\n  const providerToPath = new Map<SingleProvider, (Type<unknown> | InjectorType<unknown>)[]>();\n  const visitedContainers = new Set<Type<unknown>>();\n  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);\n\n  walkProviderTree(providerImportsContainer, visitor, [], new Set());\n\n  return providerToPath;\n}\n\n/**\n *\n * Higher order function that returns a visitor for WalkProviderTree\n *\n * Takes in a Map and Set to keep track of the providers and containers\n * visited, so that we can discover the import paths of these providers\n * during the traversal.\n *\n * This visitor takes advantage of the fact that walkProviderTree performs a\n * postorder traversal of the provider tree for the passed in container. Because postorder\n * traversal recursively processes subtrees from leaf nodes until the traversal reaches the root,\n * we write a visitor that constructs provider import paths in reverse.\n *\n *\n * We use the visitedContainers set defined outside this visitor\n * because we want to run some logic only once for\n * each container in the tree. That logic can be described as:\n *\n *\n * 1. for each discovered_provider and discovered_path in the incomplete provider paths we've\n * already discovered\n * 2. get the first container in discovered_path\n * 3. if that first container is in the imports array of the container we're visiting\n *    Then the container we're visiting is also in the import path of discovered_provider, so we\n *    unshift discovered_path with the container we're currently visiting\n *\n *\n * Example Run:\n * ```\n *                 ┌──────────┐\n *                 │containerA│\n *      ┌─imports-─┤          ├──imports─┐\n *      │          │  provA   │          │\n *      │          │  provB   │          │\n *      │          └──────────┘          │\n *      │                                │\n *     ┌▼─────────┐             ┌────────▼─┐\n *     │containerB│             │containerC│\n *     │          │             │          │\n *     │  provD   │             │  provF   │\n *     │  provE   │             │  provG   │\n *     └──────────┘             └──────────┘\n * ```\n *\n * Each step of the traversal,\n *\n * ```\n * visitor(provD, containerB)\n * providerToPath === Map { provD => [containerB] }\n * visitedContainers === Set { containerB }\n *\n * visitor(provE, containerB)\n * providerToPath === Map { provD => [containerB], provE => [containerB] }\n * visitedContainers === Set { containerB }\n *\n * visitor(provF, containerC)\n * providerToPath === Map { provD => [containerB], provE => [containerB], provF => [containerC] }\n * visitedContainers === Set { containerB, containerC }\n *\n * visitor(provG, containerC)\n * providerToPath === Map {\n *   provD => [containerB], provE => [containerB], provF => [containerC], provG => [containerC]\n * }\n * visitedContainers === Set { containerB, containerC }\n *\n * visitor(provA, containerA)\n * providerToPath === Map {\n *   provD => [containerA, containerB],\n *   provE => [containerA, containerB],\n *   provF => [containerA, containerC],\n *   provG => [containerA, containerC],\n *   provA => [containerA]\n * }\n * visitedContainers === Set { containerB, containerC, containerA }\n *\n * visitor(provB, containerA)\n * providerToPath === Map {\n *   provD => [containerA, containerB],\n *   provE => [containerA, containerB],\n *   provF => [containerA, containerC],\n *   provG => [containerA, containerC],\n *   provA => [containerA]\n *   provB => [containerA]\n * }\n * visitedContainers === Set { containerB, containerC, containerA }\n * ```\n *\n * @param providerToPath Map map of providers to paths that this function fills\n * @param visitedContainers Set a set to keep track of the containers we've already visited\n * @return function(provider SingleProvider, container: Type<unknown> | InjectorType<unknown>) =>\n *     void\n */\nfunction walkProviderTreeToDiscoverImportPaths(\n  providerToPath: Map<SingleProvider, (Type<unknown> | InjectorType<unknown>)[]>,\n  visitedContainers: Set<Type<unknown>>,\n): (provider: SingleProvider, container: Type<unknown> | InjectorType<unknown>) => void {\n  return (provider: SingleProvider, container: Type<unknown> | InjectorType<unknown>) => {\n    // If the provider is not already in the providerToPath map,\n    // add an entry with the provider as the key and an array containing the current container as\n    // the value\n    if (!providerToPath.has(provider)) {\n      providerToPath.set(provider, [container]);\n    }\n\n    // This block will run exactly once for each container in the import tree.\n    // This is where we run the logic to check the imports array of the current\n    // container to see if it's the next container in the path for our currently\n    // discovered providers.\n    if (!visitedContainers.has(container)) {\n      // Iterate through the providers we've already seen\n      for (const prov of providerToPath.keys()) {\n        const existingImportPath = providerToPath.get(prov)!;\n\n        let containerDef = getInjectorDef(container);\n        if (!containerDef) {\n          const ngModule: Type<unknown> | undefined = (container as any).ngModule as\n            | Type<unknown>\n            | undefined;\n          containerDef = getInjectorDef(ngModule);\n        }\n\n        if (!containerDef) {\n          return;\n        }\n\n        const lastContainerAddedToPath = existingImportPath[0];\n\n        let isNextStepInPath = false;\n        deepForEach(containerDef.imports, (moduleImport) => {\n          if (isNextStepInPath) {\n            return;\n          }\n\n          isNextStepInPath =\n            (moduleImport as any).ngModule === lastContainerAddedToPath ||\n            moduleImport === lastContainerAddedToPath;\n\n          if (isNextStepInPath) {\n            providerToPath.get(prov)?.unshift(container);\n          }\n        });\n      }\n    }\n\n    visitedContainers.add(container);\n  };\n}\n\n/**\n * Gets the providers configured on an EnvironmentInjector\n *\n * @param injector EnvironmentInjector\n * @returns an array of objects representing the providers of the given injector\n */\nfunction getEnvironmentInjectorProviders(injector: EnvironmentInjector): ProviderRecord[] {\n  const providerRecordsWithoutImportPaths =\n    getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];\n\n  // platform injector has no provider imports container so can we skip trying to\n  // find import paths\n  if (isPlatformInjector(injector)) {\n    return providerRecordsWithoutImportPaths;\n  }\n\n  const providerImportsContainer = getProviderImportsContainer(injector);\n  if (providerImportsContainer === null) {\n    // We assume that if an environment injector exists without an associated provider imports\n    // container, it was created without such a container. Some examples cases where this could\n    // happen:\n    // - The root injector of a standalone application\n    // - A router injector created by using the providers array in a lazy loaded route\n    // - A manually created injector that is attached to the injector tree\n    // Since each of these cases has no provider container, there is no concept of import paths,\n    // so we can simply return the provider records.\n    return providerRecordsWithoutImportPaths;\n  }\n\n  const providerToPath = getProviderImportPaths(providerImportsContainer);\n  const providerRecords = [];\n\n  for (const providerRecord of providerRecordsWithoutImportPaths) {\n    const provider = providerRecord.provider;\n    // Ignore these special providers for now until we have a cleaner way of\n    // determing when they are provided by the framework vs provided by the user.\n    const token = (provider as ValueProvider).provide;\n    if (token === ENVIRONMENT_INITIALIZER || token === INJECTOR_DEF_TYPES) {\n      continue;\n    }\n\n    let importPath = providerToPath.get(provider) ?? [];\n\n    const def = getComponentDef(providerImportsContainer);\n    const isStandaloneComponent = !!def?.standalone;\n    // We prepend the component constructor in the standalone case\n    // because walkProviderTree does not visit this constructor during it's traversal\n    if (isStandaloneComponent) {\n      importPath = [providerImportsContainer, ...importPath];\n    }\n\n    providerRecords.push({...providerRecord, importPath});\n  }\n  return providerRecords;\n}\n\nfunction isPlatformInjector(injector: Injector) {\n  return injector instanceof R3Injector && injector.scopes.has('platform');\n}\n\n/**\n * Gets the providers configured on an injector.\n *\n * @param injector the injector to lookup the providers of\n * @returns ProviderRecord[] an array of objects representing the providers of the given injector\n */\nexport function getInjectorProviders(injector: Injector): ProviderRecord[] {\n  if (injector instanceof NodeInjector) {\n    return getNodeInjectorProviders(injector);\n  } else if (injector instanceof EnvironmentInjector) {\n    return getEnvironmentInjectorProviders(injector as EnvironmentInjector);\n  }\n\n  throwError('getInjectorProviders only supports NodeInjector and EnvironmentInjector');\n}\n\n/**\n *\n * Given an injector, this function will return\n * an object containing the type and source of the injector.\n *\n * |              | type        | source                                                      |\n * |--------------|-------------|-------------------------------------------------------------|\n * | NodeInjector | element     | DOM element that created this injector                      |\n * | R3Injector   | environment | `injector.source`                                           |\n * | NullInjector | null        | null                                                        |\n *\n * @param injector the Injector to get metadata for\n * @returns an object containing the type and source of the given injector. If the injector metadata\n *     cannot be determined, returns null.\n */\nexport function getInjectorMetadata(\n  injector: Injector,\n):\n  | {type: 'element'; source: RElement}\n  | {type: 'environment'; source: string | null}\n  | {type: 'null'; source: null}\n  | null {\n  if (injector instanceof NodeInjector) {\n    const lView = getNodeInjectorLView(injector);\n    const tNode = getNodeInjectorTNode(injector)!;\n    assertTNodeForLView(tNode, lView);\n\n    return {type: 'element', source: getNativeByTNode(tNode, lView) as RElement};\n  }\n\n  if (injector instanceof R3Injector) {\n    return {type: 'environment', source: injector.source ?? null};\n  }\n\n  if (injector instanceof NullInjector) {\n    return {type: 'null', source: null};\n  }\n\n  return null;\n}\n\nexport function getInjectorResolutionPath(injector: Injector): Injector[] {\n  const resolutionPath: Injector[] = [injector];\n  getInjectorResolutionPathHelper(injector, resolutionPath);\n  return resolutionPath;\n}\n\nfunction getInjectorResolutionPathHelper(\n  injector: Injector,\n  resolutionPath: Injector[],\n): Injector[] {\n  const parent = getInjectorParent(injector);\n\n  // if getInjectorParent can't find a parent, then we've either reached the end\n  // of the path, or we need to move from the Element Injector tree to the\n  // module injector tree using the first injector in our path as the connection point.\n  if (parent === null) {\n    if (injector instanceof NodeInjector) {\n      const firstInjector = resolutionPath[0];\n      if (firstInjector instanceof NodeInjector) {\n        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);\n        if (moduleInjector === null) {\n          throwError('NodeInjector must have some connection to the module injector tree');\n        }\n\n        resolutionPath.push(moduleInjector);\n        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);\n      }\n\n      return resolutionPath;\n    }\n  } else {\n    resolutionPath.push(parent);\n    getInjectorResolutionPathHelper(parent, resolutionPath);\n  }\n\n  return resolutionPath;\n}\n\n/**\n * Gets the parent of an injector.\n *\n * This function is not able to make the jump from the Element Injector Tree to the Module\n * injector tree. This is because the \"parent\" (the next step in the reoslution path)\n * of a root NodeInjector is dependent on which NodeInjector ancestor initiated\n * the DI lookup. See getInjectorResolutionPath for a function that can make this jump.\n *\n * In the below diagram:\n * ```ts\n * getInjectorParent(NodeInjectorB)\n *  > NodeInjectorA\n * getInjectorParent(NodeInjectorA) // or getInjectorParent(getInjectorParent(NodeInjectorB))\n *  > null // cannot jump to ModuleInjector tree\n * ```\n *\n * ```\n *                ┌───────┐                ┌───────────────────┐\n *    ┌───────────┤ModuleA├───Injector────►│EnvironmentInjector│\n *    │           └───┬───┘                └───────────────────┘\n *    │               │\n *    │           bootstraps\n *    │               │\n *    │               │\n *    │          ┌────▼─────┐                 ┌─────────────┐\n * declares      │ComponentA├────Injector────►│NodeInjectorA│\n *    │          └────┬─────┘                 └─────▲───────┘\n *    │               │                             │\n *    │            renders                        parent\n *    │               │                             │\n *    │          ┌────▼─────┐                 ┌─────┴───────┐\n *    └─────────►│ComponentB├────Injector────►│NodeInjectorB│\n *               └──────────┘                 └─────────────┘\n *```\n *\n * @param injector an Injector to get the parent of\n * @returns Injector the parent of the given injector\n */\nfunction getInjectorParent(injector: Injector): Injector | null {\n  if (injector instanceof R3Injector) {\n    return injector.parent;\n  }\n\n  let tNode: TElementNode | TContainerNode | TElementContainerNode | null;\n  let lView: LView<unknown>;\n  if (injector instanceof NodeInjector) {\n    tNode = getNodeInjectorTNode(injector);\n    lView = getNodeInjectorLView(injector);\n  } else if (injector instanceof NullInjector) {\n    return null;\n  } else if (injector instanceof ChainedInjector) {\n    return injector.parentInjector;\n  } else {\n    throwError(\n      'getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector',\n    );\n  }\n\n  const parentLocation = getParentInjectorLocation(\n    tNode as TElementNode | TContainerNode | TElementContainerNode,\n    lView,\n  );\n\n  if (hasParentInjector(parentLocation)) {\n    const parentInjectorIndex = getParentInjectorIndex(parentLocation);\n    const parentLView = getParentInjectorView(parentLocation, lView);\n    const parentTView = parentLView[TVIEW];\n    const parentTNode = parentTView.data[parentInjectorIndex + NodeInjectorOffset.TNODE] as TNode;\n    return new NodeInjector(\n      parentTNode as TElementNode | TContainerNode | TElementContainerNode,\n      parentLView,\n    );\n  } else {\n    const chainedInjector = lView[INJECTOR] as ChainedInjector;\n\n    // Case where chainedInjector.injector is an OutletInjector and chainedInjector.injector.parent\n    // is a NodeInjector.\n    // todo(aleksanderbodurri): ideally nothing in packages/core should deal\n    // directly with router concerns. Refactor this so that we can make the jump from\n    // NodeInjector -> OutletInjector -> NodeInjector\n    // without explicitly relying on types contracts from packages/router\n    const injectorParent = (chainedInjector.injector as any)?.parent as Injector;\n\n    if (injectorParent instanceof NodeInjector) {\n      return injectorParent;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Gets the module injector of a NodeInjector.\n *\n * @param injector NodeInjector to get module injector of\n * @returns Injector representing module injector of the given NodeInjector\n */\nfunction getModuleInjectorOfNodeInjector(injector: NodeInjector): Injector {\n  let lView: LView<unknown>;\n  if (injector instanceof NodeInjector) {\n    lView = getNodeInjectorLView(injector);\n  } else {\n    throwError('getModuleInjectorOfNodeInjector must be called with a NodeInjector');\n  }\n\n  const inj = lView[INJECTOR] as R3Injector | ChainedInjector;\n  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;\n  if (!moduleInjector) {\n    throwError('NodeInjector must have some connection to the module injector tree');\n  }\n\n  return moduleInjector;\n}\n"]}