{"version":3,"file":"signal_debug.js","sourceRoot":"","sources":["signal_debug.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {\n  REACTIVE_LVIEW_CONSUMER_NODE,\n  ReactiveLViewConsumer,\n  TEMPORARY_CONSUMER_NODE,\n} from '../reactive_lview_consumer';\nimport {assertTNode, assertLView} from '../assert';\nimport {getFrameworkDIDebugData} from '../debug/framework_injector_profiler';\nimport {NodeInjector, getNodeInjectorTNode, getNodeInjectorLView} from '../di';\nimport {REACTIVE_TEMPLATE_CONSUMER, HOST, LView, CONTEXT} from '../interfaces/view';\nimport {EffectNode, EffectRefImpl, ROOT_EFFECT_NODE, VIEW_EFFECT_NODE} from '../reactivity/effect';\nimport {Injector} from '../../di/injector';\nimport {R3Injector} from '../../di/r3_injector';\nimport {throwError} from '../../util/assert';\nimport {\n  ComputedNode,\n  ReactiveNode,\n  SIGNAL,\n  SIGNAL_NODE,\n  SignalNode,\n} from '../../../primitives/signals';\nimport {isLView} from '../interfaces/type_checks';\n\nexport interface DebugSignalGraphNode {\n  kind: string;\n  id: string;\n  epoch: number;\n  label?: string;\n  value?: unknown;\n  debuggableFn?: () => unknown;\n}\n\nexport interface DebugSignalGraphEdge {\n  /**\n   * Index of a signal node in the `nodes` array that is a consumer of the signal produced by the producer node.\n   */\n  consumer: number;\n\n  /**\n   * Index of a signal node in the `nodes` array that is a producer of the signal consumed by the consumer node.\n   */\n  producer: number;\n}\n\n/**\n * A debug representation of the signal graph.\n */\nexport interface DebugSignalGraph {\n  nodes: DebugSignalGraphNode[];\n  edges: DebugSignalGraphEdge[];\n}\n\nfunction isComputedNode(node: ReactiveNode): node is ComputedNode<unknown> {\n  return node.kind === 'computed';\n}\n\nfunction isTemplateEffectNode(node: ReactiveNode): node is ReactiveLViewConsumer {\n  return node.kind === 'template';\n}\n\nfunction isEffectNode(node: ReactiveNode): node is EffectNode {\n  return node.kind === 'effect';\n}\n\nfunction isSignalNode(node: ReactiveNode): node is SignalNode<unknown> {\n  return node.kind === 'signal';\n}\n\n/**\n *\n * @param injector\n * @returns Template consumer of given NodeInjector\n */\nfunction getTemplateConsumer(injector: NodeInjector): ReactiveLViewConsumer | null {\n  const tNode = getNodeInjectorTNode(injector)!;\n  assertTNode(tNode);\n  const lView = getNodeInjectorLView(injector)!;\n  assertLView(lView);\n  const templateLView = lView[tNode.index]!;\n  if (isLView(templateLView)) {\n    return templateLView[REACTIVE_TEMPLATE_CONSUMER] ?? null;\n  }\n  return null;\n}\n\nconst signalDebugMap = new WeakMap<ReactiveNode, string>();\nlet counter = 0;\n\nfunction getNodesAndEdgesFromSignalMap(signalMap: ReadonlyMap<ReactiveNode, ReactiveNode[]>): {\n  nodes: DebugSignalGraphNode[];\n  edges: DebugSignalGraphEdge[];\n} {\n  const nodes = Array.from(signalMap.keys());\n  const debugSignalGraphNodes: DebugSignalGraphNode[] = [];\n  const edges: DebugSignalGraphEdge[] = [];\n\n  for (const [consumer, producers] of signalMap.entries()) {\n    const consumerIndex = nodes.indexOf(consumer);\n\n    let id = signalDebugMap.get(consumer);\n    if (!id) {\n      counter++;\n      id = counter.toString();\n      signalDebugMap.set(consumer, id);\n    }\n\n    // collect node\n    if (isComputedNode(consumer)) {\n      debugSignalGraphNodes.push({\n        label: consumer.debugName,\n        value: consumer.value,\n        kind: consumer.kind,\n        epoch: consumer.version,\n        debuggableFn: consumer.computation,\n        id,\n      });\n    } else if (isSignalNode(consumer)) {\n      debugSignalGraphNodes.push({\n        label: consumer.debugName,\n        value: consumer.value,\n        kind: consumer.kind,\n        epoch: consumer.version,\n        id,\n      });\n    } else if (isTemplateEffectNode(consumer)) {\n      debugSignalGraphNodes.push({\n        label: consumer.debugName ?? consumer.lView?.[HOST]?.tagName?.toLowerCase?.(),\n        kind: consumer.kind,\n        epoch: consumer.version,\n        // The `lView[CONTEXT]` is a reference to an instance of the component's class.\n        // We get the constructor so that `inspect(.constructor)` shows the component class.\n        debuggableFn: consumer.lView?.[CONTEXT]?.constructor as (() => unknown) | undefined,\n        id,\n      });\n    } else {\n      debugSignalGraphNodes.push({\n        label: consumer.debugName,\n        kind: consumer.kind,\n        epoch: consumer.version,\n        id,\n      });\n    }\n\n    // collect edges for node\n    for (const producer of producers) {\n      edges.push({consumer: consumerIndex, producer: nodes.indexOf(producer)});\n    }\n  }\n\n  return {nodes: debugSignalGraphNodes, edges};\n}\n\nfunction extractEffectsFromInjector(injector: Injector): ReactiveNode[] {\n  let diResolver: Injector | LView<unknown> = injector;\n  if (injector instanceof NodeInjector) {\n    const lView = getNodeInjectorLView(injector)!;\n    diResolver = lView;\n  }\n\n  const resolverToEffects = getFrameworkDIDebugData().resolverToEffects as Map<\n    Injector | LView<unknown>,\n    EffectRefImpl[]\n  >;\n  const effects = resolverToEffects.get(diResolver) ?? [];\n\n  return effects.map((effect: EffectRefImpl) => effect[SIGNAL]);\n}\n\nfunction extractSignalNodesAndEdgesFromRoots(\n  nodes: ReactiveNode[],\n  signalDependenciesMap: Map<ReactiveNode, ReactiveNode[]> = new Map(),\n): Map<ReactiveNode, ReactiveNode[]> {\n  for (const node of nodes) {\n    if (signalDependenciesMap.has(node)) {\n      continue;\n    }\n\n    const producerNodes = [];\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n      const producer = link.producer;\n      producerNodes.push(producer);\n    }\n    signalDependenciesMap.set(node, producerNodes);\n    extractSignalNodesAndEdgesFromRoots(producerNodes, signalDependenciesMap);\n  }\n\n  return signalDependenciesMap;\n}\n\n/**\n * Returns a debug representation of the signal graph for the given injector.\n *\n * Currently only supports element injectors. Starts by discovering the consumer nodes\n * and then traverses their producer nodes to build the signal graph.\n *\n * @param injector The injector to get the signal graph for.\n * @returns A debug representation of the signal graph.\n * @throws If the injector is an environment injector.\n */\nexport function getSignalGraph(injector: Injector): DebugSignalGraph {\n  let templateConsumer: ReactiveLViewConsumer | null = null;\n\n  if (!(injector instanceof NodeInjector) && !(injector instanceof R3Injector)) {\n    return throwError('getSignalGraph must be called with a NodeInjector or R3Injector');\n  }\n\n  if (injector instanceof NodeInjector) {\n    templateConsumer = getTemplateConsumer(injector as NodeInjector);\n  }\n\n  const nonTemplateEffectNodes = extractEffectsFromInjector(injector);\n\n  const signalNodes = templateConsumer\n    ? [templateConsumer, ...nonTemplateEffectNodes]\n    : nonTemplateEffectNodes;\n\n  const signalDependenciesMap = extractSignalNodesAndEdgesFromRoots(signalNodes);\n\n  return getNodesAndEdgesFromSignalMap(signalDependenciesMap);\n}\n"]}