{"version":3,"file":"inherit_definition_feature.js","sourceRoot":"","sources":["inherit_definition_feature.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type, Writable} from '../../interface/type';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from '../../util/empty';\nimport {fillProperties} from '../../util/property';\nimport {\n  ComponentDef,\n  ContentQueriesFunction,\n  DirectiveDef,\n  DirectiveDefFeature,\n  HostBindingsFunction,\n  RenderFlags,\n  ViewQueriesFunction,\n} from '../interfaces/definition';\nimport {TAttributes} from '../interfaces/node';\nimport {isComponentDef} from '../interfaces/type_checks';\nimport {mergeHostAttrs} from '../util/attrs_utils';\nimport {stringifyForError} from '../util/stringify_utils';\n\nexport function getSuperType(\n  type: Type<any>,\n): Type<any> & {ɵcmp?: ComponentDef<any>; ɵdir?: DirectiveDef<any>} {\n  return Object.getPrototypeOf(type.prototype).constructor;\n}\n\ntype WritableDef = Writable<DirectiveDef<any> | ComponentDef<any>>;\n\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n *\n * @codeGenApi\n */\nexport function ɵɵInheritDefinitionFeature(\n  definition: DirectiveDef<any> | ComponentDef<any>,\n): void {\n  let superType = getSuperType(definition.type);\n  let shouldInheritFields = true;\n  const inheritanceChain: WritableDef[] = [definition];\n\n  while (superType) {\n    let superDef: DirectiveDef<any> | ComponentDef<any> | undefined = undefined;\n    if (isComponentDef(definition)) {\n      // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n      superDef = superType.ɵcmp || superType.ɵdir;\n    } else {\n      if (superType.ɵcmp) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_INHERITANCE,\n          ngDevMode &&\n            `Directives cannot inherit Components. Directive ${stringifyForError(\n              definition.type,\n            )} is attempting to extend component ${stringifyForError(superType)}`,\n        );\n      }\n      // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n      superDef = superType.ɵdir;\n    }\n\n    if (superDef) {\n      if (shouldInheritFields) {\n        inheritanceChain.push(superDef);\n        // Some fields in the definition may be empty, if there were no values to put in them that\n        // would've justified object creation. Unwrap them if necessary.\n        const writeableDef = definition as WritableDef;\n        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\n        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\n        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\n\n        // Merge hostBindings\n        const superHostBindings = superDef.hostBindings;\n        superHostBindings && inheritHostBindings(definition, superHostBindings);\n\n        // Merge queries\n        const superViewQuery = superDef.viewQuery;\n        const superContentQueries = superDef.contentQueries;\n        superViewQuery && inheritViewQuery(definition, superViewQuery);\n        superContentQueries && inheritContentQueries(definition, superContentQueries);\n\n        // Merge inputs and outputs\n        mergeInputsWithTransforms(definition, superDef);\n        fillProperties(definition.outputs, superDef.outputs);\n\n        // Merge animations metadata.\n        // If `superDef` is a Component, the `data` field is present (defaults to an empty object).\n        if (isComponentDef(superDef) && superDef.data.animation) {\n          // If super def is a Component, the `definition` is also a Component, since Directives can\n          // not inherit Components (we throw an error above and cannot reach this code).\n          const defData = (definition as ComponentDef<any>).data;\n          defData.animation = (defData.animation || []).concat(superDef.data.animation);\n        }\n      }\n\n      // Run parent features\n      const features = superDef.features;\n      if (features) {\n        for (let i = 0; i < features.length; i++) {\n          const feature = features[i];\n          if (feature && feature.ngInherit) {\n            (feature as DirectiveDefFeature)(definition);\n          }\n          // If `InheritDefinitionFeature` is a part of the current `superDef`, it means that this\n          // def already has all the necessary information inherited from its super class(es), so we\n          // can stop merging fields from super classes. However we need to iterate through the\n          // prototype chain to look for classes that might contain other \"features\" (like\n          // NgOnChanges), which we should invoke for the original `definition`. We set the\n          // `shouldInheritFields` flag to indicate that, essentially skipping fields inheritance\n          // logic and only invoking functions from the \"features\" list.\n          if (feature === ɵɵInheritDefinitionFeature) {\n            shouldInheritFields = false;\n          }\n        }\n      }\n    }\n\n    superType = Object.getPrototypeOf(superType);\n  }\n  mergeHostAttrsAcrossInheritance(inheritanceChain);\n}\n\nfunction mergeInputsWithTransforms<T>(target: WritableDef, source: DirectiveDef<any>) {\n  for (const key in source.inputs) {\n    if (!source.inputs.hasOwnProperty(key)) {\n      continue;\n    }\n    if (target.inputs.hasOwnProperty(key)) {\n      continue;\n    }\n\n    const value = source.inputs[key];\n\n    if (value !== undefined) {\n      target.inputs[key] = value;\n      target.declaredInputs[key] = source.declaredInputs[key];\n    }\n  }\n}\n\n/**\n * Merge the `hostAttrs` and `hostVars` from the inherited parent to the base class.\n *\n * @param inheritanceChain A list of `WritableDefs` starting at the top most type and listing\n * sub-types in order. For each type take the `hostAttrs` and `hostVars` and merge it with the child\n * type.\n */\nfunction mergeHostAttrsAcrossInheritance(inheritanceChain: WritableDef[]) {\n  let hostVars: number = 0;\n  let hostAttrs: TAttributes | null = null;\n  // We process the inheritance order from the base to the leaves here.\n  for (let i = inheritanceChain.length - 1; i >= 0; i--) {\n    const def = inheritanceChain[i];\n    // For each `hostVars`, we need to add the superclass amount.\n    def.hostVars = hostVars += def.hostVars;\n    // for each `hostAttrs` we need to merge it with superclass.\n    def.hostAttrs = mergeHostAttrs(\n      def.hostAttrs,\n      (hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs)),\n    );\n  }\n}\n\nfunction maybeUnwrapEmpty<T>(value: T[]): T[];\nfunction maybeUnwrapEmpty<T>(value: T): T;\nfunction maybeUnwrapEmpty(value: any): any {\n  if (value === EMPTY_OBJ) {\n    return {};\n  } else if (value === EMPTY_ARRAY) {\n    return [];\n  } else {\n    return value;\n  }\n}\n\nfunction inheritViewQuery(definition: WritableDef, superViewQuery: ViewQueriesFunction<any>) {\n  const prevViewQuery = definition.viewQuery;\n  if (prevViewQuery) {\n    definition.viewQuery = (rf, ctx) => {\n      superViewQuery(rf, ctx);\n      prevViewQuery(rf, ctx);\n    };\n  } else {\n    definition.viewQuery = superViewQuery;\n  }\n}\n\nfunction inheritContentQueries(\n  definition: WritableDef,\n  superContentQueries: ContentQueriesFunction<any>,\n) {\n  const prevContentQueries = definition.contentQueries;\n  if (prevContentQueries) {\n    definition.contentQueries = (rf, ctx, directiveIndex) => {\n      superContentQueries(rf, ctx, directiveIndex);\n      prevContentQueries(rf, ctx, directiveIndex);\n    };\n  } else {\n    definition.contentQueries = superContentQueries;\n  }\n}\n\nfunction inheritHostBindings(\n  definition: WritableDef,\n  superHostBindings: HostBindingsFunction<any>,\n) {\n  const prevHostBindings = definition.hostBindings;\n  if (prevHostBindings) {\n    definition.hostBindings = (rf: RenderFlags, ctx: any) => {\n      superHostBindings(rf, ctx);\n      prevHostBindings(rf, ctx);\n    };\n  } else {\n    definition.hostBindings = superHostBindings;\n  }\n}\n"]}