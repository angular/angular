{"version":3,"file":"host_directives_feature.js","sourceRoot":"","sources":["host_directives_feature.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {resolveForwardRef} from '../../di';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {assertEqual} from '../../util/assert';\nimport {EMPTY_OBJ} from '../../util/empty';\nimport {getComponentDef, getDirectiveDef} from '../def_getters';\nimport {isComponentDef} from '../interfaces/type_checks';\nimport type {\n  DirectiveDef,\n  DirectiveDefFeature,\n  HostDirectiveBindingMap,\n  HostDirectiveConfig,\n  HostDirectiveDef,\n  HostDirectiveDefs,\n  HostDirectiveRanges,\n  HostDirectiveResolution,\n} from '../interfaces/definition';\n\n/**\n * This feature adds the host directives behavior to a directive definition by patching a\n * function onto it. The expectation is that the runtime will invoke the function during\n * directive matching.\n *\n * For example:\n * ```ts\n * class ComponentWithHostDirective {\n *   static ɵcmp = defineComponent({\n *    type: ComponentWithHostDirective,\n *    features: [ɵɵHostDirectivesFeature([\n *      SimpleHostDirective,\n *      {directive: AdvancedHostDirective, inputs: ['foo: alias'], outputs: ['bar']},\n *    ])]\n *  });\n * }\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵHostDirectivesFeature(\n  rawHostDirectives: HostDirectiveConfig[] | (() => HostDirectiveConfig[]),\n) {\n  const feature: DirectiveDefFeature = (definition: DirectiveDef<unknown>) => {\n    const isEager = Array.isArray(rawHostDirectives);\n\n    if (definition.hostDirectives === null) {\n      definition.resolveHostDirectives = resolveHostDirectives;\n      definition.hostDirectives = isEager\n        ? rawHostDirectives.map(createHostDirectiveDef)\n        : [rawHostDirectives];\n    } else if (isEager) {\n      definition.hostDirectives.unshift(...rawHostDirectives.map(createHostDirectiveDef));\n    } else {\n      definition.hostDirectives.unshift(rawHostDirectives);\n    }\n  };\n  feature.ngInherit = true;\n  return feature;\n}\n\n/**\n * Function that will be patched onto a definition to enable host directives. It is intended to\n * be called once during directive matching and is the same for all definitions.\n * @param matches Directives resolved through selector matching.\n */\nfunction resolveHostDirectives(matches: DirectiveDef<unknown>[]): HostDirectiveResolution {\n  const allDirectiveDefs: DirectiveDef<unknown>[] = [];\n  let hasComponent = false;\n  let hostDirectiveDefs: HostDirectiveDefs | null = null;\n  let hostDirectiveRanges: HostDirectiveRanges | null = null;\n\n  // Components are inserted at the front of the matches array so that their lifecycle\n  // hooks run before any directive lifecycle hooks. This appears to be for ViewEngine\n  // compatibility. This logic doesn't make sense with host directives, because it\n  // would allow the host directives to undo any overrides the host may have made.\n  // To handle this case, the host directives of components are inserted at the beginning\n  // of the array, followed by the component. As such, the insertion order is as follows:\n  // 1. Host directives belonging to the selector-matched component.\n  // 2. Selector-matched component.\n  // 3. Host directives belonging to selector-matched directives.\n  // 4. Selector-matched dir\n  for (let i = 0; i < matches.length; i++) {\n    const def = matches[i];\n\n    if (def.hostDirectives !== null) {\n      const start = allDirectiveDefs.length;\n\n      hostDirectiveDefs ??= new Map();\n      hostDirectiveRanges ??= new Map();\n\n      // TODO(pk): probably could return matches instead of taking in an array to fill in?\n      findHostDirectiveDefs(def, allDirectiveDefs, hostDirectiveDefs);\n\n      // Note that these indexes are within the offset by `directiveStart`. We can't do the\n      // offsetting here, because `directiveStart` hasn't been initialized on the TNode yet.\n      hostDirectiveRanges.set(def, [start, allDirectiveDefs.length - 1]);\n    }\n\n    // Component definition is always first and needs to be\n    // pushed early to maintain the correct ordering.\n    if (i === 0 && isComponentDef(def)) {\n      hasComponent = true;\n      allDirectiveDefs.push(def);\n    }\n  }\n\n  for (let i = hasComponent ? 1 : 0; i < matches.length; i++) {\n    allDirectiveDefs.push(matches[i]);\n  }\n\n  return [allDirectiveDefs, hostDirectiveDefs, hostDirectiveRanges];\n}\n\nfunction findHostDirectiveDefs(\n  currentDef: DirectiveDef<unknown>,\n  matchedDefs: DirectiveDef<unknown>[],\n  hostDirectiveDefs: HostDirectiveDefs,\n): void {\n  if (currentDef.hostDirectives !== null) {\n    for (const configOrFn of currentDef.hostDirectives) {\n      if (typeof configOrFn === 'function') {\n        const resolved = configOrFn();\n        for (const config of resolved) {\n          trackHostDirectiveDef(createHostDirectiveDef(config), matchedDefs, hostDirectiveDefs);\n        }\n      } else {\n        trackHostDirectiveDef(configOrFn, matchedDefs, hostDirectiveDefs);\n      }\n    }\n  }\n}\n\n/** Tracks a single host directive during directive matching. */\nfunction trackHostDirectiveDef(\n  def: HostDirectiveDef,\n  matchedDefs: DirectiveDef<unknown>[],\n  hostDirectiveDefs: HostDirectiveDefs,\n) {\n  const hostDirectiveDef = getDirectiveDef(def.directive)!;\n\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    validateHostDirective(def, hostDirectiveDef);\n  }\n\n  // We need to patch the `declaredInputs` so that\n  // `ngOnChanges` can map the properties correctly.\n  patchDeclaredInputs(hostDirectiveDef.declaredInputs, def.inputs);\n\n  // Host directives execute before the host so that its host bindings can be overwritten.\n  findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);\n  hostDirectiveDefs.set(hostDirectiveDef, def);\n  matchedDefs.push(hostDirectiveDef);\n}\n\n/** Creates a `HostDirectiveDef` from a used-defined host directive configuration. */\nfunction createHostDirectiveDef(config: HostDirectiveConfig): HostDirectiveDef {\n  return typeof config === 'function'\n    ? {directive: resolveForwardRef(config), inputs: EMPTY_OBJ, outputs: EMPTY_OBJ}\n    : {\n        directive: resolveForwardRef(config.directive),\n        inputs: bindingArrayToMap(config.inputs),\n        outputs: bindingArrayToMap(config.outputs),\n      };\n}\n\n/**\n * Converts an array in the form of `['publicName', 'alias', 'otherPublicName', 'otherAlias']` into\n * a map in the form of `{publicName: 'alias', otherPublicName: 'otherAlias'}`.\n */\nfunction bindingArrayToMap(bindings: string[] | undefined): HostDirectiveBindingMap {\n  if (bindings === undefined || bindings.length === 0) {\n    return EMPTY_OBJ;\n  }\n\n  const result: HostDirectiveBindingMap = {};\n\n  for (let i = 0; i < bindings.length; i += 2) {\n    result[bindings[i]] = bindings[i + 1];\n  }\n\n  return result;\n}\n\n/**\n * `ngOnChanges` has some leftover legacy ViewEngine behavior where the keys inside the\n * `SimpleChanges` event refer to the *declared* name of the input, not its public name or its\n * minified name. E.g. in `@Input('alias') foo: string`, the name in the `SimpleChanges` object\n * will always be `foo`, and not `alias` or the minified name of `foo` in apps using property\n * minification.\n *\n * This is achieved through the `DirectiveDef.declaredInputs` map that is constructed when the\n * definition is declared. When a property is written to the directive instance, the\n * `NgOnChangesFeature` will try to remap the property name being written to using the\n * `declaredInputs`.\n *\n * Since the host directive input remapping happens during directive matching, `declaredInputs`\n * won't contain the new alias that the input is available under. This function addresses the\n * issue by patching the host directive aliases to the `declaredInputs`. There is *not* a risk of\n * this patching accidentally introducing new inputs to the host directive, because `declaredInputs`\n * is used *only* by the `NgOnChangesFeature` when determining what name is used in the\n * `SimpleChanges` object which won't be reached if an input doesn't exist.\n */\nfunction patchDeclaredInputs(\n  declaredInputs: Record<string, string>,\n  exposedInputs: HostDirectiveBindingMap,\n): void {\n  for (const publicName in exposedInputs) {\n    if (exposedInputs.hasOwnProperty(publicName)) {\n      const remappedPublicName = exposedInputs[publicName];\n      const privateName = declaredInputs[publicName];\n\n      // We *technically* shouldn't be able to hit this case because we can't have multiple\n      // inputs on the same property and we have validations against conflicting aliases in\n      // `validateMappings`. If we somehow did, it would lead to `ngOnChanges` being invoked\n      // with the wrong name so we have a non-user-friendly assertion here just in case.\n      if (\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        declaredInputs.hasOwnProperty(remappedPublicName)\n      ) {\n        assertEqual(\n          declaredInputs[remappedPublicName],\n          declaredInputs[publicName],\n          `Conflicting host directive input alias ${publicName}.`,\n        );\n      }\n\n      declaredInputs[remappedPublicName] = privateName;\n    }\n  }\n}\n\n/**\n * Verifies that the host directive has been configured correctly.\n * @param hostDirectiveConfig Host directive configuration object.\n * @param directiveDef Directive definition of the host directive.\n */\nfunction validateHostDirective(\n  hostDirectiveConfig: HostDirectiveDef<unknown>,\n  directiveDef: DirectiveDef<any> | null,\n): asserts directiveDef is DirectiveDef<unknown> {\n  const type = hostDirectiveConfig.directive;\n\n  if (directiveDef === null) {\n    if (getComponentDef(type) !== null) {\n      throw new RuntimeError(\n        RuntimeErrorCode.HOST_DIRECTIVE_COMPONENT,\n        `Host directive ${type.name} cannot be a component.`,\n      );\n    }\n\n    throw new RuntimeError(\n      RuntimeErrorCode.HOST_DIRECTIVE_UNRESOLVABLE,\n      `Could not resolve metadata for host directive ${type.name}. ` +\n        `Make sure that the ${type.name} class is annotated with an @Directive decorator.`,\n    );\n  }\n\n  if (!directiveDef.standalone) {\n    throw new RuntimeError(\n      RuntimeErrorCode.HOST_DIRECTIVE_NOT_STANDALONE,\n      `Host directive ${directiveDef.type.name} must be standalone.`,\n    );\n  }\n\n  validateMappings('input', directiveDef, hostDirectiveConfig.inputs);\n  validateMappings('output', directiveDef, hostDirectiveConfig.outputs);\n}\n\n/**\n * Checks that the host directive inputs/outputs configuration is valid.\n * @param bindingType Kind of binding that is being validated. Used in the error message.\n * @param def Definition of the host directive that is being validated against.\n * @param hostDirectiveBindings Host directive mapping object that shold be validated.\n */\nfunction validateMappings<T>(\n  bindingType: 'input' | 'output',\n  def: DirectiveDef<T>,\n  hostDirectiveBindings: HostDirectiveBindingMap,\n) {\n  const className = def.type.name;\n  const bindings = bindingType === 'input' ? def.inputs : def.outputs;\n\n  for (const publicName in hostDirectiveBindings) {\n    if (hostDirectiveBindings.hasOwnProperty(publicName)) {\n      if (!bindings.hasOwnProperty(publicName)) {\n        throw new RuntimeError(\n          RuntimeErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING,\n          `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`,\n        );\n      }\n\n      const remappedPublicName = hostDirectiveBindings[publicName];\n\n      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {\n        throw new RuntimeError(\n          RuntimeErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS,\n          `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`,\n        );\n      }\n    }\n  }\n}\n"]}