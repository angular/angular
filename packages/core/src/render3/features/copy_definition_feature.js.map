{"version":3,"file":"copy_definition_feature.js","sourceRoot":"","sources":["copy_definition_feature.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,cAAc,EAAC,MAAM,2BAA2B,CAAC;AAEzD,OAAO,EAAC,YAAY,EAAC,MAAM,8BAA8B,CAAC;AAE1D;;;GAGG;AACH,MAAM,qBAAqB,GAAoC;IAC7D,0DAA0D;IAC1D,mBAAmB;IAEnB,6FAA6F;IAC7F,kDAAkD;CACnD,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,qBAAqB,GAAwE;IACjG,yFAAyF;IACzF,aAAa;IACb,UAAU;IACV,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,oBAAoB;IAEpB,4FAA4F;IAC5F,QAAQ;IACR,eAAe;IAEf,kFAAkF;IAClF,SAAS;CACV,CAAC;AAEF;;;;;;;;;;;;;;;GAeG;AACH,MAAM,UAAU,uBAAuB,CAAC,UAAiD;IACvF,IAAI,SAAS,GAAG,YAAY,CAAC,UAAU,CAAC,IAAI,CAAE,CAAC;IAE/C,IAAI,QAAQ,GAAsD,SAAS,CAAC;IAC5E,IAAI,cAAc,CAAC,UAAU,CAAC,EAAE,CAAC;QAC/B,+EAA+E;QAC/E,QAAQ,GAAG,SAAS,CAAC,IAAK,CAAC;IAC7B,CAAC;SAAM,CAAC;QACN,+EAA+E;QAC/E,QAAQ,GAAG,SAAS,CAAC,IAAK,CAAC;IAC7B,CAAC;IAED,mDAAmD;IACnD,MAAM,MAAM,GAAG,UAAiB,CAAC;IAEjC,sEAAsE;IACtE,KAAK,MAAM,KAAK,IAAI,qBAAqB,EAAE,CAAC;QAC1C,MAAM,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;IAClC,CAAC;IAED,IAAI,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC7B,2CAA2C;QAC3C,KAAK,MAAM,KAAK,IAAI,qBAAqB,EAAE,CAAC;YAC1C,MAAM,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;QAClC,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentDef, DirectiveDef} from '../interfaces/definition';\nimport {isComponentDef} from '../interfaces/type_checks';\n\nimport {getSuperType} from './inherit_definition_feature';\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `ɵɵCopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS: (keyof DirectiveDef<unknown>)[] = [\n  // The child class should use the providers of its parent.\n  'providersResolver',\n\n  // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such\n  // as inputs, outputs, and host binding functions.\n];\n\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `ɵɵCopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS: Exclude<keyof ComponentDef<unknown>, keyof DirectiveDef<unknown>>[] = [\n  // The child class should use the template function of its parent, including all template\n  // semantics.\n  'template',\n  'decls',\n  'consts',\n  'vars',\n  'onPush',\n  'ngContentSelectors',\n\n  // The child class should use the CSS styles of its parent, including all styling semantics.\n  'styles',\n  'encapsulation',\n\n  // The child class should be checked by the runtime in the same way as its parent.\n  'schemas',\n];\n\n/**\n * Copies the fields not handled by the `ɵɵInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ɵɵCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nexport function ɵɵCopyDefinitionFeature(definition: DirectiveDef<any> | ComponentDef<any>): void {\n  let superType = getSuperType(definition.type)!;\n\n  let superDef: DirectiveDef<any> | ComponentDef<any> | undefined = undefined;\n  if (isComponentDef(definition)) {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵcmp!;\n  } else {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵdir!;\n  }\n\n  // Needed because `definition` fields are readonly.\n  const defAny = definition as any;\n\n  // Copy over any fields that apply to either directives or components.\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n\n  if (isComponentDef(superDef)) {\n    // Copy over any component-specific fields.\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\n"]}