{"version":3,"file":"dynamic_bindings.js","sourceRoot":"","sources":["dynamic_bindings.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {WritableSignal} from '../core_reactivity_export_internal';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type, Writable} from '../interface/type';\nimport {assertNotDefined} from '../util/assert';\nimport {bindingUpdated} from './bindings';\nimport {setDirectiveInput, storePropertyBindingMetadata} from './instructions/shared';\nimport {TVIEW} from './interfaces/view';\nimport {getCurrentTNode, getLView, getSelectedTNode, nextBindingIndex} from './state';\nimport {stringifyForError} from './util/stringify_utils';\nimport {createOutputListener} from './view/directive_outputs';\nimport {markViewDirty} from './instructions/mark_view_dirty';\nimport {getComponentLViewByIndex} from './util/view_utils';\nimport {NotificationSource} from '../change_detection/scheduling/zoneless_scheduling';\n\n/** Symbol used to store and retrieve metadata about a binding. */\nexport const BINDING: unique symbol = /* @__PURE__ */ Symbol('BINDING');\n\n/**\n * A dynamically-defined binding targeting.\n * For example, `inputBinding('value', () => 123)` creates an input binding.\n */\nexport interface Binding {\n  readonly [BINDING]: unknown;\n}\n\nexport interface BindingInternal extends Binding {\n  readonly [BINDING]: {\n    readonly kind: string;\n    readonly requiredVars: number;\n  };\n\n  /** Target index (in a view's registry) to which to apply the binding. */\n  targetIdx?: number;\n\n  /** Callback that will be invoked during creation. */\n  create?(): void;\n\n  /** Callback that will be invoked during updates. */\n  update?(): void;\n}\n\n/**\n * Represents a dynamically-created directive with bindings targeting it specifically.\n */\nexport interface DirectiveWithBindings<T> {\n  /** Directive type that should be created. */\n  type: Type<T>;\n\n  /** Bindings that should be applied to the specific directive. */\n  bindings: Binding[];\n}\n\n// These are constant between all the bindings so we can reuse the objects.\nconst INPUT_BINDING_METADATA: BindingInternal[typeof BINDING] = {kind: 'input', requiredVars: 1};\nconst OUTPUT_BINDING_METADATA: BindingInternal[typeof BINDING] = {kind: 'output', requiredVars: 0};\n\n// TODO(pk): this is a sketch of an input binding instruction that still needs some cleanups\n// - take an index of a directive on TNode (as matched), review all the index mappings that we need to do\n// - move more logic to the first creation pass\n// - move this function to under the instructions folder\nfunction inputBindingUpdate(targetDirectiveIdx: number, publicName: string, value: unknown) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = lView[TVIEW];\n    const tNode = getSelectedTNode();\n\n    const componentLView = getComponentLViewByIndex(tNode.index, lView);\n    markViewDirty(componentLView, NotificationSource.SetInput);\n\n    // TODO(pk): don't check on each and every binding, just assert in dev mode\n    const targetDef = tView.directiveRegistry![targetDirectiveIdx];\n    if (ngDevMode && !targetDef) {\n      throw new RuntimeError(\n        RuntimeErrorCode.NO_BINDING_TARGET,\n        `Input binding to property \"${publicName}\" does not have a target.`,\n      );\n    }\n\n    // TODO(pk): the hasSet check should be replaced by one-off check in the first creation pass\n    const hasSet = setDirectiveInput(tNode, tView, lView, targetDef, publicName, value);\n\n    if (ngDevMode) {\n      if (!hasSet) {\n        throw new RuntimeError(\n          RuntimeErrorCode.NO_BINDING_TARGET,\n          `${stringifyForError(targetDef.type)} does not have an input with a public name of \"${publicName}\".`,\n        );\n      }\n      storePropertyBindingMetadata(tView.data, tNode, publicName, bindingIndex);\n    }\n  }\n}\n\n/**\n * Creates an input binding.\n * @param publicName Public name of the input to bind to.\n * @param value Callback that returns the current value for the binding. Can be either a signal or\n *   a plain getter function.\n *\n * ### Usage Example\n * In this example we create an instance of the `MyButton` component and bind the value of\n * the `isDisabled` signal to its `disabled` input.\n *\n * ```\n * const isDisabled = signal(false);\n *\n * createComponent(MyButton, {\n *   bindings: [inputBinding('disabled', isDisabled)]\n * });\n * ```\n */\nexport function inputBinding(publicName: string, value: () => unknown): Binding {\n  // Note: ideally we would use a class here, but it seems like they\n  // don't get tree shaken when constructed by a function like this.\n  const binding: BindingInternal = {\n    [BINDING]: INPUT_BINDING_METADATA,\n    update: () => inputBindingUpdate((binding as BindingInternal).targetIdx!, publicName, value()),\n  };\n\n  return binding;\n}\n\n/**\n * Creates an output binding.\n * @param eventName Public name of the output to listen to.\n * @param listener Function to be called when the output emits.\n *\n * ### Usage example\n * In this example we create an instance of the `MyCheckbox` component and listen\n * to its `onChange` event.\n *\n * ```\n * interface CheckboxChange {\n *   value: string;\n * }\n *\n * createComponent(MyCheckbox, {\n *   bindings: [\n *    outputBinding<CheckboxChange>('onChange', event => console.log(event.value))\n *   ],\n * });\n * ```\n */\nexport function outputBinding<T>(eventName: string, listener: (event: T) => unknown): Binding {\n  // Note: ideally we would use a class here, but it seems like they\n  // don't get tree shaken when constructed by a function like this.\n  const binding: BindingInternal = {\n    [BINDING]: OUTPUT_BINDING_METADATA,\n    create: () => {\n      const lView = getLView<{} | null>();\n      const tNode = getCurrentTNode()!;\n      const tView = lView[TVIEW];\n      const targetDef = tView.directiveRegistry![binding.targetIdx!];\n      createOutputListener(tNode, lView, listener, targetDef, eventName);\n    },\n  };\n\n  return binding;\n}\n\n/**\n * Creates a two-way binding.\n * @param eventName Public name of the two-way compatible input.\n * @param value Writable signal from which to get the current value and to which to write new\n * values.\n *\n * ### Usage example\n * In this example we create an instance of the `MyCheckbox` component and bind to its `value`\n * input using a two-way binding.\n *\n * ```\n * const checkboxValue = signal('');\n *\n * createComponent(MyCheckbox, {\n *   bindings: [\n *    twoWayBinding('value', checkboxValue),\n *   ],\n * });\n * ```\n */\nexport function twoWayBinding(publicName: string, value: WritableSignal<unknown>): Binding {\n  const input = inputBinding(publicName, value) as BindingInternal;\n  const output = outputBinding(publicName + 'Change', (eventValue) =>\n    value.set(eventValue),\n  ) as BindingInternal;\n\n  // We take advantage of inputs only having a `create` block and outputs only having an `update`\n  // block by passing them through directly instead of creating dedicated functions here. This\n  // assumption can break down if one of them starts targeting both blocks. These assertions\n  // are here to help us catch it if something changes in the future.\n  ngDevMode && assertNotDefined(input.create, 'Unexpected `create` callback in inputBinding');\n  ngDevMode && assertNotDefined(output.update, 'Unexpected `update` callback in outputBinding');\n\n  const binding: BindingInternal = {\n    [BINDING]: {\n      kind: 'twoWay',\n      requiredVars: input[BINDING].requiredVars + output[BINDING].requiredVars,\n    },\n    set targetIdx(idx: number) {\n      (input as Writable<BindingInternal>).targetIdx = idx;\n      (output as Writable<BindingInternal>).targetIdx = idx;\n    },\n    create: output.create,\n    update: input.update,\n  };\n  return binding;\n}\n"]}