{"version":3,"file":"effect.js","sourceRoot":"","sources":["effect.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  SIGNAL,\n  consumerDestroy,\n  isInNotificationPhase,\n  setActiveConsumer,\n  BaseEffectNode,\n  BASE_EFFECT_NODE,\n  runEffect,\n} from '../../../primitives/signals';\nimport {FLAGS, LViewFlags, LView, EFFECTS} from '../interfaces/view';\nimport {markAncestorsForTraversal} from '../util/view_utils';\nimport {inject} from '../../di/injector_compatibility';\nimport {Injector} from '../../di/injector';\nimport {assertNotInReactiveContext} from './asserts';\nimport {assertInInjectionContext} from '../../di/contextual';\nimport {DestroyRef, NodeInjectorDestroyRef} from '../../linker/destroy_ref';\nimport {ViewContext} from '../view_context';\nimport {noop} from '../../util/noop';\nimport {\n  ChangeDetectionScheduler,\n  NotificationSource,\n} from '../../change_detection/scheduling/zoneless_scheduling';\nimport {setIsRefreshingViews} from '../state';\nimport {EffectScheduler, SchedulableEffect} from './root_effect_scheduler';\n\nimport {emitEffectCreatedEvent, setInjectorProfilerContext} from '../debug/injector_profiler';\n\n/**\n * A global reactive effect, which can be manually destroyed.\n *\n * @publicApi 20.0\n */\nexport interface EffectRef {\n  /**\n   * Shut down the effect, removing it from any upcoming scheduled executions.\n   */\n  destroy(): void;\n}\n\nexport class EffectRefImpl implements EffectRef {\n  [SIGNAL]: EffectNode;\n\n  constructor(node: EffectNode) {\n    this[SIGNAL] = node;\n  }\n\n  destroy(): void {\n    this[SIGNAL].destroy();\n  }\n}\n\n/**\n * Options passed to the `effect` function.\n *\n * @publicApi 20.0\n */\nexport interface CreateEffectOptions {\n  /**\n   * The `Injector` in which to create the effect.\n   *\n   * If this is not provided, the current [injection context](guide/di/dependency-injection-context)\n   * will be used instead (via `inject`).\n   */\n  injector?: Injector;\n\n  /**\n   * Whether the `effect` should require manual cleanup.\n   *\n   * If this is `false` (the default) the effect will automatically register itself to be cleaned up\n   * with the current `DestroyRef`.\n   *\n   * If this is `true` and you want to use the effect outside an injection context, you still\n   * need to provide an `Injector` to the effect.\n   */\n  manualCleanup?: boolean;\n\n  /**\n   * @deprecated no longer required, signal writes are allowed by default.\n   */\n  allowSignalWrites?: boolean;\n\n  /**\n   * A debug name for the effect. Used in Angular DevTools to identify the effect.\n   */\n  debugName?: string;\n}\n\n/**\n * An effect can, optionally, register a cleanup function. If registered, the cleanup is executed\n * before the next effect run. The cleanup function makes it possible to \"cancel\" any work that the\n * previous effect run might have started.\n *\n * @publicApi 20.0\n */\nexport type EffectCleanupFn = () => void;\n\n/**\n * A callback passed to the effect function that makes it possible to register cleanup logic.\n *\n * @publicApi 20.0\n */\nexport type EffectCleanupRegisterFn = (cleanupFn: EffectCleanupFn) => void;\n\n/**\n * Registers an \"effect\" that will be scheduled & executed whenever the signals that it reads\n * changes.\n *\n * Angular has two different kinds of effect: component effects and root effects. Component effects\n * are created when `effect()` is called from a component, directive, or within a service of a\n * component/directive. Root effects are created when `effect()` is called from outside the\n * component tree, such as in a root service.\n *\n * The two effect types differ in their timing. Component effects run as a component lifecycle\n * event during Angular's synchronization (change detection) process, and can safely read input\n * signals or create/destroy views that depend on component state. Root effects run as microtasks\n * and have no connection to the component tree or change detection.\n *\n * `effect()` must be run in injection context, unless the `injector` option is manually specified.\n *\n * @publicApi 20.0\n */\nexport function effect(\n  effectFn: (onCleanup: EffectCleanupRegisterFn) => void,\n  options?: CreateEffectOptions,\n): EffectRef {\n  ngDevMode &&\n    assertNotInReactiveContext(\n      effect,\n      'Call `effect` outside of a reactive context. For example, schedule the ' +\n        'effect inside the component constructor.',\n    );\n\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(effect);\n  }\n\n  if (ngDevMode && options?.allowSignalWrites !== undefined) {\n    console.warn(\n      `The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`,\n    );\n  }\n\n  const injector = options?.injector ?? inject(Injector);\n  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n\n  let node: EffectNode;\n\n  const viewContext = injector.get(ViewContext, null, {optional: true});\n  const notifier = injector.get(ChangeDetectionScheduler);\n  if (viewContext !== null) {\n    // This effect was created in the context of a view, and will be associated with the view.\n    node = createViewEffect(viewContext.view, notifier, effectFn);\n    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\n      // The effect is being created in the same view as the `DestroyRef` references, so it will be\n      // automatically destroyed without the need for an explicit `DestroyRef` registration.\n      destroyRef = null;\n    }\n  } else {\n    // This effect was created outside the context of a view, and will be scheduled independently.\n    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\n  }\n  node.injector = injector;\n\n  if (destroyRef !== null) {\n    // If we need to register for cleanup, do that here.\n    node.onDestroyFn = destroyRef.onDestroy(() => node.destroy());\n  }\n\n  const effectRef = new EffectRefImpl(node);\n\n  if (ngDevMode) {\n    node.debugName = options?.debugName ?? '';\n    const prevInjectorProfilerContext = setInjectorProfilerContext({injector, token: null});\n    try {\n      emitEffectCreatedEvent(effectRef);\n    } finally {\n      setInjectorProfilerContext(prevInjectorProfilerContext);\n    }\n  }\n\n  return effectRef;\n}\n\nexport interface EffectNode extends BaseEffectNode, SchedulableEffect {\n  cleanupFns: EffectCleanupFn[] | undefined;\n  injector: Injector;\n  notifier: ChangeDetectionScheduler;\n\n  onDestroyFn: () => void;\n}\n\nexport interface ViewEffectNode extends EffectNode {\n  view: LView;\n}\n\nexport interface RootEffectNode extends EffectNode {\n  scheduler: EffectScheduler;\n}\n\nexport const EFFECT_NODE: Omit<EffectNode, 'fn' | 'destroy' | 'injector' | 'notifier'> =\n  /* @__PURE__ */ (() => ({\n    ...BASE_EFFECT_NODE,\n    cleanupFns: undefined,\n    zone: null,\n    onDestroyFn: noop,\n    run(this: EffectNode): void {\n      if (ngDevMode && isInNotificationPhase()) {\n        throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n      }\n      // We clear `setIsRefreshingViews` so that `markForCheck()` within the body of an effect will\n      // cause CD to reach the component in question.\n      const prevRefreshingViews = setIsRefreshingViews(false);\n      try {\n        runEffect(this);\n      } finally {\n        setIsRefreshingViews(prevRefreshingViews);\n      }\n    },\n\n    cleanup(this: EffectNode): void {\n      if (!this.cleanupFns?.length) {\n        return;\n      }\n      const prevConsumer = setActiveConsumer(null);\n      try {\n        // Attempt to run the cleanup functions. Regardless of failure or success, we consider\n        // cleanup \"completed\" and clear the list for the next run of the effect. Note that an error\n        // from the cleanup function will still crash the current run of the effect.\n        while (this.cleanupFns.length) {\n          this.cleanupFns.pop()!();\n        }\n      } finally {\n        this.cleanupFns = [];\n        setActiveConsumer(prevConsumer);\n      }\n    },\n  }))();\n\nexport const ROOT_EFFECT_NODE: Omit<RootEffectNode, 'fn' | 'scheduler' | 'notifier' | 'injector'> =\n  /* @__PURE__ */ (() => ({\n    ...EFFECT_NODE,\n    consumerMarkedDirty(this: RootEffectNode) {\n      this.scheduler.schedule(this);\n      this.notifier.notify(NotificationSource.RootEffect);\n    },\n    destroy(this: RootEffectNode) {\n      consumerDestroy(this);\n      this.onDestroyFn();\n      this.cleanup();\n      this.scheduler.remove(this);\n    },\n  }))();\n\nexport const VIEW_EFFECT_NODE: Omit<ViewEffectNode, 'fn' | 'view' | 'injector' | 'notifier'> =\n  /* @__PURE__ */ (() => ({\n    ...EFFECT_NODE,\n    consumerMarkedDirty(this: ViewEffectNode): void {\n      this.view[FLAGS] |= LViewFlags.HasChildViewsToRefresh;\n      markAncestorsForTraversal(this.view);\n      this.notifier.notify(NotificationSource.ViewEffect);\n    },\n    destroy(this: ViewEffectNode): void {\n      consumerDestroy(this);\n      this.onDestroyFn();\n      this.cleanup();\n      this.view[EFFECTS]?.delete(this);\n    },\n  }))();\n\nexport function createViewEffect(\n  view: LView,\n  notifier: ChangeDetectionScheduler,\n  fn: (onCleanup: EffectCleanupRegisterFn) => void,\n): ViewEffectNode {\n  const node = Object.create(VIEW_EFFECT_NODE) as ViewEffectNode;\n  node.view = view;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.notifier = notifier;\n  node.fn = createEffectFn(node, fn);\n\n  view[EFFECTS] ??= new Set();\n  view[EFFECTS].add(node);\n\n  node.consumerMarkedDirty(node);\n  return node;\n}\n\nexport function createRootEffect(\n  fn: (onCleanup: EffectCleanupRegisterFn) => void,\n  scheduler: EffectScheduler,\n  notifier: ChangeDetectionScheduler,\n): RootEffectNode {\n  const node = Object.create(ROOT_EFFECT_NODE) as RootEffectNode;\n  node.fn = createEffectFn(node, fn);\n  node.scheduler = scheduler;\n  node.notifier = notifier;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.scheduler.add(node);\n  node.notifier.notify(NotificationSource.RootEffect);\n  return node;\n}\n\nfunction createEffectFn(node: EffectNode, fn: (onCleanup: EffectCleanupRegisterFn) => void) {\n  return () => {\n    fn((cleanupFn) => (node.cleanupFns ??= []).push(cleanupFn));\n  };\n}\n"]}