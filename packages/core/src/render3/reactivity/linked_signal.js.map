{"version":3,"file":"linked_signal.js","sourceRoot":"","sources":["linked_signal.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAEL,kBAAkB,EAGlB,iBAAiB,EACjB,oBAAoB,EACpB,MAAM,GACP,MAAM,6BAA6B,CAAC;AAErC,OAAO,EAAC,kBAAkB,EAAiB,MAAM,UAAU,CAAC;AAE5D,MAAM,UAAU,GAAG,CAAI,CAAI,EAAE,EAAE,CAAC,CAAC,CAAC;AA2BlC,MAAM,UAAU,YAAY,CAC1B,oBAOa,EACb,OAA0D;IAE1D,IAAI,OAAO,oBAAoB,KAAK,UAAU,EAAE,CAAC;QAC/C,MAAM,MAAM,GAAG,kBAAkB,CAC/B,oBAAoB,EACpB,CAAA,UAAa,CAAA,EACb,OAAO,EAAE,KAAK,CACiC,CAAC;QAClD,OAAO,yBAAyB,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;IAC/D,CAAC;SAAM,CAAC;QACN,MAAM,MAAM,GAAG,kBAAkB,CAC/B,oBAAoB,CAAC,MAAM,EAC3B,oBAAoB,CAAC,WAAW,EAChC,oBAAoB,CAAC,KAAK,CAC3B,CAAC;QACF,OAAO,yBAAyB,CAAC,MAAM,EAAE,oBAAoB,CAAC,SAAS,CAAC,CAAC;IAC3E,CAAC;AACH,CAAC;AAED,SAAS,yBAAyB,CAChC,MAAgC,EAChC,SAAkB;IAElB,IAAI,SAAS,EAAE,CAAC;QACd,MAAM,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,kBAAkB,MAAM,EAAE,GAAG,CAAC;QACtD,MAAM,CAAC,MAAM,CAAC,CAAC,SAAS,GAAG,SAAS,CAAC;IACvC,CAAC;IAED,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAA2B,CAAC;IACtD,MAAM,cAAc,GAAG,MAAsD,CAAC;IAE9E,cAAc,CAAC,GAAG,GAAG,CAAC,QAAW,EAAE,EAAE,CAAC,iBAAiB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IACxE,cAAc,CAAC,MAAM,GAAG,CAAC,QAAyB,EAAE,EAAE,CAAC,oBAAoB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC5F,cAAc,CAAC,UAAU,GAAG,kBAAkB,CAAC,IAAI,CAAC,MAAa,CAAoB,CAAC;IAEtF,OAAO,cAAc,CAAC;AACxB,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComputationFn,\n  createLinkedSignal,\n  LinkedSignalGetter,\n  LinkedSignalNode,\n  linkedSignalSetFn,\n  linkedSignalUpdateFn,\n  SIGNAL,\n} from '../../../primitives/signals';\nimport {Signal, ValueEqualityFn} from './api';\nimport {signalAsReadonlyFn, WritableSignal} from './signal';\n\nconst identityFn = <T>(v: T) => v;\n\n/**\n * Creates a writable signal whose value is initialized and reset by the linked, reactive computation.\n *\n * @publicApi 20.0\n */\nexport function linkedSignal<D>(\n  computation: () => D,\n  options?: {equal?: ValueEqualityFn<NoInfer<D>>},\n): WritableSignal<D>;\n\n/**\n * Creates a writable signal whose value is initialized and reset by the linked, reactive computation.\n * This is an advanced API form where the computation has access to the previous value of the signal and the computation result.\n *\n * Note: The computation is reactive, meaning the linked signal will automatically update whenever any of the signals used within the computation change.\n *\n * @publicApi 20.0\n */\nexport function linkedSignal<S, D>(options: {\n  source: () => S;\n  computation: (source: NoInfer<S>, previous?: {source: NoInfer<S>; value: NoInfer<D>}) => D;\n  equal?: ValueEqualityFn<NoInfer<D>>;\n  debugName?: string;\n}): WritableSignal<D>;\n\nexport function linkedSignal<S, D>(\n  optionsOrComputation:\n    | {\n        source: () => S;\n        computation: ComputationFn<S, D>;\n        equal?: ValueEqualityFn<D>;\n        debugName?: string;\n      }\n    | (() => D),\n  options?: {equal?: ValueEqualityFn<D>; debugName?: string},\n): WritableSignal<D> {\n  if (typeof optionsOrComputation === 'function') {\n    const getter = createLinkedSignal<D, D>(\n      optionsOrComputation,\n      identityFn<D>,\n      options?.equal,\n    ) as LinkedSignalGetter<D, D> & WritableSignal<D>;\n    return upgradeLinkedSignalGetter(getter, options?.debugName);\n  } else {\n    const getter = createLinkedSignal<S, D>(\n      optionsOrComputation.source,\n      optionsOrComputation.computation,\n      optionsOrComputation.equal,\n    );\n    return upgradeLinkedSignalGetter(getter, optionsOrComputation.debugName);\n  }\n}\n\nfunction upgradeLinkedSignalGetter<S, D>(\n  getter: LinkedSignalGetter<S, D>,\n  debugName?: string,\n): WritableSignal<D> {\n  if (ngDevMode) {\n    getter.toString = () => `[LinkedSignal: ${getter()}]`;\n    getter[SIGNAL].debugName = debugName;\n  }\n\n  const node = getter[SIGNAL] as LinkedSignalNode<S, D>;\n  const upgradedGetter = getter as LinkedSignalGetter<S, D> & WritableSignal<D>;\n\n  upgradedGetter.set = (newValue: D) => linkedSignalSetFn(node, newValue);\n  upgradedGetter.update = (updateFn: (value: D) => D) => linkedSignalUpdateFn(node, updateFn);\n  upgradedGetter.asReadonly = signalAsReadonlyFn.bind(getter as any) as () => Signal<D>;\n\n  return upgradedGetter;\n}\n"]}