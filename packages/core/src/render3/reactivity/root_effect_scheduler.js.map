{"version":3,"file":"root_effect_scheduler.js","sourceRoot":"","sources":["root_effect_scheduler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵɵdefineInjectable} from '../../di/interface/defs';\n\n/**\n * Abstraction that encompasses any kind of effect that can be scheduled.\n */\nexport interface SchedulableEffect {\n  run(): void;\n  zone: {\n    run<T>(fn: () => T): T;\n  } | null;\n  dirty: boolean;\n}\n\n/**\n * A scheduler which manages the execution of effects.\n */\nexport abstract class EffectScheduler {\n  abstract add(e: SchedulableEffect): void;\n\n  /**\n   * Schedule the given effect to be executed at a later time.\n   *\n   * It is an error to attempt to execute any effects synchronously during a scheduling operation.\n   */\n  abstract schedule(e: SchedulableEffect): void;\n\n  /**\n   * Run any scheduled effects.\n   */\n  abstract flush(): void;\n\n  /** Remove a scheduled effect */\n  abstract remove(e: SchedulableEffect): void;\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: EffectScheduler,\n    providedIn: 'root',\n    factory: () => new ZoneAwareEffectScheduler(),\n  });\n}\n\n/**\n * A wrapper around `ZoneAwareQueueingScheduler` that schedules flushing via the microtask queue\n * when.\n */\nexport class ZoneAwareEffectScheduler implements EffectScheduler {\n  private dirtyEffectCount = 0;\n  private queues = new Map<Zone | null, Set<SchedulableEffect>>();\n\n  add(handle: SchedulableEffect): void {\n    this.enqueue(handle);\n    this.schedule(handle);\n  }\n\n  schedule(handle: SchedulableEffect): void {\n    if (!handle.dirty) {\n      return;\n    }\n    this.dirtyEffectCount++;\n  }\n\n  remove(handle: SchedulableEffect): void {\n    const zone = handle.zone as Zone | null;\n    const queue = this.queues.get(zone)!;\n    if (!queue.has(handle)) {\n      return;\n    }\n\n    queue.delete(handle);\n    if (handle.dirty) {\n      this.dirtyEffectCount--;\n    }\n  }\n\n  private enqueue(handle: SchedulableEffect): void {\n    const zone = handle.zone as Zone | null;\n    if (!this.queues.has(zone)) {\n      this.queues.set(zone, new Set());\n    }\n\n    const queue = this.queues.get(zone)!;\n    if (queue.has(handle)) {\n      return;\n    }\n    queue.add(handle);\n  }\n\n  /**\n   * Run all scheduled effects.\n   *\n   * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no\n   * ordering guarantee between effects scheduled in different zones.\n   */\n  flush(): void {\n    while (this.dirtyEffectCount > 0) {\n      let ranOneEffect = false;\n      for (const [zone, queue] of this.queues) {\n        // `zone` here must be defined.\n        if (zone === null) {\n          ranOneEffect ||= this.flushQueue(queue);\n        } else {\n          ranOneEffect ||= zone.run(() => this.flushQueue(queue));\n        }\n      }\n\n      // Safeguard against infinite looping if somehow our dirty effect count gets out of sync with\n      // the dirty flag across all the effects.\n      if (!ranOneEffect) {\n        this.dirtyEffectCount = 0;\n      }\n    }\n  }\n\n  private flushQueue(queue: Set<SchedulableEffect>): boolean {\n    let ranOneEffect = false;\n    for (const handle of queue) {\n      if (!handle.dirty) {\n        continue;\n      }\n      this.dirtyEffectCount--;\n      ranOneEffect = true;\n\n      // TODO: what happens if this throws an error?\n      handle.run();\n    }\n    return ranOneEffect;\n  }\n}\n"]}