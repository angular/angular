{"version":3,"file":"signal.js","sourceRoot":"","sources":["signal.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EACL,YAAY,EACZ,MAAM,GAKP,MAAM,6BAA6B,CAAC;AAErC,OAAO,EAAC,QAAQ,EAA0B,MAAM,OAAO,CAAC;AAExD,8FAA8F;AAC9F,MAAM,CAAC,MAAM,gBAAgB,GAAkB,eAAe,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;AA6BzF;;;GAGG;AACH,MAAM,UAAU,qBAAqB,CAAI,KAAkC;IACzE,uFAAuF;IACvF,sEAAsE;IACtE,OAAO,IAAK,CAAC;AACf,CAAC;AAiBD;;GAEG;AACH,MAAM,UAAU,MAAM,CAAI,YAAe,EAAE,OAAgC;IACzE,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,MAAM,CAAC,GAAG,YAAY,CAAC,YAAY,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IAEtE,MAAM,QAAQ,GAAG,GAA0C,CAAC;IAC5D,MAAM,IAAI,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;IAE9B,QAAQ,CAAC,GAAG,GAAG,GAAG,CAAC;IACnB,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAC;IACzB,QAAQ,CAAC,UAAU,GAAG,kBAAkB,CAAC,IAAI,CAAC,QAAe,CAAoB,CAAC;IAElF,IAAI,SAAS,EAAE,CAAC;QACd,QAAQ,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,YAAY,QAAQ,EAAE,GAAG,CAAC;QACpD,IAAI,CAAC,SAAS,GAAG,OAAO,EAAE,SAAS,CAAC;IACtC,CAAC;IAED,OAAO,QAA6B,CAAC;AACvC,CAAC;AAED,MAAM,UAAU,kBAAkB;IAChC,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAA6C,CAAC;IACtE,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;QAClC,MAAM,UAAU,GAAG,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC;QAC/B,UAAkB,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;QACnC,IAAI,CAAC,UAAU,GAAG,UAAuB,CAAC;IAC5C,CAAC;IACD,OAAO,IAAI,CAAC,UAAU,CAAC;AACzB,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,gBAAgB,CAAC,KAAc;IAC7C,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,OAAQ,KAAa,CAAC,GAAG,KAAK,UAAU,CAAC;AACrE,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  createSignal,\n  SIGNAL,\n  SignalGetter,\n  SignalNode,\n  signalSetFn,\n  signalUpdateFn,\n} from '../../../primitives/signals';\n\nimport {isSignal, Signal, ValueEqualityFn} from './api';\n\n/** Symbol used distinguish `WritableSignal` from other non-writable signals and functions. */\nexport const ɵWRITABLE_SIGNAL: unique symbol = /* @__PURE__ */ Symbol('WRITABLE_SIGNAL');\n\n/**\n * A `Signal` with a value that can be mutated via a setter interface.\n *\n * @publicApi 17.0\n */\nexport interface WritableSignal<T> extends Signal<T> {\n  [ɵWRITABLE_SIGNAL]: T;\n\n  /**\n   * Directly set the signal to a new value, and notify any dependents.\n   */\n  set(value: T): void;\n\n  /**\n   * Update the value of the signal based on its current value, and\n   * notify any dependents.\n   */\n  update(updateFn: (value: T) => T): void;\n\n  /**\n   * Returns a readonly version of this signal. Readonly signals can be accessed to read their value\n   * but can't be changed using set or update methods. The readonly signals do _not_ have\n   * any built-in mechanism that would prevent deep-mutation of their value.\n   */\n  asReadonly(): Signal<T>;\n}\n\n/**\n * Utility function used during template type checking to extract the value from a `WritableSignal`.\n * @codeGenApi\n */\nexport function ɵunwrapWritableSignal<T>(value: T | {[ɵWRITABLE_SIGNAL]: T}): T {\n  // Note: the function uses `WRITABLE_SIGNAL` as a brand instead of `WritableSignal<T>`,\n  // because the latter incorrectly unwraps non-signal getter functions.\n  return null!;\n}\n\n/**\n * Options passed to the `signal` creation function.\n */\nexport interface CreateSignalOptions<T> {\n  /**\n   * A comparison function which defines equality for signal values.\n   */\n  equal?: ValueEqualityFn<T>;\n\n  /**\n   * A debug name for the signal. Used in Angular DevTools to identify the signal.\n   */\n  debugName?: string;\n}\n\n/**\n * Create a `Signal` that can be set or updated directly.\n */\nexport function signal<T>(initialValue: T, options?: CreateSignalOptions<T>): WritableSignal<T> {\n  const [get, set, update] = createSignal(initialValue, options?.equal);\n\n  const signalFn = get as SignalGetter<T> & WritableSignal<T>;\n  const node = signalFn[SIGNAL];\n\n  signalFn.set = set;\n  signalFn.update = update;\n  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn as any) as () => Signal<T>;\n\n  if (ngDevMode) {\n    signalFn.toString = () => `[Signal: ${signalFn()}]`;\n    node.debugName = options?.debugName;\n  }\n\n  return signalFn as WritableSignal<T>;\n}\n\nexport function signalAsReadonlyFn<T>(this: SignalGetter<T>): Signal<T> {\n  const node = this[SIGNAL] as SignalNode<T> & {readonlyFn?: Signal<T>};\n  if (node.readonlyFn === undefined) {\n    const readonlyFn = () => this();\n    (readonlyFn as any)[SIGNAL] = node;\n    node.readonlyFn = readonlyFn as Signal<T>;\n  }\n  return node.readonlyFn;\n}\n\n/**\n * Checks if the given `value` is a writeable signal.\n */\nexport function isWritableSignal(value: unknown): value is WritableSignal<unknown> {\n  return isSignal(value) && typeof (value as any).set === 'function';\n}\n"]}