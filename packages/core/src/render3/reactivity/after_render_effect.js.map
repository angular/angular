{"version":3,"file":"after_render_effect.js","sourceRoot":"","sources":["after_render_effect.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  consumerDestroy,\n  consumerPollProducersForChange,\n  producerAccessed,\n  SIGNAL,\n  SIGNAL_NODE,\n  type SignalNode,\n} from '../../../primitives/signals';\nimport {type EffectCleanupFn, type EffectCleanupRegisterFn} from './effect';\nimport {type Signal} from '../reactivity/api';\nimport {TracingService, TracingSnapshot} from '../../application/tracing';\nimport {\n  ChangeDetectionScheduler,\n  NotificationSource,\n} from '../../change_detection/scheduling/zoneless_scheduling';\nimport {assertInInjectionContext} from '../../di/contextual';\nimport {Injector} from '../../di/injector';\nimport {inject} from '../../di/injector_compatibility';\nimport {DestroyRef} from '../../linker/destroy_ref';\nimport {AfterRenderPhase, type AfterRenderRef} from '../after_render/api';\nimport {NOOP_AFTER_RENDER_REF, type AfterRenderOptions} from '../after_render/hooks';\nimport {\n  AFTER_RENDER_PHASES,\n  AfterRenderImpl,\n  AfterRenderManager,\n  AfterRenderSequence,\n} from '../after_render/manager';\nimport {LView} from '../interfaces/view';\nimport {ViewContext} from '../view_context';\nimport {assertNotInReactiveContext} from './asserts';\nimport {emitEffectCreatedEvent, setInjectorProfilerContext} from '../debug/injector_profiler';\n\nconst NOT_SET = /* @__PURE__ */ Symbol('NOT_SET');\nconst EMPTY_CLEANUP_SET = /* @__PURE__ */ new Set<() => void>();\n\n/** Callback type for an `afterRenderEffect` phase effect */\ntype AfterRenderPhaseEffectHook = (\n  // Either a cleanup function or a pipelined value and a cleanup function\n  ...args:\n    | [onCleanup: EffectCleanupRegisterFn]\n    | [previousPhaseValue: unknown, onCleanup: EffectCleanupRegisterFn]\n) => unknown;\n\n/**\n * Reactive node in the graph for this `afterRenderEffect` phase effect.\n *\n * This node type extends `SignalNode` because `afterRenderEffect` phases effects produce a value\n * which is consumed as a `Signal` by subsequent phases.\n */\ninterface AfterRenderPhaseEffectNode extends SignalNode<unknown> {\n  /** The phase of the effect implemented by this node */\n  phase: AfterRenderPhase;\n  /** The sequence of phases to which this node belongs, used for state of the whole sequence */\n  sequence: AfterRenderEffectSequence;\n  /** The user's callback function */\n  userFn: AfterRenderPhaseEffectHook;\n  /** Signal function that retrieves the value of this node, used as the value for the next phase */\n  signal: Signal<unknown>;\n  /** Registered cleanup functions, or `null` if none have ever been registered */\n  cleanup: Set<() => void> | null;\n  /** Pre-bound helper function passed to the user's callback which writes to `this.cleanup` */\n  registerCleanupFn: EffectCleanupRegisterFn;\n  /** Entrypoint to running this effect that's given to the `afterRender` machinery */\n  phaseFn(previousValue?: unknown): unknown;\n}\n\nconst AFTER_RENDER_PHASE_EFFECT_NODE = /* @__PURE__ */ (() => ({\n  ...SIGNAL_NODE,\n  consumerIsAlwaysLive: true,\n  consumerAllowSignalWrites: true,\n  value: NOT_SET,\n  cleanup: null,\n  /** Called when the effect becomes dirty */\n  consumerMarkedDirty(this: AfterRenderPhaseEffectNode): void {\n    if (this.sequence.impl.executing) {\n      // If hooks are in the middle of executing, then it matters whether this node has yet been\n      // executed within its sequence. If not, then we don't want to notify the scheduler since\n      // this node will be reached naturally.\n      if (this.sequence.lastPhase === null || this.sequence.lastPhase < this.phase) {\n        return;\n      }\n\n      // If during the execution of a later phase an earlier phase became dirty, then we should not\n      // run any further phases until the earlier one reruns.\n      this.sequence.erroredOrDestroyed = true;\n    }\n\n    // Either hooks are not running, or we're marking a node dirty that has already run within its\n    // sequence.\n    this.sequence.scheduler.notify(NotificationSource.RenderHook);\n  },\n  phaseFn(this: AfterRenderPhaseEffectNode, previousValue?: unknown): unknown {\n    this.sequence.lastPhase = this.phase;\n\n    if (!this.dirty) {\n      return this.signal;\n    }\n\n    this.dirty = false;\n    if (this.value !== NOT_SET && !consumerPollProducersForChange(this)) {\n      // None of our producers report a change since the last time they were read, so no\n      // recomputation of our value is necessary.\n      return this.signal;\n    }\n\n    // Run any needed cleanup functions.\n    try {\n      for (const cleanupFn of this.cleanup ?? EMPTY_CLEANUP_SET) {\n        cleanupFn();\n      }\n    } finally {\n      // Even if a cleanup function errors, ensure it's cleared.\n      this.cleanup?.clear();\n    }\n\n    // Prepare to call the user's effect callback. If there was a previous phase, then it gave us\n    // its value as a `Signal`, otherwise `previousValue` will be `undefined`.\n    const args: unknown[] = [];\n    if (previousValue !== undefined) {\n      args.push(previousValue);\n    }\n    args.push(this.registerCleanupFn);\n\n    // Call the user's callback in our reactive context.\n    const prevConsumer = consumerBeforeComputation(this);\n    let newValue;\n    try {\n      newValue = this.userFn.apply(null, args as any);\n    } finally {\n      consumerAfterComputation(this, prevConsumer);\n    }\n\n    if (this.value === NOT_SET || !this.equal(this.value, newValue)) {\n      this.value = newValue;\n      this.version++;\n    }\n\n    return this.signal;\n  },\n}))();\n\n/**\n * An `AfterRenderSequence` that manages an `afterRenderEffect`'s phase effects.\n */\nexport class AfterRenderEffectSequence extends AfterRenderSequence {\n  /**\n   * While this sequence is executing, this tracks the last phase which was called by the\n   * `afterRender` machinery.\n   *\n   * When a phase effect is marked dirty, this is used to determine whether it's already run or not.\n   */\n  lastPhase: AfterRenderPhase | null = null;\n\n  /**\n   * The reactive nodes for each phase, if a phase effect is defined for that phase.\n   *\n   * These are initialized to `undefined` but set in the constructor.\n   */\n  private readonly nodes: [\n    AfterRenderPhaseEffectNode | undefined,\n    AfterRenderPhaseEffectNode | undefined,\n    AfterRenderPhaseEffectNode | undefined,\n    AfterRenderPhaseEffectNode | undefined,\n  ] = [undefined, undefined, undefined, undefined];\n\n  constructor(\n    impl: AfterRenderImpl,\n    effectHooks: Array<AfterRenderPhaseEffectHook | undefined>,\n    view: LView | undefined,\n    readonly scheduler: ChangeDetectionScheduler,\n    injector: Injector,\n    snapshot: TracingSnapshot | null = null,\n  ) {\n    // Note that we also initialize the underlying `AfterRenderSequence` hooks to `undefined` and\n    // populate them as we create reactive nodes below.\n    super(\n      impl,\n      [undefined, undefined, undefined, undefined],\n      view,\n      false,\n      injector.get(DestroyRef),\n      snapshot,\n    );\n\n    // Setup a reactive node for each phase.\n    for (const phase of AFTER_RENDER_PHASES) {\n      const effectHook = effectHooks[phase];\n      if (effectHook === undefined) {\n        continue;\n      }\n\n      const node = Object.create(AFTER_RENDER_PHASE_EFFECT_NODE) as AfterRenderPhaseEffectNode;\n      node.sequence = this;\n      node.phase = phase;\n      node.userFn = effectHook;\n      node.dirty = true;\n      node.signal = (() => {\n        producerAccessed(node);\n        return node.value;\n      }) as Signal<unknown>;\n      node.signal[SIGNAL] = node;\n      node.registerCleanupFn = (fn: EffectCleanupFn) =>\n        (node.cleanup ??= new Set<() => void>()).add(fn);\n\n      this.nodes[phase] = node;\n\n      // Install the upstream hook which runs the `phaseFn` for this phase.\n      this.hooks[phase] = (value) => node.phaseFn(value);\n\n      if (ngDevMode) {\n        setupDebugInfo(node, injector);\n      }\n    }\n  }\n\n  override afterRun(): void {\n    super.afterRun();\n    // We're done running this sequence, so reset `lastPhase`.\n    this.lastPhase = null;\n  }\n\n  override destroy(): void {\n    super.destroy();\n\n    // Run the cleanup functions for each node.\n    for (const node of this.nodes) {\n      if (node) {\n        try {\n          for (const fn of node.cleanup ?? EMPTY_CLEANUP_SET) {\n            fn();\n          }\n        } finally {\n          consumerDestroy(node);\n        }\n      }\n    }\n  }\n}\n\n/**\n * An argument list containing the first non-never type in the given type array, or an empty\n * argument list if there are no non-never types in the type array.\n */\nexport type ɵFirstAvailableSignal<T extends unknown[]> = T extends [infer H, ...infer R]\n  ? [H] extends [never]\n    ? ɵFirstAvailableSignal<R>\n    : [Signal<H>]\n  : [];\n\n/**\n * Register an effect that, when triggered, is invoked when the application finishes rendering, during the\n * `mixedReadWrite` phase.\n *\n * <div class=\"docs-alert docs-alert-critical\">\n *\n * You should prefer specifying an explicit phase for the effect instead, or you risk significant\n * performance degradation.\n *\n * </div>\n *\n * Note that callback-based `afterRenderEffect`s will run\n * - in the order it they are registered\n * - only when dirty\n * - on browser platforms only\n * - during the `mixedReadWrite` phase\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param callback An effect callback function to register\n * @param options Options to control the behavior of the callback\n *\n * @publicApi\n */\nexport function afterRenderEffect(\n  callback: (onCleanup: EffectCleanupRegisterFn) => void,\n  options?: AfterRenderOptions,\n): AfterRenderRef;\n/**\n * Register effects that, when triggered, are invoked when the application finishes rendering,\n * during the specified phases. The available phases are:\n * - `earlyRead`\n *   Use this phase to **read** from the DOM before a subsequent `write` callback, for example to\n *   perform custom layout that the browser doesn't natively support. Prefer the `read` phase if\n *   reading can wait until after the write phase. **Never** write to the DOM in this phase.\n * - `write`\n *    Use this phase to **write** to the DOM. **Never** read from the DOM in this phase.\n * - `mixedReadWrite`\n *    Use this phase to read from and write to the DOM simultaneously. **Never** use this phase if\n *    it is possible to divide the work among the other phases instead.\n * - `read`\n *    Use this phase to **read** from the DOM. **Never** write to the DOM in this phase.\n *\n * <div class=\"docs-alert docs-alert-critical\">\n *\n * You should prefer using the `read` and `write` phases over the `earlyRead` and `mixedReadWrite`\n * phases when possible, to avoid performance degradation.\n *\n * </div>\n *\n * Note that:\n * - Effects run in the following phase order, only when dirty through signal dependencies:\n *   1. `earlyRead`\n *   2. `write`\n *   3. `mixedReadWrite`\n *   4. `read`\n * - `afterRenderEffect`s in the same phase run in the order they are registered.\n * - `afterRenderEffect`s run on browser platforms only, they will not run on the server.\n * - `afterRenderEffect`s will run at least once.\n *\n * The first phase callback to run as part of this spec will receive no parameters. Each\n * subsequent phase callback in this spec will receive the return value of the previously run\n * phase callback as a `Signal`. This can be used to coordinate work across multiple phases.\n *\n * Angular is unable to verify or enforce that phases are used correctly, and instead\n * relies on each developer to follow the guidelines documented for each value and\n * carefully choose the appropriate one, refactoring their code if necessary. By doing\n * so, Angular is better able to minimize the performance degradation associated with\n * manual DOM access, ensuring the best experience for the end users of your application\n * or library.\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param spec The effect functions to register\n * @param options Options to control the behavior of the effects\n *\n * @usageNotes\n *\n * Use `afterRenderEffect` to create effects that will read or write from the DOM and thus should\n * run after rendering.\n *\n * @publicApi\n */\nexport function afterRenderEffect<E = never, W = never, M = never>(\n  spec: {\n    earlyRead?: (onCleanup: EffectCleanupRegisterFn) => E;\n    write?: (...args: [...ɵFirstAvailableSignal<[E]>, EffectCleanupRegisterFn]) => W;\n    mixedReadWrite?: (...args: [...ɵFirstAvailableSignal<[W, E]>, EffectCleanupRegisterFn]) => M;\n    read?: (...args: [...ɵFirstAvailableSignal<[M, W, E]>, EffectCleanupRegisterFn]) => void;\n  },\n  options?: AfterRenderOptions,\n): AfterRenderRef;\n\n/**\n * @publicApi\n */\nexport function afterRenderEffect<E = never, W = never, M = never>(\n  callbackOrSpec:\n    | ((onCleanup: EffectCleanupRegisterFn) => void)\n    | {\n        earlyRead?: (onCleanup: EffectCleanupRegisterFn) => E;\n        write?: (...args: [...ɵFirstAvailableSignal<[E]>, EffectCleanupRegisterFn]) => W;\n        mixedReadWrite?: (\n          ...args: [...ɵFirstAvailableSignal<[W, E]>, EffectCleanupRegisterFn]\n        ) => M;\n        read?: (...args: [...ɵFirstAvailableSignal<[M, W, E]>, EffectCleanupRegisterFn]) => void;\n      },\n  options?: AfterRenderOptions,\n): AfterRenderRef {\n  ngDevMode &&\n    assertNotInReactiveContext(\n      afterRenderEffect,\n      'Call `afterRenderEffect` outside of a reactive context. For example, create the render ' +\n        'effect inside the component constructor`.',\n    );\n\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(afterRenderEffect);\n  }\n\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return NOOP_AFTER_RENDER_REF;\n  }\n\n  const injector = options?.injector ?? inject(Injector);\n  const scheduler = injector.get(ChangeDetectionScheduler);\n  const manager = injector.get(AfterRenderManager);\n  const tracing = injector.get(TracingService, null, {optional: true});\n  manager.impl ??= injector.get(AfterRenderImpl);\n\n  let spec = callbackOrSpec;\n  if (typeof spec === 'function') {\n    spec = {mixedReadWrite: callbackOrSpec as any};\n  }\n\n  const viewContext = injector.get(ViewContext, null, {optional: true});\n\n  const sequence = new AfterRenderEffectSequence(\n    manager.impl,\n    [spec.earlyRead, spec.write, spec.mixedReadWrite, spec.read] as AfterRenderPhaseEffectHook[],\n    viewContext?.view,\n    scheduler,\n    injector,\n    tracing?.snapshot(null),\n  );\n  manager.impl.register(sequence);\n  return sequence;\n}\n\nfunction setupDebugInfo(node: AfterRenderPhaseEffectNode, injector: Injector): void {\n  node.debugName = `afterRenderEffect - ${phaseDebugName(node.phase)} phase`;\n  const prevInjectorProfilerContext = setInjectorProfilerContext({injector, token: null});\n  try {\n    emitEffectCreatedEvent({[SIGNAL]: node, destroy() {}} as any);\n  } finally {\n    setInjectorProfilerContext(prevInjectorProfilerContext);\n  }\n}\n\nfunction phaseDebugName(phase: AfterRenderPhase): string {\n  switch (phase) {\n    case AfterRenderPhase.EarlyRead:\n      return 'EarlyRead';\n    case AfterRenderPhase.Write:\n      return 'Write';\n    case AfterRenderPhase.MixedReadWrite:\n      return 'MixedReadWrite';\n    case AfterRenderPhase.Read:\n      return 'Read';\n  }\n}\n"]}