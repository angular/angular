{"version":3,"file":"di.js","sourceRoot":"","sources":["di.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {isForwardRef, resolveForwardRef} from '../di/forward_ref';\nimport {injectRootLimpMode, setInjectImplementation} from '../di/inject_switch';\nimport {Injector} from '../di/injector';\nimport {BackwardsCompatibleInjector, convertToBitFlags} from '../di/injector_compatibility';\nimport {InjectorMarkers} from '../di/injector_marker';\nimport {InternalInjectFlags, InjectOptions} from '../di/interface/injector';\nimport {ProviderToken} from '../di/provider_token';\nimport {Type} from '../interface/type';\nimport {assertDefined, assertEqual, assertIndexInRange} from '../util/assert';\nimport {noSideEffects} from '../util/closure';\n\nimport {assertDirectiveDef, assertNodeInjector, assertTNodeForLView} from './assert';\nimport {\n  emitInjectorToCreateInstanceEvent,\n  emitInstanceCreatedByInjectorEvent,\n  InjectorProfilerContext,\n  runInInjectorProfilerContext,\n  setInjectorProfilerContext,\n} from './debug/injector_profiler';\nimport {getFactoryDef} from './definition_factory';\nimport {\n  cyclicDependencyError,\n  cyclicDependencyErrorWithDetails,\n  throwProviderNotFoundError,\n} from './errors_di';\nimport {NG_ELEMENT_ID, NG_FACTORY_DEF} from './fields';\nimport {registerPreOrderHooks} from './hooks';\nimport {AttributeMarker} from './interfaces/attribute_marker';\nimport {ComponentDef, DirectiveDef} from './interfaces/definition';\nimport {\n  NO_PARENT_INJECTOR,\n  NodeInjectorFactory,\n  NodeInjectorOffset,\n  RelativeInjectorLocation,\n  RelativeInjectorLocationFlags,\n} from './interfaces/injector';\nimport {\n  TContainerNode,\n  TDirectiveHostNode,\n  TElementContainerNode,\n  TElementNode,\n  TNode,\n  TNodeProviderIndexes,\n  TNodeType,\n} from './interfaces/node';\nimport {isComponentDef, isComponentHost, isRootView} from './interfaces/type_checks';\nimport {\n  DECLARATION_COMPONENT_VIEW,\n  DECLARATION_VIEW,\n  EMBEDDED_VIEW_INJECTOR,\n  FLAGS,\n  INJECTOR,\n  LView,\n  LViewFlags,\n  T_HOST,\n  TData,\n  TVIEW,\n  TView,\n  TViewType,\n} from './interfaces/view';\nimport {assertTNodeType} from './node_assert';\nimport {enterDI, getCurrentTNode, getLView, leaveDI} from './state';\nimport {isNameOnlyAttributeMarker} from './util/attrs_utils';\nimport {\n  getParentInjectorIndex,\n  getParentInjectorView,\n  hasParentInjector,\n} from './util/injector_utils';\nimport {stringifyForError} from './util/stringify_utils';\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```ts\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\n\nexport function setIncludeViewProviders(v: boolean): boolean {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n\n/**\n * The number of bits that is represented by a single bloom bucket. JS bit operations are 32 bits,\n * so each bucket represents 32 distinct tokens which accounts for log2(32) = 5 bits of a bloom hash\n * number.\n */\nconst BLOOM_BUCKET_BITS = 5;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/** Value used when something wasn't found by an injector. */\nconst NOT_FOUND = {};\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nexport function bloomAdd(\n  injectorIndex: number,\n  tView: TView,\n  type: ProviderToken<any> | string,\n): void {\n  ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n  let id: number | undefined;\n  if (typeof type === 'string') {\n    id = type.charCodeAt(0) || 0;\n  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n    id = (type as any)[NG_ELEMENT_ID];\n  }\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomHash = id & BLOOM_MASK;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n\n  // Each bloom bucket in `tData` represents `BLOOM_BUCKET_BITS` number of bits of `bloomHash`.\n  // Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset that the mask\n  // should be written to.\n  (tView.data as number[])[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param lView View where the node is stored\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(\n  tNode: TElementNode | TContainerNode | TElementContainerNode,\n  lView: LView,\n): number {\n  const existingInjectorIndex = getInjectorIndex(tNode, lView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n\n  const tView = lView[TVIEW];\n  if (tView.firstCreatePass) {\n    tNode.injectorIndex = lView.length;\n    insertBloom(tView.data, tNode); // foundation for node bloom\n    insertBloom(lView, null); // foundation for cumulative bloom\n    insertBloom(tView.blueprint, null);\n  }\n\n  const parentLoc = getParentInjectorLocation(tNode, lView);\n  const injectorIndex = tNode.injectorIndex;\n\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (hasParentInjector(parentLoc)) {\n    const parentIndex = getParentInjectorIndex(parentLoc);\n    const parentLView = getParentInjectorView(parentLoc, lView);\n    const parentData = parentLView[TVIEW].data as any;\n    // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n    for (let i = 0; i < NodeInjectorOffset.BLOOM_SIZE; i++) {\n      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n\n  lView[injectorIndex + NodeInjectorOffset.PARENT] = parentLoc;\n  return injectorIndex;\n}\n\nfunction insertBloom(arr: any[], footer: TNode | null): void {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\n\nexport function getInjectorIndex(tNode: TNode, lView: LView): number {\n  if (\n    tNode.injectorIndex === -1 ||\n    // If the injector index is the same as its parent's injector index, then the index has been\n    // copied down from the parent node. No injector has been created yet on this node.\n    (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n    // After the first template pass, the injector index might exist but the parent values\n    // might not have been calculated yet for this instance\n    lView[tNode.injectorIndex + NodeInjectorOffset.PARENT] === null\n  ) {\n    return -1;\n  } else {\n    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n    return tNode.injectorIndex;\n  }\n}\n\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * @returns Returns a number that is the combination of the number of LViews that we have to go up\n * to find the LView containing the parent inject AND the index of the injector within that LView.\n */\nexport function getParentInjectorLocation(tNode: TNode, lView: LView): RelativeInjectorLocation {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    // If we have a parent `TNode` and there is an injector associated with it we are done, because\n    // the parent injector is within the current `LView`.\n    return tNode.parent.injectorIndex as RelativeInjectorLocation; // ViewOffset is 0\n  }\n\n  // When parent injector location is computed it may be outside of the current view. (ie it could\n  // be pointing to a declared parent location). This variable stores number of declaration parents\n  // we need to walk up in order to find the parent injector location.\n  let declarationViewOffset = 0;\n  let parentTNode: TNode | null = null;\n  let lViewCursor: LView | null = lView;\n\n  // The parent injector is not in the current `LView`. We will have to walk the declared parent\n  // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent\n  // `NodeInjector`.\n  while (lViewCursor !== null) {\n    parentTNode = getTNodeFromLView(lViewCursor);\n\n    if (parentTNode === null) {\n      // If we have no parent, than we are done.\n      return NO_PARENT_INJECTOR;\n    }\n\n    ngDevMode && parentTNode && assertTNodeForLView(parentTNode!, lViewCursor[DECLARATION_VIEW]!);\n    // Every iteration of the loop requires that we go to the declared parent.\n    declarationViewOffset++;\n    lViewCursor = lViewCursor[DECLARATION_VIEW];\n\n    if (parentTNode.injectorIndex !== -1) {\n      // We found a NodeInjector which points to something.\n      return (parentTNode.injectorIndex |\n        (declarationViewOffset <<\n          RelativeInjectorLocationFlags.ViewOffsetShift)) as RelativeInjectorLocation;\n    }\n  }\n  return NO_PARENT_INJECTOR;\n}\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nexport function diPublicInInjector(\n  injectorIndex: number,\n  tView: TView,\n  token: ProviderToken<any>,\n): void {\n  bloomAdd(injectorIndex, tView, token);\n}\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```ts\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```html\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```ts\n * MyComponent.ɵcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nexport function injectAttributeImpl(tNode: TNode, attrNameToInject: string): string | null {\n  ngDevMode && assertTNodeType(tNode, TNodeType.AnyContainer | TNodeType.AnyRNode);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  if (attrNameToInject === 'class') {\n    return tNode.classes;\n  }\n  if (attrNameToInject === 'style') {\n    return tNode.styles;\n  }\n\n  const attrs = tNode.attrs;\n  if (attrs) {\n    const attrsLength = attrs.length;\n    let i = 0;\n    while (i < attrsLength) {\n      const value = attrs[i];\n\n      // If we hit a `Bindings` or `Template` marker then we are done.\n      if (isNameOnlyAttributeMarker(value)) break;\n\n      // Skip namespaced attributes\n      if (value === AttributeMarker.NamespaceURI) {\n        // we skip the next two values\n        // as namespaced attributes looks like\n        // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n        // 'existValue', ...]\n        i = i + 2;\n      } else if (typeof value === 'number') {\n        // Skip to the first value of the marked attribute.\n        i++;\n        while (i < attrsLength && typeof attrs[i] === 'string') {\n          i++;\n        }\n      } else if (value === attrNameToInject) {\n        return attrs[i + 1] as string;\n      } else {\n        i = i + 2;\n      }\n    }\n  }\n  return null;\n}\n\nfunction notFoundValueOrThrow<T>(\n  notFoundValue: T | null,\n  token: ProviderToken<T>,\n  flags: InternalInjectFlags,\n): T | null {\n  if (flags & InternalInjectFlags.Optional || notFoundValue !== undefined) {\n    return notFoundValue;\n  } else {\n    throwProviderNotFoundError(token, 'NodeInjector');\n  }\n}\n\n/**\n * Returns the value associated to the given token from the ModuleInjector or throws exception\n *\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InternalInjectFlags.Optional`\n * @returns the value from the injector or throws an exception\n */\nfunction lookupTokenUsingModuleInjector<T>(\n  lView: LView,\n  token: ProviderToken<T>,\n  flags: InternalInjectFlags,\n  notFoundValue?: any,\n): T | null {\n  if (flags & InternalInjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n\n  if ((flags & (InternalInjectFlags.Self | InternalInjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR];\n    // switch to `injectInjectorOnly` implementation for module injector, since module injector\n    // should not have access to Component/Directive DI scope (that may happen through\n    // `directiveInject` implementation)\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      if (moduleInjector) {\n        return (moduleInjector as BackwardsCompatibleInjector).get(\n          token,\n          notFoundValue,\n          flags & InternalInjectFlags.Optional,\n        );\n      } else {\n        return injectRootLimpMode(token, notFoundValue, flags & InternalInjectFlags.Optional);\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n  return notFoundValueOrThrow<T>(notFoundValue, token, flags);\n}\n\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InternalInjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nexport function getOrCreateInjectable<T>(\n  tNode: TDirectiveHostNode | null,\n  lView: LView,\n  token: ProviderToken<T>,\n  flags: InternalInjectFlags = InternalInjectFlags.Default,\n  notFoundValue?: any,\n): T | null {\n  if (tNode !== null) {\n    // If the view or any of its ancestors have an embedded\n    // view injector, we have to look it up there first.\n    if (\n      lView[FLAGS] & LViewFlags.HasEmbeddedViewInjector &&\n      // The token must be present on the current node injector when the `Self`\n      // flag is set, so the lookup on embedded view injector(s) can be skipped.\n      !(flags & InternalInjectFlags.Self)\n    ) {\n      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(\n        tNode,\n        lView,\n        token,\n        flags,\n        NOT_FOUND,\n      );\n      if (embeddedInjectorValue !== NOT_FOUND) {\n        return embeddedInjectorValue;\n      }\n    }\n\n    // Otherwise try the node injector.\n    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);\n    if (value !== NOT_FOUND) {\n      return value;\n    }\n  }\n\n  // Finally, fall back to the module injector.\n  return lookupTokenUsingModuleInjector<T>(lView, token, flags, notFoundValue);\n}\n\n/**\n * Returns the value associated to the given token from the node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InternalInjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingNodeInjector<T>(\n  tNode: TDirectiveHostNode,\n  lView: LView,\n  token: ProviderToken<T>,\n  flags: InternalInjectFlags,\n  notFoundValue?: any,\n) {\n  const bloomHash = bloomHashBitOrFactory(token);\n  // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n  // so just call the factory function to create it.\n  if (typeof bloomHash === 'function') {\n    if (!enterDI(lView, tNode, flags)) {\n      // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n      // flag, the module injector is not searched for that token in Ivy.\n      return flags & InternalInjectFlags.Host\n        ? notFoundValueOrThrow<T>(notFoundValue, token, flags)\n        : lookupTokenUsingModuleInjector<T>(lView, token, flags, notFoundValue);\n    }\n    try {\n      let value: unknown;\n\n      if (ngDevMode) {\n        runInInjectorProfilerContext(\n          new NodeInjector(getCurrentTNode() as TElementNode, getLView()),\n          token as Type<T>,\n          () => {\n            emitInjectorToCreateInstanceEvent(token);\n            value = bloomHash(flags);\n            emitInstanceCreatedByInjectorEvent(value);\n          },\n        );\n      } else {\n        value = bloomHash(flags);\n      }\n\n      if (value == null && !(flags & InternalInjectFlags.Optional)) {\n        throwProviderNotFoundError(token);\n      } else {\n        return value;\n      }\n    } finally {\n      leaveDI();\n    }\n  } else if (typeof bloomHash === 'number') {\n    // A reference to the previous injector TView that was found while climbing the element\n    // injector tree. This is used to know if viewProviders can be accessed on the current\n    // injector.\n    let previousTView: TView | null = null;\n    let injectorIndex = getInjectorIndex(tNode, lView);\n    let parentLocation = NO_PARENT_INJECTOR;\n    let hostTElementNode: TNode | null =\n      flags & InternalInjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n\n    // If we should skip this injector, or if there is no injector on this node, start by\n    // searching the parent injector.\n    if (injectorIndex === -1 || flags & InternalInjectFlags.SkipSelf) {\n      parentLocation =\n        injectorIndex === -1\n          ? getParentInjectorLocation(tNode, lView)\n          : lView[injectorIndex + NodeInjectorOffset.PARENT];\n\n      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n        injectorIndex = -1;\n      } else {\n        previousTView = lView[TVIEW];\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      }\n    }\n\n    // Traverse up the injector tree until we find a potential match or until we know there\n    // *isn't* a match.\n    while (injectorIndex !== -1) {\n      ngDevMode && assertNodeInjector(lView, injectorIndex);\n\n      // Check the current injector. If it matches, see if it contains token.\n      const tView = lView[TVIEW];\n      ngDevMode &&\n        assertTNodeForLView(tView.data[injectorIndex + NodeInjectorOffset.TNODE] as TNode, lView);\n      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n        // At this point, we have an injector which *may* contain the token, so we step through\n        // the providers and directives associated with the injector's corresponding node to get\n        // the instance.\n        const instance: T | {} | null = searchTokensOnInjector<T>(\n          injectorIndex,\n          lView,\n          token,\n          previousTView,\n          flags,\n          hostTElementNode,\n        );\n        if (instance !== NOT_FOUND) {\n          return instance;\n        }\n      }\n      parentLocation = lView[injectorIndex + NodeInjectorOffset.PARENT];\n      if (\n        parentLocation !== NO_PARENT_INJECTOR &&\n        shouldSearchParent(\n          flags,\n          lView[TVIEW].data[injectorIndex + NodeInjectorOffset.TNODE] === hostTElementNode,\n        ) &&\n        bloomHasToken(bloomHash, injectorIndex, lView)\n      ) {\n        // The def wasn't found anywhere on this node, so it was a false positive.\n        // Traverse up the tree and continue searching.\n        previousTView = tView;\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      } else {\n        // If we should not search parent OR If the ancestor bloom filter value does not have the\n        // bit corresponding to the directive we can give up on traversing up to find the specific\n        // injector.\n        injectorIndex = -1;\n      }\n    }\n  }\n\n  return notFoundValue;\n}\n\nfunction searchTokensOnInjector<T>(\n  injectorIndex: number,\n  lView: LView,\n  token: ProviderToken<T>,\n  previousTView: TView | null,\n  flags: InternalInjectFlags,\n  hostTElementNode: TNode | null,\n) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + NodeInjectorOffset.TNODE] as TNode;\n  // First, we need to determine if view providers can be accessed by the starting element.\n  // There are two possibilities\n  const canAccessViewProviders =\n    previousTView == null\n      ? // 1) This is the first invocation `previousTView == null` which means that we are at the\n        // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n        // to look into the ViewProviders is if:\n        // - we are on a component\n        // - AND the injector set `includeViewProviders` to true (implying that the token can see\n        // ViewProviders because it is the Component or a Service which itself was declared in\n        // ViewProviders)\n        isComponentHost(tNode) && includeViewProviders\n      : // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n        // In such a case we are only allowed to look into the ViewProviders if:\n        // - We just crossed from child View to Parent View `previousTView != currentTView`\n        // - AND the parent TNode is an Element.\n        // This means that we just came from the Component's View and therefore are allowed to see\n        // into the ViewProviders.\n        previousTView != currentTView && (tNode.type & TNodeType.AnyRNode) !== 0;\n\n  // This special case happens when there is a @host on the inject and when we are searching\n  // on the host element node.\n  const isHostSpecialCase = flags & InternalInjectFlags.Host && hostTElementNode === tNode;\n\n  const injectableIdx = locateDirectiveOrProvider(\n    tNode,\n    currentTView,\n    token,\n    canAccessViewProviders,\n    isHostSpecialCase,\n  );\n  if (injectableIdx !== null) {\n    return getNodeInjectable(lView, currentTView, injectableIdx, tNode as TElementNode, flags);\n  } else {\n    return NOT_FOUND;\n  }\n}\n\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nexport function locateDirectiveOrProvider<T>(\n  tNode: TNode,\n  tView: TView,\n  token: ProviderToken<T> | string,\n  canAccessViewProviders: boolean,\n  isHostSpecialCase: boolean | number,\n): number | null {\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n\n  const injectablesStart = nodeProviderIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount =\n    nodeProviderIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n  const startingIndex = canAccessViewProviders\n    ? injectablesStart\n    : injectablesStart + cptViewProvidersCount;\n  // When the host special case applies, only the viewProviders and the component are visible\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef = tInjectables[i] as ProviderToken<any> | DirectiveDef<any> | string;\n    if (\n      (i < directivesStart && token === providerTokenOrDef) ||\n      (i >= directivesStart && (providerTokenOrDef as DirectiveDef<any>).type === token)\n    ) {\n      return i;\n    }\n  }\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart] as DirectiveDef<any>;\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n  return null;\n}\n\n/**\n * Used in ngDevMode to keep the injection path in case of cycles in DI.\n */\nlet injectionPath: string[] = [];\n\n/**\n * Retrieve or instantiate the injectable from the `LView` at particular `index`.\n *\n * This function checks to see if the value has already been instantiated and if so returns the\n * cached `injectable`. Otherwise if it detects that the value is still a factory it\n * instantiates the `injectable` and caches the value.\n */\nexport function getNodeInjectable(\n  lView: LView,\n  tView: TView,\n  index: number,\n  tNode: TDirectiveHostNode,\n  flags?: InternalInjectFlags,\n): any {\n  let value = lView[index];\n  const tData = tView.data;\n  if (value instanceof NodeInjectorFactory) {\n    const factory: NodeInjectorFactory = value;\n    ngDevMode && injectionPath.push(factory.name ?? 'unknown');\n    if (factory.resolving) {\n      const token = stringifyForError(tData[index]);\n      if (ngDevMode) {\n        throw cyclicDependencyErrorWithDetails(token, injectionPath);\n      } else {\n        throw cyclicDependencyError(token);\n      }\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n\n    // tData indexes mirror the concrete instances in its corresponding LView.\n    // lView[index] here is either the injectable instance itself or a factory,\n    // therefore tData[index] is the constructor of that injectable or a\n    // definition object that contains the constructor in a `.type` field.\n    const token =\n      (tData[index] as DirectiveDef<unknown> | ComponentDef<unknown>).type || tData[index];\n\n    let prevInjectContext: InjectorProfilerContext | undefined;\n    if (ngDevMode) {\n      const injector = new NodeInjector(tNode, lView);\n      prevInjectContext = setInjectorProfilerContext({injector, token});\n    }\n\n    const previousInjectImplementation = factory.injectImpl\n      ? setInjectImplementation(factory.injectImpl)\n      : null;\n    const success = enterDI(lView, tNode, InternalInjectFlags.Default);\n    ngDevMode &&\n      assertEqual(\n        success,\n        true,\n        \"Because flags do not contain `SkipSelf' we expect this to always succeed.\",\n      );\n    try {\n      ngDevMode && emitInjectorToCreateInstanceEvent(token);\n\n      value = lView[index] = factory.factory(undefined, flags, tData, lView, tNode);\n\n      ngDevMode && emitInstanceCreatedByInjectorEvent(value);\n\n      // This code path is hit for both directives and providers.\n      // For perf reasons, we want to avoid searching for hooks on providers.\n      // It does no harm to try (the hooks just won't exist), but the extra\n      // checks are unnecessary and this is a hot path. So we check to see\n      // if the index of the dependency is in the directive range for this\n      // tNode. If it's not, we know it's a provider and skip hook registration.\n      if (tView.firstCreatePass && index >= tNode.directiveStart) {\n        ngDevMode && assertDirectiveDef(tData[index]);\n        registerPreOrderHooks(index, tData[index] as DirectiveDef<any>, tView);\n      }\n    } finally {\n      ngDevMode && setInjectorProfilerContext(prevInjectContext!);\n\n      previousInjectImplementation !== null &&\n        setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      leaveDI();\n      ngDevMode && (injectionPath = []);\n    }\n  }\n  return value;\n}\n\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nexport function bloomHashBitOrFactory(\n  token: ProviderToken<any> | string,\n): number | Function | undefined {\n  ngDevMode && assertDefined(token, 'token must be defined');\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId: number | undefined =\n    // First check with `hasOwnProperty` so we don't get an inherited ID.\n    token.hasOwnProperty(NG_ELEMENT_ID) ? (token as any)[NG_ELEMENT_ID] : undefined;\n  // Negative token IDs are used for special objects such as `Injector`\n  if (typeof tokenId === 'number') {\n    if (tokenId >= 0) {\n      return tokenId & BLOOM_MASK;\n    } else {\n      ngDevMode &&\n        assertEqual(tokenId, InjectorMarkers.Injector, 'Expecting to get Special Injector Id');\n      return createNodeInjector;\n    }\n  } else {\n    return tokenId;\n  }\n}\n\nexport function bloomHasToken(\n  bloomHash: number,\n  injectorIndex: number,\n  injectorView: LView | TData,\n) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n\n  // Each bloom bucket in `injectorView` represents `BLOOM_BUCKET_BITS` number of bits of\n  // `bloomHash`. Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset\n  // that should be used.\n  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];\n\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(\n  flags: InternalInjectFlags,\n  isFirstHostTNode: boolean,\n): boolean | number {\n  return (\n    !(flags & InternalInjectFlags.Self) && !(flags & InternalInjectFlags.Host && isFirstHostTNode)\n  );\n}\n\nexport function getNodeInjectorLView(nodeInjector: NodeInjector): LView {\n  return (nodeInjector as any)._lView as LView;\n}\n\nexport function getNodeInjectorTNode(\n  nodeInjector: NodeInjector,\n): TElementNode | TContainerNode | TElementContainerNode | null {\n  return (nodeInjector as any)._tNode as\n    | TElementNode\n    | TContainerNode\n    | TElementContainerNode\n    | null;\n}\n\nexport class NodeInjector implements Injector {\n  constructor(\n    private _tNode: TElementNode | TContainerNode | TElementContainerNode | null,\n    private _lView: LView,\n  ) {}\n\n  get(token: any, notFoundValue?: any, flags?: InternalInjectFlags | InjectOptions): any {\n    return getOrCreateInjectable(\n      this._tNode,\n      this._lView,\n      token,\n      convertToBitFlags(flags),\n      notFoundValue,\n    );\n  }\n}\n\n/** Creates a `NodeInjector` for the current node. */\nexport function createNodeInjector(): Injector {\n  return new NodeInjector(getCurrentTNode()! as TDirectiveHostNode, getLView()) as any;\n}\n\n/**\n * @codeGenApi\n */\nexport function ɵɵgetInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T {\n  return noSideEffects(() => {\n    const ownConstructor = type.prototype.constructor;\n    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);\n    const objectPrototype = Object.prototype;\n    let parent = Object.getPrototypeOf(type.prototype).constructor;\n\n    // Go up the prototype until we hit `Object`.\n    while (parent && parent !== objectPrototype) {\n      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);\n\n      // If we hit something that has a factory and the factory isn't the same as the type,\n      // we've found the inherited factory. Note the check that the factory isn't the type's\n      // own factory is redundant in most cases, but if the user has custom decorators on the\n      // class, this lookup will start one level down in the prototype chain, causing us to\n      // find the own factory first and potentially triggering an infinite loop downstream.\n      if (factory && factory !== ownFactory) {\n        return factory;\n      }\n\n      parent = Object.getPrototypeOf(parent);\n    }\n\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return (t: Type<T>) => new t();\n  });\n}\n\nfunction getFactoryOf<T>(type: Type<any>): ((type?: Type<T>) => T | null) | null {\n  if (isForwardRef(type)) {\n    return () => {\n      const factory = getFactoryOf<T>(resolveForwardRef(type));\n      return factory && factory();\n    };\n  }\n  return getFactoryDef<T>(type);\n}\n\n/**\n * Returns a value from the closest embedded or node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InternalInjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingEmbeddedInjector<T>(\n  tNode: TDirectiveHostNode,\n  lView: LView,\n  token: ProviderToken<T>,\n  flags: InternalInjectFlags,\n  notFoundValue?: any,\n) {\n  let currentTNode: TDirectiveHostNode | null = tNode;\n  let currentLView: LView | null = lView;\n\n  // When an LView with an embedded view injector is inserted, it'll likely be interlaced with\n  // nodes who may have injectors (e.g. node injector -> embedded view injector -> node injector).\n  // Since the bloom filters for the node injectors have already been constructed and we don't\n  // have a way of extracting the records from an injector, the only way to maintain the correct\n  // hierarchy when resolving the value is to walk it node-by-node while attempting to resolve\n  // the token at each level.\n  while (\n    currentTNode !== null &&\n    currentLView !== null &&\n    currentLView[FLAGS] & LViewFlags.HasEmbeddedViewInjector &&\n    !isRootView(currentLView)\n  ) {\n    ngDevMode && assertTNodeForLView(currentTNode, currentLView);\n\n    // Note that this lookup on the node injector is using the `Self` flag, because\n    // we don't want the node injector to look at any parent injectors since we\n    // may hit the embedded view injector first.\n    const nodeInjectorValue = lookupTokenUsingNodeInjector(\n      currentTNode,\n      currentLView,\n      token,\n      flags | InternalInjectFlags.Self,\n      NOT_FOUND,\n    );\n    if (nodeInjectorValue !== NOT_FOUND) {\n      return nodeInjectorValue;\n    }\n\n    // Has an explicit type due to a TS bug: https://github.com/microsoft/TypeScript/issues/33191\n    let parentTNode: TElementNode | TContainerNode | null = currentTNode.parent;\n\n    // `TNode.parent` includes the parent within the current view only. If it doesn't exist,\n    // it means that we've hit the view boundary and we need to go up to the next view.\n    if (!parentTNode) {\n      // Before we go to the next LView, check if the token exists on the current embedded injector.\n      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];\n      if (embeddedViewInjector) {\n        const embeddedViewInjectorValue = (embeddedViewInjector as BackwardsCompatibleInjector).get(\n          token,\n          NOT_FOUND as T | {},\n          flags,\n        );\n        if (embeddedViewInjectorValue !== NOT_FOUND) {\n          return embeddedViewInjectorValue;\n        }\n      }\n\n      // Otherwise keep going up the tree.\n      parentTNode = getTNodeFromLView(currentLView);\n      currentLView = currentLView[DECLARATION_VIEW];\n    }\n\n    currentTNode = parentTNode;\n  }\n\n  return notFoundValue;\n}\n\n/** Gets the TNode associated with an LView inside of the declaration view. */\nfunction getTNodeFromLView(lView: LView): TElementNode | TElementContainerNode | null {\n  const tView = lView[TVIEW];\n  const tViewType = tView.type;\n\n  // The parent pointer differs based on `TView.type`.\n  if (tViewType === TViewType.Embedded) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode as TElementContainerNode;\n  } else if (tViewType === TViewType.Component) {\n    // Components don't have `TView.declTNode` because each instance of component could be\n    // inserted in different location, hence `TView.declTNode` is meaningless.\n    return lView[T_HOST] as TElementNode;\n  }\n\n  return null;\n}\n"]}