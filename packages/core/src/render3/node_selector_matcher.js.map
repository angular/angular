{"version":3,"file":"node_selector_matcher.js","sourceRoot":"","sources":["node_selector_matcher.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {assertDefined, assertEqual, assertNotEqual} from '../util/assert';\n\nimport {AttributeMarker} from './interfaces/attribute_marker';\nimport {TAttributes, TNode, TNodeType} from './interfaces/node';\nimport {CssSelector, CssSelectorList, SelectorFlags} from './interfaces/projection';\nimport {classIndexOf} from './styling/class_differ';\nimport {isNameOnlyAttributeMarker} from './util/attrs_utils';\n\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param tNode static data of the node to match\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\nfunction isCssClassMatching(\n  tNode: TNode,\n  attrs: TAttributes,\n  cssClassToMatch: string,\n  isProjectionMode: boolean,\n): boolean {\n  ngDevMode &&\n    assertEqual(\n      cssClassToMatch,\n      cssClassToMatch.toLowerCase(),\n      'Class name expected to be lowercase.',\n    );\n  let i = 0;\n  if (isProjectionMode) {\n    for (; i < attrs.length && typeof attrs[i] === 'string'; i += 2) {\n      // Search for an implicit `class` attribute and check if its value matches `cssClassToMatch`.\n      if (\n        attrs[i] === 'class' &&\n        classIndexOf((attrs[i + 1] as string).toLowerCase(), cssClassToMatch, 0) !== -1\n      ) {\n        return true;\n      }\n    }\n  } else if (isInlineTemplate(tNode)) {\n    // Matching directives (i.e. when not matching for projection mode) should not consider the\n    // class bindings that are present on inline templates, as those class bindings only target\n    // the root node of the template, not the template itself.\n    return false;\n  }\n\n  // Resume the search for classes after the `Classes` marker.\n  i = attrs.indexOf(AttributeMarker.Classes, i);\n  if (i > -1) {\n    // We found the classes section. Start searching for the class.\n    let item: TAttributes[number];\n    while (++i < attrs.length && typeof (item = attrs[i]) === 'string') {\n      if (item.toLowerCase() === cssClassToMatch) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Checks whether the `tNode` represents an inline template (e.g. `*ngFor`).\n *\n * @param tNode current TNode\n */\nexport function isInlineTemplate(tNode: TNode): boolean {\n  return tNode.type === TNodeType.Container && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\n\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(\n  tNode: TNode,\n  currentSelector: string,\n  isProjectionMode: boolean,\n): boolean {\n  const tagNameToCompare =\n    tNode.type === TNodeType.Container && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n  return currentSelector === tagNameToCompare;\n}\n\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param tNode static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nexport function isNodeMatchingSelector(\n  tNode: TNode,\n  selector: CssSelector,\n  isProjectionMode: boolean,\n): boolean {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n  let mode: SelectorFlags = SelectorFlags.ELEMENT;\n  const nodeAttrs = tNode.attrs;\n\n  // Find the index of first attribute that has no value, only a name.\n  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;\n\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = (current as number) | (mode & SelectorFlags.NOT);\n      continue;\n    }\n\n    if (skipToNextSelector) continue;\n\n    if (mode & SelectorFlags.ELEMENT) {\n      mode = SelectorFlags.ATTRIBUTE | (mode & SelectorFlags.NOT);\n      if (\n        (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode)) ||\n        (current === '' && selector.length === 1)\n      ) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else if (mode & SelectorFlags.CLASS) {\n      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const selectorAttrValue = selector[++i];\n      const attrIndexInNode = findAttrIndexInNode(\n        current,\n        nodeAttrs,\n        isInlineTemplate(tNode),\n        isProjectionMode,\n      );\n\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue: string;\n        if (attrIndexInNode > nameOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode &&\n            assertNotEqual(\n              nodeAttrs![attrIndexInNode],\n              AttributeMarker.NamespaceURI,\n              'We do not match directives on namespaced attributes',\n            );\n          // we lowercase the attribute value to be able to match\n          // selectors without case-sensitivity\n          // (selectors are already in lowercase when generated)\n          nodeAttrValue = (nodeAttrs![attrIndexInNode + 1] as string).toLowerCase();\n        }\n\n        if (mode & SelectorFlags.ATTRIBUTE && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n\n  return isPositive(mode) || skipToNextSelector;\n}\n\nfunction isPositive(mode: SelectorFlags): boolean {\n  return (mode & SelectorFlags.NOT) === 0;\n}\n\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(\n  name: string,\n  attrs: TAttributes | null,\n  isInlineTemplate: boolean,\n  isProjectionMode: boolean,\n): number {\n  if (attrs === null) return -1;\n\n  let i = 0;\n\n  if (isProjectionMode || !isInlineTemplate) {\n    let bindingsMode = false;\n    while (i < attrs.length) {\n      const maybeAttrName = attrs[i];\n      if (maybeAttrName === name) {\n        return i;\n      } else if (\n        maybeAttrName === AttributeMarker.Bindings ||\n        maybeAttrName === AttributeMarker.I18n\n      ) {\n        bindingsMode = true;\n      } else if (\n        maybeAttrName === AttributeMarker.Classes ||\n        maybeAttrName === AttributeMarker.Styles\n      ) {\n        let value = attrs[++i];\n        // We should skip classes here because we have a separate mechanism for\n        // matching classes in projection mode.\n        while (typeof value === 'string') {\n          value = attrs[++i];\n        }\n        continue;\n      } else if (maybeAttrName === AttributeMarker.Template) {\n        // We do not care about Template attributes in this scenario.\n        break;\n      } else if (maybeAttrName === AttributeMarker.NamespaceURI) {\n        // Skip the whole namespaced attribute and value. This is by design.\n        i += 4;\n        continue;\n      }\n      // In binding mode there are only names, rather than name-value pairs.\n      i += bindingsMode ? 1 : 2;\n    }\n    // We did not match the attribute\n    return -1;\n  } else {\n    return matchTemplateAttribute(attrs, name);\n  }\n}\n\nexport function isNodeMatchingSelectorList(\n  tNode: TNode,\n  selector: CssSelectorList,\n  isProjectionMode: boolean = false,\n): boolean {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function getProjectAsAttrValue(tNode: TNode): CssSelector | null {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(AttributeMarker.ProjectAs);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1] as CssSelector;\n    }\n  }\n  return null;\n}\n\nfunction getNameOnlyMarkerIndex(nodeAttrs: TAttributes) {\n  for (let i = 0; i < nodeAttrs.length; i++) {\n    const nodeAttr = nodeAttrs[i];\n    if (isNameOnlyAttributeMarker(nodeAttr)) {\n      return i;\n    }\n  }\n  return nodeAttrs.length;\n}\n\nfunction matchTemplateAttribute(attrs: TAttributes, name: string): number {\n  let i = attrs.indexOf(AttributeMarker.Template);\n  if (i > -1) {\n    i++;\n    while (i < attrs.length) {\n      const attr = attrs[i];\n      // Return in case we checked all template attrs and are switching to the next section in the\n      // attrs array (that starts with a number that represents an attribute marker).\n      if (typeof attr === 'number') return -1;\n      if (attr === name) return i;\n      i++;\n    }\n  }\n  return -1;\n}\n\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nexport function isSelectorInSelectorList(selector: CssSelector, list: CssSelectorList): boolean {\n  selectorListLoop: for (let i = 0; i < list.length; i++) {\n    const currentSelectorInList = list[i];\n    if (selector.length !== currentSelectorInList.length) {\n      continue;\n    }\n    for (let j = 0; j < selector.length; j++) {\n      if (selector[j] !== currentSelectorInList[j]) {\n        continue selectorListLoop;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction maybeWrapInNotSelector(isNegativeMode: boolean, chunk: string): string {\n  return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\n\nfunction stringifyCSSSelector(selector: CssSelector): string {\n  let result = selector[0] as string;\n  let i = 1;\n  let mode = SelectorFlags.ATTRIBUTE;\n  let currentChunk = '';\n  let isNegativeMode = false;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode & SelectorFlags.ATTRIBUTE) {\n        const attrValue = selector[++i] as string;\n        currentChunk +=\n          '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n      } else if (mode & SelectorFlags.CLASS) {\n        currentChunk += '.' + valueOrMarker;\n      } else if (mode & SelectorFlags.ELEMENT) {\n        currentChunk += ' ' + valueOrMarker;\n      }\n    } else {\n      //\n      // Append current chunk to the final result in case we come across SelectorFlag, which\n      // indicates that the previous section of a selector is over. We need to accumulate content\n      // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n      // ```\n      //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n      // ```\n      // should be transformed to `.classA :not(.classB .classC)`.\n      //\n      // Note: for negative selector part, we accumulate content between flags until we find the\n      // next negative flag. This is needed to support a case where `:not()` rule contains more than\n      // one chunk, e.g. the following selector:\n      // ```\n      //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n      // ```\n      // should be stringified to `:not(p.foo) :not(.bar)`\n      //\n      if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n        currentChunk = '';\n      }\n      mode = valueOrMarker;\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector.\n      isNegativeMode = isNegativeMode || !isPositive(mode);\n    }\n    i++;\n  }\n  if (currentChunk !== '') {\n    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n  }\n  return result;\n}\n\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\nexport function stringifyCSSSelectorList(selectorList: CssSelectorList): string {\n  return selectorList.map(stringifyCSSSelector).join(',');\n}\n\n/**\n * Extracts attributes and classes information from a given CSS selector.\n *\n * This function is used while creating a component dynamically. In this case, the host element\n * (that is created dynamically) should contain attributes and classes specified in component's CSS\n * selector.\n *\n * @param selector CSS selector in parsed form (in a form of array)\n * @returns object with `attrs` and `classes` fields that contain extracted information\n */\nexport function extractAttrsAndClassesFromSelector(selector: CssSelector): TAttributes {\n  const attrs: TAttributes = [];\n  const classes: string[] = [];\n  let i = 1;\n  let mode = SelectorFlags.ATTRIBUTE;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode === SelectorFlags.ATTRIBUTE) {\n        if (valueOrMarker !== '') {\n          attrs.push(valueOrMarker, selector[++i] as string);\n        }\n      } else if (mode === SelectorFlags.CLASS) {\n        classes.push(valueOrMarker);\n      }\n    } else {\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector. Since attributes and classes are\n      // extracted only for \"positive\" part of the selector, we can stop here.\n      if (!isPositive(mode)) break;\n      mode = valueOrMarker;\n    }\n    i++;\n  }\n  if (classes.length) {\n    attrs.push(AttributeMarker.Classes, ...classes);\n  }\n\n  return attrs;\n}\n"]}