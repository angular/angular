{"version":3,"file":"reactive_lview_consumer.js","sourceRoot":"","sources":["reactive_lview_consumer.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,aAAa,EAAe,MAAM,0BAA0B,CAAC;AAErE,OAAO,EAAQ,0BAA0B,EAAE,KAAK,EAAmB,MAAM,mBAAmB,CAAC;AAC7F,OAAO,EAAC,cAAc,EAAE,yBAAyB,EAAE,kBAAkB,EAAC,MAAM,mBAAmB,CAAC;AAEhG,IAAI,aAAa,GAAmB,EAAE,CAAC;AAKvC;;;;GAIG;AACH,MAAM,UAAU,gCAAgC,CAAC,KAAY;IAC3D,OAAO,KAAK,CAAC,0BAA0B,CAAC,IAAI,2BAA2B,CAAC,KAAK,CAAC,CAAC;AACjF,CAAC;AAED,SAAS,2BAA2B,CAAC,KAAY;IAC/C,MAAM,QAAQ,GAAG,aAAa,CAAC,GAAG,EAAE,IAAI,MAAM,CAAC,MAAM,CAAC,4BAA4B,CAAC,CAAC;IACpF,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED,MAAM,UAAU,gCAAgC,CAAC,QAA+B;IAC9E,IAAI,QAAQ,CAAC,KAAM,CAAC,0BAA0B,CAAC,KAAK,QAAQ,EAAE,CAAC;QAC7D,8BAA8B;QAC9B,OAAO;IACT,CAAC;IACD,QAAQ,CAAC,KAAK,GAAG,IAAI,CAAC;IACtB,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC/B,CAAC;AAED,MAAM,CAAC,MAAM,4BAA4B,GAAyC;IAChF,GAAG,aAAa;IAChB,oBAAoB,EAAE,IAAI;IAC1B,IAAI,EAAE,UAAU;IAChB,mBAAmB,EAAE,CAAC,IAA2B,EAAE,EAAE;QACnD,yBAAyB,CAAC,IAAI,CAAC,KAAM,CAAC,CAAC;IACzC,CAAC;IACD,oBAAoB;QAClB,IAAI,CAAC,KAAM,CAAC,0BAA0B,CAAC,GAAG,IAAI,CAAC;IACjD,CAAC;CACF,CAAC;AAEF;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,4BAA4B,CAAC,KAAY;IACvD,MAAM,QAAQ,GAAG,KAAK,CAAC,0BAA0B,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,uBAAuB,CAAC,CAAC;IAC7F,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED,MAAM,CAAC,MAAM,uBAAuB,GAAiB;IACnD,GAAG,aAAa;IAChB,oBAAoB,EAAE,IAAI;IAC1B,IAAI,EAAE,UAAU;IAChB,mBAAmB,EAAE,CAAC,IAA2B,EAAE,EAAE;QACnD,IAAI,MAAM,GAAG,cAAc,CAAC,IAAI,CAAC,KAAM,CAAC,CAAC;QACzC,OAAO,MAAM,IAAI,CAAC,8BAA8B,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;YAChE,MAAM,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;QAClC,CAAC;QACD,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,yEAAyE;YACzE,kGAAkG;YAClG,OAAO;QACT,CAAC;QAED,kBAAkB,CAAC,MAAM,CAAC,CAAC;IAC7B,CAAC;IACD,oBAAoB;QAClB,IAAI,CAAC,KAAM,CAAC,0BAA0B,CAAC,GAAG,IAAI,CAAC;IACjD,CAAC;CACF,CAAC;AAEF;;;;;;;;;;;;;GAaG;AACH,MAAM,UAAU,8BAA8B,CAAC,KAAY;IACzD,OAAO,KAAK,CAAC,IAAI,+BAAuB,CAAC;AAC3C,CAAC;AAED,MAAM,UAAU,uBAAuB,CAAC,IAAkB;IACxD,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC;AAClC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {REACTIVE_NODE, ReactiveNode} from '../../primitives/signals';\n\nimport {LView, REACTIVE_TEMPLATE_CONSUMER, TVIEW, TView, TViewType} from './interfaces/view';\nimport {getLViewParent, markAncestorsForTraversal, markViewForRefresh} from './util/view_utils';\n\nlet freeConsumers: ReactiveNode[] = [];\nexport interface ReactiveLViewConsumer extends ReactiveNode {\n  lView: LView | null;\n}\n\n/**\n * Create a new template consumer pointing at the specified LView.\n * Sometimes, a previously created consumer may be reused, in order to save on allocations. In that\n * case, the LView will be updated.\n */\nexport function getOrBorrowReactiveLViewConsumer(lView: LView): ReactiveLViewConsumer {\n  return lView[REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);\n}\n\nfunction borrowReactiveLViewConsumer(lView: LView): ReactiveLViewConsumer {\n  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);\n  consumer.lView = lView;\n  return consumer;\n}\n\nexport function maybeReturnReactiveLViewConsumer(consumer: ReactiveLViewConsumer): void {\n  if (consumer.lView![REACTIVE_TEMPLATE_CONSUMER] === consumer) {\n    // The consumer got committed.\n    return;\n  }\n  consumer.lView = null;\n  freeConsumers.push(consumer);\n}\n\nexport const REACTIVE_LVIEW_CONSUMER_NODE: Omit<ReactiveLViewConsumer, 'lView'> = {\n  ...REACTIVE_NODE,\n  consumerIsAlwaysLive: true,\n  kind: 'template',\n  consumerMarkedDirty: (node: ReactiveLViewConsumer) => {\n    markAncestorsForTraversal(node.lView!);\n  },\n  consumerOnSignalRead(this: ReactiveLViewConsumer): void {\n    this.lView![REACTIVE_TEMPLATE_CONSUMER] = this;\n  },\n};\n\n/**\n * Creates a temporary consumer for use with `LView`s that should not have consumers.\n * If the LView already has a consumer, returns the existing one instead.\n *\n * This is necessary because some APIs may cause change detection directly on an LView\n * that we do not want to have a consumer (Embedded views today). As a result, there\n * would be no active consumer from running change detection on its host component\n * and any signals in the LView template would be untracked. Instead, we create\n * this temporary consumer that marks the first parent that _should_ have a consumer\n * for refresh. Once change detection runs as part of that refresh, we throw away\n * this consumer because its signals will then be tracked by the parent's consumer.\n */\nexport function getOrCreateTemporaryConsumer(lView: LView): ReactiveLViewConsumer {\n  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER] ?? Object.create(TEMPORARY_CONSUMER_NODE);\n  consumer.lView = lView;\n  return consumer;\n}\n\nexport const TEMPORARY_CONSUMER_NODE: ReactiveNode = {\n  ...REACTIVE_NODE,\n  consumerIsAlwaysLive: true,\n  kind: 'template',\n  consumerMarkedDirty: (node: ReactiveLViewConsumer) => {\n    let parent = getLViewParent(node.lView!);\n    while (parent && !viewShouldHaveReactiveConsumer(parent[TVIEW])) {\n      parent = getLViewParent(parent);\n    }\n    if (!parent) {\n      // If we can't find an appropriate parent that should have a consumer, we\n      // don't have a way of appropriately refreshing this LView as part of application synchronization.\n      return;\n    }\n\n    markViewForRefresh(parent);\n  },\n  consumerOnSignalRead(this: ReactiveLViewConsumer): void {\n    this.lView![REACTIVE_TEMPLATE_CONSUMER] = this;\n  },\n};\n\n/**\n * Indicates if the view should get its own reactive consumer node.\n *\n * In the current design, all embedded views share a consumer with the component view. This allows\n * us to refresh at the component level rather than at a per-view level. In addition, root views get\n * their own reactive node because root component will have a host view that executes the\n * component's host bindings. This needs to be tracked in a consumer as well.\n *\n * To get a more granular change detection than per-component, all we would just need to update the\n * condition here so that a given view gets a reactive consumer which can become dirty independently\n * from its parent component. For example embedded views for signal components could be created with\n * a new type \"SignalEmbeddedView\" and the condition here wouldn't even need updating in order to\n * get granular per-view change detection for signal components.\n */\nexport function viewShouldHaveReactiveConsumer(tView: TView) {\n  return tView.type !== TViewType.Embedded;\n}\n\nexport function isReactiveLViewConsumer(node: ReactiveNode): node is ReactiveLViewConsumer {\n  return node.kind === 'template';\n}\n"]}