{"version":3,"file":"state.js","sourceRoot":"","sources":["state.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InternalInjectFlags} from '../di/interface/injector';\nimport {\n  assertDefined,\n  assertEqual,\n  assertGreaterThanOrEqual,\n  assertLessThan,\n  assertNotEqual,\n  throwError,\n} from '../util/assert';\n\nimport {assertLViewOrUndefined, assertTNodeForLView, assertTNodeForTView} from './assert';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TNode, TNodeType} from './interfaces/node';\nimport {\n  CONTEXT,\n  DECLARATION_VIEW,\n  HEADER_OFFSET,\n  LView,\n  OpaqueViewState,\n  T_HOST,\n  TData,\n  TVIEW,\n  TView,\n  TViewType,\n} from './interfaces/view';\nimport {MATH_ML_NAMESPACE, SVG_NAMESPACE} from './namespaces';\nimport {getTNode, walkUpViews} from './util/view_utils';\n\n/**\n *\n */\ninterface LFrame {\n  /**\n   * Parent LFrame.\n   *\n   * This is needed when `leaveView` is called to restore the previous state.\n   */\n  parent: LFrame;\n\n  /**\n   * Child LFrame.\n   *\n   * This is used to cache existing LFrames to relieve the memory pressure.\n   */\n  child: LFrame | null;\n\n  /**\n   * State of the current view being processed.\n   *\n   * An array of nodes (text, element, container, etc), pipes, their bindings, and\n   * any local variables that need to be stored between invocations.\n   */\n  lView: LView;\n\n  /**\n   * Current `TView` associated with the `LFrame.lView`.\n   *\n   * One can get `TView` from `lFrame[TVIEW]` however because it is so common it makes sense to\n   * store it in `LFrame` for perf reasons.\n   */\n  tView: TView;\n\n  /**\n   * Used to set the parent property when nodes are created and track query results.\n   *\n   * This is used in conjunction with `isParent`.\n   */\n  currentTNode: TNode | null;\n\n  /**\n   * If `isParent` is:\n   *  - `true`: then `currentTNode` points to a parent node.\n   *  - `false`: then `currentTNode` points to previous node (sibling).\n   */\n  isParent: boolean;\n\n  /**\n   * Index of currently selected element in LView.\n   *\n   * Used by binding instructions. Updated as part of advance instruction.\n   */\n  selectedIndex: number;\n\n  /**\n   * Current pointer to the binding index.\n   */\n  bindingIndex: number;\n\n  /**\n   * The last viewData retrieved by nextContext().\n   * Allows building nextContext() and reference() calls.\n   *\n   * e.g. const inner = x().$implicit; const outer = x().$implicit;\n   */\n  contextLView: LView | null;\n\n  /**\n   * Store the element depth count. This is used to identify the root elements of the template\n   * so that we can then attach patch data `LView` to only those elements. We know that those\n   * are the only places where the patch data could change, this way we will save on number\n   * of places where tha patching occurs.\n   */\n  elementDepthCount: number;\n\n  /**\n   * Current namespace to be used when creating elements\n   */\n  currentNamespace: string | null;\n\n  /**\n   * The root index from which pure function instructions should calculate their binding\n   * indices. In component views, this is TView.bindingStartIndex. In a host binding\n   * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n   */\n  bindingRootIndex: number;\n\n  /**\n   * Current index of a View or Content Query which needs to be processed next.\n   * We iterate over the list of Queries and increment current query index at every step.\n   */\n  currentQueryIndex: number;\n\n  /**\n   * When host binding is executing this points to the directive index.\n   * `TView.data[currentDirectiveIndex]` is `DirectiveDef`\n   * `LView[currentDirectiveIndex]` is directive instance.\n   */\n  currentDirectiveIndex: number;\n\n  /**\n   * Are we currently in i18n block as denoted by `ɵɵelementStart` and `ɵɵelementEnd`.\n   *\n   * This information is needed because while we are in i18n block all elements must be pre-declared\n   * in the translation. (i.e. `Hello �#2�World�/#2�!` pre-declares element at `�#2�` location.)\n   * This allocates `TNodeType.Placeholder` element at location `2`. If translator removes `�#2�`\n   * from translation than the runtime must also ensure tha element at `2` does not get inserted\n   * into the DOM. The translation does not carry information about deleted elements. Therefor the\n   * only way to know that an element is deleted is that it was not pre-declared in the translation.\n   *\n   * This flag works by ensuring that elements which are created without pre-declaration\n   * (`TNodeType.Placeholder`) are not inserted into the DOM render tree. (It does mean that the\n   * element still gets instantiated along with all of its behavior [directives])\n   */\n  inI18n: boolean;\n}\n\n/**\n * All implicit instruction state is stored here.\n *\n * It is useful to have a single object where all of the state is stored as a mental model\n * (rather it being spread across many different variables.)\n *\n * PERF NOTE: Turns out that writing to a true global variable is slower than\n * having an intermediate object with properties.\n */\ninterface InstructionState {\n  /**\n   * Current `LFrame`\n   *\n   * `null` if we have not called `enterView`\n   */\n  lFrame: LFrame;\n\n  /**\n   * Stores whether directives should be matched to elements.\n   *\n   * When template contains `ngNonBindable` then we need to prevent the runtime from matching\n   * directives on children of that element.\n   *\n   * Example:\n   * ```html\n   * <my-comp my-directive>\n   *   Should match component / directive.\n   * </my-comp>\n   * <div ngNonBindable>\n   *   <my-comp my-directive>\n   *     Should not match component / directive because we are in ngNonBindable.\n   *   </my-comp>\n   * </div>\n   * ```\n   */\n  bindingsEnabled: boolean;\n\n  /**\n   * Stores the root TNode that has the 'ngSkipHydration' attribute on it for later reference.\n   *\n   * Example:\n   * ```html\n   * <my-comp ngSkipHydration>\n   *   Should reference this root node\n   * </my-comp>\n   * ```\n   */\n  skipHydrationRootTNode: TNode | null;\n}\n\nconst instructionState: InstructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true,\n  skipHydrationRootTNode: null,\n};\n\nexport enum CheckNoChangesMode {\n  Off,\n  Exhaustive,\n  OnlyDirtyViews,\n}\n\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\nlet _checkNoChangesMode: CheckNoChangesMode = 0; /* CheckNoChangesMode.Off */\n\n/**\n * Flag used to indicate that we are in the middle running change detection on a view\n *\n * @see detectChangesInViewWhileDirty\n */\nlet _isRefreshingViews = false;\n\n/**\n * Returns true if the instruction state stack is empty.\n *\n * Intended to be called from tests only (tree shaken otherwise).\n */\nexport function specOnlyIsInstructionStateEmpty(): boolean {\n  return instructionState.lFrame.parent === null;\n}\n\nexport function getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\n\nexport function increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\n\nexport function decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\n\nexport function getBindingsEnabled(): boolean {\n  return instructionState.bindingsEnabled;\n}\n\n/**\n * Returns true if currently inside a skip hydration block.\n * @returns boolean\n */\nexport function isInSkipHydrationBlock(): boolean {\n  return instructionState.skipHydrationRootTNode !== null;\n}\n\n/**\n * Returns true if this is the root TNode of the skip hydration block.\n * @param tNode the current TNode\n * @returns boolean\n */\nexport function isSkipHydrationRootTNode(tNode: TNode): boolean {\n  return instructionState.skipHydrationRootTNode === tNode;\n}\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```html\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵenableBindings(): void {\n  instructionState.bindingsEnabled = true;\n}\n\n/**\n * Sets a flag to specify that the TNode is in a skip hydration block.\n * @param tNode the current TNode\n */\nexport function enterSkipHydrationBlock(tNode: TNode): void {\n  instructionState.skipHydrationRootTNode = tNode;\n}\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```html\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵdisableBindings(): void {\n  instructionState.bindingsEnabled = false;\n}\n\n/**\n * Clears the root skip hydration node when leaving a skip hydration block.\n */\nexport function leaveSkipHydrationBlock(): void {\n  instructionState.skipHydrationRootTNode = null;\n}\n\n/**\n * Return the current `LView`.\n */\nexport function getLView<T>(): LView<T> {\n  return instructionState.lFrame.lView as LView<T>;\n}\n\n/**\n * Return the current `TView`.\n */\nexport function getTView(): TView {\n  return instructionState.lFrame.tView;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nexport function ɵɵrestoreView<T = any>(viewToRestore: OpaqueViewState): T {\n  instructionState.lFrame.contextLView = viewToRestore as any as LView;\n  return (viewToRestore as any as LView)[CONTEXT] as unknown as T;\n}\n\n/**\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nexport function ɵɵresetView<T>(value?: T): T | undefined {\n  instructionState.lFrame.contextLView = null;\n  return value;\n}\n\nexport function getCurrentTNode(): TNode | null {\n  let currentTNode = getCurrentTNodePlaceholderOk();\n  while (currentTNode !== null && currentTNode.type === TNodeType.Placeholder) {\n    currentTNode = currentTNode.parent;\n  }\n  return currentTNode;\n}\n\nexport function getCurrentTNodePlaceholderOk(): TNode | null {\n  return instructionState.lFrame.currentTNode;\n}\n\nexport function getCurrentParentTNode(): TNode | null {\n  const lFrame = instructionState.lFrame;\n  const currentTNode = lFrame.currentTNode;\n  return lFrame.isParent ? currentTNode : currentTNode!.parent;\n}\n\nexport function setCurrentTNode(tNode: TNode | null, isParent: boolean) {\n  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n  const lFrame = instructionState.lFrame;\n  lFrame.currentTNode = tNode;\n  lFrame.isParent = isParent;\n}\n\nexport function isCurrentTNodeParent(): boolean {\n  return instructionState.lFrame.isParent;\n}\n\nexport function setCurrentTNodeAsNotParent(): void {\n  instructionState.lFrame.isParent = false;\n}\n\nexport function getContextLView(): LView {\n  const contextLView = instructionState.lFrame.contextLView;\n  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n  return contextLView!;\n}\n\nexport function isInCheckNoChangesMode(): boolean {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _checkNoChangesMode !== CheckNoChangesMode.Off;\n}\n\nexport function isExhaustiveCheckNoChanges(): boolean {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;\n}\n\nexport function setIsInCheckNoChangesMode(mode: CheckNoChangesMode): void {\n  !ngDevMode && throwError('Must never be called in production mode');\n  _checkNoChangesMode = mode;\n}\n\nexport function isRefreshingViews(): boolean {\n  return _isRefreshingViews;\n}\n\nexport function setIsRefreshingViews(mode: boolean): boolean {\n  const prev = _isRefreshingViews;\n  _isRefreshingViews = mode;\n  return prev;\n}\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n  return index;\n}\n\nexport function getBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex;\n}\n\nexport function setBindingIndex(value: number): number {\n  return (instructionState.lFrame.bindingIndex = value);\n}\n\nexport function nextBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex++;\n}\n\nexport function incrementBindingIndex(count: number): number {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\n\nexport function isInI18nBlock() {\n  return instructionState.lFrame.inI18n;\n}\n\nexport function setInI18nBlock(isInI18nBlock: boolean): void {\n  instructionState.lFrame.inI18n = isInI18nBlock;\n}\n\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nexport function setBindingRootForHostBindings(\n  bindingRootIndex: number,\n  currentDirectiveIndex: number,\n) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nexport function getCurrentDirectiveIndex(): number {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\n\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nexport function setCurrentDirectiveIndex(currentDirectiveIndex: number): void {\n  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nexport function getCurrentDirectiveDef(tData: TData): DirectiveDef<any> | null {\n  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n  return currentDirectiveIndex === -1 ? null : (tData[currentDirectiveIndex] as DirectiveDef<any>);\n}\n\nexport function getCurrentQueryIndex(): number {\n  return instructionState.lFrame.currentQueryIndex;\n}\n\nexport function setCurrentQueryIndex(value: number): void {\n  instructionState.lFrame.currentQueryIndex = value;\n}\n\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView: LView): TNode | null {\n  const tView = lView[TVIEW];\n\n  // Return the declaration parent for embedded views\n  if (tView.type === TViewType.Embedded) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  }\n\n  // Components don't have `TView.declTNode` because each instance of component could be\n  // inserted in different location, hence `TView.declTNode` is meaningless.\n  // Falling back to `T_HOST` in case we cross component boundary.\n  if (tView.type === TViewType.Component) {\n    return lView[T_HOST];\n  }\n\n  // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n  return null;\n}\n\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nexport function enterDI(lView: LView, tNode: TNode, flags: InternalInjectFlags) {\n  ngDevMode && assertLViewOrUndefined(lView);\n\n  if (flags & InternalInjectFlags.SkipSelf) {\n    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n\n    let parentTNode = tNode as TNode | null;\n    let parentLView = lView;\n\n    while (true) {\n      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n      parentTNode = parentTNode!.parent as TNode | null;\n      if (parentTNode === null && !(flags & InternalInjectFlags.Host)) {\n        parentTNode = getDeclarationTNode(parentLView);\n        if (parentTNode === null) break;\n\n        // In this case, a parent exists and is definitely an element. So it will definitely\n        // have an existing lView as the declaration view, which is why we can assume it's defined.\n        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n        parentLView = parentLView[DECLARATION_VIEW]!;\n\n        // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n        // We want to skip those and look only at Elements and ElementContainers to ensure\n        // we're looking at true parent nodes, and not content or other types.\n        if (parentTNode.type & (TNodeType.Element | TNodeType.ElementContainer)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (parentTNode === null) {\n      // If we failed to find a parent TNode this means that we should use module injector.\n      return false;\n    } else {\n      tNode = parentTNode;\n      lView = parentLView;\n    }\n  }\n\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const lFrame = (instructionState.lFrame = allocLFrame());\n  lFrame.currentTNode = tNode;\n  lFrame.lView = lView;\n\n  return true;\n}\n\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nexport function enterView(newView: LView): void {\n  ngDevMode && assertNotEqual(newView[0], newView[1] as any, '????');\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  if (ngDevMode) {\n    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n  }\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n  newLFrame.currentTNode = tView.firstChild!;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.contextLView = newView;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.inI18n = false;\n}\n\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\n\nfunction createLFrame(parent: LFrame | null): LFrame {\n  const lFrame: LFrame = {\n    currentTNode: null,\n    isParent: true,\n    lView: null!,\n    tView: null!,\n    selectedIndex: -1,\n    contextLView: null,\n    elementDepthCount: 0,\n    currentNamespace: null,\n    currentDirectiveIndex: -1,\n    bindingRootIndex: -1,\n    bindingIndex: -1,\n    currentQueryIndex: 0,\n    parent: parent!,\n    child: null,\n    inI18n: false,\n  };\n  parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n  return lFrame;\n}\n\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight(): LFrame {\n  const oldLFrame = instructionState.lFrame;\n  instructionState.lFrame = oldLFrame.parent;\n  oldLFrame.currentTNode = null!;\n  oldLFrame.lView = null!;\n  return oldLFrame;\n}\n\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nexport const leaveDI: () => void = leaveViewLight;\n\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nexport function leaveView() {\n  const oldLFrame = leaveViewLight();\n  oldLFrame.isParent = true;\n  oldLFrame.tView = null!;\n  oldLFrame.selectedIndex = -1;\n  oldLFrame.contextLView = null;\n  oldLFrame.elementDepthCount = 0;\n  oldLFrame.currentDirectiveIndex = -1;\n  oldLFrame.currentNamespace = null;\n  oldLFrame.bindingRootIndex = -1;\n  oldLFrame.bindingIndex = -1;\n  oldLFrame.currentQueryIndex = 0;\n}\n\nexport function nextContextImpl<T = any>(level: number): T {\n  const contextLView = (instructionState.lFrame.contextLView = walkUpViews(\n    level,\n    instructionState.lFrame.contextLView!,\n  ));\n  return contextLView[CONTEXT] as unknown as T;\n}\n\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nexport function getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\n\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nexport function setSelectedIndex(index: number) {\n  ngDevMode &&\n    index !== -1 &&\n    assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n  ngDevMode &&\n    assertLessThan(\n      index,\n      instructionState.lFrame.lView.length,\n      \"Can't set index passed end of LView\",\n    );\n  instructionState.lFrame.selectedIndex = index;\n}\n\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nexport function getSelectedTNode() {\n  const lFrame = instructionState.lFrame;\n  return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nexport function ɵɵnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nexport function ɵɵnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nexport function ɵɵnamespaceHTML() {\n  namespaceHTMLInternal();\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nexport function namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\n\nexport function getNamespace(): string | null {\n  return instructionState.lFrame.currentNamespace;\n}\n\nlet _wasLastNodeCreated = true;\n\n/**\n * Retrieves a global flag that indicates whether the most recent DOM node\n * was created or hydrated.\n */\nexport function wasLastNodeCreated(): boolean {\n  return _wasLastNodeCreated;\n}\n\n/**\n * Sets a global flag to indicate whether the most recent DOM node\n * was created or hydrated.\n */\nexport function lastNodeWasCreated(flag: boolean): void {\n  _wasLastNodeCreated = flag;\n}\n"]}