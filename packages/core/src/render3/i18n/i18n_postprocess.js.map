{"version":3,"file":"i18n_postprocess.js","sourceRoot":"","sources":["i18n_postprocess.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,yBAAyB;AACzB,MAAM,gBAAgB,GAAG,CAAC,CAAC;AAC3B,MAAM,kCAAkC,GAAG,cAAc,CAAC;AAC1D,MAAM,sBAAsB,GAAG,gCAAgC,CAAC;AAChE,MAAM,kBAAkB,GAAG,2CAA2C,CAAC;AACvE,MAAM,0BAA0B,GAAG,iBAAiB,CAAC;AACrD,MAAM,cAAc,GAAG,0BAA0B,CAAC;AAClD,MAAM,wBAAwB,GAAG,MAAM,CAAC;AACxC,MAAM,qBAAqB,GAAG,YAAY,CAAC;AAM3C;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,UAAU,eAAe,CAC7B,OAAe,EACf,eAAmD,EAAE;IAErD;;;;;;;;;OASG;IACH,IAAI,MAAM,GAAW,OAAO,CAAC;IAC7B,IAAI,kCAAkC,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;QACrD,MAAM,OAAO,GAA8C,EAAE,CAAC;QAC9D,MAAM,gBAAgB,GAAa,CAAC,gBAAgB,CAAC,CAAC;QACtD,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,sBAAsB,EAAE,CAAC,CAAM,EAAE,GAAW,EAAE,IAAY,EAAU,EAAE;YAC5F,MAAM,OAAO,GAAG,GAAG,IAAI,IAAI,CAAC;YAC5B,MAAM,YAAY,GAA6B,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;YACtE,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC;gBACzB,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,WAAmB,EAAE,EAAE;oBACjD,MAAM,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;oBACvD,MAAM,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC;oBACrE,MAAM,kBAAkB,GAAG,wBAAwB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;oBACtE,YAAY,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,kBAAkB,EAAE,WAAW,CAAC,CAAC,CAAC;gBACnE,CAAC,CAAC,CAAC;gBACH,OAAO,CAAC,OAAO,CAAC,GAAG,YAAY,CAAC;YAClC,CAAC;YAED,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC;gBACzB,MAAM,IAAI,KAAK,CAAC,6CAA6C,OAAO,EAAE,CAAC,CAAC;YAC1E,CAAC;YAED,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACxE,IAAI,GAAG,GAAG,CAAC,CAAC;YACZ,0DAA0D;YAC1D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC7C,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,iBAAiB,EAAE,CAAC;oBAC7C,GAAG,GAAG,CAAC,CAAC;oBACR,MAAM;gBACR,CAAC;YACH,CAAC;YACD,8DAA8D;YAC9D,MAAM,CAAC,UAAU,EAAE,kBAAkB,EAAE,WAAW,CAAC,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;YACxE,IAAI,kBAAkB,EAAE,CAAC;gBACvB,gBAAgB,CAAC,GAAG,EAAE,CAAC;YACzB,CAAC;iBAAM,IAAI,iBAAiB,KAAK,UAAU,EAAE,CAAC;gBAC5C,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACpC,CAAC;YACD,qCAAqC;YACrC,YAAY,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YAC5B,OAAO,WAAW,CAAC;QACrB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,qDAAqD;IACrD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,MAAM,EAAE,CAAC;QACtC,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,kBAAkB,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,EAAU,EAAE;QAC1F,OAAO,YAAY,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,GAAG,YAAY,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;IACzF,CAAC,CAAC,CAAC;IAEH;;OAEG;IACH,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,0BAA0B,EAAE,CAAC,KAAK,EAAE,GAAG,EAAU,EAAE;QACzE,OAAO,YAAY,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAE,YAAY,CAAC,GAAG,CAAY,CAAC,CAAC,CAAC,KAAK,CAAC;IAClF,CAAC,CAAC,CAAC;IAEH;;;OAGG;IACH,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,GAAG,EAAU,EAAE;QAC7D,IAAI,YAAY,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE,CAAC;YACrC,MAAM,IAAI,GAAG,YAAY,CAAC,GAAG,CAAa,CAAC;YAC3C,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;gBACjB,MAAM,IAAI,KAAK,CAAC,qCAAqC,KAAK,cAAc,GAAG,EAAE,CAAC,CAAC;YACjF,CAAC;YACD,OAAO,IAAI,CAAC,KAAK,EAAG,CAAC;QACvB,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n\n// Parsed placeholder structure used in postprocessing (within `i18nPostprocess` function)\n// Contains the following fields: [templateId, isCloseTemplateTag, placeholder]\ntype PostprocessPlaceholder = [number, boolean, string];\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function i18nPostprocess(\n  message: string,\n  replacements: {[key: string]: string | string[]} = {},\n): string {\n  /**\n   * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n   *\n   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n   * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n   * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n   * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n   * front of �#6�. The post processing step restores the right order by keeping track of the\n   * template id stack and looks for placeholders that belong to the currently active template.\n   */\n  let result: string = message;\n  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n    const matches: {[key: string]: PostprocessPlaceholder[]} = {};\n    const templateIdsStack: number[] = [ROOT_TEMPLATE_ID];\n    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m: any, phs: string, tmpl: string): string => {\n      const content = phs || tmpl;\n      const placeholders: PostprocessPlaceholder[] = matches[content] || [];\n      if (!placeholders.length) {\n        content.split('|').forEach((placeholder: string) => {\n          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n        });\n        matches[content] = placeholders;\n      }\n\n      if (!placeholders.length) {\n        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n      }\n\n      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n      let idx = 0;\n      // find placeholder index that matches current template id\n      for (let i = 0; i < placeholders.length; i++) {\n        if (placeholders[i][0] === currentTemplateId) {\n          idx = i;\n          break;\n        }\n      }\n      // update template id stack based on the current tag extracted\n      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n      if (isCloseTemplateTag) {\n        templateIdsStack.pop();\n      } else if (currentTemplateId !== templateId) {\n        templateIdsStack.push(templateId);\n      }\n      // remove processed tag from the list\n      placeholders.splice(idx, 1);\n      return placeholder;\n    });\n  }\n\n  // return current result if no replacements specified\n  if (!Object.keys(replacements).length) {\n    return result;\n  }\n\n  /**\n   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n   */\n  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end): string => {\n    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n  });\n\n  /**\n   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n   */\n  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key): string => {\n    return replacements.hasOwnProperty(key) ? (replacements[key] as string) : match;\n  });\n\n  /**\n   * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n   * multiple ICUs have the same placeholder name\n   */\n  result = result.replace(PP_ICUS_REGEXP, (match, key): string => {\n    if (replacements.hasOwnProperty(key)) {\n      const list = replacements[key] as string[];\n      if (!list.length) {\n        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n      }\n      return list.shift()!;\n    }\n    return match;\n  });\n\n  return result;\n}\n"]}