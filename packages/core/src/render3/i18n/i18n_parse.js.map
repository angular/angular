{"version":3,"file":"i18n_parse.js","sourceRoot":"","sources":["i18n_parse.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {XSS_SECURITY_URL} from '../../error_details_base_url';\nimport {\n  getTemplateContent,\n  URI_ATTRS,\n  VALID_ATTRS,\n  VALID_ELEMENTS,\n} from '../../sanitization/html_sanitizer';\nimport {getInertBodyHelper} from '../../sanitization/inert_body';\nimport {_sanitizeUrl} from '../../sanitization/url_sanitizer';\nimport {\n  assertDefined,\n  assertEqual,\n  assertGreaterThanOrEqual,\n  assertOneOf,\n  assertString,\n} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\nimport {loadIcuContainerVisitor} from './i18n_icu_container_visitor';\n\nimport {getDocument} from '../interfaces/document';\nimport {\n  ELEMENT_MARKER,\n  I18nCreateOpCode,\n  I18nCreateOpCodes,\n  I18nElementNode,\n  I18nNode,\n  I18nNodeKind,\n  I18nPlaceholderNode,\n  I18nPlaceholderType,\n  I18nRemoveOpCodes,\n  I18nUpdateOpCode,\n  I18nUpdateOpCodes,\n  ICU_MARKER,\n  IcuCreateOpCode,\n  IcuCreateOpCodes,\n  IcuExpression,\n  IcuType,\n  TI18n,\n  TIcu,\n} from '../interfaces/i18n';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, TView} from '../interfaces/view';\nimport {getCurrentParentTNode, getCurrentTNode, setCurrentTNode} from '../state';\n\nimport {\n  i18nCreateOpCodesToString,\n  i18nRemoveOpCodesToString,\n  i18nUpdateOpCodesToString,\n  icuCreateOpCodesToString,\n} from './i18n_debug';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\nimport {ensureIcuContainerVisitorLoaded} from './i18n_tree_shaking';\nimport {\n  createTNodePlaceholder,\n  icuCreateOpCode,\n  isRootTemplateMessage,\n  setTIcu,\n  setTNodeInsertBeforeIndex,\n} from './i18n_util';\nimport {createTNodeAtIndex} from '../tnode_manipulation';\nimport {allocExpando} from '../view/construction';\n\nconst BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\nconst ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /�(\\d+)�/;\nconst ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\n\nconst MARKER = `�`;\nconst SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\nconst PH_REGEXP = /�(\\/?[#*]\\d+):?\\d*�/gi;\n\n/**\n * Angular uses the special entity &ngsp; as a placeholder for non-removable space.\n * It's replaced by the 0xE500 PUA (Private Use Areas) unicode character and later on replaced by a\n * space.\n * We are re-implementing the same idea since translations might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value: string): string {\n  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\nfunction attachDebugGetter<T>(obj: T, debugGetter: (this: T) => any): void {\n  if (ngDevMode) {\n    Object.defineProperty(obj, 'debug', {get: debugGetter, enumerable: false});\n  } else {\n    throw new Error(\n      'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!',\n    );\n  }\n}\n\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `ɵɵi18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nexport function i18nStartFirstCreatePass(\n  tView: TView,\n  parentTNodeIndex: number,\n  lView: LView,\n  index: number,\n  message: string,\n  subTemplateIndex: number,\n) {\n  const rootTNode = getCurrentParentTNode();\n  const createOpCodes: I18nCreateOpCodes = [] as any;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  const existingTNodeStack: TNode[][] = [[]];\n  const astStack: Array<Array<I18nNode>> = [[]];\n  if (ngDevMode) {\n    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n\n  message = getTranslationForTemplate(message, subTemplateIndex);\n  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n  for (let i = 0; i < msgParts.length; i++) {\n    let value = msgParts[i];\n    if ((i & 1) === 0) {\n      // Even indexes are text (including bindings & ICU expressions)\n      const parts = i18nParseTextIntoPartsAndICU(value);\n      for (let j = 0; j < parts.length; j++) {\n        let part = parts[j];\n        if ((j & 1) === 0) {\n          // `j` is odd therefore `part` is string\n          const text = part as string;\n          ngDevMode && assertString(text, 'Parsed ICU part should be string');\n          if (text !== '') {\n            i18nStartFirstCreatePassProcessTextNode(\n              astStack[0],\n              tView,\n              rootTNode,\n              existingTNodeStack[0],\n              createOpCodes,\n              updateOpCodes,\n              lView,\n              text,\n            );\n          }\n        } else {\n          // `j` is Even therefor `part` is an `ICUExpression`\n          const icuExpression: IcuExpression = part as IcuExpression;\n          // Verify that ICU expression has the right shape. Translations might contain invalid\n          // constructions (while original messages were correct), so ICU parsing at runtime may\n          // not succeed (thus `icuExpression` remains a string).\n          // Note: we intentionally retain the error here by not using `ngDevMode`, because\n          // the value can change based on the locale and users aren't guaranteed to hit\n          // an invalid string while they're developing.\n          if (typeof icuExpression !== 'object') {\n            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n          }\n          const icuContainerTNode = createTNodeAndAddOpCode(\n            tView,\n            rootTNode,\n            existingTNodeStack[0],\n            lView,\n            createOpCodes,\n            ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '',\n            true,\n          );\n          const icuNodeIndex = icuContainerTNode.index;\n          ngDevMode &&\n            assertGreaterThanOrEqual(\n              icuNodeIndex,\n              HEADER_OFFSET,\n              'Index must be in absolute LView offset',\n            );\n          icuStart(\n            astStack[0],\n            tView,\n            lView,\n            updateOpCodes,\n            parentTNodeIndex,\n            icuExpression,\n            icuNodeIndex,\n          );\n        }\n      }\n    } else {\n      // Odd indexes are placeholders (elements and sub-templates)\n      // At this point value is something like: '/#1:2' (originally coming from '�/#1:2�')\n      const isClosing = value.charCodeAt(0) === CharCode.SLASH;\n      const type = value.charCodeAt(isClosing ? 1 : 0);\n      ngDevMode && assertOneOf(type, CharCode.STAR, CharCode.HASH);\n      const index = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));\n      if (isClosing) {\n        existingTNodeStack.shift();\n        astStack.shift();\n        setCurrentTNode(getCurrentParentTNode()!, false);\n      } else {\n        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n        existingTNodeStack.unshift([]);\n        setCurrentTNode(tNode, true);\n\n        const placeholderNode: I18nPlaceholderNode = {\n          kind: I18nNodeKind.PLACEHOLDER,\n          index,\n          children: [],\n          type:\n            type === CharCode.HASH ? I18nPlaceholderType.ELEMENT : I18nPlaceholderType.SUBTEMPLATE,\n        };\n        astStack[0].push(placeholderNode);\n        astStack.unshift(placeholderNode.children);\n      }\n    }\n  }\n\n  tView.data[index] = <TI18n>{\n    create: createOpCodes,\n    update: updateOpCodes,\n    ast: astStack[0],\n    parentTNodeIndex,\n  };\n}\n\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(\n  tView: TView,\n  rootTNode: TNode | null,\n  existingTNodes: TNode[],\n  lView: LView,\n  createOpCodes: I18nCreateOpCodes,\n  text: string | null,\n  isICU: boolean,\n): TNode {\n  const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n  let parentTNode = getCurrentParentTNode();\n\n  if (rootTNode === parentTNode) {\n    // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n    // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n    // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n    parentTNode = null;\n  }\n  if (parentTNode === null) {\n    // If we don't have a parent that means that we can eagerly add nodes.\n    // If we have a parent than these nodes can't be added now (as the parent has not been created\n    // yet) and instead the `parentTNode` is responsible for adding it. See\n    // `TNode.insertBeforeIndex`\n    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n  }\n  if (isICU) {\n    opCode |= I18nCreateOpCode.COMMENT;\n    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n  }\n  createOpCodes.push(opCode, text === null ? '' : text);\n  // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n  // bindings are.\n  const tNode = createTNodeAtIndex(\n    tView,\n    i18nNodeIdx,\n    isICU ? TNodeType.Icu : TNodeType.Text,\n    text === null ? (ngDevMode ? '{{?}}' : '') : text,\n    null,\n  );\n  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n  const tNodeIdx = tNode.index;\n  setCurrentTNode(tNode, false /* Text nodes are self closing */);\n  if (parentTNode !== null && rootTNode !== parentTNode) {\n    // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n    // We have to make sure to add ourselves to the parent.\n    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n  }\n  return tNode;\n}\n\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(\n  ast: I18nNode[],\n  tView: TView,\n  rootTNode: TNode | null,\n  existingTNodes: TNode[],\n  createOpCodes: I18nCreateOpCodes,\n  updateOpCodes: I18nUpdateOpCodes,\n  lView: LView,\n  text: string,\n): void {\n  const hasBinding = text.match(BINDING_REGEXP);\n  const tNode = createTNodeAndAddOpCode(\n    tView,\n    rootTNode,\n    existingTNodes,\n    lView,\n    createOpCodes,\n    hasBinding ? null : text,\n    false,\n  );\n  const index = tNode.index;\n  if (hasBinding) {\n    generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);\n  }\n  ast.push({kind: I18nNodeKind.TEXT, index});\n}\n\n/**\n * See `i18nAttributes` above.\n */\nexport function i18nAttributesFirstPass(tView: TView, index: number, values: string[]) {\n  const previousElement = getCurrentTNode()!;\n  const previousElementIndex = previousElement.index;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  if (tView.firstCreatePass && tView.data[index] === null) {\n    for (let i = 0; i < values.length; i += 2) {\n      const attrName = values[i];\n      const message = values[i + 1];\n\n      if (message !== '') {\n        // Check if attribute value contains an ICU and throw an error if that's the case.\n        // ICUs in element attributes are not supported.\n        // Note: we intentionally retain the error here by not using `ngDevMode`, because\n        // the `value` can change based on the locale and users aren't guaranteed to hit\n        // an invalid string while they're developing.\n        if (ICU_REGEXP.test(message)) {\n          throw new Error(\n            `ICU expressions are not supported in attributes. Message: \"${message}\".`,\n          );\n        }\n\n        // i18n attributes that hit this code path are guaranteed to have bindings, because\n        // the compiler treats static i18n attributes as regular attribute bindings.\n        // Since this may not be the first i18n attribute on this element we need to pass in how\n        // many previous bindings there have already been.\n        generateBindingUpdateOpCodes(\n          updateOpCodes,\n          message,\n          previousElementIndex,\n          attrName,\n          countBindings(updateOpCodes),\n          null,\n        );\n      }\n    }\n    tView.data[index] = updateOpCodes;\n  }\n}\n\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(\n  updateOpCodes: I18nUpdateOpCodes,\n  str: string,\n  destinationNode: number,\n  attrName: string | null,\n  bindingStart: number,\n  sanitizeFn: SanitizerFn | null,\n): number {\n  ngDevMode &&\n    assertGreaterThanOrEqual(\n      destinationNode,\n      HEADER_OFFSET,\n      'Index must be in absolute LView offset',\n    );\n  const maskIndex = updateOpCodes.length; // Location of mask\n  const sizeIndex = maskIndex + 1; // location of size for skipping\n  updateOpCodes.push(null, null); // Alloc space for mask and size\n  const startIndex = maskIndex + 2; // location of first allocation.\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  const textParts = str.split(BINDING_REGEXP);\n  let mask = 0;\n\n  for (let j = 0; j < textParts.length; j++) {\n    const textValue = textParts[j];\n\n    if (j & 1) {\n      // Odd indexes are bindings\n      const bindingIndex = bindingStart + parseInt(textValue, 10);\n      updateOpCodes.push(-1 - bindingIndex);\n      mask = mask | toMaskBit(bindingIndex);\n    } else if (textValue !== '') {\n      // Even indexes are text\n      updateOpCodes.push(textValue);\n    }\n  }\n\n  updateOpCodes.push(\n    (destinationNode << I18nUpdateOpCode.SHIFT_REF) |\n      (attrName ? I18nUpdateOpCode.Attr : I18nUpdateOpCode.Text),\n  );\n  if (attrName) {\n    updateOpCodes.push(attrName, sanitizeFn);\n  }\n  updateOpCodes[maskIndex] = mask;\n  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n  return mask;\n}\n\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes: I18nUpdateOpCodes): number {\n  let count = 0;\n  for (let i = 0; i < opCodes.length; i++) {\n    const opCode = opCodes[i];\n    // Bindings are negative numbers.\n    if (typeof opCode === 'number' && opCode < 0) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex: number): number {\n  return 1 << Math.min(bindingIndex, 31);\n}\n\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message: string): string {\n  let match;\n  let res = '';\n  let index = 0;\n  let inTemplate = false;\n  let tagMatched;\n\n  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n    if (!inTemplate) {\n      res += message.substring(index, match.index + match[0].length);\n      tagMatched = match[1];\n      inTemplate = true;\n    } else {\n      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n        index = match.index;\n        inTemplate = false;\n      }\n    }\n  }\n\n  ngDevMode &&\n    assertEqual(\n      inTemplate,\n      false,\n      `Tag mismatch: unable to find the end of the sub-template in the translation \"${message}\"`,\n    );\n\n  res += message.slice(index);\n  return res;\n}\n\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```html\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nexport function getTranslationForTemplate(message: string, subTemplateIndex: number) {\n  if (isRootTemplateMessage(subTemplateIndex)) {\n    // We want the root template message, ignore all sub-templates\n    return removeInnerTemplateTranslation(message);\n  } else {\n    // We want a specific sub-template\n    const start =\n      message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n    return removeInnerTemplateTranslation(message.substring(start, end));\n  }\n}\n\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nfunction icuStart(\n  ast: I18nNode[],\n  tView: TView,\n  lView: LView,\n  updateOpCodes: I18nUpdateOpCodes,\n  parentIdx: number,\n  icuExpression: IcuExpression,\n  anchorIdx: number,\n) {\n  ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n  let bindingMask = 0;\n  const tIcu: TIcu = {\n    type: icuExpression.type,\n    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n    anchorIdx,\n    cases: [],\n    create: [],\n    remove: [],\n    update: [],\n  };\n  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n  setTIcu(tView, anchorIdx, tIcu);\n  const values = icuExpression.values;\n  const cases: I18nNode[][] = [];\n  for (let i = 0; i < values.length; i++) {\n    // Each value is an array of strings & other ICU expressions\n    const valueArr = values[i];\n    const nestedIcus: IcuExpression[] = [];\n    for (let j = 0; j < valueArr.length; j++) {\n      const value = valueArr[j];\n      if (typeof value !== 'string') {\n        // It is an nested ICU expression\n        const icuIndex = nestedIcus.push(value as IcuExpression) - 1;\n        // Replace nested ICU expression by a comment node\n        valueArr[j] = `<!--�${icuIndex}�-->`;\n      }\n    }\n    const caseAst: I18nNode[] = [];\n    cases.push(caseAst);\n    bindingMask =\n      parseIcuCase(\n        caseAst,\n        tView,\n        tIcu,\n        lView,\n        updateOpCodes,\n        parentIdx,\n        icuExpression.cases[i],\n        valueArr.join(''),\n        nestedIcus,\n      ) | bindingMask;\n  }\n  if (bindingMask) {\n    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n  }\n  ast.push({\n    kind: I18nNodeKind.ICU,\n    index: anchorIdx,\n    cases,\n    currentCaseLViewIndex: tIcu.currentCaseLViewIndex,\n  });\n}\n\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nfunction parseICUBlock(pattern: string): IcuExpression {\n  const cases = [];\n  const values: (string | IcuExpression)[][] = [];\n  let icuType = IcuType.plural;\n  let mainBinding = 0;\n  pattern = pattern.replace(\n    ICU_BLOCK_REGEXP,\n    function (str: string, binding: string, type: string) {\n      if (type === 'select') {\n        icuType = IcuType.select;\n      } else {\n        icuType = IcuType.plural;\n      }\n      mainBinding = parseInt(binding.slice(1), 10);\n      return '';\n    },\n  );\n\n  const parts = i18nParseTextIntoPartsAndICU(pattern) as string[];\n  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n  for (let pos = 0; pos < parts.length; ) {\n    let key = parts[pos++].trim();\n    if (icuType === IcuType.plural) {\n      // Key can be \"=x\", we just want \"x\"\n      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n    }\n    if (key.length) {\n      cases.push(key);\n    }\n\n    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]) as string[];\n    if (cases.length > values.length) {\n      values.push(blocks);\n    }\n  }\n\n  // TODO(ocombe): support ICU expressions in attributes, see #21615\n  return {type: icuType, mainBinding: mainBinding, cases, values};\n}\n\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nfunction i18nParseTextIntoPartsAndICU(pattern: string): (string | IcuExpression)[] {\n  if (!pattern) {\n    return [];\n  }\n\n  let prevPos = 0;\n  const braceStack = [];\n  const results: (string | IcuExpression)[] = [];\n  const braces = /[{}]/g;\n  // lastIndex doesn't get set to 0 so we have to.\n  braces.lastIndex = 0;\n\n  let match;\n  while ((match = braces.exec(pattern))) {\n    const pos = match.index;\n    if (match[0] == '}') {\n      braceStack.pop();\n\n      if (braceStack.length == 0) {\n        // End of the block.\n        const block = pattern.substring(prevPos, pos);\n        if (ICU_BLOCK_REGEXP.test(block)) {\n          results.push(parseICUBlock(block));\n        } else {\n          results.push(block);\n        }\n\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        const substring = pattern.substring(prevPos, pos);\n        results.push(substring);\n        prevPos = pos + 1;\n      }\n      braceStack.push('{');\n    }\n  }\n\n  const substring = pattern.substring(prevPos);\n  results.push(substring);\n  return results;\n}\n\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nfunction parseIcuCase(\n  ast: I18nNode[],\n  tView: TView,\n  tIcu: TIcu,\n  lView: LView,\n  updateOpCodes: I18nUpdateOpCodes,\n  parentIdx: number,\n  caseName: string,\n  unsafeCaseHtml: string,\n  nestedIcus: IcuExpression[],\n): number {\n  const create: IcuCreateOpCodes = [] as any;\n  const remove: I18nRemoveOpCodes = [] as any;\n  const update: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(create, icuCreateOpCodesToString);\n    attachDebugGetter(remove, i18nRemoveOpCodesToString);\n    attachDebugGetter(update, i18nUpdateOpCodesToString);\n  }\n  tIcu.cases.push(caseName);\n  tIcu.create.push(create);\n  tIcu.remove.push(remove);\n  tIcu.update.push(update);\n\n  const inertBodyHelper = getInertBodyHelper(getDocument());\n  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n  ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n  const inertRootNode = (getTemplateContent(inertBodyElement!) as Element) || inertBodyElement;\n  if (inertRootNode) {\n    return walkIcuTree(\n      ast,\n      tView,\n      tIcu,\n      lView,\n      updateOpCodes,\n      create,\n      remove,\n      update,\n      inertRootNode,\n      parentIdx,\n      nestedIcus,\n      0,\n    );\n  } else {\n    return 0;\n  }\n}\n\nfunction walkIcuTree(\n  ast: I18nNode[],\n  tView: TView,\n  tIcu: TIcu,\n  lView: LView,\n  sharedUpdateOpCodes: I18nUpdateOpCodes,\n  create: IcuCreateOpCodes,\n  remove: I18nRemoveOpCodes,\n  update: I18nUpdateOpCodes,\n  parentNode: Element,\n  parentIdx: number,\n  nestedIcus: IcuExpression[],\n  depth: number,\n): number {\n  let bindingMask = 0;\n  let currentNode = parentNode.firstChild;\n  while (currentNode) {\n    const newIndex = allocExpando(tView, lView, 1, null);\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = currentNode as Element;\n        const tagName = element.tagName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n          tView.data[newIndex] = tagName;\n          const elAttrs = element.attributes;\n          for (let i = 0; i < elAttrs.length; i++) {\n            const attr = elAttrs.item(i)!;\n            const lowerAttrName = attr.name.toLowerCase();\n            const hasBinding = !!attr.value.match(BINDING_REGEXP);\n            // we assume the input string is safe, unless it's using a binding\n            if (hasBinding) {\n              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                if (URI_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(\n                    update,\n                    attr.value,\n                    newIndex,\n                    attr.name,\n                    0,\n                    _sanitizeUrl,\n                  );\n                } else {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                }\n              } else {\n                ngDevMode &&\n                  console.warn(\n                    `WARNING: ignoring unsafe attribute value ` +\n                      `${lowerAttrName} on element ${tagName} ` +\n                      `(see ${XSS_SECURITY_URL})`,\n                  );\n              }\n            } else {\n              addCreateAttribute(create, newIndex, attr);\n            }\n          }\n          const elementNode: I18nElementNode = {\n            kind: I18nNodeKind.ELEMENT,\n            index: newIndex,\n            children: [],\n          };\n          ast.push(elementNode);\n          // Parse the children of this node (if any)\n          bindingMask =\n            walkIcuTree(\n              elementNode.children,\n              tView,\n              tIcu,\n              lView,\n              sharedUpdateOpCodes,\n              create,\n              remove,\n              update,\n              currentNode as Element,\n              newIndex,\n              nestedIcus,\n              depth + 1,\n            ) | bindingMask;\n          addRemoveNode(remove, newIndex, depth);\n        }\n        break;\n      case Node.TEXT_NODE:\n        const value = currentNode.textContent || '';\n        const hasBinding = value.match(BINDING_REGEXP);\n        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n        addRemoveNode(remove, newIndex, depth);\n        if (hasBinding) {\n          bindingMask =\n            generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n        }\n        ast.push({\n          kind: I18nNodeKind.TEXT,\n          index: newIndex,\n        });\n        break;\n      case Node.COMMENT_NODE:\n        // Check if the comment node is a placeholder for a nested ICU\n        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n        if (isNestedIcu) {\n          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n          const icuExpression: IcuExpression = nestedIcus[nestedIcuIndex];\n          // Create the comment node that will anchor the ICU expression\n          addCreateNodeAndAppend(\n            create,\n            ICU_MARKER,\n            ngDevMode ? `nested ICU ${nestedIcuIndex}` : '',\n            parentIdx,\n            newIndex,\n          );\n          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n          addRemoveNestedIcu(remove, newIndex, depth);\n        }\n        break;\n    }\n    currentNode = currentNode.nextSibling;\n  }\n  return bindingMask;\n}\n\nfunction addRemoveNode(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(index);\n  }\n}\n\nfunction addRemoveNestedIcu(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(~index); // remove ICU at `index`\n    remove.push(index); // remove ICU comment at `index`\n  }\n}\n\nfunction addUpdateIcuSwitch(\n  update: I18nUpdateOpCodes,\n  icuExpression: IcuExpression,\n  index: number,\n) {\n  update.push(\n    toMaskBit(icuExpression.mainBinding),\n    2,\n    -1 - icuExpression.mainBinding,\n    (index << I18nUpdateOpCode.SHIFT_REF) | I18nUpdateOpCode.IcuSwitch,\n  );\n}\n\nfunction addUpdateIcuUpdate(update: I18nUpdateOpCodes, bindingMask: number, index: number) {\n  update.push(bindingMask, 1, (index << I18nUpdateOpCode.SHIFT_REF) | I18nUpdateOpCode.IcuUpdate);\n}\n\nfunction addCreateNodeAndAppend(\n  create: IcuCreateOpCodes,\n  marker: null | ICU_MARKER | ELEMENT_MARKER,\n  text: string,\n  appendToParentIdx: number,\n  createAtIdx: number,\n) {\n  if (marker !== null) {\n    create.push(marker);\n  }\n  create.push(\n    text,\n    createAtIdx,\n    icuCreateOpCode(IcuCreateOpCode.AppendChild, appendToParentIdx, createAtIdx),\n  );\n}\n\nfunction addCreateAttribute(create: IcuCreateOpCodes, newIndex: number, attr: Attr) {\n  create.push(\n    (newIndex << IcuCreateOpCode.SHIFT_REF) | IcuCreateOpCode.Attr,\n    attr.name,\n    attr.value,\n  );\n}\n"]}