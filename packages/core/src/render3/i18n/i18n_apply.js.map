{"version":3,"file":"i18n_apply.js","sourceRoot":"","sources":["i18n_apply.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {claimDehydratedIcuCase, isI18nHydrationSupportEnabled} from '../../hydration/i18n';\nimport {locateI18nRNodeByIndex} from '../../hydration/node_lookup_utils';\nimport {isDisconnectedNode, markRNodeAsClaimedByHydration} from '../../hydration/utils';\nimport {getPluralCase} from '../../i18n/localization';\nimport {\n  assertDefined,\n  assertDomNode,\n  assertEqual,\n  assertGreaterThan,\n  assertIndexInRange,\n  throwError,\n} from '../../util/assert';\nimport {assertIndexInExpandoRange, assertTIcu} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {setPropertyAndInputs, setElementAttribute} from '../instructions/shared';\nimport {\n  ELEMENT_MARKER,\n  I18nCreateOpCode,\n  I18nCreateOpCodes,\n  I18nUpdateOpCode,\n  I18nUpdateOpCodes,\n  ICU_MARKER,\n  IcuCreateOpCode,\n  IcuCreateOpCodes,\n  IcuType,\n  TI18n,\n  TIcu,\n} from '../interfaces/i18n';\nimport {TNode} from '../interfaces/node';\nimport {RElement, RNode, RText} from '../interfaces/renderer_dom';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, HYDRATION, LView, RENDERER, TView} from '../interfaces/view';\nimport {\n  createCommentNode,\n  createElementNode,\n  createTextNode,\n  nativeInsertBefore,\n  nativeRemoveNode,\n  updateTextNode,\n} from '../dom_node_manipulation';\nimport {\n  getBindingIndex,\n  isInSkipHydrationBlock,\n  lastNodeWasCreated,\n  wasLastNodeCreated,\n} from '../state';\nimport {renderStringify} from '../util/stringify_utils';\nimport {getNativeByIndex, unwrapRNode} from '../util/view_utils';\n\nimport {getLocaleId} from './i18n_locale_id';\nimport {\n  getCurrentICUCaseIndex,\n  getParentFromIcuCreateOpCode,\n  getRefFromIcuCreateOpCode,\n  getTIcu,\n} from './i18n_util';\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `ɵɵi18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `ɵɵi18nExp` then all changes past 32nd `ɵɵi18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `ɵɵi18nExp`\n */\nlet changeMaskCounter = 0;\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `ɵɵi18nExp`.\n *\n * @param hasChange did `ɵɵi18nExp` detect a change.\n */\nexport function setMaskBit(hasChange: boolean) {\n  if (hasChange) {\n    changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n  }\n  changeMaskCounter++;\n}\n\nexport function applyI18n(tView: TView, lView: LView, index: number) {\n  if (changeMaskCounter > 0) {\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const tI18n = tView.data[index] as TI18n | I18nUpdateOpCodes;\n    // When `index` points to an `ɵɵi18nAttributes` then we have an array otherwise `TI18n`\n    const updateOpCodes: I18nUpdateOpCodes = Array.isArray(tI18n)\n      ? (tI18n as I18nUpdateOpCodes)\n      : (tI18n as TI18n).update;\n    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n  }\n  // Reset changeMask & maskBit to default for the next update cycle\n  changeMask = 0b0;\n  changeMaskCounter = 0;\n}\n\nfunction createNodeWithoutHydration(\n  lView: LView,\n  textOrName: string,\n  nodeType: typeof Node.COMMENT_NODE | typeof Node.TEXT_NODE | typeof Node.ELEMENT_NODE,\n) {\n  const renderer = lView[RENDERER];\n\n  switch (nodeType) {\n    case Node.COMMENT_NODE:\n      return createCommentNode(renderer, textOrName);\n\n    case Node.TEXT_NODE:\n      return createTextNode(renderer, textOrName);\n\n    case Node.ELEMENT_NODE:\n      return createElementNode(renderer, textOrName, null);\n  }\n}\n\nlet _locateOrCreateNode: typeof locateOrCreateNodeImpl = (lView, index, textOrName, nodeType) => {\n  lastNodeWasCreated(true);\n  return createNodeWithoutHydration(lView, textOrName, nodeType);\n};\n\nfunction locateOrCreateNodeImpl(\n  lView: LView,\n  index: number,\n  textOrName: string,\n  nodeType: typeof Node.COMMENT_NODE | typeof Node.TEXT_NODE | typeof Node.ELEMENT_NODE,\n) {\n  const hydrationInfo = lView[HYDRATION];\n  const noOffsetIndex = index - HEADER_OFFSET;\n  const isNodeCreationMode =\n    !isI18nHydrationSupportEnabled() ||\n    !hydrationInfo ||\n    isInSkipHydrationBlock() ||\n    isDisconnectedNode(hydrationInfo, noOffsetIndex);\n\n  lastNodeWasCreated(isNodeCreationMode);\n  if (isNodeCreationMode) {\n    return createNodeWithoutHydration(lView, textOrName, nodeType);\n  }\n\n  const native = locateI18nRNodeByIndex(hydrationInfo!, noOffsetIndex) as RNode;\n\n  // TODO: Improve error handling\n  //\n  // Other hydration paths use validateMatchingNode() in order to provide\n  // detailed information in development mode about the expected DOM.\n  // However, not every node in an i18n block has a TNode. Instead, we\n  // need to be able to use the AST to generate a similar message.\n  ngDevMode && assertDefined(native, 'expected native element');\n  ngDevMode && assertEqual((native as Node).nodeType, nodeType, 'expected matching nodeType');\n  ngDevMode &&\n    nodeType === Node.ELEMENT_NODE &&\n    assertEqual(\n      (native as HTMLElement).tagName.toLowerCase(),\n      textOrName.toLowerCase(),\n      'expecting matching tagName',\n    );\n  ngDevMode && markRNodeAsClaimedByHydration(native);\n\n  return native;\n}\n\nexport function enableLocateOrCreateI18nNodeImpl() {\n  _locateOrCreateNode = locateOrCreateNodeImpl;\n}\n\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nexport function applyCreateOpCodes(\n  lView: LView,\n  createOpCodes: I18nCreateOpCodes,\n  parentRNode: RElement | null,\n  insertInFrontOf: RElement | null,\n): void {\n  const renderer = lView[RENDERER];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++] as any;\n    const text = createOpCodes[i] as string;\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow =\n      (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    let rNode = lView[index];\n    let lastNodeWasCreated = false;\n    if (rNode === null) {\n      // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n      // case which was already instantiated, no need to create new DOM nodes.\n      rNode = lView[index] = _locateOrCreateNode(\n        lView,\n        index,\n        text,\n        isComment ? Node.COMMENT_NODE : Node.TEXT_NODE,\n      );\n      lastNodeWasCreated = wasLastNodeCreated();\n    }\n    if (appendNow && parentRNode !== null && lastNodeWasCreated) {\n      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n    }\n  }\n}\n\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nexport function applyMutableOpCodes(\n  tView: TView,\n  mutableOpCodes: IcuCreateOpCodes,\n  lView: LView,\n  anchorRNode: RNode,\n): void {\n  ngDevMode && assertDomNode(anchorRNode);\n  const renderer = lView[RENDERER];\n  // `rootIdx` represents the node into which all inserts happen.\n  let rootIdx: number | null = null;\n  // `rootRNode` represents the real node into which we insert. This can be different from\n  // `lView[rootIdx]` if we have projection.\n  //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n  //    LView which has no parent.)\n  //  - `RElement` The element representing the root after taking projection into account.\n  let rootRNode!: RElement | null;\n  for (let i = 0; i < mutableOpCodes.length; i++) {\n    const opCode = mutableOpCodes[i];\n    if (typeof opCode == 'string') {\n      const textNodeIndex = mutableOpCodes[++i] as number;\n      if (lView[textNodeIndex] === null) {\n        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);\n      }\n    } else if (typeof opCode == 'number') {\n      switch (opCode & IcuCreateOpCode.MASK_INSTRUCTION) {\n        case IcuCreateOpCode.AppendChild:\n          const parentIdx = getParentFromIcuCreateOpCode(opCode);\n          if (rootIdx === null) {\n            // The first operation should save the `rootIdx` because the first operation\n            // must insert into the root. (Only subsequent operations can insert into a dynamic\n            // parent)\n            rootIdx = parentIdx;\n            rootRNode = renderer.parentNode(anchorRNode);\n          }\n          let insertInFrontOf: RNode | null;\n          let parentRNode: RElement | null;\n          if (parentIdx === rootIdx) {\n            insertInFrontOf = anchorRNode;\n            parentRNode = rootRNode;\n          } else {\n            insertInFrontOf = null;\n            parentRNode = unwrapRNode(lView[parentIdx]) as RElement;\n          }\n          // FIXME(misko): Refactor with `processI18nText`\n          if (parentRNode !== null) {\n            // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n            // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n            // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n            // get picked up and added.\n            ngDevMode && assertDomNode(parentRNode);\n            const refIdx = getRefFromIcuCreateOpCode(opCode);\n            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n            // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n            // which can't have components.\n            const child = lView[refIdx] as RElement;\n            ngDevMode && assertDomNode(child);\n            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n            const tIcu = getTIcu(tView, refIdx);\n            if (tIcu !== null && typeof tIcu === 'object') {\n              // If we just added a comment node which has ICU then that ICU may have already been\n              // rendered and therefore we need to re-add it here.\n              ngDevMode && assertTIcu(tIcu);\n              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n              if (caseIndex !== null) {\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n              }\n            }\n          }\n          break;\n        case IcuCreateOpCode.Attr:\n          const elementNodeIndex = opCode >>> IcuCreateOpCode.SHIFT_REF;\n          const attrName = mutableOpCodes[++i] as string;\n          const attrValue = mutableOpCodes[++i] as string;\n          // This code is used for ICU expressions only, since we don't support\n          // directives/components in ICUs, we don't need to worry about inputs here\n          setElementAttribute(\n            renderer,\n            getNativeByIndex(elementNodeIndex, lView) as RElement,\n            null,\n            null,\n            attrName,\n            attrValue,\n            null,\n          );\n          break;\n        default:\n          if (ngDevMode) {\n            throw new RuntimeError(\n              RuntimeErrorCode.INVALID_I18N_STRUCTURE,\n              `Unable to determine the type of mutate operation for \"${opCode}\"`,\n            );\n          }\n      }\n    } else {\n      switch (opCode) {\n        case ICU_MARKER:\n          const commentValue = mutableOpCodes[++i] as string;\n          const commentNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[commentNodeIndex] === null) {\n            ngDevMode &&\n              assertEqual(\n                typeof commentValue,\n                'string',\n                `Expected \"${commentValue}\" to be a comment node value`,\n              );\n            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n            const commentRNode = (lView[commentNodeIndex] = _locateOrCreateNode(\n              lView,\n              commentNodeIndex,\n              commentValue,\n              Node.COMMENT_NODE,\n            ));\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(commentRNode, lView);\n          }\n          break;\n        case ELEMENT_MARKER:\n          const tagName = mutableOpCodes[++i] as string;\n          const elementNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[elementNodeIndex] === null) {\n            ngDevMode &&\n              assertEqual(\n                typeof tagName,\n                'string',\n                `Expected \"${tagName}\" to be an element node tag name`,\n              );\n\n            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n            const elementRNode = (lView[elementNodeIndex] = _locateOrCreateNode(\n              lView,\n              elementNodeIndex,\n              tagName,\n              Node.ELEMENT_NODE,\n            ));\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(elementRNode, lView);\n          }\n          break;\n        default:\n          ngDevMode &&\n            throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n      }\n    }\n  }\n}\n\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nexport function applyUpdateOpCodes(\n  tView: TView,\n  lView: LView,\n  updateOpCodes: I18nUpdateOpCodes,\n  bindingsStartIndex: number,\n  changeMask: number,\n) {\n  for (let i = 0; i < updateOpCodes.length; i++) {\n    // bit code to check if we should apply the next update\n    const checkBit = updateOpCodes[i] as number;\n    // Number of opCodes to skip until next set of update codes\n    const skipCodes = updateOpCodes[++i] as number;\n    if (checkBit & changeMask) {\n      // The value has been updated since last checked\n      let value = '';\n      for (let j = i + 1; j <= i + skipCodes; j++) {\n        const opCode = updateOpCodes[j];\n        if (typeof opCode == 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // Negative opCode represent `i18nExp` values offset.\n            value += renderStringify(lView[bindingsStartIndex - opCode]);\n          } else {\n            const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n              case I18nUpdateOpCode.Attr:\n                const propName = updateOpCodes[++j] as string;\n                const sanitizeFn = updateOpCodes[++j] as SanitizerFn | null;\n                const tNodeOrTagName = tView.data[nodeIndex] as TNode | string;\n                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                if (typeof tNodeOrTagName === 'string') {\n                  // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                  // not have TNode), in which case we know that there are no directives, and hence\n                  // we use attribute setting.\n                  setElementAttribute(\n                    lView[RENDERER],\n                    lView[nodeIndex],\n                    null,\n                    tNodeOrTagName,\n                    propName,\n                    value,\n                    sanitizeFn,\n                  );\n                } else {\n                  setPropertyAndInputs(\n                    tNodeOrTagName,\n                    lView,\n                    propName,\n                    value,\n                    lView[RENDERER],\n                    sanitizeFn,\n                  );\n                }\n                break;\n              case I18nUpdateOpCode.Text:\n                const rText = lView[nodeIndex] as RText | null;\n                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                break;\n              case I18nUpdateOpCode.IcuSwitch:\n                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex)!, lView, value);\n                break;\n              case I18nUpdateOpCode.IcuUpdate:\n                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex)!, bindingsStartIndex, lView);\n                break;\n            }\n          }\n        }\n      }\n    } else {\n      const opCode = updateOpCodes[i + 1] as number;\n      if (opCode > 0 && (opCode & I18nUpdateOpCode.MASK_OPCODE) === I18nUpdateOpCode.IcuUpdate) {\n        // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n        // we still need to execute `icuUpdateCase` because the case has changed recently due to\n        // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n        // pairs.)\n        const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n        const tIcu = getTIcu(tView, nodeIndex)!;\n        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n        if (currentIndex < 0) {\n          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n        }\n      }\n    }\n    i += skipCodes;\n  }\n}\n\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView: TView, tIcu: TIcu, bindingsStartIndex: number, lView: LView) {\n  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n  if (activeCaseIndex !== null) {\n    let mask = changeMask;\n    if (activeCaseIndex < 0) {\n      // Clear the flag.\n      // Negative number means that the ICU was freshly created and we need to force the update.\n      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n      // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n      mask = -1;\n    }\n    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n  }\n}\n\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView: TView, tIcu: TIcu, lView: LView, value: string) {\n  // Rebuild a new case for this ICU\n  const caseIndex = getCaseIndex(tIcu, value);\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== caseIndex) {\n    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n    if (caseIndex !== null) {\n      // Add the nodes for the new case\n      const anchorRNode = lView[tIcu.anchorIdx];\n      if (anchorRNode) {\n        ngDevMode && assertDomNode(anchorRNode);\n        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n      }\n      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);\n    }\n  }\n}\n\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView: TView, tIcu: TIcu, lView: LView) {\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== null) {\n    const removeCodes = tIcu.remove[activeCaseIndex];\n    for (let i = 0; i < removeCodes.length; i++) {\n      const nodeOrIcuIndex = removeCodes[i] as number;\n      if (nodeOrIcuIndex > 0) {\n        // Positive numbers are `RNode`s.\n        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n      } else {\n        // Negative numbers are ICUs\n        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex)!, lView);\n      }\n    }\n  }\n}\n\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression: TIcu, bindingValue: string): number | null {\n  let index = icuExpression.cases.indexOf(bindingValue);\n  if (index === -1) {\n    switch (icuExpression.type) {\n      case IcuType.plural: {\n        const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n        index = icuExpression.cases.indexOf(resolvedCase);\n        if (index === -1 && resolvedCase !== 'other') {\n          index = icuExpression.cases.indexOf('other');\n        }\n        break;\n      }\n      case IcuType.select: {\n        index = icuExpression.cases.indexOf('other');\n        break;\n      }\n    }\n  }\n  return index === -1 ? null : index;\n}\n"]}