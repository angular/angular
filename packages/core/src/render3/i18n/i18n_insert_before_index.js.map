{"version":3,"file":"i18n_insert_before_index.js","sourceRoot":"","sources":["i18n_insert_before_index.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,WAAW,EAAC,MAAM,mBAAmB,CAAC;AAE9C,OAAO,EAAC,eAAe,EAAC,MAAM,sBAAsB,CAAC;AACrD,OAAO,EAAC,+BAA+B,EAAE,uBAAuB,EAAC,MAAM,2BAA2B,CAAC;AAEnG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,MAAM,UAAU,kCAAkC,CAAC,cAAuB,EAAE,QAAe;IACzF,mBAAmB;IACnB,SAAS;QACP,WAAW,CAAC,QAAQ,CAAC,iBAAiB,EAAE,IAAI,EAAE,6CAA6C,CAAC,CAAC;IAE/F,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC9B,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC9B,KAAK,IAAI,CAAC,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACpD,MAAM,aAAa,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;YACxC,0FAA0F;YAC1F,6BAA6B;YAC7B,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE,CAAC;gBAC/B,IACE,uBAAuB,CAAC,aAAa,EAAE,QAAQ,CAAC;oBAChD,oBAAoB,CAAC,aAAa,CAAC,KAAK,IAAI,EAC5C,CAAC;oBACD,sFAAsF;oBACtF,oCAAoC;oBACpC,oBAAoB,CAAC,aAAa,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC;gBACtD,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC;AAED,SAAS,UAAU,CAAC,KAAY;IAC9B,OAAO,CAAC,CAAC,KAAK,CAAC,IAAI,iCAAwB,CAAC,CAAC;AAC/C,CAAC;AAED,SAAS,uBAAuB,CAAC,aAAoB,EAAE,QAAe;IACpE,OAAO,UAAU,CAAC,QAAQ,CAAC,IAAI,aAAa,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;AACtE,CAAC;AAED,SAAS,oBAAoB,CAAC,KAAY;IACxC,MAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,CAAC;IACtC,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;AACjD,CAAC;AAED,SAAS,oBAAoB,CAAC,KAAY,EAAE,KAAa;IACvD,MAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,CAAC;IACtC,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QACzB,kFAAkF;QAClF,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;IACnB,CAAC;SAAM,CAAC;QACN,eAAe,CAAC,+BAA+B,EAAE,uBAAuB,CAAC,CAAC;QAC1E,KAAK,CAAC,iBAAiB,GAAG,KAAK,CAAC;IAClC,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertEqual} from '../../util/assert';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\n\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `ɵɵi18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `ɵɵelementStart` instruction.\n * 3. `ɵɵelementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nexport function addTNodeAndUpdateInsertBeforeIndex(previousTNodes: TNode[], newTNode: TNode) {\n  // Start with Rule1\n  ngDevMode &&\n    assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n\n  previousTNodes.push(newTNode);\n  if (previousTNodes.length > 1) {\n    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n      const existingTNode = previousTNodes[i];\n      // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n      // It is safe to ignore them.\n      if (!isI18nText(existingTNode)) {\n        if (\n          isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n          getInsertBeforeIndex(existingTNode) === null\n        ) {\n          // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n          // then add the `insertBeforeIndex`.\n          setInsertBeforeIndex(existingTNode, newTNode.index);\n        }\n      }\n    }\n  }\n}\n\nfunction isI18nText(tNode: TNode): boolean {\n  return !(tNode.type & TNodeType.Placeholder);\n}\n\nfunction isNewTNodeCreatedBefore(existingTNode: TNode, newTNode: TNode): boolean {\n  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\n\nfunction getInsertBeforeIndex(tNode: TNode): number | null {\n  const index = tNode.insertBeforeIndex;\n  return Array.isArray(index) ? index[0] : index;\n}\n\nfunction setInsertBeforeIndex(tNode: TNode, value: number): void {\n  const index = tNode.insertBeforeIndex;\n  if (Array.isArray(index)) {\n    // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n    index[0] = value;\n  } else {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    tNode.insertBeforeIndex = value;\n  }\n}\n"]}