{"version":3,"file":"shared.js","sourceRoot":"","sources":["shared.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector} from '../../di/injector';\nimport {INTERNAL_APPLICATION_ERROR_HANDLER} from '../../error_handler';\nimport {hasSkipHydrationAttrOnRElement} from '../../hydration/skip_hydration';\nimport {PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT} from '../../hydration/tokens';\nimport {processTextNodeMarkersBeforeHydration} from '../../hydration/utils';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {\n  validateAgainstEventAttributes,\n  validateAgainstEventProperties,\n} from '../../sanitization/sanitization';\nimport {assertIndexInRange, assertNotSame} from '../../util/assert';\nimport {escapeCommentText} from '../../util/dom';\nimport {normalizeDebugBindingName, normalizeDebugBindingValue} from '../../ng_reflect';\nimport {stringify} from '../../util/stringify';\nimport {assertFirstCreatePass, assertHasParent, assertLView} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {getNodeInjectable, getOrCreateNodeInjectorForNode} from '../di';\nimport {throwMultipleComponentError} from '../errors';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, RenderFlags} from '../interfaces/definition';\nimport {\n  InitialInputData,\n  InitialInputs,\n  LocalRefExtractor,\n  TContainerNode,\n  TDirectiveHostNode,\n  TElementContainerNode,\n  TElementNode,\n  TNode,\n  TNodeFlags,\n  TNodeType,\n} from '../interfaces/node';\nimport {Renderer} from '../interfaces/renderer';\nimport {RComment, RElement, RNode} from '../interfaces/renderer_dom';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {isComponentDef, isComponentHost, isDirectiveHost} from '../interfaces/type_checks';\nimport {\n  CONTEXT,\n  ENVIRONMENT,\n  FLAGS,\n  HEADER_OFFSET,\n  INJECTOR,\n  LView,\n  LViewFlags,\n  RENDERER,\n  TData,\n  TVIEW,\n  TView,\n} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {isNodeMatchingSelectorList} from '../node_selector_matcher';\nimport {profiler} from '../profiler';\nimport {ProfilerEvent} from '../profiler_types';\nimport {\n  getCurrentDirectiveIndex,\n  getCurrentTNode,\n  getElementDepthCount,\n  getSelectedIndex,\n  increaseElementDepthCount,\n  isCurrentTNodeParent,\n  isInCheckNoChangesMode,\n  setCurrentDirectiveIndex,\n  setCurrentTNode,\n  setCurrentTNodeAsNotParent,\n  setSelectedIndex,\n  wasLastNodeCreated,\n} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {INTERPOLATION_DELIMITER} from '../util/misc_utils';\nimport {renderStringify} from '../util/stringify_utils';\nimport {getComponentLViewByIndex, getNativeByTNode, unwrapLView} from '../util/view_utils';\n\nimport {clearElementContents, setupStaticAttributes} from '../dom_node_manipulation';\nimport {createComponentLView} from '../view/construction';\nimport {selectIndexInternal} from './advance';\nimport {handleUnknownPropertyError, isPropertyValid, matchingSchemas} from './element_validation';\nimport {writeToDirectiveInput} from './write_to_directive_input';\nimport {isDetachedByI18n} from '../../i18n/utils';\nimport {appendChild} from '../node_manipulation';\n\nexport function executeTemplate<T>(\n  tView: TView,\n  lView: LView<T>,\n  templateFn: ComponentTemplate<T>,\n  rf: RenderFlags,\n  context: T,\n) {\n  const prevSelectedIndex = getSelectedIndex();\n  const isUpdatePhase = rf & RenderFlags.Update;\n  try {\n    setSelectedIndex(-1);\n    if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n      // When we're updating, inherently select 0 so we don't\n      // have to generate that instruction for most update blocks.\n      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());\n    }\n\n    const preHookType = isUpdatePhase\n      ? ProfilerEvent.TemplateUpdateStart\n      : ProfilerEvent.TemplateCreateStart;\n    profiler(preHookType, context as unknown as {}, templateFn);\n    templateFn(rf, context);\n  } finally {\n    setSelectedIndex(prevSelectedIndex);\n\n    const postHookType = isUpdatePhase\n      ? ProfilerEvent.TemplateUpdateEnd\n      : ProfilerEvent.TemplateCreateEnd;\n    profiler(postHookType, context as unknown as {}, templateFn);\n  }\n}\n\n/**\n * Creates directive instances.\n */\nexport function createDirectivesInstances(tView: TView, lView: LView, tNode: TDirectiveHostNode) {\n  instantiateAllDirectives(tView, lView, tNode);\n  if ((tNode.flags & TNodeFlags.hasHostBindings) === TNodeFlags.hasHostBindings) {\n    invokeDirectivesHostBindings(tView, lView, tNode);\n  }\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nexport function saveResolvedLocalsInData(\n  viewData: LView,\n  tNode: TDirectiveHostNode,\n  localRefExtractor: LocalRefExtractor = getNativeByTNode,\n): void {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value =\n        index === -1\n          ? localRefExtractor(\n              tNode as TElementNode | TContainerNode | TElementContainerNode,\n              viewData,\n            )\n          : viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param renderer the renderer used to locate the element.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n * @param injector Root view injector instance.\n */\nexport function locateHostElement(\n  renderer: Renderer,\n  elementOrSelector: RElement | string,\n  encapsulation: ViewEncapsulation,\n  injector: Injector,\n): RElement {\n  // Note: we use default value for the `PRESERVE_HOST_CONTENT` here even though it's a\n  // tree-shakable one (providedIn:'root'). This code path can be triggered during dynamic\n  // component creation (after calling ViewContainerRef.createComponent) when an injector\n  // instance can be provided. The injector instance might be disconnected from the main DI\n  // tree, thus the `PRESERVE_HOST_CONTENT` would not be able to instantiate. In this case, the\n  // default value will be used.\n  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);\n\n  // When using native Shadow DOM, do not clear host element to allow native slot\n  // projection.\n  const preserveContent =\n    preserveHostContent ||\n    encapsulation === ViewEncapsulation.ShadowDom ||\n    encapsulation === ViewEncapsulation.IsolatedShadowDom;\n  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);\n  applyRootElementTransform(rootElement as HTMLElement);\n  return rootElement;\n}\n\n/**\n * Applies any root element transformations that are needed. If hydration is enabled,\n * this will process corrupted text nodes.\n *\n * @param rootElement the app root HTML Element\n */\nexport function applyRootElementTransform(rootElement: HTMLElement) {\n  _applyRootElementTransformImpl(rootElement as HTMLElement);\n}\n\n/**\n * Reference to a function that applies transformations to the root HTML element\n * of an app. When hydration is enabled, this processes any corrupt text nodes\n * so they are properly hydratable on the client.\n *\n * @param rootElement the app root HTML Element\n */\nlet _applyRootElementTransformImpl: typeof applyRootElementTransformImpl = () => null;\n\n/**\n * Processes text node markers before hydration begins. This replaces any special comment\n * nodes that were added prior to serialization are swapped out to restore proper text\n * nodes before hydration.\n *\n * @param rootElement the app root HTML Element\n */\nexport function applyRootElementTransformImpl(rootElement: HTMLElement) {\n  if (hasSkipHydrationAttrOnRElement(rootElement)) {\n    // Handle a situation when the `ngSkipHydration` attribute is applied\n    // to the root node of an application. In this case, we should clear\n    // the contents and render everything from scratch.\n    clearElementContents(rootElement as RElement);\n  } else {\n    processTextNodeMarkersBeforeHydration(rootElement);\n  }\n}\n\n/**\n * Sets the implementation for the `applyRootElementTransform` function.\n */\nexport function enableApplyRootElementTransformImpl() {\n  _applyRootElementTransformImpl = applyRootElementTransformImpl;\n}\n\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equivalent mappings in the compiler.\n */\nfunction mapPropName(name: string): string {\n  if (name === 'class') return 'className';\n  if (name === 'for') return 'htmlFor';\n  if (name === 'formaction') return 'formAction';\n  if (name === 'innerHtml') return 'innerHTML';\n  if (name === 'readonly') return 'readOnly';\n  if (name === 'tabindex') return 'tabIndex';\n  return name;\n}\n\nexport function setPropertyAndInputs<T>(\n  tNode: TNode,\n  lView: LView,\n  propName: string,\n  value: T,\n  renderer: Renderer,\n  sanitizer: SanitizerFn | null | undefined,\n): void {\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n  const tView = lView[TVIEW];\n  const hasSetInput = setAllInputsForProperty(tNode, tView, lView, propName, value);\n\n  if (hasSetInput) {\n    isComponentHost(tNode) && markDirtyIfOnPush(lView, tNode.index);\n    ngDevMode && setNgReflectProperties(lView, tView, tNode, propName, value);\n    return; // Stop propcessing if we've matched at least one input.\n  }\n\n  // If the property is going to a DOM node, we have to remap it.\n  if (tNode.type & TNodeType.AnyRNode) {\n    propName = mapPropName(propName);\n  }\n\n  setDomProperty(tNode, lView, propName, value, renderer, sanitizer);\n}\n\n/**\n * Sets a DOM property on a specific node.\n * @param tNode TNode on which to set the value.\n * @param lView View in which the node is located.\n * @param propName Name of the property.\n * @param value Value to set on the property.\n * @param renderer Renderer to use when setting the property.\n * @param sanitizer Function used to sanitize the value before setting it.\n */\nexport function setDomProperty<T>(\n  tNode: TNode,\n  lView: LView,\n  propName: string,\n  value: T,\n  renderer: Renderer,\n  sanitizer: SanitizerFn | null | undefined,\n) {\n  if (tNode.type & TNodeType.AnyRNode) {\n    const element = getNativeByTNode(tNode, lView) as RElement | RComment;\n\n    if (ngDevMode) {\n      validateAgainstEventProperties(propName);\n      if (!isPropertyValid(element, propName, tNode.value, lView[TVIEW].schemas)) {\n        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n      }\n    }\n\n    // It is assumed that the sanitizer is only added when the compiler determines that the\n    // property is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value, tNode.value || '', propName) as any) : value;\n    renderer.setProperty(element as RElement, propName, value);\n  } else if (tNode.type & TNodeType.AnyContainer) {\n    // If the node is a container and the property didn't\n    // match any of the inputs or schemas we should throw.\n    if (ngDevMode && !matchingSchemas(lView[TVIEW].schemas, tNode.value)) {\n      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n    }\n  }\n}\n\n/** If node is an OnPush component, marks its LView dirty. */\nexport function markDirtyIfOnPush(lView: LView, viewIndex: number): void {\n  ngDevMode && assertLView(lView);\n  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & LViewFlags.CheckAlways)) {\n    childComponentLView[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\nfunction setNgReflectProperty(lView: LView, tNode: TNode, attrName: string, value: any) {\n  const environment = lView[ENVIRONMENT];\n  if (!environment.ngReflect) {\n    return;\n  }\n  const element = getNativeByTNode(tNode, lView) as RElement | RComment;\n  const renderer = lView[RENDERER];\n  attrName = normalizeDebugBindingName(attrName);\n  const debugValue = normalizeDebugBindingValue(value);\n  if (tNode.type & TNodeType.AnyRNode) {\n    if (value == null) {\n      renderer.removeAttribute(element as RElement, attrName);\n    } else {\n      renderer.setAttribute(element as RElement, attrName, debugValue);\n    }\n  } else {\n    const textContent = escapeCommentText(\n      `bindings=${JSON.stringify({[attrName]: debugValue}, null, 2)}`,\n    );\n    renderer.setValue(element as RComment, textContent);\n  }\n}\n\nexport function setNgReflectProperties(\n  lView: LView,\n  tView: TView,\n  tNode: TNode,\n  publicName: string,\n  value: any,\n) {\n  const environment = lView[ENVIRONMENT];\n  if (!environment.ngReflect || !(tNode.type & (TNodeType.AnyRNode | TNodeType.Container))) {\n    return;\n  }\n\n  const inputConfig = tNode.inputs?.[publicName];\n  const hostInputConfig = tNode.hostDirectiveInputs?.[publicName];\n\n  if (hostInputConfig) {\n    for (let i = 0; i < hostInputConfig.length; i += 2) {\n      const index = hostInputConfig[i] as number;\n      const publicName = hostInputConfig[i + 1] as string;\n      const def = tView.data[index] as DirectiveDef<unknown>;\n      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);\n    }\n  }\n\n  // Note: we set the private name of the input as the reflected property, not the public one.\n  if (inputConfig) {\n    for (const index of inputConfig) {\n      const def = tView.data[index] as DirectiveDef<unknown>;\n      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);\n    }\n  }\n}\n\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(tView: TView, lView: LView, tNode: TDirectiveHostNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n\n  // The component view needs to be created before creating the node injector\n  // since it is used to inject some special symbols like `ChangeDetectorRef`.\n  if (isComponentHost(tNode)) {\n    ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode);\n    createComponentLView(\n      lView,\n      tNode as TElementNode,\n      tView.data[start + tNode.componentOffset] as ComponentDef<unknown>,\n    );\n  }\n\n  if (!tView.firstCreatePass) {\n    getOrCreateNodeInjectorForNode(tNode, lView);\n  }\n\n  const initialInputs = tNode.initialInputs;\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    const directive = getNodeInjectable(lView, tView, i, tNode);\n    attachPatchData(directive, lView);\n\n    if (initialInputs !== null) {\n      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs!);\n    }\n\n    if (isComponentDef(def)) {\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);\n    }\n  }\n}\n\nexport function invokeDirectivesHostBindings(tView: TView, lView: LView, tNode: TNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const elementIndex = tNode.index;\n  const currentDirectiveIndex = getCurrentDirectiveIndex();\n  try {\n    setSelectedIndex(elementIndex);\n    for (let dirIndex = start; dirIndex < end; dirIndex++) {\n      const def = tView.data[dirIndex] as DirectiveDef<unknown>;\n      const directive = lView[dirIndex];\n      setCurrentDirectiveIndex(dirIndex);\n      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n        invokeHostBindingsInCreationMode(def, directive);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n  }\n}\n\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\nexport function invokeHostBindingsInCreationMode(def: DirectiveDef<any>, directive: any) {\n  if (def.hostBindings !== null) {\n    def.hostBindings!(RenderFlags.Create, directive);\n  }\n}\n\n/**\n * Matches the current node against all available selectors.\n * If a component is matched (at most one), it is returned in first position in the array.\n */\nexport function findDirectiveDefMatches(\n  tView: TView,\n  tNode: TElementNode | TContainerNode | TElementContainerNode,\n): DirectiveDef<unknown>[] | null {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode | TNodeType.AnyContainer);\n\n  const registry = tView.directiveRegistry;\n  let matches: DirectiveDef<unknown>[] | null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i] as ComponentDef<any> | DirectiveDef<any>;\n      if (isNodeMatchingSelectorList(tNode, def.selectors!, /* isProjectionMode */ false)) {\n        matches ??= [];\n\n        if (isComponentDef(def)) {\n          if (ngDevMode) {\n            assertTNodeType(\n              tNode,\n              TNodeType.Element,\n              `\"${tNode.value}\" tags cannot be used as component hosts. ` +\n                `Please use a different tag to activate the ${stringify(def.type)} component.`,\n            );\n\n            if (matches.length && isComponentDef(matches[0])) {\n              throwMultipleComponentError(tNode, matches.find(isComponentDef)!.type, def.type);\n            }\n          }\n\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n\n  return matches;\n}\n\nexport function elementAttributeInternal(\n  tNode: TNode,\n  lView: LView,\n  name: string,\n  value: any,\n  sanitizer: SanitizerFn | null | undefined,\n  namespace: string | null | undefined,\n) {\n  if (ngDevMode) {\n    assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n    validateAgainstEventAttributes(name);\n    assertTNodeType(\n      tNode,\n      TNodeType.Element,\n      `Attempted to set attribute \\`${name}\\` on a container node. ` +\n        `Host bindings are not valid on ng-container or ng-template.`,\n    );\n  }\n  const element = getNativeByTNode(tNode, lView) as RElement;\n  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\n\nexport function setElementAttribute(\n  renderer: Renderer,\n  element: RElement,\n  namespace: string | null | undefined,\n  tagName: string | null,\n  name: string,\n  value: any,\n  sanitizer: SanitizerFn | null | undefined,\n) {\n  if (value == null) {\n    renderer.removeAttribute(element, name, namespace);\n  } else {\n    const strValue =\n      sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n\n    renderer.setAttribute(element, name, strValue as string, namespace);\n  }\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n  lView: LView,\n  directiveIndex: number,\n  instance: T,\n  def: DirectiveDef<T>,\n  tNode: TNode,\n  initialInputData: InitialInputData,\n): void {\n  const initialInputs: InitialInputs | null = initialInputData![directiveIndex];\n  if (initialInputs !== null) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      const lookupName = initialInputs[i];\n      const value = initialInputs[i + 1];\n\n      writeToDirectiveInput<T>(def, instance, lookupName, value);\n\n      if (ngDevMode) {\n        setNgReflectProperty(lView, tNode, def.inputs[lookupName][0], value);\n      }\n    }\n  }\n}\n\n/** Shared code between instructions that indicate the start of an element. */\nexport function elementLikeStartShared(\n  tNode: TElementNode | TElementContainerNode,\n  lView: LView,\n  index: number,\n  name: string,\n  locateOrCreateNativeNode: (\n    tView: TView,\n    lView: LView,\n    tNode: TNode,\n    name: string,\n    index: number,\n  ) => RNode,\n) {\n  const adjustedIndex = HEADER_OFFSET + index;\n  const tView = lView[TVIEW];\n  const native = locateOrCreateNativeNode(tView, lView, tNode, name, index);\n  lView[adjustedIndex] = native;\n  setCurrentTNode(tNode, true);\n\n  // It's important that this runs before we've instantiated the directives.\n  const isElement = tNode.type === TNodeType.Element;\n  if (isElement) {\n    setupStaticAttributes(lView[RENDERER], native as RElement, tNode);\n\n    // any immediate children of a component or template container must be pre-emptively\n    // monkey-patched with the component view data so that the element can be inspected\n    // later on using any element discovery utility methods (see `element_discovery.ts`)\n    if (getElementDepthCount() === 0 || isDirectiveHost(tNode)) {\n      attachPatchData(native, lView);\n    }\n    increaseElementDepthCount();\n  } else {\n    attachPatchData(native, lView);\n  }\n\n  if (wasLastNodeCreated() && (!isElement || !isDetachedByI18n(tNode))) {\n    // In the i18n case, the translation may have removed this element, so only add it if it is not\n    // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n    appendChild(tView, lView, native, tNode);\n  }\n\n  return tNode;\n}\n\n/** Shared code between instructions that indicate the end of an element. */\nexport function elementLikeEndShared(tNode: TNode): TNode {\n  let currentTNode = tNode;\n\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(getCurrentTNode());\n    currentTNode = currentTNode.parent!;\n    setCurrentTNode(currentTNode, false);\n  }\n\n  return currentTNode;\n}\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyName�prefix�interpolation_static_part1�..interpolation_static_partN�suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param tNode `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nexport function storePropertyBindingMetadata(\n  tData: TData,\n  tNode: TNode,\n  propertyName: string,\n  bindingIndex: number,\n  ...interpolationParts: string[]\n) {\n  // Binding meta-data are stored only the first time a given property instruction is processed.\n  // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n  // binding meta-data to decide if one should be stored (or if was stored already).\n  if (tData[bindingIndex] === null) {\n    if (!tNode.inputs?.[propertyName] && !tNode.hostDirectiveInputs?.[propertyName]) {\n      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n      propBindingIdxs.push(bindingIndex);\n      let bindingMetadata = propertyName;\n      if (interpolationParts.length > 0) {\n        bindingMetadata +=\n          INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n      }\n      tData[bindingIndex] = bindingMetadata;\n    }\n  }\n}\n\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nexport function loadComponentRenderer(\n  currentDef: DirectiveDef<any> | null,\n  tNode: TNode,\n  lView: LView,\n): Renderer {\n  // TODO(FW-2043): the `currentDef` is null when host bindings are invoked while creating root\n  // component (see packages/core/src/render3/component.ts). This is not consistent with the process\n  // of creating inner components, when current directive index is available in the state. In order\n  // to avoid relying on current def being `null` (thus special-casing root component creation), the\n  // process of creating root component should be unified with the process of creating inner\n  // components.\n  if (currentDef === null || isComponentDef(currentDef)) {\n    lView = unwrapLView(lView[tNode.index])!;\n  }\n  return lView[RENDERER];\n}\n\n/** Handles an error thrown in an LView. */\nexport function handleUncaughtError(lView: LView, error: any): void {\n  const injector = lView[INJECTOR];\n  if (!injector) {\n    return;\n  }\n  let errorHandler: ((e: any) => void) | null;\n  try {\n    errorHandler = injector.get(INTERNAL_APPLICATION_ERROR_HANDLER, null);\n  } catch {\n    errorHandler = null;\n  }\n  errorHandler?.(error);\n}\n\n/**\n * Set all directive inputs with the specific public name on the node.\n *\n * @param tNode TNode on which the input is being set.\n * @param tView Current TView\n * @param lView `LView` which contains the directives.\n * @param publicName Public name of the input being set.\n * @param value Value to set.\n */\nexport function setAllInputsForProperty(\n  tNode: TNode,\n  tView: TView,\n  lView: LView,\n  publicName: string,\n  value: unknown,\n): boolean {\n  const inputs = tNode.inputs?.[publicName];\n  const hostDirectiveInputs = tNode.hostDirectiveInputs?.[publicName];\n  let hasMatch = false;\n\n  if (hostDirectiveInputs) {\n    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {\n      const index = hostDirectiveInputs[i] as number;\n      ngDevMode && assertIndexInRange(lView, index);\n      const publicName = hostDirectiveInputs[i + 1] as string;\n      const def = tView.data[index] as DirectiveDef<unknown>;\n      writeToDirectiveInput(def, lView[index], publicName, value);\n      hasMatch = true;\n    }\n  }\n\n  if (inputs) {\n    for (const index of inputs) {\n      ngDevMode && assertIndexInRange(lView, index);\n      const instance = lView[index];\n      const def = tView.data[index] as DirectiveDef<any>;\n      writeToDirectiveInput(def, instance, publicName, value);\n      hasMatch = true;\n    }\n  }\n\n  return hasMatch;\n}\n\n/**\n * Sets an input value only on a specific directive and its host directives.\n * @param tNode TNode on which the input is being set.\n * @param tView Current TView\n * @param lView `LView` which contains the directives.\n * @param target Directive on which to set the input.\n * @param publicName Public name of the input being set.\n * @param value Value to set.\n */\nexport function setDirectiveInput(\n  tNode: TNode,\n  tView: TView,\n  lView: LView,\n  target: DirectiveDef<unknown>,\n  publicName: string,\n  value: unknown,\n): boolean {\n  let hostIndex: number | null = null;\n  let hostDirectivesStart: number | null = null;\n  let hostDirectivesEnd: number | null = null;\n  let hasSet = false;\n\n  if (ngDevMode && !tNode.directiveToIndex?.has(target.type)) {\n    throw new Error(`Node does not have a directive with type ${target.type.name}`);\n  }\n\n  const data = tNode.directiveToIndex!.get(target.type)!;\n\n  if (typeof data === 'number') {\n    hostIndex = data;\n  } else {\n    [hostIndex, hostDirectivesStart, hostDirectivesEnd] = data;\n  }\n\n  if (\n    hostDirectivesStart !== null &&\n    hostDirectivesEnd !== null &&\n    tNode.hostDirectiveInputs?.hasOwnProperty(publicName)\n  ) {\n    const hostDirectiveInputs = tNode.hostDirectiveInputs[publicName];\n\n    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {\n      const index = hostDirectiveInputs[i] as number;\n\n      if (index >= hostDirectivesStart && index <= hostDirectivesEnd) {\n        ngDevMode && assertIndexInRange(lView, index);\n        const def = tView.data[index] as DirectiveDef<unknown>;\n        const hostDirectivePublicName = hostDirectiveInputs[i + 1] as string;\n        writeToDirectiveInput(def, lView[index], hostDirectivePublicName, value);\n        hasSet = true;\n      } else if (index > hostDirectivesEnd) {\n        // Directives here are in ascending order so we can stop looking once we're past the range.\n        break;\n      }\n    }\n  }\n\n  if (hostIndex !== null && target.inputs.hasOwnProperty(publicName)) {\n    ngDevMode && assertIndexInRange(lView, hostIndex);\n    writeToDirectiveInput(target, lView[hostIndex], publicName, value);\n    hasSet = true;\n  }\n\n  return hasSet;\n}\n"]}