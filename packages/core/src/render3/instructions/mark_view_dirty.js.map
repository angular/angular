{"version":3,"file":"mark_view_dirty.js","sourceRoot":"","sources":["mark_view_dirty.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,UAAU,EAAC,MAAM,2BAA2B,CAAC;AACrD,OAAO,EAAC,WAAW,EAAE,KAAK,EAAoB,MAAM,oBAAoB,CAAC;AACzE,OAAO,EAAC,iBAAiB,EAAC,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAC,cAAc,EAAC,MAAM,oBAAoB,CAAC;AAElD;;;;;;;;;;GAUG;AACH,MAAM,UAAU,aAAa,CAAC,KAAY,EAAE,MAA0B;IACpE,MAAM,cAAc,GAAG,iBAAiB,EAAE;QACxC,CAAC,CAAC,oFAAoF;;QAMtF,CAAC,CAAC,oEAAoE;YACpE,oFAAoF;YACpF,gFAAgF;YAChF,iFAAiF;YACjF,qDAAqD;YACrD,6DAAyC,CAAC;IAC9C,KAAK,CAAC,WAAW,CAAC,CAAC,wBAAwB,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;IAC5D,OAAO,KAAK,EAAE,CAAC;QACb,KAAK,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC;QAC/B,MAAM,MAAM,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QACrC,2FAA2F;QAC3F,IAAI,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;YACjC,OAAO,KAAK,CAAC;QACf,CAAC;QACD,qBAAqB;QACrB,KAAK,GAAG,MAAO,CAAC;IAClB,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NotificationSource} from '../../change_detection/scheduling/zoneless_scheduling';\nimport {isRootView} from '../interfaces/type_checks';\nimport {ENVIRONMENT, FLAGS, LView, LViewFlags} from '../interfaces/view';\nimport {isRefreshingViews} from '../state';\nimport {getLViewParent} from '../util/view_utils';\n\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nexport function markViewDirty(lView: LView, source: NotificationSource): LView | null {\n  const dirtyBitsToUse = isRefreshingViews()\n    ? // When we are actively refreshing views, we only use the `Dirty` bit to mark a view\n      // for check. This bit is ignored in ChangeDetectionMode.Targeted, which is used to\n      // synchronously rerun change detection on a specific set of views (those which have\n      // the `RefreshView` flag and those with dirty signal consumers). `LViewFlags.Dirty`\n      // does not support re-entrant change detection on its own.\n      LViewFlags.Dirty\n    : // When we are not actively refreshing a view tree, it is absolutely\n      // valid to update state and mark views dirty. We use the `RefreshView` flag in this\n      // case to allow synchronously rerunning change detection. This applies today to\n      // afterRender hooks as well as animation listeners which execute after detecting\n      // changes in a view when the render factory flushes.\n      LViewFlags.RefreshView | LViewFlags.Dirty;\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(source);\n  while (lView) {\n    lView[FLAGS] |= dirtyBitsToUse;\n    const parent = getLViewParent(lView);\n    // Stop traversing up as soon as you find a root view that wasn't attached to any container\n    if (isRootView(lView) && !parent) {\n      return lView;\n    }\n    // continue otherwise\n    lView = parent!;\n  }\n  return null;\n}\n"]}