{"version":3,"file":"change_detection.js","sourceRoot":"","sources":["change_detection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  consumerDestroy,\n  consumerPollProducersForChange,\n  getActiveConsumer,\n  ReactiveNode,\n  setActiveConsumer,\n} from '../../../primitives/signals';\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {assertDefined, assertEqual} from '../../util/assert';\nimport {addAfterRenderSequencesForView} from '../after_render/view';\nimport {executeCheckHooks, executeInitAndCheckHooks, incrementInitPhaseFlags} from '../hooks';\nimport {CONTAINER_HEADER_OFFSET, LContainerFlags, MOVED_VIEWS} from '../interfaces/container';\nimport {ComponentTemplate, HostBindingsFunction, RenderFlags} from '../interfaces/definition';\nimport {\n  CONTEXT,\n  EFFECTS_TO_SCHEDULE,\n  ANIMATIONS,\n  ENVIRONMENT,\n  FLAGS,\n  InitPhaseState,\n  LView,\n  LViewFlags,\n  REACTIVE_TEMPLATE_CONSUMER,\n  TVIEW,\n  TView,\n} from '../interfaces/view';\nimport {\n  getOrBorrowReactiveLViewConsumer,\n  getOrCreateTemporaryConsumer,\n  maybeReturnReactiveLViewConsumer,\n  ReactiveLViewConsumer,\n  viewShouldHaveReactiveConsumer,\n} from '../reactive_lview_consumer';\nimport {\n  CheckNoChangesMode,\n  enterView,\n  isExhaustiveCheckNoChanges,\n  isInCheckNoChangesMode,\n  isRefreshingViews,\n  leaveView,\n  setBindingIndex,\n  setBindingRootForHostBindings,\n  setIsInCheckNoChangesMode,\n  setIsRefreshingViews,\n  setSelectedIndex,\n} from '../state';\nimport {getFirstLContainer, getNextLContainer} from '../util/view_traversal_utils';\nimport {\n  getComponentLViewByIndex,\n  isCreationMode,\n  markAncestorsForTraversal,\n  markViewForRefresh,\n  requiresRefreshOrTraversal,\n  resetPreOrderHookFlags,\n  viewAttachedToChangeDetector,\n} from '../util/view_utils';\n\nimport {isDestroyed} from '../interfaces/type_checks';\nimport {profiler} from '../profiler';\nimport {ProfilerEvent} from '../profiler_types';\nimport {executeViewQueryFn, refreshContentQueries} from '../queries/query_execution';\nimport {runEffectsInView} from '../reactivity/view_effect_runner';\nimport {executeTemplate} from './shared';\n\n/**\n * The maximum number of times the change detection traversal will rerun before throwing an error.\n */\nexport const MAXIMUM_REFRESH_RERUNS = 100;\n\nexport function detectChangesInternal(lView: LView, mode = ChangeDetectionMode.Global) {\n  const environment = lView[ENVIRONMENT];\n  const rendererFactory = environment.rendererFactory;\n\n  // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to invoke renderer factory functions in that mode\n  // to avoid any possible side-effects.\n  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();\n\n  if (!checkNoChangesMode) {\n    rendererFactory.begin?.();\n  }\n\n  try {\n    detectChangesInViewWhileDirty(lView, mode);\n  } finally {\n    if (!checkNoChangesMode) {\n      rendererFactory.end?.();\n    }\n  }\n}\n\nfunction detectChangesInViewWhileDirty(lView: LView, mode: ChangeDetectionMode) {\n  const lastIsRefreshingViewsValue = isRefreshingViews();\n  try {\n    setIsRefreshingViews(true);\n    detectChangesInView(lView, mode);\n\n    // We don't need or want to do any looping when in exhaustive checkNoChanges because we\n    // already traverse all the views and nothing should change so we shouldn't have to do\n    // another pass to pick up new changes.\n    if (ngDevMode && isExhaustiveCheckNoChanges()) {\n      return;\n    }\n\n    let retries = 0;\n    // If after running change detection, this view still needs to be refreshed or there are\n    // descendants views that need to be refreshed due to re-dirtying during the change detection\n    // run, detect changes on the view again. We run change detection in `Targeted` mode to only\n    // refresh views with the `RefreshView` flag.\n    while (requiresRefreshOrTraversal(lView)) {\n      if (retries === MAXIMUM_REFRESH_RERUNS) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INFINITE_CHANGE_DETECTION,\n          ngDevMode &&\n            'Infinite change detection while trying to refresh views. ' +\n              'There may be components which each cause the other to require a refresh, ' +\n              'causing an infinite loop.',\n        );\n      }\n      retries++;\n      // Even if this view is detached, we still detect changes in targeted mode because this was\n      // the root of the change detection run.\n      detectChangesInView(lView, ChangeDetectionMode.Targeted);\n    }\n  } finally {\n    // restore state to what it was before entering this change detection loop\n    setIsRefreshingViews(lastIsRefreshingViewsValue);\n  }\n}\n\nexport function checkNoChangesInternal(lView: LView, exhaustive: boolean) {\n  setIsInCheckNoChangesMode(\n    exhaustive ? CheckNoChangesMode.Exhaustive : CheckNoChangesMode.OnlyDirtyViews,\n  );\n  try {\n    detectChangesInternal(lView);\n  } finally {\n    setIsInCheckNoChangesMode(CheckNoChangesMode.Off);\n  }\n}\n\n/**\n * Different modes of traversing the logical view tree during change detection.\n *\n *\n * The change detection traversal algorithm switches between these modes based on various\n * conditions.\n */\nexport const enum ChangeDetectionMode {\n  /**\n   * In `Global` mode, `Dirty` and `CheckAlways` views are refreshed as well as views with the\n   * `RefreshView` flag.\n   */\n  Global,\n  /**\n   * In `Targeted` mode, only views with the `RefreshView` flag or updated signals are refreshed.\n   */\n  Targeted,\n}\n\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\n\nexport function refreshView<T>(\n  tView: TView,\n  lView: LView,\n  templateFn: ComponentTemplate<{}> | null,\n  context: T,\n) {\n  ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n\n  if (isDestroyed(lView)) return;\n\n  const flags = lView[FLAGS];\n\n  // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to execute lifecycle hooks in that mode.\n  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n  const isInExhaustiveCheckNoChangesPass = ngDevMode && isExhaustiveCheckNoChanges();\n\n  // Start component reactive context\n  // - We might already be in a reactive context if this is an embedded view of the host.\n  // - We might be descending into a view that needs a consumer.\n  enterView(lView);\n  let returnConsumerToPool = true;\n  let prevConsumer: ReactiveNode | null = null;\n  let currentConsumer: ReactiveLViewConsumer | null = null;\n  if (!isInCheckNoChangesPass) {\n    if (viewShouldHaveReactiveConsumer(tView)) {\n      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);\n      prevConsumer = consumerBeforeComputation(currentConsumer);\n    } else if (getActiveConsumer() === null) {\n      // If the current view should not have a reactive consumer but we don't have an active consumer,\n      // we still need to create a temporary consumer to track any signal reads in this template.\n      // This is a rare case that can happen with\n      // - `viewContainerRef.createEmbeddedView(...).detectChanges()`.\n      // - `viewContainerRef.createEmbeddedView(...)` without any other dirty marking on the parent,\n      //   flagging the parent component for traversal but not triggering a full `refreshView`.\n      // This temporary consumer marks the first parent that _should_ have a consumer for refresh.\n      // Once that refresh happens, the signals will be tracked in the parent consumer and we can destroy\n      // the temporary one.\n      returnConsumerToPool = false;\n      currentConsumer = getOrCreateTemporaryConsumer(lView);\n      prevConsumer = consumerBeforeComputation(currentConsumer);\n    } else if (lView[REACTIVE_TEMPLATE_CONSUMER]) {\n      consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);\n      lView[REACTIVE_TEMPLATE_CONSUMER] = null;\n    }\n  }\n\n  try {\n    resetPreOrderHookFlags(lView);\n\n    setBindingIndex(tView.bindingStartIndex);\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, RenderFlags.Update, context);\n    }\n    runEnterAnimations(lView);\n\n    const hooksInitPhaseCompleted =\n      (flags & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n\n    // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const preOrderCheckHooks = tView.preOrderCheckHooks;\n        if (preOrderCheckHooks !== null) {\n          executeCheckHooks(lView, preOrderCheckHooks, null);\n        }\n      } else {\n        const preOrderHooks = tView.preOrderHooks;\n        if (preOrderHooks !== null) {\n          executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, null);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.OnInitHooksToBeRun);\n      }\n    }\n\n    // We do not need to mark transplanted views for refresh when doing exhaustive checks\n    // because all views will be reached anyways during the traversal.\n    if (!isInExhaustiveCheckNoChangesPass) {\n      // First mark transplanted views that are declared in this lView as needing a refresh at their\n      // insertion points. This is needed to avoid the situation where the template is defined in this\n      // `LView` but its declaration appears after the insertion component.\n      markTransplantedViewsForRefresh(lView);\n    }\n    runEffectsInView(lView);\n    detectChangesInEmbeddedViews(lView, ChangeDetectionMode.Global);\n\n    // Content query results must be refreshed before content hooks are called.\n    if (tView.contentQueries !== null) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // execute content hooks (AfterContentInit, AfterContentChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const contentCheckHooks = tView.contentCheckHooks;\n        if (contentCheckHooks !== null) {\n          executeCheckHooks(lView, contentCheckHooks);\n        }\n      } else {\n        const contentHooks = tView.contentHooks;\n        if (contentHooks !== null) {\n          executeInitAndCheckHooks(\n            lView,\n            contentHooks,\n            InitPhaseState.AfterContentInitHooksToBeRun,\n          );\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterContentInitHooksToBeRun);\n      }\n    }\n\n    processHostBindingOpCodes(tView, lView);\n\n    // Refresh child component views.\n    const components = tView.components;\n    if (components !== null) {\n      detectChangesInChildComponents(lView, components, ChangeDetectionMode.Global);\n    }\n\n    // View queries must execute after refreshing child components because a template in this view\n    // could be inserted in a child component. If the view query executes before child component\n    // refresh, the template might not yet be inserted.\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn<T>(RenderFlags.Update, viewQuery, context);\n    }\n\n    // execute view hooks (AfterViewInit, AfterViewChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const viewCheckHooks = tView.viewCheckHooks;\n        if (viewCheckHooks !== null) {\n          executeCheckHooks(lView, viewCheckHooks);\n        }\n      } else {\n        const viewHooks = tView.viewHooks;\n        if (viewHooks !== null) {\n          executeInitAndCheckHooks(lView, viewHooks, InitPhaseState.AfterViewInitHooksToBeRun);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterViewInitHooksToBeRun);\n      }\n    }\n    if (tView.firstUpdatePass === true) {\n      // We need to make sure that we only flip the flag on successful `refreshView` only\n      // Don't do this in `finally` block.\n      // If we did this in `finally` block then an exception could block the execution of styling\n      // instructions which in turn would be unable to insert themselves into the styling linked\n      // list. The result of this would be that if the exception would not be throw on subsequent CD\n      // the styling would be unable to process it data and reflect to the DOM.\n      tView.firstUpdatePass = false;\n    }\n\n    // Schedule any effects that are waiting on the update pass of this view.\n    if (lView[EFFECTS_TO_SCHEDULE]) {\n      for (const notifyEffect of lView[EFFECTS_TO_SCHEDULE]) {\n        notifyEffect();\n      }\n\n      // Once they've been run, we can drop the array.\n      lView[EFFECTS_TO_SCHEDULE] = null;\n    }\n\n    // Do not reset the dirty state when running in check no changes mode. We don't want components\n    // to behave differently depending on whether check no changes is enabled or not. For example:\n    // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n    // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n    // no changes cycle, the component would be not be dirty for the next update pass. This would\n    // be different in production mode where the component dirty state is not reset.\n    if (!isInCheckNoChangesPass) {\n      addAfterRenderSequencesForView(lView);\n\n      lView[FLAGS] &= ~(LViewFlags.Dirty | LViewFlags.FirstLViewPass);\n    }\n  } catch (e) {\n    if (!isInCheckNoChangesPass) {\n      // If refreshing a view causes an error, we need to remark the ancestors as needing traversal\n      // because the error might have caused a situation where views below the current location are\n      // dirty but will be unreachable because the \"has dirty children\" flag in the ancestors has been\n      // cleared during change detection and we failed to run to completion.\n      markAncestorsForTraversal(lView);\n    }\n    throw e;\n  } finally {\n    if (currentConsumer !== null) {\n      consumerAfterComputation(currentConsumer, prevConsumer);\n      if (returnConsumerToPool) {\n        maybeReturnReactiveLViewConsumer(currentConsumer);\n      }\n    }\n    leaveView();\n  }\n}\n\nfunction runEnterAnimations(lView: LView) {\n  const animationData = lView[ANIMATIONS];\n  if (animationData?.enter) {\n    for (const animateFn of animationData.enter) {\n      animateFn();\n    }\n    animationData.enter = undefined;\n  }\n}\n\n/**\n * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction detectChangesInEmbeddedViews(lView: LView, mode: ChangeDetectionMode) {\n  for (\n    let lContainer = getFirstLContainer(lView);\n    lContainer !== null;\n    lContainer = getNextLContainer(lContainer)\n  ) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n      detectChangesInViewIfAttached(embeddedLView, mode);\n    }\n  }\n}\n\n/**\n * Mark transplanted views as needing to be refreshed at their attachment points.\n *\n * @param lView The `LView` that may have transplanted views.\n */\nfunction markTransplantedViewsForRefresh(lView: LView) {\n  for (\n    let lContainer = getFirstLContainer(lView);\n    lContainer !== null;\n    lContainer = getNextLContainer(lContainer)\n  ) {\n    if (!(lContainer[FLAGS] & LContainerFlags.HasTransplantedViews)) continue;\n\n    const movedViews = lContainer[MOVED_VIEWS]!;\n    ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n    for (let i = 0; i < movedViews.length; i++) {\n      const movedLView = movedViews[i]!;\n      markViewForRefresh(movedLView);\n    }\n  }\n}\n\n/**\n * Detects changes in a component by entering the component view and processing its bindings,\n * queries, etc. if it is CheckAlways, OnPush and Dirty, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction detectChangesInComponent(\n  hostLView: LView,\n  componentHostIdx: number,\n  mode: ChangeDetectionMode,\n): void {\n  ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n  profiler(ProfilerEvent.ComponentStart);\n\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  detectChangesInViewIfAttached(componentView, mode);\n\n  profiler(ProfilerEvent.ComponentEnd, componentView[CONTEXT] as any as {});\n}\n\n/**\n * Visits a view as part of change detection traversal.\n *\n * If the view is detached, no additional traversal happens.\n */\nfunction detectChangesInViewIfAttached(lView: LView, mode: ChangeDetectionMode) {\n  if (!viewAttachedToChangeDetector(lView)) {\n    return;\n  }\n  detectChangesInView(lView, mode);\n}\n\n/**\n * Visits a view as part of change detection traversal.\n *\n * The view is refreshed if:\n * - If the view is CheckAlways or Dirty and ChangeDetectionMode is `Global`\n * - If the view has the `RefreshView` flag\n *\n * The view is not refreshed, but descendants are traversed in `ChangeDetectionMode.Targeted` if the\n * view HasChildViewsToRefresh flag is set.\n */\nfunction detectChangesInView(lView: LView, mode: ChangeDetectionMode) {\n  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n  const tView = lView[TVIEW];\n  const flags = lView[FLAGS];\n  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER];\n\n  // Refresh CheckAlways views in Global mode.\n  let shouldRefreshView: boolean = !!(\n    mode === ChangeDetectionMode.Global && flags & LViewFlags.CheckAlways\n  );\n\n  // Refresh Dirty views in Global mode, as long as we're not in checkNoChanges.\n  // CheckNoChanges never worked with `OnPush` components because the `Dirty` flag was\n  // cleared before checkNoChanges ran. Because there is now a loop for to check for\n  // backwards views, it gives an opportunity for `OnPush` components to be marked `Dirty`\n  // before the CheckNoChanges pass. We don't want existing errors that are hidden by the\n  // current CheckNoChanges bug to surface when making unrelated changes.\n  shouldRefreshView ||= !!(\n    flags & LViewFlags.Dirty &&\n    mode === ChangeDetectionMode.Global &&\n    !isInCheckNoChangesPass\n  );\n\n  // Always refresh views marked for refresh, regardless of mode.\n  shouldRefreshView ||= !!(flags & LViewFlags.RefreshView);\n\n  // Refresh views when they have a dirty reactive consumer, regardless of mode.\n  shouldRefreshView ||= !!(consumer?.dirty && consumerPollProducersForChange(consumer));\n\n  shouldRefreshView ||= !!(ngDevMode && isExhaustiveCheckNoChanges());\n\n  // Mark the Flags and `ReactiveNode` as not dirty before refreshing the component, so that they\n  // can be re-dirtied during the refresh process.\n  if (consumer) {\n    consumer.dirty = false;\n  }\n  lView[FLAGS] &= ~(LViewFlags.HasChildViewsToRefresh | LViewFlags.RefreshView);\n\n  if (shouldRefreshView) {\n    refreshView(tView, lView, tView.template, lView[CONTEXT]);\n  } else if (flags & LViewFlags.HasChildViewsToRefresh) {\n    // Set active consumer to null to avoid inheriting an improper reactive context\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      if (!isInCheckNoChangesPass) {\n        runEffectsInView(lView);\n      }\n      detectChangesInEmbeddedViews(lView, ChangeDetectionMode.Targeted);\n      const components = tView.components;\n      if (components !== null) {\n        detectChangesInChildComponents(lView, components, ChangeDetectionMode.Targeted);\n      }\n      if (!isInCheckNoChangesPass) {\n        addAfterRenderSequencesForView(lView);\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}\n\n/** Refreshes child components in the current view (update mode). */\nfunction detectChangesInChildComponents(\n  hostLView: LView,\n  components: number[],\n  mode: ChangeDetectionMode,\n): void {\n  for (let i = 0; i < components.length; i++) {\n    detectChangesInComponent(hostLView, components[i], mode);\n  }\n}\n\n/**\n * Invoke `HostBindingsFunction`s for view.\n *\n * This methods executes `TView.hostBindingOpCodes`. It is used to execute the\n * `HostBindingsFunction`s associated with the current `LView`.\n *\n * @param tView Current `TView`.\n * @param lView Current `LView`.\n */\nfunction processHostBindingOpCodes(tView: TView, lView: LView): void {\n  const hostBindingOpCodes = tView.hostBindingOpCodes;\n  if (hostBindingOpCodes === null) return;\n  try {\n    for (let i = 0; i < hostBindingOpCodes.length; i++) {\n      const opCode = hostBindingOpCodes[i] as number;\n      if (opCode < 0) {\n        // Negative numbers are element indexes.\n        setSelectedIndex(~opCode);\n      } else {\n        // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n        const directiveIdx = opCode;\n        const bindingRootIndx = hostBindingOpCodes[++i] as number;\n        const hostBindingFn = hostBindingOpCodes[++i] as HostBindingsFunction<any>;\n        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n        const context = lView[directiveIdx];\n        profiler(ProfilerEvent.HostBindingsUpdateStart, context);\n        hostBindingFn(RenderFlags.Update, context);\n        profiler(ProfilerEvent.HostBindingsUpdateEnd, context);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n  }\n}\n"]}