{"version":3,"file":"control_flow.js","sourceRoot":"","sources":["control_flow.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {setActiveConsumer} from '../../../primitives/signals';\n\nimport {TrackByFunction} from '../../change_detection';\nimport {formatRuntimeError, RuntimeErrorCode} from '../../errors';\nimport {DehydratedContainerView} from '../../hydration/interfaces';\nimport {\n  findAndReconcileMatchingDehydratedViews,\n  findMatchingDehydratedView,\n} from '../../hydration/views';\nimport {assertDefined, assertFunction} from '../../util/assert';\nimport {performanceMarkFeature} from '../../util/performance';\nimport {assertLContainer, assertLView, assertTNode} from '../assert';\nimport {bindingUpdated} from '../bindings';\nimport {CONTAINER_HEADER_OFFSET, LContainer} from '../interfaces/container';\nimport {ComponentTemplate} from '../interfaces/definition';\nimport {LocalRefExtractor, TAttributes, TNode, TNodeFlags} from '../interfaces/node';\nimport {\n  ANIMATIONS,\n  CONTEXT,\n  DECLARATION_COMPONENT_VIEW,\n  HEADER_OFFSET,\n  HYDRATION,\n  LView,\n  TVIEW,\n  TView,\n} from '../interfaces/view';\nimport {LiveCollection, reconcile} from '../list_reconciliation';\nimport {destroyLView} from '../node_manipulation';\nimport {getLView, getSelectedIndex, getTView, nextBindingIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {getConstant, getTNode} from '../util/view_utils';\nimport {createAndRenderEmbeddedLView, shouldAddViewToDom} from '../view_manipulation';\n\nimport {declareNoDirectiveHostTemplate} from './template';\nimport {\n  addLViewToLContainer,\n  detachView,\n  getLViewFromLContainer,\n  removeLViewFromLContainer,\n} from '../view/container';\nimport {removeDehydratedViews} from '../../hydration/cleanup';\nimport {AnimationLViewData} from '../../animation/interfaces';\n\n/**\n * Creates an LContainer for an ng-template representing a root node\n * of control flow (@if, @switch). We use this to explicitly set\n * flags on the TNode created to identify which nodes are in control\n * flow or starting control flow for hydration identification and\n * cleanup timing.\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n * @codeGenApi\n */\nexport function ɵɵconditionalCreate(\n  index: number,\n  templateFn: ComponentTemplate<any> | null,\n  decls: number,\n  vars: number,\n  tagName?: string | null,\n  attrsIndex?: number | null,\n  localRefsIndex?: number | null,\n  localRefExtractor?: LocalRefExtractor,\n): typeof ɵɵconditionalBranchCreate {\n  performanceMarkFeature('NgControlFlow');\n  const lView = getLView();\n  const tView = getTView();\n  const attrs = getConstant<TAttributes>(tView.consts, attrsIndex);\n  declareNoDirectiveHostTemplate(\n    lView,\n    tView,\n    index,\n    templateFn,\n    decls,\n    vars,\n    tagName,\n    attrs,\n    TNodeFlags.isControlFlowStart,\n    localRefsIndex,\n    localRefExtractor,\n  );\n  return ɵɵconditionalBranchCreate;\n}\n\n/**\n * Creates an LContainer for an ng-template representing a branch\n * of control flow (@else, @case, @default). We use this to explicitly\n * set flags on the TNode created to identify which nodes are in\n * control flow or starting control flow for hydration identification\n * and cleanup timing.\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n * @codeGenApi\n */\nexport function ɵɵconditionalBranchCreate(\n  index: number,\n  templateFn: ComponentTemplate<any> | null,\n  decls: number,\n  vars: number,\n  tagName?: string | null,\n  attrsIndex?: number | null,\n  localRefsIndex?: number | null,\n  localRefExtractor?: LocalRefExtractor,\n): typeof ɵɵconditionalBranchCreate {\n  performanceMarkFeature('NgControlFlow');\n  const lView = getLView();\n  const tView = getTView();\n  const attrs = getConstant<TAttributes>(tView.consts, attrsIndex);\n\n  declareNoDirectiveHostTemplate(\n    lView,\n    tView,\n    index,\n    templateFn,\n    decls,\n    vars,\n    tagName,\n    attrs,\n    TNodeFlags.isInControlFlow,\n    localRefsIndex,\n    localRefExtractor,\n  );\n  return ɵɵconditionalBranchCreate;\n}\n\n/**\n * The conditional instruction represents the basic building block on the runtime side to support\n * built-in \"if\" and \"switch\". On the high level this instruction is responsible for adding and\n * removing views selected by a conditional expression.\n *\n * @param matchingTemplateIndex Index of a template TNode representing a conditional view to be\n *     inserted; -1 represents a special case when there is no view to insert.\n * @param contextValue Value that should be exposed as the context of the conditional.\n * @codeGenApi\n */\nexport function ɵɵconditional<T>(matchingTemplateIndex: number, contextValue?: T) {\n  performanceMarkFeature('NgControlFlow');\n\n  const hostLView = getLView();\n  const bindingIndex = nextBindingIndex();\n  const prevMatchingTemplateIndex: number =\n    hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;\n  const prevContainer =\n    prevMatchingTemplateIndex !== -1\n      ? getLContainer(hostLView, HEADER_OFFSET + prevMatchingTemplateIndex)\n      : undefined;\n  const viewInContainerIdx = 0;\n\n  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      // The index of the view to show changed - remove the previously displayed one\n      // (it is a noop if there are no active views in a container).\n      if (prevContainer !== undefined) {\n        removeLViewFromLContainer(prevContainer, viewInContainerIdx);\n      }\n\n      // Index -1 is a special case where none of the conditions evaluates to\n      // a truthy value and as the consequence we've got no view to show.\n      if (matchingTemplateIndex !== -1) {\n        const nextLContainerIndex = HEADER_OFFSET + matchingTemplateIndex;\n        const nextContainer = getLContainer(hostLView, nextLContainerIndex);\n        const templateTNode = getExistingTNode(hostLView[TVIEW], nextLContainerIndex);\n\n        const dehydratedView = findAndReconcileMatchingDehydratedViews(\n          nextContainer,\n          templateTNode,\n          hostLView,\n        );\n        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {\n          dehydratedView,\n        });\n\n        addLViewToLContainer(\n          nextContainer,\n          embeddedLView,\n          viewInContainerIdx,\n          shouldAddViewToDom(templateTNode, dehydratedView),\n        );\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  } else if (prevContainer !== undefined) {\n    // We might keep displaying the same template but the actual value of the expression could have\n    // changed - re-bind in context.\n    const lView = getLViewFromLContainer<T | undefined>(prevContainer, viewInContainerIdx);\n    if (lView !== undefined) {\n      lView[CONTEXT] = contextValue;\n    }\n  }\n}\n\nexport class RepeaterContext<T> {\n  constructor(\n    private lContainer: LContainer,\n    public $implicit: T,\n    public $index: number,\n  ) {}\n\n  get $count(): number {\n    return this.lContainer.length - CONTAINER_HEADER_OFFSET;\n  }\n}\n\n/**\n * A built-in trackBy function used for situations where users specified collection index as a\n * tracking expression. Having this function body in the runtime avoids unnecessary code generation.\n *\n * @param index\n * @returns\n */\nexport function ɵɵrepeaterTrackByIndex(index: number) {\n  return index;\n}\n\n/**\n * A built-in trackBy function used for situations where users specified collection item reference\n * as a tracking expression. Having this function body in the runtime avoids unnecessary code\n * generation.\n *\n * @param index\n * @returns\n */\nexport function ɵɵrepeaterTrackByIdentity<T>(_: number, value: T) {\n  return value;\n}\n\nclass RepeaterMetadata {\n  constructor(\n    public hasEmptyBlock: boolean,\n    public trackByFn: TrackByFunction<unknown>,\n    public liveCollection?: LiveCollectionLContainerImpl,\n  ) {}\n}\n\n/**\n * The repeaterCreate instruction runs in the creation part of the template pass and initializes\n * internal data structures required by the update pass of the built-in repeater logic. Repeater\n * metadata are allocated in the data part of LView with the following layout:\n * - LView[HEADER_OFFSET + index] - metadata\n * - LView[HEADER_OFFSET + index + 1] - reference to a template function rendering an item\n * - LView[HEADER_OFFSET + index + 2] - optional reference to a template function rendering an empty\n * block\n *\n * @param index Index at which to store the metadata of the repeater.\n * @param templateFn Reference to the template of the main repeater block.\n * @param decls The number of nodes, local refs, and pipes for the main block.\n * @param vars The number of bindings for the main block.\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param trackByFn Reference to the tracking function.\n * @param trackByUsesComponentInstance Whether the tracking function has any references to the\n *  component instance. If it doesn't, we can avoid rebinding it.\n * @param emptyTemplateFn Reference to the template function of the empty block.\n * @param emptyDecls The number of nodes, local refs, and pipes for the empty block.\n * @param emptyVars The number of bindings for the empty block.\n * @param emptyTagName The name of the empty block container element, if applicable\n * @param emptyAttrsIndex Index of the empty block template attributes in the `consts` array.\n *\n * @codeGenApi\n */\nexport function ɵɵrepeaterCreate(\n  index: number,\n  templateFn: ComponentTemplate<unknown>,\n  decls: number,\n  vars: number,\n  tagName: string | null,\n  attrsIndex: number | null,\n  trackByFn: TrackByFunction<unknown>,\n  trackByUsesComponentInstance?: boolean,\n  emptyTemplateFn?: ComponentTemplate<unknown>,\n  emptyDecls?: number,\n  emptyVars?: number,\n  emptyTagName?: string | null,\n  emptyAttrsIndex?: number | null,\n): void {\n  performanceMarkFeature('NgControlFlow');\n\n  ngDevMode &&\n    assertFunction(\n      trackByFn,\n      `A track expression must be a function, was ${typeof trackByFn} instead.`,\n    );\n\n  const lView = getLView();\n  const tView = getTView();\n  const hasEmptyBlock = emptyTemplateFn !== undefined;\n  const hostLView = getLView();\n  const boundTrackBy = trackByUsesComponentInstance\n    ? // We only want to bind when necessary, because it produces a\n      // new function. For pure functions it's not necessary.\n      trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT])\n    : trackByFn;\n  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);\n  hostLView[HEADER_OFFSET + index] = metadata;\n\n  declareNoDirectiveHostTemplate(\n    lView,\n    tView,\n    index + 1,\n    templateFn,\n    decls,\n    vars,\n    tagName,\n    getConstant(tView.consts, attrsIndex),\n    TNodeFlags.isControlFlowStart,\n  );\n\n  if (hasEmptyBlock) {\n    ngDevMode &&\n      assertDefined(emptyDecls, 'Missing number of declarations for the empty repeater block.');\n    ngDevMode &&\n      assertDefined(emptyVars, 'Missing number of bindings for the empty repeater block.');\n\n    declareNoDirectiveHostTemplate(\n      lView,\n      tView,\n      index + 2,\n      emptyTemplateFn,\n      emptyDecls!,\n      emptyVars!,\n      emptyTagName,\n      getConstant(tView.consts, emptyAttrsIndex),\n      TNodeFlags.isInControlFlow,\n    );\n  }\n}\n\nfunction isViewExpensiveToRecreate(lView: LView): boolean {\n  // assumption: anything more than a text node with a binding is considered \"expensive\"\n  return lView.length - HEADER_OFFSET > 2;\n}\n\nclass OperationsCounter {\n  created = 0;\n  destroyed = 0;\n\n  reset() {\n    this.created = 0;\n    this.destroyed = 0;\n  }\n\n  recordCreate() {\n    this.created++;\n  }\n\n  recordDestroy() {\n    this.destroyed++;\n  }\n\n  /**\n   * A method indicating if the entire collection was re-created as part of the reconciliation pass.\n   * Used to warn developers about the usage of a tracking function that might result in excessive\n   * amount of view creation / destroy operations.\n   *\n   * @returns boolean value indicating if a live collection was re-created\n   */\n  wasReCreated(collectionLen: number): boolean {\n    return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;\n  }\n}\n\nclass LiveCollectionLContainerImpl extends LiveCollection<\n  LView<RepeaterContext<unknown>>,\n  unknown\n> {\n  operationsCounter = ngDevMode ? new OperationsCounter() : undefined;\n\n  /**\n   Property indicating if indexes in the repeater context need to be updated following the live\n   collection changes. Index updates are necessary if and only if views are inserted / removed in\n   the middle of LContainer. Adds and removals at the end don't require index updates.\n */\n  private needsIndexUpdate = false;\n  constructor(\n    private lContainer: LContainer,\n    private hostLView: LView,\n    private templateTNode: TNode,\n  ) {\n    super();\n  }\n\n  override get length(): number {\n    return this.lContainer.length - CONTAINER_HEADER_OFFSET;\n  }\n  override at(index: number): unknown {\n    return this.getLView(index)[CONTEXT].$implicit;\n  }\n  override attach(index: number, lView: LView<RepeaterContext<unknown>>): void {\n    const dehydratedView = lView[HYDRATION] as DehydratedContainerView;\n    this.needsIndexUpdate ||= index !== this.length;\n    addLViewToLContainer(\n      this.lContainer,\n      lView,\n      index,\n      shouldAddViewToDom(this.templateTNode, dehydratedView),\n    );\n  }\n  override detach(index: number, skipLeaveAnimations?: boolean): LView<RepeaterContext<unknown>> {\n    this.needsIndexUpdate ||= index !== this.length - 1;\n    if (skipLeaveAnimations) setSkipLeaveAnimations(this.lContainer, index);\n    return detachExistingView<RepeaterContext<unknown>>(this.lContainer, index);\n  }\n  override create(index: number, value: unknown): LView<RepeaterContext<unknown>> {\n    const dehydratedView = findMatchingDehydratedView(\n      this.lContainer,\n      this.templateTNode.tView!.ssrId,\n    );\n    const embeddedLView = createAndRenderEmbeddedLView(\n      this.hostLView,\n      this.templateTNode,\n      new RepeaterContext(this.lContainer, value, index),\n      {dehydratedView},\n    );\n    this.operationsCounter?.recordCreate();\n\n    return embeddedLView;\n  }\n  override destroy(lView: LView<RepeaterContext<unknown>>): void {\n    destroyLView(lView[TVIEW], lView);\n    this.operationsCounter?.recordDestroy();\n  }\n  override updateValue(index: number, value: unknown): void {\n    this.getLView(index)[CONTEXT].$implicit = value;\n  }\n\n  reset(): void {\n    this.needsIndexUpdate = false;\n    this.operationsCounter?.reset();\n  }\n\n  updateIndexes(): void {\n    if (this.needsIndexUpdate) {\n      for (let i = 0; i < this.length; i++) {\n        this.getLView(i)[CONTEXT].$index = i;\n      }\n    }\n  }\n\n  private getLView(index: number): LView<RepeaterContext<unknown>> {\n    return getExistingLViewFromLContainer(this.lContainer, index);\n  }\n}\n\n/**\n * The repeater instruction does update-time diffing of a provided collection (against the\n * collection seen previously) and maps changes in the collection to views structure (by adding,\n * removing or moving views as needed).\n * @param collection - the collection instance to be checked for changes\n * @codeGenApi\n */\nexport function ɵɵrepeater(collection: Iterable<unknown> | undefined | null): void {\n  const prevConsumer = setActiveConsumer(null);\n  const metadataSlotIdx = getSelectedIndex();\n  try {\n    const hostLView = getLView();\n    const hostTView = hostLView[TVIEW];\n    const metadata = hostLView[metadataSlotIdx] as RepeaterMetadata;\n    const containerIndex = metadataSlotIdx + 1;\n    const lContainer = getLContainer(hostLView, containerIndex);\n\n    if (metadata.liveCollection === undefined) {\n      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);\n      metadata.liveCollection = new LiveCollectionLContainerImpl(\n        lContainer,\n        hostLView,\n        itemTemplateTNode,\n      );\n    } else {\n      metadata.liveCollection.reset();\n    }\n\n    const liveCollection = metadata.liveCollection;\n    reconcile(liveCollection, collection, metadata.trackByFn);\n\n    // Warn developers about situations where the entire collection was re-created as part of the\n    // reconciliation pass. Note that this warning might be \"overreacting\" and report cases where\n    // the collection re-creation is the intended behavior. Still, the assumption is that most of\n    // the time it is undesired.\n    if (\n      ngDevMode &&\n      metadata.trackByFn === ɵɵrepeaterTrackByIdentity &&\n      liveCollection.operationsCounter?.wasReCreated(liveCollection.length) &&\n      isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))\n    ) {\n      const message = formatRuntimeError(\n        RuntimeErrorCode.LOOP_TRACK_RECREATE,\n        `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. ` +\n          'This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. ' +\n          'Please review the \"track expression\" and make sure that it uniquely identifies items in a collection.',\n      );\n      console.warn(message);\n    }\n\n    // moves in the container might caused context's index to get out of order, re-adjust if needed\n    liveCollection.updateIndexes();\n\n    // handle empty blocks\n    if (metadata.hasEmptyBlock) {\n      const bindingIndex = nextBindingIndex();\n      const isCollectionEmpty = liveCollection.length === 0;\n      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {\n        const emptyTemplateIndex = metadataSlotIdx + 2;\n        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);\n        if (isCollectionEmpty) {\n          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);\n          const dehydratedView = findAndReconcileMatchingDehydratedViews(\n            lContainerForEmpty,\n            emptyTemplateTNode,\n            hostLView,\n          );\n          const embeddedLView = createAndRenderEmbeddedLView(\n            hostLView,\n            emptyTemplateTNode,\n            undefined,\n            {dehydratedView},\n          );\n          addLViewToLContainer(\n            lContainerForEmpty,\n            embeddedLView,\n            0,\n            shouldAddViewToDom(emptyTemplateTNode, dehydratedView),\n          );\n        } else {\n          // we know that an ssrId was generated for the empty template, but\n          // we were unable to match it to a dehydrated view earlier, which\n          // means that we may have changed branches between server and client.\n          // We'll need to find and remove the stale empty template view.\n          if (hostTView.firstUpdatePass) {\n            removeDehydratedViews(lContainerForEmpty);\n          }\n\n          removeLViewFromLContainer(lContainerForEmpty, 0);\n        }\n      }\n    }\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n\nfunction getLContainer(lView: LView, index: number): LContainer {\n  const lContainer = lView[index];\n  ngDevMode && assertLContainer(lContainer);\n\n  return lContainer;\n}\n\nfunction setSkipLeaveAnimations(lContainer: LContainer, index: number): void {\n  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;\n\n  const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n  const viewToDetach = lContainer[indexInContainer];\n  if (viewToDetach && viewToDetach[ANIMATIONS]) {\n    (viewToDetach[ANIMATIONS] as AnimationLViewData).skipLeaveAnimations = true;\n  }\n}\n\nfunction detachExistingView<T>(lContainer: LContainer, index: number): LView<T> {\n  const existingLView = detachView(lContainer, index);\n  ngDevMode && assertLView(existingLView);\n\n  return existingLView as LView<T>;\n}\n\nfunction getExistingLViewFromLContainer<T>(lContainer: LContainer, index: number): LView<T> {\n  const existingLView = getLViewFromLContainer<T>(lContainer, index);\n  ngDevMode && assertLView(existingLView);\n\n  return existingLView!;\n}\n\nfunction getExistingTNode(tView: TView, index: number): TNode {\n  const tNode = getTNode(tView, index);\n  ngDevMode && assertTNode(tNode);\n\n  return tNode;\n}\n"]}