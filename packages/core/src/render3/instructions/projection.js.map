{"version":3,"file":"projection.js","sourceRoot":"","sources":["projection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {findMatchingDehydratedView} from '../../hydration/views';\nimport {isDetachedByI18n} from '../../i18n/utils';\nimport {newArray} from '../../util/array_utils';\nimport {assertLContainer, assertTNode} from '../assert';\nimport {ComponentTemplate} from '../interfaces/definition';\nimport {TAttributes, TElementNode, TNode, TNodeType} from '../interfaces/node';\nimport {ProjectionSlots} from '../interfaces/projection';\nimport {\n  DECLARATION_COMPONENT_VIEW,\n  HEADER_OFFSET,\n  HYDRATION,\n  LView,\n  T_HOST,\n  TView,\n} from '../interfaces/view';\nimport {applyProjection} from '../node_manipulation';\nimport {\n  getProjectAsAttrValue,\n  isNodeMatchingSelectorList,\n  isSelectorInSelectorList,\n} from '../node_selector_matcher';\nimport {getLView, getTView, isInSkipHydrationBlock, setCurrentTNodeAsNotParent} from '../state';\nimport {getOrCreateTNode} from '../tnode_manipulation';\nimport {addLViewToLContainer} from '../view/container';\nimport {createAndRenderEmbeddedLView, shouldAddViewToDom} from '../view_manipulation';\n\nimport {declareNoDirectiveHostTemplate} from './template';\n\n/**\n * Checks a given node against matching projection slots and returns the\n * determined slot index. Returns \"null\" if no slot matched the given node.\n *\n * This function takes into account the parsed ngProjectAs selector from the\n * node's attributes. If present, it will check whether the ngProjectAs selector\n * matches any of the projection slot selectors.\n */\nexport function matchingProjectionSlotIndex(\n  tNode: TNode,\n  projectionSlots: ProjectionSlots,\n): number | null {\n  let wildcardNgContentIndex = null;\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n  for (let i = 0; i < projectionSlots.length; i++) {\n    const slotValue = projectionSlots[i];\n    // The last wildcard projection slot should match all nodes which aren't matching\n    // any selector. This is necessary to be backwards compatible with view engine.\n    if (slotValue === '*') {\n      wildcardNgContentIndex = i;\n      continue;\n    }\n    // If we ran into an `ngProjectAs` attribute, we should match its parsed selector\n    // to the list of selectors, otherwise we fall back to matching against the node.\n    if (\n      ngProjectAsAttrVal === null\n        ? isNodeMatchingSelectorList(tNode, slotValue, /* isProjectionMode */ true)\n        : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)\n    ) {\n      return i; // first matching selector \"captures\" a given node\n    }\n  }\n  return wildcardNgContentIndex;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param projectionSlots? A collection of projection slots. A projection slot can be based\n *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\n *        all nodes which do not match any selector. If not specified, a single wildcard\n *        selector projection slot will be defined.\n *\n * @codeGenApi\n */\nexport function ɵɵprojectionDef(projectionSlots?: ProjectionSlots): void {\n  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST] as TElementNode;\n\n  if (!componentNode.projection) {\n    // If no explicit projection slots are defined, fall back to a single\n    // projection slot with the wildcard selector.\n    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\n    const projectionHeads: (TNode | null)[] = (componentNode.projection = newArray(\n      numProjectionSlots,\n      null! as TNode,\n    ));\n    const tails: (TNode | null)[] = projectionHeads.slice();\n\n    let componentChild: TNode | null = componentNode.child;\n\n    while (componentChild !== null) {\n      // Do not project let declarations so they don't occupy a slot.\n      if (componentChild.type !== TNodeType.LetDeclaration) {\n        const slotIndex = projectionSlots\n          ? matchingProjectionSlotIndex(componentChild, projectionSlots)\n          : 0;\n\n        if (slotIndex !== null) {\n          if (tails[slotIndex]) {\n            tails[slotIndex]!.projectionNext = componentChild;\n          } else {\n            projectionHeads[slotIndex] = componentChild;\n          }\n          tails[slotIndex] = componentChild;\n        }\n      }\n\n      componentChild = componentChild.next;\n    }\n  }\n}\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex Index of the projection node.\n * @param selectorIndex Index of the slot selector.\n *  - 0 when the selector is `*` (or unspecified as this is the default value),\n *  - 1 based index of the selector from the {@link projectionDef}\n * @param attrs Static attributes set on the `ng-content` node.\n * @param fallbackTemplateFn Template function with fallback content.\n *   Will be rendered if the slot is empty at runtime.\n * @param fallbackDecls Number of declarations in the fallback template.\n * @param fallbackVars Number of variables in the fallback template.\n *\n * @codeGenApi\n */\nexport function ɵɵprojection(\n  nodeIndex: number,\n  selectorIndex: number = 0,\n  attrs?: TAttributes,\n  fallbackTemplateFn?: ComponentTemplate<unknown>,\n  fallbackDecls?: number,\n  fallbackVars?: number,\n): void {\n  const lView = getLView();\n  const tView = getTView();\n  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;\n\n  // Fallback content needs to be declared no matter whether the slot is empty since different\n  // instances of the component may or may not insert it. Also it needs to be declare *before*\n  // the projection node in order to work correctly with hydration.\n  if (fallbackIndex !== null) {\n    declareNoDirectiveHostTemplate(\n      lView,\n      tView,\n      fallbackIndex,\n      fallbackTemplateFn!,\n      fallbackDecls!,\n      fallbackVars!,\n      null,\n      attrs,\n    );\n  }\n\n  const tProjectionNode = getOrCreateTNode(\n    tView,\n    HEADER_OFFSET + nodeIndex,\n    TNodeType.Projection,\n    null,\n    attrs || null,\n  );\n\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (tProjectionNode.projection === null) {\n    tProjectionNode.projection = selectorIndex;\n  }\n\n  // `<ng-content>` has no content. Even if there's fallback\n  // content, the fallback is shown next to it.\n  setCurrentTNodeAsNotParent();\n\n  const hydrationInfo = lView[HYDRATION];\n  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock();\n  const componentHostNode = lView[DECLARATION_COMPONENT_VIEW][T_HOST] as TElementNode;\n  const isEmpty = componentHostNode.projection![tProjectionNode.projection] === null;\n\n  if (isEmpty && fallbackIndex !== null) {\n    insertFallbackContent(lView, tView, fallbackIndex);\n  } else if (isNodeCreationMode && !isDetachedByI18n(tProjectionNode)) {\n    // re-distribution of projectable nodes is stored on a component's view level\n    applyProjection(tView, lView, tProjectionNode);\n  }\n}\n\n/** Inserts the fallback content of a projection slot. Assumes there's no projected content. */\nfunction insertFallbackContent(lView: LView, tView: TView, fallbackIndex: number) {\n  const adjustedIndex = HEADER_OFFSET + fallbackIndex;\n  const fallbackTNode = tView.data[adjustedIndex] as TNode;\n  const fallbackLContainer = lView[adjustedIndex];\n  ngDevMode && assertTNode(fallbackTNode);\n  ngDevMode && assertLContainer(fallbackLContainer);\n\n  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView!.ssrId);\n  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, undefined, {\n    dehydratedView,\n  });\n  addLViewToLContainer(\n    fallbackLContainer,\n    fallbackLView,\n    0,\n    shouldAddViewToDom(fallbackTNode, dehydratedView),\n  );\n}\n"]}