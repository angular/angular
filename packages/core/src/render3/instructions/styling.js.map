{"version":3,"file":"styling.js","sourceRoot":"","sources":["styling.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SafeValue, unwrapSafeValue} from '../../sanitization/bypass';\nimport {KeyValueArray, keyValueArrayGet, keyValueArraySet} from '../../util/array_utils';\nimport {\n  assertDefined,\n  assertEqual,\n  assertLessThan,\n  assertNotEqual,\n  throwError,\n} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {concatStringsWithSpace, stringify} from '../../util/stringify';\nimport {assertFirstUpdatePass} from '../assert';\nimport {bindingUpdated} from '../bindings';\nimport {AttributeMarker} from '../interfaces/attribute_marker';\nimport {DirectiveDef} from '../interfaces/definition';\nimport {TAttributes, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {Renderer} from '../interfaces/renderer';\nimport {RElement} from '../interfaces/renderer_dom';\nimport {\n  getTStylingRangeNext,\n  getTStylingRangeNextDuplicate,\n  getTStylingRangePrev,\n  getTStylingRangePrevDuplicate,\n  TStylingKey,\n  TStylingRange,\n} from '../interfaces/styling';\nimport {LView, RENDERER, TData, TView} from '../interfaces/view';\nimport {applyStyling} from '../node_manipulation';\nimport {\n  getCurrentDirectiveDef,\n  getLView,\n  getSelectedIndex,\n  getTView,\n  incrementBindingIndex,\n} from '../state';\nimport {insertTStylingBinding} from '../styling/style_binding_list';\nimport {\n  getLastParsedKey,\n  getLastParsedValue,\n  parseClassName,\n  parseClassNameNext,\n  parseStyle,\n  parseStyleNext,\n} from '../styling/styling_parser';\nimport {NO_CHANGE} from '../tokens';\nimport {getNativeByIndex} from '../util/view_utils';\n\nimport {setDirectiveInputsWhichShadowsStyling} from './property';\n\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\nexport function ɵɵstyleProp(\n  prop: string,\n  value: string | number | SafeValue | undefined | null,\n  suffix?: string | null,\n): typeof ɵɵstyleProp {\n  checkStylingProperty(prop, value, suffix, false);\n  return ɵɵstyleProp;\n}\n\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\nexport function ɵɵclassProp(\n  className: string,\n  value: boolean | undefined | null,\n): typeof ɵɵclassProp {\n  checkStylingProperty(className, value, null, true);\n  return ɵɵclassProp;\n}\n\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\nexport function ɵɵstyleMap(styles: {[styleName: string]: any} | string | undefined | null): void {\n  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);\n}\n\n/**\n * Parse text as style and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵstyleMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nexport function styleStringParser(keyValueArray: KeyValueArray<any>, text: string): void {\n  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {\n    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));\n  }\n}\n\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\nexport function ɵɵclassMap(\n  classes: {[className: string]: boolean | undefined | null} | string | undefined | null,\n): void {\n  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);\n}\n\n/**\n * Parse text as class and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵclassMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nexport function classStringParser(keyValueArray: KeyValueArray<any>, text: string): void {\n  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);\n  }\n}\n\n/**\n * Common code between `ɵɵclassProp` and `ɵɵstyleProp`.\n *\n * @param prop property name.\n * @param value binding value.\n * @param suffix suffix for the property (e.g. `em` or `px`)\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nexport function checkStylingProperty(\n  prop: string,\n  value: any | NO_CHANGE,\n  suffix: string | undefined | null,\n  isClassBased: boolean,\n): void {\n  const lView = getLView();\n  const tView = getTView();\n  // Styling instructions use 2 slots per binding.\n  // 1. one for the value / TStylingKey\n  // 2. one for the intermittent-value / TStylingRange\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);\n  }\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    const tNode = tView.data[getSelectedIndex()] as TNode;\n    updateStyling(\n      tView,\n      tNode,\n      lView,\n      lView[RENDERER],\n      prop,\n      (lView[bindingIndex + 1] = normalizeSuffix(value, suffix)),\n      isClassBased,\n      bindingIndex,\n    );\n  }\n}\n\n/**\n * Common code between `ɵɵclassMap` and `ɵɵstyleMap`.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done for tree shaking purposes.\n * @param stringParser Parser used to parse `value` if `string`. (Passed in as `style` and `class`\n *        have different parsers.)\n * @param value bound value from application\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nexport function checkStylingMap(\n  keyValueArraySet: (keyValueArray: KeyValueArray<any>, key: string, value: any) => void,\n  stringParser: (styleKeyValueArray: KeyValueArray<any>, text: string) => void,\n  value: any | NO_CHANGE,\n  isClassBased: boolean,\n): void {\n  const tView = getTView();\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);\n  }\n  const lView = getLView();\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tView.data[getSelectedIndex()] as TNode;\n    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {\n      if (ngDevMode) {\n        // verify that if we are shadowing then `TData` is appropriately marked so that we skip\n        // processing this binding in styling resolution.\n        const tStylingKey = tView.data[bindingIndex];\n        assertEqual(\n          Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey,\n          false,\n          \"Styling linked list shadow input should be marked as 'false'\",\n        );\n      }\n      // VE does not concatenate the static portion like we are doing here.\n      // Instead VE just ignores the static completely if dynamic binding is present.\n      // Because of locality we have already set the static portion because we don't know if there\n      // is a dynamic portion until later. If we would ignore the static portion it would look like\n      // the binding has removed it. This would confuse `[ngStyle]`/`[ngClass]` to do the wrong\n      // thing as it would think that the static portion was removed. For this reason we\n      // concatenate it so that `[ngStyle]`/`[ngClass]`  can continue to work on changed.\n      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;\n      ngDevMode &&\n        isClassBased === false &&\n        staticPrefix !== null &&\n        assertEqual(staticPrefix.endsWith(';'), true, \"Expecting static portion to end with ';'\");\n      if (staticPrefix !== null) {\n        // We want to make sure that falsy values of `value` become empty strings.\n        value = concatStringsWithSpace(staticPrefix, value ? value : '');\n      }\n      // Given `<div [style] my-dir>` such that `my-dir` has `@Input('style')`.\n      // This takes over the `[style]` binding. (Same for `[class]`)\n      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);\n    } else {\n      updateStylingMap(\n        tView,\n        tNode,\n        lView,\n        lView[RENDERER],\n        lView[bindingIndex + 1],\n        (lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value)),\n        isClassBased,\n        bindingIndex,\n      );\n    }\n  }\n}\n\n/**\n * Determines when the binding is in `hostBindings` section\n *\n * @param tView Current `TView`\n * @param bindingIndex index of binding which we would like if it is in `hostBindings`\n */\nfunction isInHostBindings(tView: TView, bindingIndex: number): boolean {\n  // All host bindings are placed after the expando section.\n  return bindingIndex >= tView.expandoStartIndex;\n}\n\n/**\n * Collects the necessary information to insert the binding into a linked list of style bindings\n * using `insertTStylingBinding`.\n *\n * @param tView `TView` where the binding linked list will be stored.\n * @param tStylingKey Property/key of the binding.\n * @param bindingIndex Index of binding associated with the `prop`\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction stylingFirstUpdatePass(\n  tView: TView,\n  tStylingKey: TStylingKey,\n  bindingIndex: number,\n  isClassBased: boolean,\n): void {\n  ngDevMode && assertFirstUpdatePass(tView);\n  const tData = tView.data;\n  if (tData[bindingIndex + 1] === null) {\n    // The above check is necessary because we don't clear first update pass until first successful\n    // (no exception) template execution. This prevents the styling instruction from double adding\n    // itself to the list.\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tData[getSelectedIndex()] as TNode;\n    ngDevMode && assertDefined(tNode, 'TNode expected');\n    const isHostBindings = isInHostBindings(tView, bindingIndex);\n    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {\n      // `tStylingKey === null` implies that we are either `[style]` or `[class]` binding.\n      // If there is a directive which uses `@Input('style')` or `@Input('class')` than\n      // we need to neutralize this binding since that directive is shadowing it.\n      // We turn this into a noop by setting the key to `false`\n      tStylingKey = false;\n    }\n    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);\n    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);\n  }\n}\n\n/**\n * Adds static styling information to the binding if applicable.\n *\n * The linked list of styles not only stores the list and keys, but also stores static styling\n * information on some of the keys. This function determines if the key should contain the styling\n * information and computes it.\n *\n * See `TStylingStatic` for more details.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey `TStylingKeyPrimitive` which may need to be wrapped into `TStylingKey`\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nexport function wrapInStaticStylingKey(\n  tData: TData,\n  tNode: TNode,\n  stylingKey: TStylingKey,\n  isClassBased: boolean,\n): TStylingKey {\n  const hostDirectiveDef = getCurrentDirectiveDef(tData);\n  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n  if (hostDirectiveDef === null) {\n    // We are in template node.\n    // If template node already had styling instruction then it has already collected the static\n    // styling and there is no need to collect them again. We know that we are the first styling\n    // instruction because the `TNode.*Bindings` points to 0 (nothing has been inserted yet).\n    const isFirstStylingInstructionInTemplate =\n      ((isClassBased ? tNode.classBindings : tNode.styleBindings) as any as number) === 0;\n    if (isFirstStylingInstructionInTemplate) {\n      // It would be nice to be able to get the statics from `mergeAttrs`, however, at this point\n      // they are already merged and it would not be possible to figure which property belongs where\n      // in the priority.\n      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);\n      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);\n      // We know that if we have styling binding in template we can't have residual.\n      residual = null;\n    }\n  } else {\n    // We are in host binding node and there was no binding instruction in template node.\n    // This means that we need to compute the residual.\n    const directiveStylingLast = tNode.directiveStylingLast;\n    const isFirstStylingInstructionInHostBinding =\n      directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;\n    if (isFirstStylingInstructionInHostBinding) {\n      stylingKey = collectStylingFromDirectives(\n        hostDirectiveDef,\n        tData,\n        tNode,\n        stylingKey,\n        isClassBased,\n      );\n      if (residual === null) {\n        // - If `null` than either:\n        //    - Template styling instruction already ran and it has consumed the static\n        //      styling into its `TStylingKey` and so there is no need to update residual. Instead\n        //      we need to update the `TStylingKey` associated with the first template node\n        //      instruction. OR\n        //    - Some other styling instruction ran and determined that there are no residuals\n        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);\n        if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {\n          // Only recompute if `templateStylingKey` had static values. (If no static value found\n          // then there is nothing to do since this operation can only produce less static keys, not\n          // more.)\n          templateStylingKey = collectStylingFromDirectives(\n            null,\n            tData,\n            tNode,\n            templateStylingKey[1] /* unwrap previous statics */,\n            isClassBased,\n          );\n          templateStylingKey = collectStylingFromTAttrs(\n            templateStylingKey,\n            tNode.attrs,\n            isClassBased,\n          );\n          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);\n        }\n      } else {\n        // We only need to recompute residual if it is not `null`.\n        // - If existing residual (implies there was no template styling). This means that some of\n        //   the statics may have moved from the residual to the `stylingKey` and so we have to\n        //   recompute.\n        // - If `undefined` this is the first time we are running.\n        residual = collectResidual(tData, tNode, isClassBased);\n      }\n    }\n  }\n  if (residual !== undefined) {\n    isClassBased ? (tNode.residualClasses = residual) : (tNode.residualStyles = residual);\n  }\n  return stylingKey;\n}\n\n/**\n * Retrieve the `TStylingKey` for the template styling instruction.\n *\n * This is needed since `hostBinding` styling instructions are inserted after the template\n * instruction. While the template instruction needs to update the residual in `TNode` the\n * `hostBinding` instructions need to update the `TStylingKey` of the template instruction because\n * the template instruction is downstream from the `hostBindings` instructions.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @return `TStylingKey` if found or `undefined` if not found.\n */\nfunction getTemplateHeadTStylingKey(\n  tData: TData,\n  tNode: TNode,\n  isClassBased: boolean,\n): TStylingKey | undefined {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  if (getTStylingRangeNext(bindings) === 0) {\n    // There does not seem to be a styling instruction in the `template`.\n    return undefined;\n  }\n  return tData[getTStylingRangePrev(bindings)] as TStylingKey;\n}\n\n/**\n * Update the `TStylingKey` of the first template instruction in `TNode`.\n *\n * Logically `hostBindings` styling instructions are of lower priority than that of the template.\n * However, they execute after the template styling instructions. This means that they get inserted\n * in front of the template styling instructions.\n *\n * If we have a template styling instruction and a new `hostBindings` styling instruction is\n * executed it means that it may need to steal static fields from the template instruction. This\n * method allows us to update the first template instruction `TStylingKey` with a new value.\n *\n * Assume:\n * ```angular-ts\n * <div my-dir style=\"color: red\" [style.color]=\"tmplExp\"></div>\n *\n * @Directive({\n *   host: {\n *     'style': 'width: 100px',\n *     '[style.color]': 'dirExp',\n *   }\n * })\n * class MyDir {}\n * ```\n *\n * when `[style.color]=\"tmplExp\"` executes it creates this data structure.\n * ```ts\n *  ['', 'color', 'color', 'red', 'width', '100px'],\n * ```\n *\n * The reason for this is that the template instruction does not know if there are styling\n * instructions and must assume that there are none and must collect all of the static styling.\n * (both\n * `color' and 'width`)\n *\n * When `'[style.color]': 'dirExp',` executes we need to insert a new data into the linked list.\n * ```ts\n *  ['', 'color', 'width', '100px'],  // newly inserted\n *  ['', 'color', 'color', 'red', 'width', '100px'], // this is wrong\n * ```\n *\n * Notice that the template statics is now wrong as it incorrectly contains `width` so we need to\n * update it like so:\n * ```ts\n *  ['', 'color', 'width', '100px'],\n *  ['', 'color', 'color', 'red'],    // UPDATE\n * ```\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param tStylingKey New `TStylingKey` which is replacing the old one.\n */\nfunction setTemplateHeadTStylingKey(\n  tData: TData,\n  tNode: TNode,\n  isClassBased: boolean,\n  tStylingKey: TStylingKey,\n): void {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  ngDevMode &&\n    assertNotEqual(\n      getTStylingRangeNext(bindings),\n      0,\n      'Expecting to have at least one template styling binding.',\n    );\n  tData[getTStylingRangePrev(bindings)] = tStylingKey;\n}\n\n/**\n * Collect all static values after the current `TNode.directiveStylingLast` index.\n *\n * Collect the remaining styling information which has not yet been collected by an existing\n * styling instruction.\n *\n * @param tData `TData` where the `DirectiveDefs` are stored.\n * @param tNode `TNode` which contains the directive range.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectResidual(\n  tData: TData,\n  tNode: TNode,\n  isClassBased: boolean,\n): KeyValueArray<any> | null {\n  let residual: KeyValueArray<any> | null | undefined = undefined;\n  const directiveEnd = tNode.directiveEnd;\n  ngDevMode &&\n    assertNotEqual(\n      tNode.directiveStylingLast,\n      -1,\n      'By the time this function gets called at least one hostBindings-node styling instruction must have executed.',\n    );\n  // We add `1 + tNode.directiveStart` because we need to skip the current directive (as we are\n  // collecting things after the last `hostBindings` directive which had a styling instruction.)\n  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {\n    const attrs = (tData[i] as DirectiveDef<any>).hostAttrs;\n    residual = collectStylingFromTAttrs(residual, attrs, isClassBased) as KeyValueArray<any> | null;\n  }\n  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased) as KeyValueArray<any> | null;\n}\n\n/**\n * Collect the static styling information with lower priority than `hostDirectiveDef`.\n *\n * (This is opposite of residual styling.)\n *\n * @param hostDirectiveDef `DirectiveDef` for which we want to collect lower priority static\n *        styling. (Or `null` if template styling)\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey Existing `TStylingKey` to update or wrap.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromDirectives(\n  hostDirectiveDef: DirectiveDef<any> | null,\n  tData: TData,\n  tNode: TNode,\n  stylingKey: TStylingKey,\n  isClassBased: boolean,\n): TStylingKey {\n  // We need to loop because there can be directives which have `hostAttrs` but don't have\n  // `hostBindings` so this loop catches up to the current directive..\n  let currentDirective: DirectiveDef<any> | null = null;\n  const directiveEnd = tNode.directiveEnd;\n  let directiveStylingLast = tNode.directiveStylingLast;\n  if (directiveStylingLast === -1) {\n    directiveStylingLast = tNode.directiveStart;\n  } else {\n    directiveStylingLast++;\n  }\n  while (directiveStylingLast < directiveEnd) {\n    currentDirective = tData[directiveStylingLast] as DirectiveDef<any>;\n    ngDevMode && assertDefined(currentDirective, 'expected to be defined');\n    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);\n    if (currentDirective === hostDirectiveDef) break;\n    directiveStylingLast++;\n  }\n  if (hostDirectiveDef !== null) {\n    // we only advance the styling cursor if we are collecting data from host bindings.\n    // Template executes before host bindings and so if we would update the index,\n    // host bindings would not get their statics.\n    tNode.directiveStylingLast = directiveStylingLast;\n  }\n  return stylingKey;\n}\n\n/**\n * Convert `TAttrs` into `TStylingStatic`.\n *\n * @param stylingKey existing `TStylingKey` to update or wrap.\n * @param attrs `TAttributes` to process.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromTAttrs(\n  stylingKey: TStylingKey | undefined,\n  attrs: TAttributes | null,\n  isClassBased: boolean,\n): TStylingKey {\n  const desiredMarker = isClassBased ? AttributeMarker.Classes : AttributeMarker.Styles;\n  let currentMarker = AttributeMarker.ImplicitAttributes;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const item = attrs[i] as number | string;\n      if (typeof item === 'number') {\n        currentMarker = item;\n      } else {\n        if (currentMarker === desiredMarker) {\n          if (!Array.isArray(stylingKey)) {\n            stylingKey = stylingKey === undefined ? [] : (['', stylingKey] as any);\n          }\n          keyValueArraySet(\n            stylingKey as KeyValueArray<any>,\n            item,\n            isClassBased ? true : attrs[++i],\n          );\n        }\n      }\n    }\n  }\n  return stylingKey === undefined ? null : stylingKey;\n}\n\n/**\n * Convert user input to `KeyValueArray`.\n *\n * This function takes user input which could be `string`, Object literal, or iterable and converts\n * it into a consistent representation. The output of this is `KeyValueArray` (which is an array\n * where\n * even indexes contain keys and odd indexes contain values for those keys).\n *\n * The advantage of converting to `KeyValueArray` is that we can perform diff in an input\n * independent\n * way.\n * (ie we can compare `foo bar` to `['bar', 'baz'] and determine a set of changes which need to be\n * applied)\n *\n * The fact that `KeyValueArray` is sorted is very important because it allows us to compute the\n * difference in linear fashion without the need to allocate any additional data.\n *\n * For example if we kept this as a `Map` we would have to iterate over previous `Map` to determine\n * which values need to be deleted, over the new `Map` to determine additions, and we would have to\n * keep additional `Map` to keep track of duplicates or items which have not yet been visited.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done\n *        for tree shaking purposes.\n * @param stringParser The parser is passed in so that it will be tree shakable. See\n *        `styleStringParser` and `classStringParser`\n * @param value The value to parse/convert to `KeyValueArray`\n */\nexport function toStylingKeyValueArray(\n  keyValueArraySet: (keyValueArray: KeyValueArray<any>, key: string, value: any) => void,\n  stringParser: (styleKeyValueArray: KeyValueArray<any>, text: string) => void,\n  value: string | string[] | {[key: string]: any} | SafeValue | null | undefined,\n): KeyValueArray<any> {\n  if (value == null /*|| value === undefined */ || value === '') return EMPTY_ARRAY as any;\n  const styleKeyValueArray: KeyValueArray<any> = [] as any;\n  const unwrappedValue = unwrapSafeValue(value) as string | string[] | {[key: string]: any};\n  if (Array.isArray(unwrappedValue)) {\n    for (let i = 0; i < unwrappedValue.length; i++) {\n      keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);\n    }\n  } else if (typeof unwrappedValue === 'object') {\n    for (const key in unwrappedValue) {\n      if (unwrappedValue.hasOwnProperty(key)) {\n        keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);\n      }\n    }\n  } else if (typeof unwrappedValue === 'string') {\n    stringParser(styleKeyValueArray, unwrappedValue);\n  } else {\n    ngDevMode &&\n      throwError(\n        'Unsupported styling type: ' + typeof unwrappedValue + ' (' + unwrappedValue + ')',\n      );\n  }\n  return styleKeyValueArray;\n}\n\n/**\n * Set a `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nexport function styleKeyValueArraySet(keyValueArray: KeyValueArray<any>, key: string, value: any) {\n  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));\n}\n\n/**\n * Class-binding-specific function for setting the `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nexport function classKeyValueArraySet(keyValueArray: KeyValueArray<any>, key: unknown, value: any) {\n  // We use `classList.add` to eventually add the CSS classes to the DOM node. Any value passed into\n  // `add` is stringified and added to the `class` attribute, e.g. even null, undefined or numbers\n  // will be added. Stringify the key here so that our internal data structure matches the value in\n  // the DOM. The only exceptions are empty strings and strings that contain spaces for which\n  // the browser throws an error. We ignore such values, because the error is somewhat cryptic.\n  const stringKey = String(key);\n  if (stringKey !== '' && !stringKey.includes(' ')) {\n    keyValueArraySet(keyValueArray, stringKey, value);\n  }\n}\n\n/**\n * Update map based styling.\n *\n * Map based styling could be anything which contains more than one binding. For example `string`,\n * or object literal. Dealing with all of these types would complicate the logic so\n * instead this function expects that the complex input is first converted into normalized\n * `KeyValueArray`. The advantage of normalization is that we get the values sorted, which makes it\n * very cheap to compute deltas between the previous and current value.\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param oldKeyValueArray Previous value represented as `KeyValueArray`\n * @param newKeyValueArray Current value represented as `KeyValueArray`\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStylingMap(\n  tView: TView,\n  tNode: TNode,\n  lView: LView,\n  renderer: Renderer,\n  oldKeyValueArray: KeyValueArray<any>,\n  newKeyValueArray: KeyValueArray<any>,\n  isClassBased: boolean,\n  bindingIndex: number,\n) {\n  if ((oldKeyValueArray as KeyValueArray<any> | NO_CHANGE) === NO_CHANGE) {\n    // On first execution the oldKeyValueArray is NO_CHANGE => treat it as empty KeyValueArray.\n    oldKeyValueArray = EMPTY_ARRAY as any;\n  }\n  let oldIndex = 0;\n  let newIndex = 0;\n  let oldKey: string | null = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;\n  let newKey: string | null = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;\n  while (oldKey !== null || newKey !== null) {\n    ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');\n    ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');\n    const oldValue =\n      oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;\n    const newValue =\n      newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;\n    let setKey: string | null = null;\n    let setValue: any = undefined;\n    if (oldKey === newKey) {\n      // UPDATE: Keys are equal => new value is overwriting old value.\n      oldIndex += 2;\n      newIndex += 2;\n      if (oldValue !== newValue) {\n        setKey = newKey;\n        setValue = newValue;\n      }\n    } else if (newKey === null || (oldKey !== null && oldKey < newKey!)) {\n      // DELETE: oldKey key is missing or we did not find the oldKey in the newValue\n      // (because the keyValueArray is sorted and `newKey` is found later alphabetically).\n      // `\"background\" < \"color\"` so we need to delete `\"background\"` because it is not found in the\n      // new array.\n      oldIndex += 2;\n      setKey = oldKey;\n    } else {\n      // CREATE: newKey's is earlier alphabetically than oldKey's (or no oldKey) => we have new key.\n      // `\"color\" > \"background\"` so we need to add `color` because it is in new array but not in\n      // old array.\n      ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');\n      newIndex += 2;\n      setKey = newKey;\n      setValue = newValue;\n    }\n    if (setKey !== null) {\n      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);\n    }\n    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;\n    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;\n  }\n}\n\n/**\n * Update a simple (property name) styling.\n *\n * This function takes `prop` and updates the DOM to that value. The function takes the binding\n * value as well as binding priority into consideration to determine which value should be written\n * to DOM. (For example it may be determined that there is a higher priority overwrite which blocks\n * the DOM write, or if the value goes to `undefined` a lower priority overwrite may be consulted.)\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param prop Either style property name or a class name.\n * @param value Either style value for `prop` or `true`/`false` if `prop` is class.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStyling(\n  tView: TView,\n  tNode: TNode,\n  lView: LView,\n  renderer: Renderer,\n  prop: string,\n  value: string | undefined | null | boolean,\n  isClassBased: boolean,\n  bindingIndex: number,\n) {\n  if (!(tNode.type & TNodeType.AnyRNode)) {\n    // It is possible to have styling on non-elements (such as ng-container).\n    // This is rare, but it does happen. In such a case, just ignore the binding.\n    return;\n  }\n  const tData = tView.data;\n  const tRange = tData[bindingIndex + 1] as TStylingRange;\n  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange)\n    ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased)\n    : undefined;\n  if (!isStylingValuePresent(higherPriorityValue)) {\n    // We don't have a next duplicate, or we did not find a duplicate value.\n    if (!isStylingValuePresent(value)) {\n      // We should delete current value or restore to lower priority value.\n      if (getTStylingRangePrevDuplicate(tRange)) {\n        // We have a possible prev duplicate, let's retrieve it.\n        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);\n      }\n    }\n    const rNode = getNativeByIndex(getSelectedIndex(), lView) as RElement;\n    applyStyling(renderer, isClassBased, rNode, prop, value);\n  }\n}\n\n/**\n * Search for styling value with higher priority which is overwriting current value, or a\n * value of lower priority to which we should fall back if the value is `undefined`.\n *\n * When value is being applied at a location, related values need to be consulted.\n * - If there is a higher priority binding, we should be using that one instead.\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp1`\n *   requires that we check `exp2` to see if it is set to value other than `undefined`.\n * - If there is a lower priority binding and we are changing to `undefined`\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp2` to\n *   `undefined` requires that we check `exp1` (and static values) and use that as new value.\n *\n * NOTE: The styling stores two values.\n * 1. The raw value which came from the application is stored at `index + 0` location. (This value\n *    is used for dirty checking).\n * 2. The normalized value is stored at `index + 1`.\n *\n * @param tData `TData` used for traversing the priority.\n * @param tNode `TNode` to use for resolving static styling. Also controls search direction.\n *   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n *      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n *   - `null` search prev and go all the way to end. Return last value where\n *     `isStylingValuePresent(value)` is true.\n * @param lView `LView` used for retrieving the actual values.\n * @param prop Property which we are interested in.\n * @param index Starting index in the linked list of styling bindings where the search should start.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction findStylingValue(\n  tData: TData,\n  tNode: TNode | null,\n  lView: LView,\n  prop: string,\n  index: number,\n  isClassBased: boolean,\n): any {\n  // `TNode` to use for resolving static styling. Also controls search direction.\n  //   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n  //      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n  //   - `null` search prev and go all the way to end. Return last value where\n  //     `isStylingValuePresent(value)` is true.\n  const isPrevDirection = tNode === null;\n  let value: any = undefined;\n  while (index > 0) {\n    const rawKey = tData[index] as TStylingKey;\n    const containsStatics = Array.isArray(rawKey);\n    // Unwrap the key if we contain static values.\n    const key = containsStatics ? (rawKey as string[])[1] : rawKey;\n    const isStylingMap = key === null;\n    let valueAtLViewIndex = lView[index + 1];\n    if (valueAtLViewIndex === NO_CHANGE) {\n      // In firstUpdatePass the styling instructions create a linked list of styling.\n      // On subsequent passes it is possible for a styling instruction to try to read a binding\n      // which\n      // has not yet executed. In that case we will find `NO_CHANGE` and we should assume that\n      // we have `undefined` (or empty array in case of styling-map instruction) instead. This\n      // allows the resolution to apply the value (which may later be overwritten when the\n      // binding actually executes.)\n      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : undefined;\n    }\n    let currentValue = isStylingMap\n      ? keyValueArrayGet(valueAtLViewIndex, prop)\n      : key === prop\n        ? valueAtLViewIndex\n        : undefined;\n    if (containsStatics && !isStylingValuePresent(currentValue)) {\n      currentValue = keyValueArrayGet(rawKey as KeyValueArray<any>, prop);\n    }\n    if (isStylingValuePresent(currentValue)) {\n      value = currentValue;\n      if (isPrevDirection) {\n        return value;\n      }\n    }\n    const tRange = tData[index + 1] as TStylingRange;\n    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);\n  }\n  if (tNode !== null) {\n    // in case where we are going in next direction AND we did not find anything, we need to\n    // consult residual styling\n    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n    if (residual != null /** OR residual !=== undefined */) {\n      value = keyValueArrayGet(residual!, prop);\n    }\n  }\n  return value;\n}\n\n/**\n * Determines if the binding value should be used (or if the value is 'undefined' and hence priority\n * resolution should be used.)\n *\n * @param value Binding style value.\n */\nfunction isStylingValuePresent(value: any): boolean {\n  // Currently only `undefined` value is considered non-binding. That is `undefined` says I don't\n  // have an opinion as to what this binding should be and you should consult other bindings by\n  // priority to determine the valid value.\n  // This is extracted into a single function so that we have a single place to control this.\n  return value !== undefined;\n}\n\n/**\n * Normalizes and/or adds a suffix to the value.\n *\n * If value is `null`/`undefined` no suffix is added\n * @param value\n * @param suffix\n */\nfunction normalizeSuffix(\n  value: any,\n  suffix: string | undefined | null,\n): string | null | undefined | boolean {\n  if (value == null || value === '') {\n    // do nothing\n    // Do not add the suffix if the value is going to be empty.\n    // As it produce invalid CSS, which the browsers will automatically omit but Domino will not.\n    // Example: `\"left\": \"px;\"` instead of `\"left\": \"\"`.\n  } else if (typeof suffix === 'string') {\n    value = value + suffix;\n  } else if (typeof value === 'object') {\n    value = stringify(unwrapSafeValue(value));\n  }\n  return value;\n}\n\n/**\n * Tests if the `TNode` has input shadow.\n *\n * An input shadow is when a directive steals (shadows) the input by using `@Input('style')` or\n * `@Input('class')` as input.\n *\n * @param tNode `TNode` which we would like to see if it has shadow.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nexport function hasStylingInputShadow(tNode: TNode, isClassBased: boolean) {\n  return (tNode.flags & (isClassBased ? TNodeFlags.hasClassInput : TNodeFlags.hasStyleInput)) !== 0;\n}\n"]}