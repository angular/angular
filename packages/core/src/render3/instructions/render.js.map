{"version":3,"file":"render.js","sourceRoot":"","sources":["render.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {retrieveHydrationInfo} from '../../hydration/utils';\nimport {assertEqual, assertNotReactive} from '../../util/assert';\nimport {RenderFlags} from '../interfaces/definition';\nimport {\n  CONTEXT,\n  FLAGS,\n  HOST,\n  HYDRATION,\n  INJECTOR,\n  LView,\n  LViewFlags,\n  QUERIES,\n  TVIEW,\n  TView,\n} from '../interfaces/view';\nimport {profiler} from '../profiler';\nimport {ProfilerEvent} from '../profiler_types';\nimport {executeViewQueryFn, refreshContentQueries} from '../queries/query_execution';\nimport {enterView, leaveView} from '../state';\nimport {getComponentLViewByIndex, isCreationMode} from '../util/view_utils';\n\nimport {executeTemplate} from './shared';\n\nexport function renderComponent(hostLView: LView, componentHostIdx: number) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  const componentTView = componentView[TVIEW];\n  syncViewWithBlueprint(componentTView, componentView);\n\n  const hostRNode = componentView[HOST];\n  // Populate an LView with hydration info retrieved from the DOM via TransferState.\n  if (hostRNode !== null && componentView[HYDRATION] === null) {\n    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR]);\n  }\n\n  profiler(ProfilerEvent.ComponentStart);\n\n  renderView(componentTView, componentView, componentView[CONTEXT]);\n\n  profiler(ProfilerEvent.ComponentEnd, componentView[CONTEXT] as any as {});\n}\n\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```html\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\nexport function syncViewWithBlueprint(tView: TView, lView: LView) {\n  for (let i = lView.length; i < tView.blueprint.length; i++) {\n    lView.push(tView.blueprint[i]);\n  }\n}\n\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nexport function renderView<T>(tView: TView, lView: LView<T>, context: T): void {\n  ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n  ngDevMode && assertNotReactive(renderView.name);\n  enterView(lView);\n  try {\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn<T>(RenderFlags.Create, viewQuery, context);\n    }\n\n    // Execute a template associated with this view, if it exists. A template function might not be\n    // defined for the root component views.\n    const templateFn = tView.template;\n    if (templateFn !== null) {\n      executeTemplate<T>(tView, lView, templateFn, RenderFlags.Create, context);\n    }\n\n    // This needs to be set before children are processed to support recursive components.\n    // This must be set to false immediately after the first creation run because in an\n    // ngFor loop, all the views will be created together before update mode runs and turns\n    // off firstCreatePass. If we don't set it here, instances will perform directive\n    // matching, etc again and again.\n    if (tView.firstCreatePass) {\n      tView.firstCreatePass = false;\n    }\n\n    // Mark all queries active in this view as dirty. This is necessary for signal-based queries to\n    // have a clear marking point where we can read query results atomically (for a given view).\n    lView[QUERIES]?.finishViewCreation(tView);\n\n    // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n    // content queries are resolved during change detection (i.e. update mode), after embedded\n    // views are refreshed (see block above).\n    if (tView.staticContentQueries) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // We must materialize query results before child components are processed\n    // in case a child component has projected a container. The LContainer needs\n    // to exist so the embedded views are properly attached by the container.\n    if (tView.staticViewQueries) {\n      executeViewQueryFn<T>(RenderFlags.Update, tView.viewQuery!, context);\n    }\n\n    // Render child component views.\n    const components = tView.components;\n    if (components !== null) {\n      renderChildComponents(lView, components);\n    }\n  } catch (error) {\n    // If we didn't manage to get past the first template pass due to\n    // an error, mark the view as corrupted so we can try to recover.\n    if (tView.firstCreatePass) {\n      tView.incompleteFirstPass = true;\n      tView.firstCreatePass = false;\n    }\n\n    throw error;\n  } finally {\n    lView[FLAGS] &= ~LViewFlags.CreationMode;\n    leaveView();\n  }\n}\n\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView: LView, components: number[]): void {\n  for (let i = 0; i < components.length; i++) {\n    renderComponent(hostLView, components[i]);\n  }\n}\n"]}