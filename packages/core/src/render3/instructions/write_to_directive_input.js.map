{"version":3,"file":"write_to_directive_input.js","sourceRoot":"","sources":["write_to_directive_input.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,iBAAiB,EAAE,MAAM,EAAC,MAAM,6BAA6B,CAAC;AAItE,OAAO,EAAC,sBAAsB,EAAC,MAAM,4BAA4B,CAAC;AAElE,OAAO,EAAC,UAAU,EAAC,MAAM,2BAA2B,CAAC;AACrD,OAAO,EAAC,mBAAmB,EAAC,MAAM,wBAAwB,CAAC;AAE3D,MAAM,UAAU,qBAAqB,CACnC,GAAoB,EACpB,QAAW,EACX,UAAkB,EAClB,KAAc;IAEd,MAAM,YAAY,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC7C,IAAI,CAAC;QACH,IAAI,SAAS,EAAE,CAAC;YACd,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,CAAC;gBAC3C,MAAM,IAAI,KAAK,CACb,8BAA8B,GAAG,CAAC,IAAI,CAAC,IAAI,kDAAkD,UAAU,GAAG,CAC3G,CAAC;YACJ,CAAC;YAED,0FAA0F;YAC1F,0FAA0F;YAC1F,8FAA8F;YAC9F,IAAI,QAAQ,YAAY,mBAAmB,EAAE,CAAC;gBAC5C,MAAM,IAAI,KAAK,CACb,2DAA2D,GAAG,CAAC,IAAI,CAAC,IAAI,uCAAuC,CAChH,CAAC;YACJ,CAAC;QACH,CAAC;QAED,MAAM,CAAC,WAAW,EAAE,KAAK,EAAE,SAAS,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QAE/D,wEAAwE;QACxE,qEAAqE;QACrE,wEAAwE;QACxE,oEAAoE;QACpE,IAAI,eAAe,GAA6C,IAAI,CAAC;QACrE,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC;YAC3C,MAAM,KAAK,GAAI,QAAgB,CAAC,WAAW,CAA+C,CAAC;YAC3F,eAAe,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;QAClC,CAAC;QAED,uEAAuE;QACvE,6CAA6C;QAC7C,IAAI,eAAe,KAAK,IAAI,IAAI,eAAe,CAAC,WAAW,KAAK,SAAS,EAAE,CAAC;YAC1E,KAAK,GAAG,eAAe,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAC7C,CAAC;aAAM,IAAI,SAAS,KAAK,IAAI,EAAE,CAAC;YAC9B,mDAAmD;YACnD,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QAC1C,CAAC;QAED,IAAI,GAAG,CAAC,QAAQ,KAAK,IAAI,EAAE,CAAC;YAC1B,GAAG,CAAC,QAAQ,CAAC,QAAQ,EAAE,eAAe,EAAE,KAAK,EAAE,UAAU,EAAE,WAAW,CAAC,CAAC;QAC1E,CAAC;aAAM,CAAC;YACN,sBAAsB,CAAC,QAAQ,EAAE,eAAe,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;QACxE,CAAC;IACH,CAAC;YAAS,CAAC;QACT,iBAAiB,CAAC,YAAY,CAAC,CAAC;IAClC,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {setActiveConsumer, SIGNAL} from '../../../primitives/signals';\n\nimport {InputSignalWithTransform} from '../../authoring/input/input_signal';\nimport {InputSignalNode} from '../../authoring/input/input_signal_node';\nimport {applyValueToInputField} from '../apply_value_input_field';\nimport {DirectiveDef} from '../interfaces/definition';\nimport {InputFlags} from '../interfaces/input_flags';\nimport {NodeInjectorFactory} from '../interfaces/injector';\n\nexport function writeToDirectiveInput<T>(\n  def: DirectiveDef<T>,\n  instance: T,\n  publicName: string,\n  value: unknown,\n) {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    if (ngDevMode) {\n      if (!def.inputs.hasOwnProperty(publicName)) {\n        throw new Error(\n          `ASSERTION ERROR: Directive ${def.type.name} does not have an input with a public name of \"${publicName}\"`,\n        );\n      }\n\n      // Usually we resolve the directive instance using `LView[someIndex]` before writing to an\n      // input, however if the read happens to early, the `LView[someIndex]` might actually be a\n      // `NodeInjectorFactory`. Check for this specific case here since it can break in subtle ways.\n      if (instance instanceof NodeInjectorFactory) {\n        throw new Error(\n          `ASSERTION ERROR: Cannot write input to factory for type ${def.type.name}. Directive has not been created yet.`,\n        );\n      }\n    }\n\n    const [privateName, flags, transform] = def.inputs[publicName];\n\n    // If we know we are dealing with a signal input, we cache its reference\n    // in a tree-shakable way. The input signal node can then be used for\n    // value transform execution or actual value updates without introducing\n    // additional megamorphic accesses for accessing the instance field.\n    let inputSignalNode: InputSignalNode<unknown, unknown> | null = null;\n    if ((flags & InputFlags.SignalBased) !== 0) {\n      const field = (instance as any)[privateName] as InputSignalWithTransform<unknown, unknown>;\n      inputSignalNode = field[SIGNAL];\n    }\n\n    // If there is a signal node and a transform, run it before potentially\n    // delegating to features like `NgOnChanges`.\n    if (inputSignalNode !== null && inputSignalNode.transformFn !== undefined) {\n      value = inputSignalNode.transformFn(value);\n    } else if (transform !== null) {\n      // If there is a decorator input transform, run it.\n      value = transform.call(instance, value);\n    }\n\n    if (def.setInput !== null) {\n      def.setInput(instance, inputSignalNode, value, publicName, privateName);\n    } else {\n      applyValueToInputField(instance, inputSignalNode, privateName, value);\n    }\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n"]}