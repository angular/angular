{"version":3,"file":"component.js","sourceRoot":"","sources":["component.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAsB,eAAe,EAAC,MAAM,mBAAmB,CAAC;AAIvE,OAAO,EAAC,gBAAgB,EAAC,MAAM,iBAAiB,CAAC;AACjD,OAAO,EAAC,eAAe,EAAC,MAAM,eAAe,CAAC;AAE9C,OAAO,EAAC,kBAAkB,EAAC,MAAM,UAAU,CAAC;AAE5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6DG;AACH,MAAM,UAAU,eAAe,CAC7B,SAAkB,EAClB,OAOC;IAED,SAAS,IAAI,kBAAkB,CAAC,SAAS,CAAC,CAAC;IAC3C,MAAM,YAAY,GAAG,eAAe,CAAC,SAAS,CAAE,CAAC;IACjD,MAAM,eAAe,GAAG,OAAO,CAAC,eAAe,IAAI,eAAe,EAAE,CAAC;IACrE,MAAM,OAAO,GAAG,IAAI,gBAAgB,CAAI,YAAY,CAAC,CAAC;IACtD,OAAO,OAAO,CAAC,MAAM,CACnB,eAAe,EACf,OAAO,CAAC,gBAAgB,EACxB,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,mBAAmB,EAC3B,OAAO,CAAC,UAAU,EAClB,OAAO,CAAC,QAAQ,CACjB,CAAC;AACJ,CAAC;AA8CD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCG;AACH,MAAM,UAAU,oBAAoB,CAAI,SAAkB;IACxD,MAAM,YAAY,GAAG,eAAe,CAAC,SAAS,CAAC,CAAC;IAChD,IAAI,CAAC,YAAY;QAAE,OAAO,IAAI,CAAC;IAE/B,MAAM,OAAO,GAAG,IAAI,gBAAgB,CAAI,YAAY,CAAC,CAAC;IACtD,OAAO;QACL,IAAI,QAAQ;YACV,OAAO,OAAO,CAAC,QAAQ,CAAC;QAC1B,CAAC;QACD,IAAI,IAAI;YACN,OAAO,OAAO,CAAC,aAAa,CAAC;QAC/B,CAAC;QACD,IAAI,MAAM;YAMR,OAAO,OAAO,CAAC,MAAM,CAAC;QACxB,CAAC;QACD,IAAI,OAAO;YACT,OAAO,OAAO,CAAC,OAAO,CAAC;QACzB,CAAC;QACD,IAAI,kBAAkB;YACpB,OAAO,OAAO,CAAC,kBAAkB,CAAC;QACpC,CAAC;QACD,IAAI,YAAY;YACd,OAAO,YAAY,CAAC,UAAU,CAAC;QACjC,CAAC;QACD,IAAI,QAAQ;YACV,OAAO,YAAY,CAAC,OAAO,CAAC;QAC9B,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector} from '../di/injector';\nimport {EnvironmentInjector, getNullInjector} from '../di/r3_injector';\nimport {Type} from '../interface/type';\nimport {ComponentRef} from '../linker/component_factory';\n\nimport {ComponentFactory} from './component_ref';\nimport {getComponentDef} from './def_getters';\nimport {Binding, DirectiveWithBindings} from './dynamic_bindings';\nimport {assertComponentDef} from './errors';\n\n/**\n * Creates a `ComponentRef` instance based on provided component type and a set of options.\n *\n * @usageNotes\n *\n * The example below demonstrates how the `createComponent` function can be used\n * to create an instance of a ComponentRef dynamically and attach it to an ApplicationRef,\n * so that it gets included into change detection cycles.\n *\n * Note: the example uses standalone components, but the function can also be used for\n * non-standalone components (declared in an NgModule) as well.\n *\n * ```angular-ts\n * @Component({\n *   template: `Hello {{ name }}!`\n * })\n * class HelloComponent {\n *   name = 'Angular';\n * }\n *\n * @Component({\n *   template: `<div id=\"hello-component-host\"></div>`\n * })\n * class RootComponent {}\n *\n * // Bootstrap an application.\n * const applicationRef = await bootstrapApplication(RootComponent);\n *\n * // Locate a DOM node that would be used as a host.\n * const hostElement = document.getElementById('hello-component-host');\n *\n * // Get an `EnvironmentInjector` instance from the `ApplicationRef`.\n * const environmentInjector = applicationRef.injector;\n *\n * // We can now create a `ComponentRef` instance.\n * const componentRef = createComponent(HelloComponent, {hostElement, environmentInjector});\n *\n * // Last step is to register the newly created ref using the `ApplicationRef` instance\n * // to include the component view into change detection cycles.\n * applicationRef.attachView(componentRef.hostView);\n * componentRef.changeDetectorRef.detectChanges();\n * ```\n *\n * @param component Component class reference.\n * @param options Set of options to use:\n *  * `environmentInjector`: An `EnvironmentInjector` instance to be used for the component.\n *  * `hostElement` (optional): A DOM node that should act as a host node for the component. If not\n * provided, Angular creates one based on the tag name used in the component selector (and falls\n * back to using `div` if selector doesn't have tag name info).\n *  * `elementInjector` (optional): An `ElementInjector` instance, see additional info about it\n * [here](guide/di/hierarchical-dependency-injection#elementinjector).\n *  * `projectableNodes` (optional): A list of DOM nodes that should be projected through\n * [`<ng-content>`](api/core/ng-content) of the new component instance, e.g.,\n * `[[element1, element2]]`: projects `element1` and `element2` into the same `<ng-content>`.\n * `[[element1, element2], [element3]]`: projects `element1` and `element2` into one `<ng-content>`,\n * and `element3` into a separate `<ng-content>`.\n *  * `directives` (optional): Directives that should be applied to the component.\n *  * `bindings` (optional): Bindings to apply to the root component.\n * @returns ComponentRef instance that represents a given Component.\n *\n * @publicApi\n */\nexport function createComponent<C>(\n  component: Type<C>,\n  options: {\n    environmentInjector: EnvironmentInjector;\n    hostElement?: Element;\n    elementInjector?: Injector;\n    projectableNodes?: Node[][];\n    directives?: (Type<unknown> | DirectiveWithBindings<unknown>)[];\n    bindings?: Binding[];\n  },\n): ComponentRef<C> {\n  ngDevMode && assertComponentDef(component);\n  const componentDef = getComponentDef(component)!;\n  const elementInjector = options.elementInjector || getNullInjector();\n  const factory = new ComponentFactory<C>(componentDef);\n  return factory.create(\n    elementInjector,\n    options.projectableNodes,\n    options.hostElement,\n    options.environmentInjector,\n    options.directives,\n    options.bindings,\n  );\n}\n\n/**\n * An interface that describes the subset of component metadata\n * that can be retrieved using the `reflectComponentType` function.\n *\n * @publicApi\n */\nexport interface ComponentMirror<C> {\n  /**\n   * The component's HTML selector.\n   */\n  get selector(): string;\n  /**\n   * The type of component the factory will create.\n   */\n  get type(): Type<C>;\n  /**\n   * The inputs of the component.\n   */\n  get inputs(): ReadonlyArray<{\n    readonly propName: string;\n    readonly templateName: string;\n    readonly transform?: (value: any) => any;\n    readonly isSignal: boolean;\n  }>;\n  /**\n   * The outputs of the component.\n   */\n  get outputs(): ReadonlyArray<{readonly propName: string; readonly templateName: string}>;\n  /**\n   * Selector for all <ng-content> elements in the component.\n   */\n  get ngContentSelectors(): ReadonlyArray<string>;\n  /**\n   * Whether this component is marked as standalone.\n   * Note: an extra flag, not present in `ComponentFactory`.\n   */\n  get isStandalone(): boolean;\n  /**\n   * // TODO(signals): Remove internal and add public documentation\n   * @internal\n   */\n  get isSignal(): boolean;\n}\n\n/**\n * Creates an object that allows to retrieve component metadata.\n *\n * @usageNotes\n *\n * The example below demonstrates how to use the function and how the fields\n * of the returned object map to the component metadata.\n *\n * ```angular-ts\n * @Component({\n *   selector: 'foo-component',\n *   template: `\n *     <ng-content></ng-content>\n *     <ng-content select=\"content-selector-a\"></ng-content>\n *   `,\n * })\n * class FooComponent {\n *   @Input('inputName') inputPropName: string;\n *   @Output('outputName') outputPropName = new EventEmitter<void>();\n * }\n *\n * const mirror = reflectComponentType(FooComponent);\n * expect(mirror.type).toBe(FooComponent);\n * expect(mirror.selector).toBe('foo-component');\n * expect(mirror.isStandalone).toBe(true);\n * expect(mirror.inputs).toEqual([{propName: 'inputName', templateName: 'inputPropName'}]);\n * expect(mirror.outputs).toEqual([{propName: 'outputName', templateName: 'outputPropName'}]);\n * expect(mirror.ngContentSelectors).toEqual([\n *   '*',                 // first `<ng-content>` in a template, the selector defaults to `*`\n *   'content-selector-a' // second `<ng-content>` in a template\n * ]);\n * ```\n *\n * @param component Component class reference.\n * @returns An object that allows to retrieve component metadata.\n *\n * @publicApi\n */\nexport function reflectComponentType<C>(component: Type<C>): ComponentMirror<C> | null {\n  const componentDef = getComponentDef(component);\n  if (!componentDef) return null;\n\n  const factory = new ComponentFactory<C>(componentDef);\n  return {\n    get selector(): string {\n      return factory.selector;\n    },\n    get type(): Type<C> {\n      return factory.componentType;\n    },\n    get inputs(): ReadonlyArray<{\n      propName: string;\n      templateName: string;\n      transform?: (value: any) => any;\n      isSignal: boolean;\n    }> {\n      return factory.inputs;\n    },\n    get outputs(): ReadonlyArray<{propName: string; templateName: string}> {\n      return factory.outputs;\n    },\n    get ngContentSelectors(): ReadonlyArray<string> {\n      return factory.ngContentSelectors;\n    },\n    get isStandalone(): boolean {\n      return componentDef.standalone;\n    },\n    get isSignal(): boolean {\n      return componentDef.signals;\n    },\n  };\n}\n"]}