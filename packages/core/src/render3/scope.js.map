{"version":3,"file":"scope.js","sourceRoot":"","sources":["scope.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,YAAY,EAAE,iBAAiB,EAAC,MAAM,mBAAmB,CAAC;AAElE,OAAO,EAAC,OAAO,EAAC,MAAM,qBAAqB,CAAC;AAC5C,OAAO,EAAC,aAAa,EAAC,MAAM,iBAAiB,CAAC;AAC9C,OAAO,EAAC,WAAW,EAAC,MAAM,eAAe,CAAC;AAC1C,OAAO,EAAC,qBAAqB,EAAE,UAAU,EAAC,MAAM,eAAe,CAAC;AAEhE,OAAO,EAAC,uBAAuB,EAAE,mBAAmB,EAAC,MAAM,cAAc,CAAC;AAC1E,OAAO,EAAC,WAAW,EAAC,MAAM,6BAA6B,CAAC;AAOxD,OAAO,EAAC,qBAAqB,EAAC,MAAM,YAAY,CAAC;AAEjD;;;;;;;;GAQG;AACH,MAAM,UAAU,mBAAmB,CACjC,IAAwB,EACxB,UAA6C,EAC7C,KAAwC;IAExC,MAAM,GAAG,GAAG,IAAI,CAAC,IAAyB,CAAC;IAC3C,GAAG,CAAC,aAAa,GAAG,uBAAuB,CAAC,UAAU,EAAE,mBAAmB,CAAC,CAAC;IAC7E,GAAG,CAAC,QAAQ,GAAG,uBAAuB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AAC5D,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,kBAAkB,CAAC,IAAS,EAAE,KAAqC;IACjF,OAAO,aAAa,CAAC,GAAG,EAAE;QACxB,MAAM,WAAW,GAAG,qBAAqB,CAAC,IAAI,CAAC,CAAC;QAChD,WAAW,CAAC,YAAY,GAAG,kBAAkB,CAAC,KAAK,CAAC,YAAY,IAAI,WAAW,CAAC,CAAC;QACjF,WAAW,CAAC,OAAO,GAAG,kBAAkB,CAAC,KAAK,CAAC,OAAO,IAAI,WAAW,CAAC,CAAC;QACvE,WAAW,CAAC,OAAO,GAAG,kBAAkB,CAAC,KAAK,CAAC,OAAO,IAAI,WAAW,CAAC,CAAC;QAEvE,IAAI,KAAK,CAAC,SAAS,EAAE,CAAC;YACpB,+CAA+C;YAC/C,WAAW,CAAC,SAAS,GAAG,kBAAkB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QAC9D,CAAC;QAED,WAAW,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,kBAAkB,CACzB,MAAuE;IAEvE,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE,CAAC;QACjC,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,MAAM,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;IAEtC,IAAI,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC;QACrC,OAAO,GAAG,EAAE,CAAC,aAAa,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC,GAAG,CAAC,8BAA8B,CAAC,CAAC;IACxF,CAAC;SAAM,CAAC;QACN,OAAO,aAAa,CAAC,GAAG,CAAC,8BAA8B,CAAC,CAAC;IAC3D,CAAC;AACH,CAAC;AAED,SAAS,8BAA8B,CAAC,KAAU;IAChD,OAAO,qBAAqB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAE,KAAmB,CAAC;AAC9E,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {isForwardRef, resolveForwardRef} from '../di/forward_ref';\nimport {Type} from '../interface/type';\nimport {flatten} from '../util/array_utils';\nimport {noSideEffects} from '../util/closure';\nimport {EMPTY_ARRAY} from '../util/empty';\nimport {getNgModuleDefOrThrow, getPipeDef} from './def_getters';\n\nimport {extractDefListOrFactory, extractDirectiveDef} from './definition';\nimport {depsTracker} from './deps_tracker/deps_tracker';\nimport {\n  ComponentDef,\n  ComponentType,\n  NgModuleScopeInfoFromDecorator,\n  RawScopeInfoFromDecorator,\n} from './interfaces/definition';\nimport {isModuleWithProviders} from './jit/util';\n\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nexport function ɵɵsetComponentScope(\n  type: ComponentType<any>,\n  directives: Type<any>[] | (() => Type<any>[]),\n  pipes: Type<any>[] | (() => Type<any>[]),\n): void {\n  const def = type.ɵcmp as ComponentDef<any>;\n  def.directiveDefs = extractDefListOrFactory(directives, extractDirectiveDef);\n  def.pipeDefs = extractDefListOrFactory(pipes, getPipeDef);\n}\n\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nexport function ɵɵsetNgModuleScope(type: any, scope: NgModuleScopeInfoFromDecorator): unknown {\n  return noSideEffects(() => {\n    const ngModuleDef = getNgModuleDefOrThrow(type);\n    ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);\n    ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);\n    ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);\n\n    if (scope.bootstrap) {\n      // This only happens in local compilation mode.\n      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);\n    }\n\n    depsTracker.registerNgModule(type, scope);\n  });\n}\n\nfunction convertToTypeArray(\n  values: Type<any>[] | (() => Type<any>[]) | RawScopeInfoFromDecorator[],\n): Type<any>[] | (() => Type<any>[]) {\n  if (typeof values === 'function') {\n    return values;\n  }\n\n  const flattenValues = flatten(values);\n\n  if (flattenValues.some(isForwardRef)) {\n    return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);\n  } else {\n    return flattenValues.map(maybeUnwrapModuleWithProviders);\n  }\n}\n\nfunction maybeUnwrapModuleWithProviders(value: any): Type<any> {\n  return isModuleWithProviders(value) ? value.ngModule : (value as Type<any>);\n}\n"]}