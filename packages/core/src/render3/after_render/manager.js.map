{"version":3,"file":"manager.js","sourceRoot":"","sources":["manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {TracingAction, TracingService, TracingSnapshot} from '../../application/tracing';\nimport {\n  ChangeDetectionScheduler,\n  NotificationSource,\n} from '../../change_detection/scheduling/zoneless_scheduling';\nimport {inject} from '../../di/injector_compatibility';\nimport {ɵɵdefineInjectable} from '../../di/interface/defs';\nimport {ErrorHandler} from '../../error_handler';\nimport {type DestroyRef} from '../../linker/destroy_ref';\nimport {NgZone} from '../../zone';\nimport {AFTER_RENDER_SEQUENCES_TO_ADD, FLAGS, LView, LViewFlags} from '../interfaces/view';\nimport {profiler} from '../profiler';\nimport {ProfilerEvent} from '../profiler_types';\nimport {markAncestorsForTraversal} from '../util/view_utils';\nimport {AfterRenderPhase, AfterRenderRef} from './api';\n\nexport class AfterRenderManager {\n  impl: AfterRenderImpl | null = null;\n\n  execute(): void {\n    this.impl?.execute();\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: AfterRenderManager,\n    providedIn: 'root',\n    factory: () => new AfterRenderManager(),\n  });\n}\n\nexport const AFTER_RENDER_PHASES: AfterRenderPhase[] = /* @__PURE__ **/ (() =>\n  [\n    AfterRenderPhase.EarlyRead,\n    AfterRenderPhase.Write,\n    AfterRenderPhase.MixedReadWrite,\n    AfterRenderPhase.Read,\n  ] as const)();\n\nexport class AfterRenderImpl {\n  private readonly ngZone = inject(NgZone);\n  private readonly scheduler = inject(ChangeDetectionScheduler);\n  private readonly errorHandler = inject(ErrorHandler, {optional: true});\n\n  /** Current set of active sequences. */\n  private readonly sequences = new Set<AfterRenderSequence>();\n\n  /** Tracks registrations made during the current set of executions. */\n  private readonly deferredRegistrations = new Set<AfterRenderSequence>();\n\n  /** Whether the `AfterRenderManager` is currently executing hooks. */\n  executing = false;\n\n  constructor() {\n    // Inject the tracing service to make sure it's initialized.\n    inject(TracingService, {optional: true});\n  }\n\n  /**\n   * Run the sequence of phases of hooks, once through. As a result of executing some hooks, more\n   * might be scheduled.\n   */\n  execute(): void {\n    const hasSequencesToExecute = this.sequences.size > 0;\n\n    if (hasSequencesToExecute) {\n      profiler(ProfilerEvent.AfterRenderHooksStart);\n    }\n\n    this.executing = true;\n    for (const phase of AFTER_RENDER_PHASES) {\n      for (const sequence of this.sequences) {\n        if (sequence.erroredOrDestroyed || !sequence.hooks[phase]) {\n          continue;\n        }\n\n        try {\n          sequence.pipelinedValue = this.ngZone.runOutsideAngular(() =>\n            this.maybeTrace(() => {\n              const hookFn = sequence.hooks[phase]!;\n              const value = hookFn(sequence.pipelinedValue);\n              return value;\n            }, sequence.snapshot),\n          );\n        } catch (err) {\n          sequence.erroredOrDestroyed = true;\n          this.errorHandler?.handleError(err);\n        }\n      }\n    }\n    this.executing = false;\n\n    // Cleanup step to reset sequence state and also collect one-shot sequences for removal.\n    for (const sequence of this.sequences) {\n      sequence.afterRun();\n      if (sequence.once) {\n        this.sequences.delete(sequence);\n        // Destroy the sequence so its on destroy callbacks can be cleaned up\n        // immediately, instead of waiting until the injector is destroyed.\n        sequence.destroy();\n      }\n    }\n\n    for (const sequence of this.deferredRegistrations) {\n      this.sequences.add(sequence);\n    }\n    if (this.deferredRegistrations.size > 0) {\n      this.scheduler.notify(NotificationSource.RenderHook);\n    }\n    this.deferredRegistrations.clear();\n\n    if (hasSequencesToExecute) {\n      profiler(ProfilerEvent.AfterRenderHooksEnd);\n    }\n  }\n\n  register(sequence: AfterRenderSequence): void {\n    const {view} = sequence;\n    if (view !== undefined) {\n      // Delay adding it to the manager, add it to the view instead.\n      (view[AFTER_RENDER_SEQUENCES_TO_ADD] ??= []).push(sequence);\n\n      // Mark the view for traversal to ensure we eventually schedule the afterNextRender.\n      markAncestorsForTraversal(view);\n      view[FLAGS] |= LViewFlags.HasChildViewsToRefresh;\n    } else if (!this.executing) {\n      this.addSequence(sequence);\n    } else {\n      this.deferredRegistrations.add(sequence);\n    }\n  }\n\n  addSequence(sequence: AfterRenderSequence): void {\n    this.sequences.add(sequence);\n    // Trigger an `ApplicationRef.tick()` if one is not already pending/running, because we have a\n    // new render hook that needs to run.\n    this.scheduler.notify(NotificationSource.RenderHook);\n  }\n\n  unregister(sequence: AfterRenderSequence): void {\n    if (this.executing && this.sequences.has(sequence)) {\n      // We can't remove an `AfterRenderSequence` in the middle of iteration.\n      // Instead, mark it as destroyed so it doesn't run any more, and mark it as one-shot so it'll\n      // be removed at the end of the current execution.\n      sequence.erroredOrDestroyed = true;\n      sequence.pipelinedValue = undefined;\n      sequence.once = true;\n    } else {\n      // It's safe to directly remove this sequence.\n      this.sequences.delete(sequence);\n      this.deferredRegistrations.delete(sequence);\n    }\n  }\n\n  protected maybeTrace<T>(fn: () => T, snapshot: TracingSnapshot | null): T {\n    // Only trace the execution if the snapshot is defined.\n    return snapshot ? snapshot.run(TracingAction.AFTER_NEXT_RENDER, fn) : fn();\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: AfterRenderImpl,\n    providedIn: 'root',\n    factory: () => new AfterRenderImpl(),\n  });\n}\n\nexport type AfterRenderHook = (value?: unknown) => unknown;\nexport type AfterRenderHooks = [\n  /*      EarlyRead */ AfterRenderHook | undefined,\n  /*          Write */ AfterRenderHook | undefined,\n  /* MixedReadWrite */ AfterRenderHook | undefined,\n  /*           Read */ AfterRenderHook | undefined,\n];\n\nexport class AfterRenderSequence implements AfterRenderRef {\n  /**\n   * Whether this sequence errored or was destroyed during this execution, and hooks should no\n   * longer run for it.\n   */\n  erroredOrDestroyed: boolean = false;\n\n  /**\n   * The value returned by the last hook execution (if any), ready to be pipelined into the next\n   * one.\n   */\n  pipelinedValue: unknown = undefined;\n\n  private unregisterOnDestroy: (() => void) | undefined;\n\n  constructor(\n    readonly impl: AfterRenderImpl,\n    readonly hooks: AfterRenderHooks,\n    readonly view: LView | undefined,\n    public once: boolean,\n    destroyRef: DestroyRef | null,\n    public snapshot: TracingSnapshot | null = null,\n  ) {\n    this.unregisterOnDestroy = destroyRef?.onDestroy(() => this.destroy());\n  }\n\n  afterRun(): void {\n    this.erroredOrDestroyed = false;\n    this.pipelinedValue = undefined;\n\n    // Clear the tracing snapshot after the initial run. This snapshot only\n    // associates the initial run of the hook with the context that created it.\n    // Follow-up runs are independent of that initial context and have different\n    // triggers.\n    this.snapshot?.dispose();\n    this.snapshot = null;\n  }\n\n  destroy(): void {\n    this.impl.unregister(this);\n    this.unregisterOnDestroy?.();\n    const scheduled = this.view?.[AFTER_RENDER_SEQUENCES_TO_ADD];\n    if (scheduled) {\n      this.view[AFTER_RENDER_SEQUENCES_TO_ADD] = scheduled.filter((s) => s !== this);\n    }\n  }\n}\n"]}