{"version":3,"file":"hooks.js","sourceRoot":"","sources":["hooks.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {TracingService} from '../../application/tracing';\nimport {assertInInjectionContext} from '../../di';\nimport {Injector} from '../../di/injector';\nimport {inject} from '../../di/injector_compatibility';\nimport {DestroyRef} from '../../linker/destroy_ref';\nimport {performanceMarkFeature} from '../../util/performance';\nimport {assertNotInReactiveContext} from '../reactivity/asserts';\nimport {ViewContext} from '../view_context';\nimport {AfterRenderRef} from './api';\nimport {\n  AfterRenderHooks,\n  AfterRenderImpl,\n  AfterRenderManager,\n  AfterRenderSequence,\n} from './manager';\n\n/**\n * An argument list containing the first non-never type in the given type array, or an empty\n * argument list if there are no non-never types in the type array.\n */\nexport type ɵFirstAvailable<T extends unknown[]> = T extends [infer H, ...infer R]\n  ? [H] extends [never]\n    ? ɵFirstAvailable<R>\n    : [H]\n  : [];\n\n/**\n * Options passed to `afterEveryRender` and `afterNextRender`.\n *\n * @publicApi 20.0\n */\nexport interface AfterRenderOptions {\n  /**\n   * The `Injector` to use during creation.\n   *\n   * If this is not provided, the current injection context will be used instead (via `inject`).\n   */\n  injector?: Injector;\n\n  /**\n   * Whether the hook should require manual cleanup.\n   *\n   * If this is `false` (the default) the hook will automatically register itself to be cleaned up\n   * with the current `DestroyRef`.\n   */\n  manualCleanup?: boolean;\n}\n\n/**\n * Register callbacks to be invoked each time the application finishes rendering, during the\n * specified phases. The available phases are:\n * - `earlyRead`\n *   Use this phase to **read** from the DOM before a subsequent `write` callback, for example to\n *   perform custom layout that the browser doesn't natively support. Prefer the `read` phase if\n *   reading can wait until after the write phase. **Never** write to the DOM in this phase.\n * - `write`\n *    Use this phase to **write** to the DOM. **Never** read from the DOM in this phase.\n * - `mixedReadWrite`\n *    Use this phase to read from and write to the DOM simultaneously. **Never** use this phase if\n *    it is possible to divide the work among the other phases instead.\n * - `read`\n *    Use this phase to **read** from the DOM. **Never** write to the DOM in this phase.\n *\n * <div class=\"docs-alert docs-alert-critical\">\n *\n * You should prefer using the `read` and `write` phases over the `earlyRead` and `mixedReadWrite`\n * phases when possible, to avoid performance degradation.\n *\n * </div>\n *\n * Note that:\n * - Callbacks run in the following phase order *after each render*:\n *   1. `earlyRead`\n *   2. `write`\n *   3. `mixedReadWrite`\n *   4. `read`\n * - Callbacks in the same phase run in the order they are registered.\n * - Callbacks run on browser platforms only, they will not run on the server.\n *\n * The first phase callback to run as part of this spec will receive no parameters. Each\n * subsequent phase callback in this spec will receive the return value of the previously run\n * phase callback as a parameter. This can be used to coordinate work across multiple phases.\n *\n * Angular is unable to verify or enforce that phases are used correctly, and instead\n * relies on each developer to follow the guidelines documented for each value and\n * carefully choose the appropriate one, refactoring their code if necessary. By doing\n * so, Angular is better able to minimize the performance degradation associated with\n * manual DOM access, ensuring the best experience for the end users of your application\n * or library.\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param spec The callback functions to register\n * @param options Options to control the behavior of the callback\n *\n * @usageNotes\n *\n * Use `afterEveryRender` to read or write the DOM after each render.\n *\n * ### Example\n * ```angular-ts\n * @Component({\n *   selector: 'my-cmp',\n *   template: `<span #content>{{ ... }}</span>`,\n * })\n * export class MyComponent {\n *   @ViewChild('content') contentRef: ElementRef;\n *\n *   constructor() {\n *     afterEveryRender({\n *       read: () => {\n *         console.log('content height: ' + this.contentRef.nativeElement.scrollHeight);\n *       }\n *     });\n *   }\n * }\n * ```\n *\n * @publicApi 20.0\n */\nexport function afterEveryRender<E = never, W = never, M = never>(\n  spec: {\n    earlyRead?: () => E;\n    write?: (...args: ɵFirstAvailable<[E]>) => W;\n    mixedReadWrite?: (...args: ɵFirstAvailable<[W, E]>) => M;\n    read?: (...args: ɵFirstAvailable<[M, W, E]>) => void;\n  },\n  options?: AfterRenderOptions,\n): AfterRenderRef;\n\n/**\n * Register a callback to be invoked each time the application finishes rendering, during the\n * `mixedReadWrite` phase.\n *\n * <div class=\"docs-alert docs-alert-critical\">\n *\n * You should prefer specifying an explicit phase for the callback instead, or you risk significant\n * performance degradation.\n *\n * </div>\n *\n * Note that the callback will run\n * - in the order it was registered\n * - once per render\n * - on browser platforms only\n * - during the `mixedReadWrite` phase\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param callback A callback function to register\n * @param options Options to control the behavior of the callback\n *\n * @usageNotes\n *\n * Use `afterEveryRender` to read or write the DOM after each render.\n *\n * ### Example\n * ```angular-ts\n * @Component({\n *   selector: 'my-cmp',\n *   template: `<span #content>{{ ... }}</span>`,\n * })\n * export class MyComponent {\n *   @ViewChild('content') contentRef: ElementRef;\n *\n *   constructor() {\n *     afterEveryRender({\n *       read: () => {\n *         console.log('content height: ' + this.contentRef.nativeElement.scrollHeight);\n *       }\n *     });\n *   }\n * }\n * ```\n *\n * @publicApi 20.0\n */\nexport function afterEveryRender(\n  callback: VoidFunction,\n  options?: AfterRenderOptions,\n): AfterRenderRef;\n\nexport function afterEveryRender(\n  callbackOrSpec:\n    | VoidFunction\n    | {\n        earlyRead?: () => unknown;\n        write?: (r?: unknown) => unknown;\n        mixedReadWrite?: (r?: unknown) => unknown;\n        read?: (r?: unknown) => void;\n      },\n  options?: AfterRenderOptions,\n): AfterRenderRef {\n  ngDevMode &&\n    assertNotInReactiveContext(\n      afterEveryRender,\n      'Call `afterEveryRender` outside of a reactive context. For example, schedule the render ' +\n        'callback inside the component constructor`.',\n    );\n\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(afterEveryRender);\n  }\n\n  const injector = options?.injector ?? inject(Injector);\n\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return NOOP_AFTER_RENDER_REF;\n  }\n\n  performanceMarkFeature('NgAfterRender');\n\n  return afterEveryRenderImpl(callbackOrSpec, injector, options, /* once */ false);\n}\n\n/**\n * Register callbacks to be invoked the next time the application finishes rendering, during the\n * specified phases. The available phases are:\n * - `earlyRead`\n *   Use this phase to **read** from the DOM before a subsequent `write` callback, for example to\n *   perform custom layout that the browser doesn't natively support. Prefer the `read` phase if\n *   reading can wait until after the write phase. **Never** write to the DOM in this phase.\n * - `write`\n *    Use this phase to **write** to the DOM. **Never** read from the DOM in this phase.\n * - `mixedReadWrite`\n *    Use this phase to read from and write to the DOM simultaneously. **Never** use this phase if\n *    it is possible to divide the work among the other phases instead.\n * - `read`\n *    Use this phase to **read** from the DOM. **Never** write to the DOM in this phase.\n *\n * <div class=\"docs-alert docs-alert-critical\">\n *\n * You should prefer using the `read` and `write` phases over the `earlyRead` and `mixedReadWrite`\n * phases when possible, to avoid performance degradation.\n *\n * </div>\n *\n * Note that:\n * - Callbacks run in the following phase order *once, after the next render*:\n *   1. `earlyRead`\n *   2. `write`\n *   3. `mixedReadWrite`\n *   4. `read`\n * - Callbacks in the same phase run in the order they are registered.\n * - Callbacks run on browser platforms only, they will not run on the server.\n *\n * The first phase callback to run as part of this spec will receive no parameters. Each\n * subsequent phase callback in this spec will receive the return value of the previously run\n * phase callback as a parameter. This can be used to coordinate work across multiple phases.\n *\n * Angular is unable to verify or enforce that phases are used correctly, and instead\n * relies on each developer to follow the guidelines documented for each value and\n * carefully choose the appropriate one, refactoring their code if necessary. By doing\n * so, Angular is better able to minimize the performance degradation associated with\n * manual DOM access, ensuring the best experience for the end users of your application\n * or library.\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param spec The callback functions to register\n * @param options Options to control the behavior of the callback\n *\n * @usageNotes\n *\n * Use `afterNextRender` to read or write the DOM once,\n * for example to initialize a non-Angular library.\n *\n * ### Example\n * ```angular-ts\n * @Component({\n *   selector: 'my-chart-cmp',\n *   template: `<div #chart>{{ ... }}</div>`,\n * })\n * export class MyChartCmp {\n *   @ViewChild('chart') chartRef: ElementRef;\n *   chart: MyChart|null;\n *\n *   constructor() {\n *     afterNextRender({\n *       write: () => {\n *         this.chart = new MyChart(this.chartRef.nativeElement);\n *       }\n *     });\n *   }\n * }\n * ```\n *\n * @publicApi 20.0\n */\nexport function afterNextRender<E = never, W = never, M = never>(\n  spec: {\n    earlyRead?: () => E;\n    write?: (...args: ɵFirstAvailable<[E]>) => W;\n    mixedReadWrite?: (...args: ɵFirstAvailable<[W, E]>) => M;\n    read?: (...args: ɵFirstAvailable<[M, W, E]>) => void;\n  },\n  options?: AfterRenderOptions,\n): AfterRenderRef;\n\n/**\n * Register a callback to be invoked the next time the application finishes rendering, during the\n * `mixedReadWrite` phase.\n *\n * <div class=\"docs-alert docs-alert-critical\">\n *\n * You should prefer specifying an explicit phase for the callback instead, or you risk significant\n * performance degradation.\n *\n * </div>\n *\n * Note that the callback will run\n * - in the order it was registered\n * - on browser platforms only\n * - during the `mixedReadWrite` phase\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param callback A callback function to register\n * @param options Options to control the behavior of the callback\n *\n * @usageNotes\n *\n * Use `afterNextRender` to read or write the DOM once,\n * for example to initialize a non-Angular library.\n *\n * ### Example\n * ```angular-ts\n * @Component({\n *   selector: 'my-chart-cmp',\n *   template: `<div #chart>{{ ... }}</div>`,\n * })\n * export class MyChartCmp {\n *   @ViewChild('chart') chartRef: ElementRef;\n *   chart: MyChart|null;\n *\n *   constructor() {\n *     afterNextRender({\n *       write: () => {\n *         this.chart = new MyChart(this.chartRef.nativeElement);\n *       }\n *     });\n *   }\n * }\n * ```\n *\n * @publicApi 20.0\n */\nexport function afterNextRender(\n  callback: VoidFunction,\n  options?: AfterRenderOptions,\n): AfterRenderRef;\n\nexport function afterNextRender(\n  callbackOrSpec:\n    | VoidFunction\n    | {\n        earlyRead?: () => unknown;\n        write?: (r?: unknown) => unknown;\n        mixedReadWrite?: (r?: unknown) => unknown;\n        read?: (r?: unknown) => void;\n      },\n  options?: AfterRenderOptions,\n): AfterRenderRef {\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(afterNextRender);\n  }\n\n  const injector = options?.injector ?? inject(Injector);\n\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return NOOP_AFTER_RENDER_REF;\n  }\n\n  performanceMarkFeature('NgAfterNextRender');\n\n  return afterEveryRenderImpl(callbackOrSpec, injector, options, /* once */ true);\n}\n\nfunction getHooks(\n  callbackOrSpec:\n    | VoidFunction\n    | {\n        earlyRead?: () => unknown;\n        write?: (r?: unknown) => unknown;\n        mixedReadWrite?: (r?: unknown) => unknown;\n        read?: (r?: unknown) => void;\n      },\n): AfterRenderHooks {\n  if (callbackOrSpec instanceof Function) {\n    return [undefined, undefined, /* MixedReadWrite */ callbackOrSpec, undefined];\n  } else {\n    return [\n      callbackOrSpec.earlyRead,\n      callbackOrSpec.write,\n      callbackOrSpec.mixedReadWrite,\n      callbackOrSpec.read,\n    ];\n  }\n}\n\n/**\n * Shared implementation for `afterEveryRender` and `afterNextRender`.\n */\nfunction afterEveryRenderImpl(\n  callbackOrSpec:\n    | VoidFunction\n    | {\n        earlyRead?: () => unknown;\n        write?: (r?: unknown) => unknown;\n        mixedReadWrite?: (r?: unknown) => unknown;\n        read?: (r?: unknown) => void;\n      },\n  injector: Injector,\n  options: AfterRenderOptions | undefined,\n  once: boolean,\n): AfterRenderRef {\n  const manager = injector.get(AfterRenderManager);\n  // Lazily initialize the handler implementation, if necessary. This is so that it can be\n  // tree-shaken if `afterEveryRender` and `afterNextRender` aren't used.\n  manager.impl ??= injector.get(AfterRenderImpl);\n\n  const tracing = injector.get(TracingService, null, {optional: true});\n\n  const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n  const viewContext = injector.get(ViewContext, null, {optional: true});\n  const sequence = new AfterRenderSequence(\n    manager.impl,\n    getHooks(callbackOrSpec),\n    viewContext?.view,\n    once,\n    destroyRef,\n    tracing?.snapshot(null),\n  );\n  manager.impl.register(sequence);\n  return sequence;\n}\n\n/** `AfterRenderRef` that does nothing. */\nexport const NOOP_AFTER_RENDER_REF: AfterRenderRef = {\n  destroy() {},\n};\n"]}