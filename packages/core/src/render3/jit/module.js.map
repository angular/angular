{"version":3,"file":"module.js","sourceRoot":"","sources":["module.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  getCompilerFacade,\n  JitCompilerUsage,\n  R3InjectorMetadataFacade,\n} from '../../compiler/compiler_facade';\nimport {resolveForwardRef} from '../../di/forward_ref';\nimport {NG_INJ_DEF} from '../../di/interface/defs';\nimport type {ModuleWithProviders} from '../../di/interface/provider';\nimport {reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {registerNgModuleType} from '../../linker/ng_module_registration';\nimport type {NgModule} from '../../metadata/ng_module';\nimport type {\n  NgModuleDef,\n  NgModuleTransitiveScopes,\n  NgModuleType,\n} from '../../metadata/ng_module_def';\nimport {deepForEach, flatten} from '../../util/array_utils';\nimport {assertDefined} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {GENERATED_COMP_IDS} from '../definition';\nimport {\n  getComponentDef,\n  getDirectiveDef,\n  getNgModuleDef,\n  getNgModuleDefOrThrow,\n  getPipeDef,\n  isStandalone,\n} from '../def_getters';\nimport {depsTracker} from '../deps_tracker/deps_tracker';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF, NG_MOD_DEF, NG_PIPE_DEF} from '../fields';\nimport type {ComponentDef} from '../interfaces/definition';\nimport {maybeUnwrapFn} from '../util/misc_utils';\nimport {stringifyForError} from '../util/stringify_utils';\n\nimport {angularCoreEnv} from './environment';\nimport {patchModuleCompilation} from './module_patch';\nimport {isModuleWithProviders, isNgModule} from './util';\n\ninterface ModuleQueueItem {\n  moduleType: Type<any>;\n  ngModule: NgModule;\n}\n\nconst moduleQueue: ModuleQueueItem[] = [];\n\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\nfunction enqueueModuleForDelayedScoping(moduleType: Type<any>, ngModule: NgModule) {\n  moduleQueue.push({moduleType, ngModule});\n}\n\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nexport function flushModuleScopingQueueAsMuchAsPossible() {\n  if (!flushingModuleQueue) {\n    flushingModuleQueue = true;\n    try {\n      for (let i = moduleQueue.length - 1; i >= 0; i--) {\n        const {moduleType, ngModule} = moduleQueue[i];\n\n        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n          // dequeue\n          moduleQueue.splice(i, 1);\n          setScopeOnDeclaredComponents(moduleType, ngModule);\n        }\n      }\n    } finally {\n      flushingModuleQueue = false;\n    }\n  }\n}\n\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\nfunction isResolvedDeclaration(declaration: any[] | Type<any>): boolean {\n  if (Array.isArray(declaration)) {\n    return declaration.every(isResolvedDeclaration);\n  }\n  return !!resolveForwardRef(declaration);\n}\n\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nexport function compileNgModule(moduleType: Type<any>, ngModule: NgModule = {}): void {\n  patchModuleCompilation();\n  compileNgModuleDefs(moduleType as NgModuleType, ngModule);\n  if (ngModule.id !== undefined) {\n    registerNgModuleType(moduleType as NgModuleType, ngModule.id);\n  }\n\n  // Because we don't know if all declarations have resolved yet at the moment the\n  // NgModule decorator is executing, we're enqueueing the setting of module scope\n  // on its declarations to be run at a later time when all declarations for the module,\n  // including forward refs, have resolved.\n  enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n\n/**\n * Compiles and adds the `ɵmod`, `ɵfac` and `ɵinj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nexport function compileNgModuleDefs(\n  moduleType: NgModuleType,\n  ngModule: NgModule,\n  allowDuplicateDeclarationsInRoot: boolean = false,\n): void {\n  ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n  ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n  let ngModuleDef: any = null;\n  Object.defineProperty(moduleType, NG_MOD_DEF, {\n    configurable: true,\n    get: () => {\n      if (ngModuleDef === null) {\n        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n          // We need to assert this immediately, because allowing it to continue will cause it to\n          // go into an infinite loop before we've reached the point where we throw all the errors.\n          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n        }\n        const compiler = getCompilerFacade({\n          usage: JitCompilerUsage.Decorator,\n          kind: 'NgModule',\n          type: moduleType,\n        });\n        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {\n          type: moduleType,\n          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n          declarations: declarations.map(resolveForwardRef),\n          imports: flatten(ngModule.imports || EMPTY_ARRAY)\n            .map(resolveForwardRef)\n            .map(expandModuleWithProviders),\n          exports: flatten(ngModule.exports || EMPTY_ARRAY)\n            .map(resolveForwardRef)\n            .map(expandModuleWithProviders),\n          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,\n          id: ngModule.id || null,\n        });\n        // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n        // should verify that there are no unknown elements in a template. In AOT mode, that check\n        // happens at compile time and `schemas` information is not present on Component and Module\n        // defs after compilation (so the check doesn't happen the second time at runtime).\n        if (!ngModuleDef.schemas) {\n          ngModuleDef.schemas = [];\n        }\n      }\n      return ngModuleDef;\n    },\n  });\n\n  let ngFactoryDef: any = null;\n  Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const compiler = getCompilerFacade({\n          usage: JitCompilerUsage.Decorator,\n          kind: 'NgModule',\n          type: moduleType,\n        });\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {\n          name: moduleType.name,\n          type: moduleType,\n          deps: reflectDependencies(moduleType),\n          target: compiler.FactoryTarget.NgModule,\n          typeArgumentCount: 0,\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n\n  let ngInjectorDef: any = null;\n  Object.defineProperty(moduleType, NG_INJ_DEF, {\n    get: () => {\n      if (ngInjectorDef === null) {\n        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n        const meta: R3InjectorMetadataFacade = {\n          name: moduleType.name,\n          type: moduleType,\n          providers: ngModule.providers || EMPTY_ARRAY,\n          imports: [\n            (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),\n            (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef),\n          ],\n        };\n        const compiler = getCompilerFacade({\n          usage: JitCompilerUsage.Decorator,\n          kind: 'NgModule',\n          type: moduleType,\n        });\n        ngInjectorDef = compiler.compileInjector(\n          angularCoreEnv,\n          `ng:///${moduleType.name}/ɵinj.js`,\n          meta,\n        );\n      }\n      return ngInjectorDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nexport function generateStandaloneInDeclarationsError(type: Type<any>, location: string) {\n  const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n  const suffix =\n    `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` +\n    'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n  return `${prefix} ${location}, ${suffix}`;\n}\n\nfunction verifySemanticsOfNgModuleDef(\n  moduleType: NgModuleType,\n  allowDuplicateDeclarationsInRoot: boolean,\n  importingModule?: NgModuleType,\n): void {\n  if (verifiedNgModule.get(moduleType)) return;\n\n  // skip verifications of standalone components, directives, and pipes\n  if (isStandalone(moduleType)) return;\n\n  verifiedNgModule.set(moduleType, true);\n  moduleType = resolveForwardRef(moduleType);\n  let ngModuleDef: NgModuleDef<any>;\n  if (importingModule) {\n    ngModuleDef = getNgModuleDef(moduleType)!;\n    if (!ngModuleDef) {\n      throw new Error(\n        `Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`,\n      );\n    }\n  } else {\n    ngModuleDef = getNgModuleDefOrThrow(moduleType);\n  }\n  const errors: string[] = [];\n  const declarations = maybeUnwrapFn(ngModuleDef.declarations);\n  const imports = maybeUnwrapFn(ngModuleDef.imports);\n  flatten(imports)\n    .map(unwrapModuleWithProvidersImports)\n    .forEach((modOrStandaloneCmpt) => {\n      verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n      verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n    });\n  const exports = maybeUnwrapFn(ngModuleDef.exports);\n  declarations.forEach(verifyDeclarationsHaveDefinitions);\n  declarations.forEach(verifyDirectivesHaveSelector);\n  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));\n  const combinedDeclarations: Type<any>[] = [\n    ...declarations.map(resolveForwardRef),\n    ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef),\n  ];\n  exports.forEach(verifyExportsAreDeclaredOrReExported);\n  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n\n  const ngModule = getAnnotation<NgModule>(moduleType, 'NgModule');\n  if (ngModule) {\n    ngModule.imports &&\n      flatten(ngModule.imports)\n        .map(unwrapModuleWithProvidersImports)\n        .forEach((mod) => {\n          verifySemanticsOfNgModuleImport(mod, moduleType);\n          verifySemanticsOfNgModuleDef(mod, false, moduleType);\n        });\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n  }\n\n  // Throw Error if any errors were detected.\n  if (errors.length) {\n    throw new Error(errors.join('\\n'));\n  }\n  ////////////////////////////////////////////////////////////////////////////////////////////////\n  function verifyDeclarationsHaveDefinitions(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (!def) {\n      errors.push(\n        `Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(\n          moduleType,\n        )}'. Please add a @Pipe/@Directive/@Component annotation.`,\n      );\n    }\n  }\n\n  function verifyDirectivesHaveSelector(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getDirectiveDef(type);\n    if (!getComponentDef(type) && def && def.selectors.length == 0) {\n      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n    }\n  }\n\n  function verifyNotStandalone(type: Type<any>, moduleType: NgModuleType): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (def?.standalone) {\n      const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n      errors.push(generateStandaloneInDeclarationsError(type, location));\n    }\n  }\n\n  function verifyExportsAreDeclaredOrReExported(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const kind =\n      (getComponentDef(type) && 'component') ||\n      (getDirectiveDef(type) && 'directive') ||\n      (getPipeDef(type) && 'pipe');\n    if (kind) {\n      // only checked if we are declared as Component, Directive, or Pipe\n      // Modules don't need to be declared or imported.\n      if (combinedDeclarations.lastIndexOf(type) === -1) {\n        // We are exporting something which we don't explicitly declare or import.\n        errors.push(\n          `Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(\n            moduleType,\n          )} as it was neither declared nor imported!`,\n        );\n      }\n    }\n  }\n\n  function verifyDeclarationIsUnique(type: Type<any>, suppressErrors: boolean) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (existingModule && existingModule !== moduleType) {\n      if (!suppressErrors) {\n        const modules = [existingModule, moduleType].map(stringifyForError).sort();\n        errors.push(\n          `Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${\n            modules[0]\n          } and ${modules[1]}! ` +\n            `Please consider moving ${stringifyForError(type)} to a higher module that imports ${\n              modules[0]\n            } and ${modules[1]}. ` +\n            `You can also create a new NgModule that exports and includes ${stringifyForError(\n              type,\n            )} then import that NgModule in ${modules[0]} and ${modules[1]}.`,\n        );\n      }\n    } else {\n      // Mark type as having owner.\n      ownerNgModule.set(type, moduleType);\n    }\n  }\n\n  function verifyComponentIsPartOfNgModule(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (!existingModule && !isStandalone(type)) {\n      errors.push(\n        `Component ${stringifyForError(\n          type,\n        )} is not part of any NgModule or the module has not been imported into your module.`,\n      );\n    }\n  }\n\n  function verifyCorrectBootstrapType(type: Type<any>) {\n    type = resolveForwardRef(type);\n    if (!getComponentDef(type)) {\n      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n    }\n    if (isStandalone(type)) {\n      // Note: this error should be the same as the\n      // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n      errors.push(\n        `The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` +\n          `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` +\n          `function for bootstrap instead.`,\n      );\n    }\n  }\n\n  function verifySemanticsOfNgModuleImport(type: Type<any>, importingModule: Type<any>) {\n    type = resolveForwardRef(type);\n\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null && !directiveDef.standalone) {\n      throw new Error(\n        `Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`,\n      );\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null && !pipeDef.standalone) {\n      throw new Error(\n        `Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`,\n      );\n    }\n  }\n}\n\nfunction unwrapModuleWithProvidersImports(\n  typeOrWithProviders: NgModuleType<any> | {ngModule: NgModuleType<any>},\n): NgModuleType<any> {\n  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n  return (typeOrWithProviders as any).ngModule || typeOrWithProviders;\n}\n\nfunction getAnnotation<T>(type: any, name: string): T | null {\n  let annotation: T | null = null;\n  collect(type.__annotations__);\n  collect(type.decorators);\n  return annotation;\n\n  function collect(annotations: any[] | null) {\n    if (annotations) {\n      annotations.forEach(readAnnotation);\n    }\n  }\n\n  function readAnnotation(decorator: {\n    type: {prototype: {ngMetadataName: string}; args: any[]};\n    args: any;\n  }): void {\n    if (!annotation) {\n      const proto = Object.getPrototypeOf(decorator);\n      if (proto.ngMetadataName == name) {\n        annotation = decorator as any;\n      } else if (decorator.type) {\n        const proto = Object.getPrototypeOf(decorator.type);\n        if (proto.ngMetadataName == name) {\n          annotation = decorator.args[0];\n        }\n      }\n    }\n  }\n}\n\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\nlet ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\nlet verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n\nexport function resetCompiledComponents(): void {\n  ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\n  verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n  moduleQueue.length = 0;\n  GENERATED_COMP_IDS.clear();\n}\n\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\nfunction computeCombinedExports(type: Type<any>): Type<any>[] {\n  type = resolveForwardRef(type);\n  const ngModuleDef = getNgModuleDef(type);\n\n  // a standalone component, directive or pipe\n  if (ngModuleDef === null) {\n    return [type];\n  }\n\n  return flatten(\n    maybeUnwrapFn(ngModuleDef.exports).map((type) => {\n      const ngModuleDef = getNgModuleDef(type);\n      if (ngModuleDef) {\n        verifySemanticsOfNgModuleDef(type as any as NgModuleType, false);\n        return computeCombinedExports(type);\n      } else {\n        return type;\n      }\n    }),\n  );\n}\n\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * ɵcmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\nfunction setScopeOnDeclaredComponents(moduleType: Type<any>, ngModule: NgModule) {\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n\n  const transitiveScopes = transitiveScopesFor(moduleType);\n\n  declarations.forEach((declaration) => {\n    declaration = resolveForwardRef(declaration);\n    if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n      // A `ɵcmp` field exists - go ahead and patch the component directly.\n      const component = declaration as Type<any> & {ɵcmp: ComponentDef<any>};\n      const componentDef = getComponentDef(component)!;\n      patchComponentDefWithScope(componentDef, transitiveScopes);\n    } else if (\n      !declaration.hasOwnProperty(NG_DIR_DEF) &&\n      !declaration.hasOwnProperty(NG_PIPE_DEF)\n    ) {\n      // Set `ngSelectorScope` for future reference when the component compilation finishes.\n      (declaration as Type<any> & {ngSelectorScope?: any}).ngSelectorScope = moduleType;\n    }\n  });\n}\n\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nexport function patchComponentDefWithScope<C>(\n  componentDef: ComponentDef<C>,\n  transitiveScopes: NgModuleTransitiveScopes,\n) {\n  componentDef.directiveDefs = () =>\n    Array.from(transitiveScopes.compilation.directives)\n      .map((dir) =>\n        dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir)! : getDirectiveDef(dir)!,\n      )\n      .filter((def) => !!def);\n  componentDef.pipeDefs = () =>\n    Array.from(transitiveScopes.compilation.pipes).map((pipe) => getPipeDef(pipe)!);\n  componentDef.schemas = transitiveScopes.schemas;\n\n  // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n  // may face a problem where previously compiled defs available to a given Component/Directive\n  // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n  // order to avoid this problem, we force fresh TView to be created.\n  componentDef.tView = null;\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nexport function transitiveScopesFor<T>(type: Type<T>): NgModuleTransitiveScopes {\n  if (isNgModule(type)) {\n    const scope = depsTracker.getNgModuleScope(type);\n    const def = getNgModuleDefOrThrow(type);\n    return {\n      schemas: def.schemas || null,\n      ...scope,\n    };\n  } else if (isStandalone(type)) {\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>([type]),\n          pipes: new Set<any>(),\n        },\n      };\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>(),\n          pipes: new Set<any>([type]),\n        },\n      };\n    }\n  }\n\n  // TODO: change the error message to be more user-facing and take standalone into account\n  throw new Error(`${type.name} does not have a module def (ɵmod property)`);\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\nexport function transitiveScopesForNgModule<T>(moduleType: Type<T>): NgModuleTransitiveScopes {\n  const def = getNgModuleDefOrThrow(moduleType);\n\n  if (def.transitiveCompileScopes !== null) {\n    return def.transitiveCompileScopes;\n  }\n\n  const scopes: NgModuleTransitiveScopes = {\n    schemas: def.schemas || null,\n    compilation: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n    exported: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n  };\n\n  maybeUnwrapFn(def.imports).forEach(<I>(imported: Type<I>) => {\n    // When this module imports another, the imported module's exported directives and pipes are\n    // added to the compilation scope of this module.\n    const importedScope = transitiveScopesFor(imported);\n    importedScope.exported.directives.forEach((entry) => scopes.compilation.directives.add(entry));\n    importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));\n  });\n\n  maybeUnwrapFn(def.declarations).forEach((declared) => {\n    const declaredWithDefs = declared as Type<any> & {\n      ɵpipe?: any;\n    };\n\n    if (getPipeDef(declaredWithDefs)) {\n      scopes.compilation.pipes.add(declared);\n    } else {\n      // Either declared has a ɵcmp or ɵdir, or it's a component which hasn't\n      // had its template compiled yet. In either case, it gets added to the compilation's\n      // directives.\n      scopes.compilation.directives.add(declared);\n    }\n  });\n\n  maybeUnwrapFn(def.exports).forEach(<E>(exported: Type<E>) => {\n    const exportedType = exported as Type<E> & {\n      // Components, Directives, NgModules, and Pipes can all be exported.\n      ɵcmp?: any;\n      ɵdir?: any;\n      ɵmod?: NgModuleDef<E>;\n      ɵpipe?: any;\n    };\n\n    // Either the type is a module, a pipe, or a component/directive (which may not have a\n    // ɵcmp as it might be compiled asynchronously).\n    if (isNgModule(exportedType)) {\n      // When this module exports another, the exported module's exported directives and pipes are\n      // added to both the compilation and exported scopes of this module.\n      const exportedScope = transitiveScopesFor(exportedType);\n      exportedScope.exported.directives.forEach((entry) => {\n        scopes.compilation.directives.add(entry);\n        scopes.exported.directives.add(entry);\n      });\n      exportedScope.exported.pipes.forEach((entry) => {\n        scopes.compilation.pipes.add(entry);\n        scopes.exported.pipes.add(entry);\n      });\n    } else if (getPipeDef(exportedType)) {\n      scopes.exported.pipes.add(exportedType);\n    } else {\n      scopes.exported.directives.add(exportedType);\n    }\n  });\n\n  def.transitiveCompileScopes = scopes;\n  return scopes;\n}\n\nfunction expandModuleWithProviders(value: Type<any> | ModuleWithProviders<{}>): Type<any> {\n  if (isModuleWithProviders(value)) {\n    return value.ngModule;\n  }\n  return value;\n}\n"]}