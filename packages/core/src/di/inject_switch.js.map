{"version":3,"file":"inject_switch.js","sourceRoot":"","sources":["inject_switch.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,0BAA0B,EAAC,MAAM,sBAAsB,CAAC;AAChE,OAAO,EAAC,cAAc,EAAC,MAAM,gBAAgB,CAAC;AAE9C,OAAO,EAAC,gBAAgB,EAA0B,MAAM,kBAAkB,CAAC;AAI3E;;;;;;;;GAQG;AACH,IAAI,qBAES,CAAC;AACd,MAAM,UAAU,uBAAuB;IACrC,OAAO,qBAAqB,CAAC;AAC/B,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,uBAAuB,CACrC,IAAyF;IAEzF,MAAM,QAAQ,GAAG,qBAAqB,CAAC;IACvC,qBAAqB,GAAG,IAAI,CAAC;IAC7B,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,kBAAkB,CAChC,KAAuB,EACvB,aAA4B,EAC5B,KAA0B;IAE1B,MAAM,aAAa,GAAsC,gBAAgB,CAAC,KAAK,CAAC,CAAC;IACjF,IAAI,aAAa,IAAI,aAAa,CAAC,UAAU,IAAI,MAAM,EAAE,CAAC;QACxD,OAAO,aAAa,CAAC,KAAK,KAAK,SAAS;YACtC,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,GAAG,aAAa,CAAC,OAAO,EAAE,CAAC;YACjD,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC;IAC1B,CAAC;IACD,IAAI,KAAK,uCAA+B;QAAE,OAAO,IAAI,CAAC;IACtD,IAAI,aAAa,KAAK,SAAS;QAAE,OAAO,aAAa,CAAC;IACtD,0BAA0B,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AAChD,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,kCAAkC,CAChD,EAAyE;IAEzE,SAAS;QACP,cAAc,CAAC,qBAAqB,EAAE,EAAE,EAAE,iDAAiD,CAAC,CAAC;AACjG,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {throwProviderNotFoundError} from '../render3/errors_di';\nimport {assertNotEqual} from '../util/assert';\n\nimport {getInjectableDef, ɵɵInjectableDeclaration} from './interface/defs';\nimport {InternalInjectFlags} from './interface/injector';\nimport {ProviderToken} from './provider_token';\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation:\n  | (<T>(token: ProviderToken<T>, flags?: InternalInjectFlags) => T | null)\n  | undefined;\nexport function getInjectImplementation() {\n  return _injectImplementation;\n}\n\n/**\n * Sets the current inject implementation.\n */\nexport function setInjectImplementation(\n  impl: (<T>(token: ProviderToken<T>, flags?: InternalInjectFlags) => T | null) | undefined,\n): (<T>(token: ProviderToken<T>, flags?: InternalInjectFlags) => T | null) | undefined {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nexport function injectRootLimpMode<T>(\n  token: ProviderToken<T>,\n  notFoundValue: T | undefined,\n  flags: InternalInjectFlags,\n): T | null {\n  const injectableDef: ɵɵInjectableDeclaration<T> | null = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined\n      ? (injectableDef.value = injectableDef.factory())\n      : injectableDef.value;\n  }\n  if (flags & InternalInjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throwProviderNotFoundError(token, 'Injector');\n}\n\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nexport function assertInjectImplementationNotEqual(\n  fn: <T>(token: ProviderToken<T>, flags?: InternalInjectFlags) => T | null,\n) {\n  ngDevMode &&\n    assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n"]}