{"version":3,"file":"defs.js","sourceRoot":"","sources":["defs.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,sBAAsB,EAAC,MAAM,qBAAqB,CAAC;AA2I3D;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,UAAU,kBAAkB,CAAI,IAIrC;IACC,OAAO;QACL,KAAK,EAAE,IAAI,CAAC,KAAK;QACjB,UAAU,EAAG,IAAI,CAAC,UAAkB,IAAI,IAAI;QAC5C,OAAO,EAAE,IAAI,CAAC,OAAO;QACrB,KAAK,EAAE,SAAS;KACa,CAAC;AAClC,CAAC;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,UAAU,gBAAgB,CAAC,OAA6C;IAC5E,OAAO,EAAC,SAAS,EAAE,OAAO,CAAC,SAAS,IAAI,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,OAAO,IAAI,EAAE,EAAC,CAAC;AAC9E,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,gBAAgB,CAAI,IAAS;IAC3C,OAAO,gBAAgB,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;AAC7C,CAAC;AAED,MAAM,UAAU,YAAY,CAAC,IAAS;IACpC,OAAO,gBAAgB,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC;AACzC,CAAC;AAED;;;GAGG;AACH,SAAS,gBAAgB,CAAI,IAAS,EAAE,KAAa;IACnD,wEAAwE;IACxE,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC;AAC7D,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,yBAAyB,CAAI,IAAS;IACpD,wEAAwE;IACxE,MAAM,GAAG,GAAG,IAAI,EAAE,CAAC,WAAW,CAAC,IAAI,IAAI,CAAC;IAExC,IAAI,GAAG,EAAE,CAAC;QACR,SAAS;YACP,OAAO,CAAC,IAAI,CACV,4CAA4C,IAAI,CAAC,IAAI,8EAA8E;gBACjI,8FAA8F,IAAI,CAAC,IAAI,UAAU,CACpH,CAAC;QACJ,OAAO,GAAG,CAAC;IACb,CAAC;SAAM,CAAC;QACN,OAAO,IAAI,CAAC;IACd,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,cAAc,CAAI,IAAS;IACzC,OAAO,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC,CAAE,IAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;AACpF,CAAC;AAED,MAAM,CAAC,MAAM,WAAW,GAAW,sBAAsB,CAAC,EAAC,KAAK,EAAE,sBAAsB,EAAC,CAAC,CAAC;AAC3F,MAAM,CAAC,MAAM,UAAU,GAAW,sBAAsB,CAAC,EAAC,IAAI,EAAE,sBAAsB,EAAC,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../../interface/type';\nimport {getClosureSafeProperty} from '../../util/property';\n\nimport {\n  ClassProvider,\n  ConstructorProvider,\n  EnvironmentProviders,\n  ExistingProvider,\n  FactoryProvider,\n  StaticClassProvider,\n  ValueProvider,\n} from './provider';\n\n/**\n * Information about how a type or `InjectionToken` interfaces with the DI system.\n *\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\n * requesting injection of other types if necessary.\n *\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\n * `Injector`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\n * that the injectable does not belong to any scope.\n *\n * @codeGenApi\n * @publicApi The ViewEngine compiler emits code with this type for injectables. This code is\n *   deployed to npm, and should be treated as public api.\n\n */\nexport interface ɵɵInjectableDeclaration<T> {\n  /**\n   * Specifies that the given type belongs to a particular injector:\n   * - `InjectorType` such as `NgModule`,\n   * - `'root'` the root injector\n   * - `'any'` all injectors.\n   * - `null`, does not belong to any injector. Must be explicitly listed in the injector\n   *   `providers`.\n   */\n  providedIn: InjectorType<any> | 'root' | 'platform' | 'any' | 'environment' | null;\n\n  /**\n   * The token to which this definition belongs.\n   *\n   * Note that this may not be the same as the type that the `factory` will create.\n   */\n  token: unknown;\n\n  /**\n   * Factory method to execute to create an instance of the injectable.\n   */\n  factory: (t?: Type<any>) => T;\n\n  /**\n   * In a case of no explicit injector, a location where the instance of the injectable is stored.\n   */\n  value: T | undefined;\n}\n\n/**\n * Information about the providers to be included in an `Injector` as well as how the given type\n * which carries the information should be created by the DI system.\n *\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\n * structure of providers with a defined priority (identically to how `NgModule`s also have\n * an import/dependency structure).\n *\n * NOTE: This is a private type and should not be exported\n *\n * @codeGenApi\n */\nexport interface ɵɵInjectorDef<T> {\n  // TODO(alxhub): Narrow down the type here once decorators properly change the return type of the\n  // class they are decorating (to add the ɵprov property for example).\n  providers: (\n    | Type<any>\n    | ValueProvider\n    | ExistingProvider\n    | FactoryProvider\n    | ConstructorProvider\n    | StaticClassProvider\n    | ClassProvider\n    | EnvironmentProviders\n    | any[]\n  )[];\n\n  imports: (InjectorType<any> | InjectorTypeWithProviders<any>)[];\n}\n\n/**\n * A `Type` which has a `ɵprov: ɵɵInjectableDeclaration` static field.\n *\n * `InjectableType`s contain their own Dependency Injection metadata and are usable in an\n * `InjectorDef`-based `StaticInjector`.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  ɵprov: unknown;\n}\n\n/**\n * A type which has an `InjectorDef` static field.\n *\n * `InjectorTypes` can be used to configure a `StaticInjector`.\n *\n * This is an opaque type whose structure is highly version dependent. Do not rely on any\n * properties.\n *\n * @publicApi\n */\nexport interface InjectorType<T> extends Type<T> {\n  ɵfac?: unknown;\n  ɵinj: unknown;\n}\n\n/**\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorType` with an\n * associated array of providers.\n *\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorTypeWithProviders<T> {\n  ngModule: InjectorType<T>;\n  providers?: (\n    | Type<any>\n    | ValueProvider\n    | ExistingProvider\n    | FactoryProvider\n    | ConstructorProvider\n    | StaticClassProvider\n    | ClassProvider\n    | EnvironmentProviders\n    | any[]\n  )[];\n}\n\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call [`inject`](api/core/inject) to access the `Injector` and request injection\n * of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nexport function ɵɵdefineInjectable<T>(opts: {\n  token: unknown;\n  providedIn?: Type<any> | 'root' | 'platform' | 'any' | 'environment' | null;\n  factory: () => T;\n}): unknown {\n  return {\n    token: opts.token,\n    providedIn: (opts.providedIn as any) || null,\n    factory: opts.factory,\n    value: undefined,\n  } as ɵɵInjectableDeclaration<T>;\n}\n\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nexport function ɵɵdefineInjector(options: {providers?: any[]; imports?: any[]}): unknown {\n  return {providers: options.providers || [], imports: options.imports || []};\n}\n\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\nexport function getInjectableDef<T>(type: any): ɵɵInjectableDeclaration<T> | null {\n  return getOwnDefinition(type, NG_PROV_DEF);\n}\n\nexport function isInjectable(type: any): boolean {\n  return getInjectableDef(type) !== null;\n}\n\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition<T>(type: any, field: string): ɵɵInjectableDeclaration<T> | null {\n  // if the ɵprov prop exist but is undefined we still want to return null\n  return (type.hasOwnProperty(field) && type[field]) || null;\n}\n\n/**\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\n *\n * @param type A type which may have `ɵprov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `ɵprov` on an ancestor only.\n */\nexport function getInheritedInjectableDef<T>(type: any): ɵɵInjectableDeclaration<T> | null {\n  // if the ɵprov prop exist but is undefined we still want to return null\n  const def = type?.[NG_PROV_DEF] ?? null;\n\n  if (def) {\n    ngDevMode &&\n      console.warn(\n        `DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n          `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`,\n      );\n    return def;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`ɵinj`)\n */\nexport function getInjectorDef<T>(type: any): ɵɵInjectorDef<T> | null {\n  return type && type.hasOwnProperty(NG_INJ_DEF) ? (type as any)[NG_INJ_DEF] : null;\n}\n\nexport const NG_PROV_DEF: string = getClosureSafeProperty({ɵprov: getClosureSafeProperty});\nexport const NG_INJ_DEF: string = getClosureSafeProperty({ɵinj: getClosureSafeProperty});\n"]}