/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
import '../util/ng_dev_mode';
import type { Injector } from './injector';
import { DecoratorFlags, InternalInjectFlags, InjectOptions } from './interface/injector';
import { ProviderToken } from './provider_token';
import type { HostAttributeToken } from './host_attribute_token';
import { Injector as PrimitivesInjector, NotFound, InjectionToken as PrimitivesInjectionToken } from '../../primitives/di';
export declare const THROW_IF_NOT_FOUND: {};
export { getCurrentInjector, setCurrentInjector } from '../../primitives/di';
/**
 * A wrapper around an `Injector` that implements the `PrimitivesInjector` interface.
 *
 * This is used to allow the `inject` function to be used with the new primitives-based DI system.
 */
export declare class RetrievingInjector implements PrimitivesInjector {
    readonly injector: Injector;
    constructor(injector: Injector);
    retrieve<T>(token: PrimitivesInjectionToken<T>, options: unknown): T | NotFound;
}
export declare const NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
export declare const SOURCE = "__source";
/**
 * Temporary type to allow internal symbols to use inject flags. This should be
 * removed once we consolidate the flags and the object literal approach.
 */
export type BackwardsCompatibleInjector = Injector & {
    get<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InternalInjectFlags | InjectOptions): T;
};
export declare function injectInjectorOnly<T>(token: ProviderToken<T>): T;
export declare function injectInjectorOnly<T>(token: ProviderToken<T>, flags?: InternalInjectFlags): T | null;
/**
 * Generated instruction: injects a token from the currently active injector.
 *
 * (Additional documentation moved to `inject`, as it is the public API, and an alias for this
 * instruction)
 *
 * @see inject
 * @codeGenApi
 * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.
 */
export declare function ɵɵinject<T>(token: ProviderToken<T>): T;
export declare function ɵɵinject<T>(token: ProviderToken<T>, flags?: InternalInjectFlags): T | null;
export declare function ɵɵinject(token: HostAttributeToken): string;
export declare function ɵɵinject(token: HostAttributeToken, flags?: InternalInjectFlags): string | null;
export declare function ɵɵinject<T>(token: ProviderToken<T> | HostAttributeToken, flags?: InternalInjectFlags): string | null;
/**
 * Throws an error indicating that a factory function could not be generated by the compiler for a
 * particular class.
 *
 * The name of the class is not mentioned here, but will be in the generated factory function name
 * and thus in the stack trace.
 *
 * @codeGenApi
 */
export declare function ɵɵinvalidFactoryDep(index: number): never;
/**
 * @param token A token that represents a dependency that should be injected.
 * @returns the injected value if operation is successful, `null` otherwise.
 * @throws if called outside of a supported context.
 *
 * @publicApi
 */
export declare function inject<T>(token: ProviderToken<T>): T;
/**
 * @param token A token that represents a dependency that should be injected.
 * @param options Control how injection is executed. Options correspond to injection strategies
 *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and
 *     `@Optional`.
 * @returns the injected value if operation is successful.
 * @throws if called outside of a supported context, or if the token is not found.
 *
 * @publicApi
 */
export declare function inject<T>(token: ProviderToken<T>, options: InjectOptions & {
    optional?: false;
}): T;
/**
 * @param token A token that represents a dependency that should be injected.
 * @param options Control how injection is executed. Options correspond to injection strategies
 *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and
 *     `@Optional`.
 * @returns the injected value if operation is successful,  `null` if the token is not
 *     found and optional injection has been requested.
 * @throws if called outside of a supported context, or if the token is not found and optional
 *     injection was not requested.
 *
 * @publicApi
 */
export declare function inject<T>(token: ProviderToken<T>, options: InjectOptions): T | null;
/**
 * @param token A token that represents a static attribute on the host node that should be injected.
 * @returns Value of the attribute if it exists.
 * @throws If called outside of a supported context or the attribute does not exist.
 *
 * @publicApi
 */
export declare function inject(token: HostAttributeToken): string;
/**
 * @param token A token that represents a static attribute on the host node that should be injected.
 * @returns Value of the attribute if it exists, otherwise `null`.
 * @throws If called outside of a supported context.
 *
 * @publicApi
 */
export declare function inject(token: HostAttributeToken, options: {
    optional: true;
}): string | null;
/**
 * @param token A token that represents a static attribute on the host node that should be injected.
 * @returns Value of the attribute if it exists.
 * @throws If called outside of a supported context or the attribute does not exist.
 *
 * @publicApi
 */
export declare function inject(token: HostAttributeToken, options: {
    optional: false;
}): string;
export declare function convertToBitFlags(flags: InjectOptions | InternalInjectFlags | undefined): InternalInjectFlags | undefined;
export declare function injectArgs(types: (ProviderToken<any> | any[])[]): any[];
/**
 * Attaches a given InjectFlag to a given decorator using monkey-patching.
 * Since DI decorators can be used in providers `deps` array (when provider is configured using
 * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we
 * attach the flag to make it available both as a static property and as a field on decorator
 * instance.
 *
 * @param decorator Provided DI decorator.
 * @param flag InjectFlag that should be applied.
 */
export declare function attachInjectFlag(decorator: any, flag: InternalInjectFlags | DecoratorFlags): any;
/**
 * Reads monkey-patched property that contains InjectFlag attached to a decorator.
 *
 * @param token Token that may contain monkey-patched DI flags property.
 */
export declare function getInjectFlag(token: any): number | undefined;
export declare function formatError(text: string, obj: any, injectorErrorName: string, source?: string | null): string;
