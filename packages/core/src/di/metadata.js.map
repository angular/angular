{"version":3,"file":"metadata.js","sourceRoot":"","sources":["metadata.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,kBAAkB,EAAC,MAAM,oBAAoB,CAAC;AAEtD,OAAO,EAAC,gBAAgB,EAAC,MAAM,0BAA0B,CAAC;AAiD1D;;;;;GAKG;AACH,MAAM,CAAC,MAAM,MAAM,GAAoB,gBAAgB;AACrD,8EAA8E;AAC9E,kBAAkB,CAAC,QAAQ,EAAE,CAAC,KAAU,EAAE,EAAE,CAAC,CAAC,EAAC,KAAK,EAAC,CAAC,CAAC,iCAGxD,CAAC;AAmCF;;;;;GAKG;AACH,MAAM,CAAC,MAAM,QAAQ;AACnB,mFAAmF;AACnF,wDAAwD;AACxD,gBAAgB,CAAC,kBAAkB,CAAC,UAAU,CAAC,uCAA+B,CAAC;AAsCjF;;;;;GAKG;AACH,MAAM,CAAC,MAAM,IAAI;AACf,mFAAmF;AACnF,wDAAwD;AACxD,gBAAgB,CAAC,kBAAkB,CAAC,MAAM,CAAC,mCAA2B,CAAC;AAqCzE;;;;;GAKG;AACH,MAAM,CAAC,MAAM,QAAQ;AACnB,mFAAmF;AACnF,wDAAwD;AACxD,gBAAgB,CAAC,kBAAkB,CAAC,UAAU,CAAC,uCAA+B,CAAC;AAiCjF;;;;;GAKG;AACH,MAAM,CAAC,MAAM,IAAI;AACf,mFAAmF;AACnF,wDAAwD;AACxD,gBAAgB,CAAC,kBAAkB,CAAC,MAAM,CAAC,mCAA2B,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {makeParamDecorator} from '../util/decorators';\n\nimport {attachInjectFlag} from './injector_compatibility';\nimport {DecoratorFlags, InternalInjectFlags} from './interface/injector';\n\n/**\n * Type of the Inject decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectDecorator {\n  /**\n   * Warning: String tokens are not recommended.\n   *\n   * Use an InjectionToken or a class as a token instead.\n   */\n  (token: string): any;\n  new (token: string): Inject;\n\n  /**\n   * Parameter decorator on a dependency parameter of a class constructor\n   * that specifies a custom provider of the dependency.\n   *\n   * @usageNotes\n   * The following example shows a class constructor that specifies a\n   * custom provider of a dependency using the parameter decorator.\n   *\n   * When `@Inject()` is not present, the injector uses the type annotation of the\n   * parameter as the provider.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='InjectWithoutDecorator'}\n   *\n   * @see [Dependency Injection Guide](guide/di/dependency-injection\n   *\n   */\n  (token: any): any;\n  new (token: any): Inject;\n}\n\n/**\n * Type of the Inject metadata.\n *\n * @publicApi\n */\nexport interface Inject {\n  /**\n   * A DI token that maps to the dependency to be injected.\n   */\n  token: any;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Inject: InjectDecorator = attachInjectFlag(\n  // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\n  makeParamDecorator('Inject', (token: any) => ({token})),\n  // tslint:disable-next-line: no-toplevel-property-access\n  DecoratorFlags.Inject,\n);\n\n/**\n * Type of the Optional decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OptionalDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which marks the parameter as being an optional dependency.\n   * The DI framework provides `null` if the dependency is not found.\n   *\n   * Can be used together with other parameter decorators\n   * that modify how dependency injection operates.\n   *\n   * @usageNotes\n   *\n   * The following code allows the possibility of a `null` result:\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Optional'}\n   *\n   * @see [Dependency Injection Guide](guide/di/dependency-injection.\n   */\n  (): any;\n  new (): Optional;\n}\n\n/**\n * Type of the Optional metadata.\n *\n * @publicApi\n */\nexport interface Optional {}\n\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Optional: OptionalDecorator =\n  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n  // tslint:disable-next-line: no-toplevel-property-access\n  attachInjectFlag(makeParamDecorator('Optional'), InternalInjectFlags.Optional);\n\n/**\n * Type of the Self decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the local injector.\n   *\n   * Resolution works upward through the injector hierarchy, so the children\n   * of this class must configure their own providers or be prepared for a `null` result.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved\n   * by the local injector when instantiating the class itself, but not\n   * when instantiating a child.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Self'}\n   *\n   * @see {@link SkipSelf}\n   * @see {@link Optional}\n   *\n   */\n  (): any;\n  new (): Self;\n}\n\n/**\n * Type of the Self metadata.\n *\n * @publicApi\n */\nexport interface Self {}\n\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Self: SelfDecorator =\n  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n  // tslint:disable-next-line: no-toplevel-property-access\n  attachInjectFlag(makeParamDecorator('Self'), InternalInjectFlags.Self);\n\n/**\n * Type of the `SkipSelf` decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SkipSelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the parent injector.\n   * Resolution works upward through the injector hierarchy, so the local injector\n   * is not checked for a provider.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved when\n   * instantiating a child, but not when instantiating the class itself.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='SkipSelf'}\n   *\n   * @see [Dependency Injection guide](guide/di/di-in-action#skip).\n   * @see {@link Self}\n   * @see {@link Optional}\n   *\n   */\n  (): any;\n  new (): SkipSelf;\n}\n\n/**\n * Type of the `SkipSelf` metadata.\n *\n * @publicApi\n */\nexport interface SkipSelf {}\n\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const SkipSelf: SkipSelfDecorator =\n  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n  // tslint:disable-next-line: no-toplevel-property-access\n  attachInjectFlag(makeParamDecorator('SkipSelf'), InternalInjectFlags.SkipSelf);\n\n/**\n * Type of the `Host` decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostDecorator {\n  /**\n   * Parameter decorator on a view-provider parameter of a class constructor\n   * that tells the DI framework to resolve the view by checking injectors of child\n   * elements, and stop when reaching the host element of the current component.\n   *\n   * @usageNotes\n   *\n   * The following shows use with the `@Optional` decorator, and allows for a `null` result.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Host'}\n   *\n   * For an extended example, see [\"Dependency Injection\n   * Guide\"](guide/di/di-in-action#optional).\n   */\n  (): any;\n  new (): Host;\n}\n\n/**\n * Type of the Host metadata.\n *\n * @publicApi\n */\nexport interface Host {}\n\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Host: HostDecorator =\n  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n  // tslint:disable-next-line: no-toplevel-property-access\n  attachInjectFlag(makeParamDecorator('Host'), InternalInjectFlags.Host);\n"]}