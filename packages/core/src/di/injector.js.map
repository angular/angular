{"version":3,"file":"injector.js","sourceRoot":"","sources":["injector.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,cAAc,EAAC,MAAM,mBAAmB,CAAC;AACjD,OAAO,EAAC,kBAAkB,EAAE,QAAQ,EAAC,MAAM,0BAA0B,CAAC;AAEtE,OAAO,EAAC,QAAQ,EAAC,MAAM,kBAAkB,CAAC;AAC1C,OAAO,EAAC,kBAAkB,EAAC,MAAM,kBAAkB,CAAC;AAGpD,OAAO,EAAC,YAAY,EAAC,MAAM,iBAAiB,CAAC;AAG7C;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,OAAgB,QAAQ;IA6D5B,MAAM,CAAC,MAAM,CACX,OAEmF,EACnF,MAAiB;QAEjB,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC;YAC3B,OAAO,cAAc,CAAC,EAAC,IAAI,EAAE,EAAE,EAAC,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;QACzD,CAAC;aAAM,CAAC;YACN,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,IAAI,EAAE,CAAC;YAChC,OAAO,cAAc,CAAC,EAAC,IAAI,EAAC,EAAE,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QACzE,CAAC;IACH,CAAC;;AAxEM,2BAAkB,GAAG,kBAAkB,CAAC;AACxC,aAAI,GAA6B,IAAI,YAAY,EAAE,CAAC;AAyE3D,kBAAkB;AACX,cAAK,GAA6C,kBAAkB,CAAC;IAC1E,KAAK,EAAE,QAAQ;IACf,UAAU,EAAE,KAAK;IACjB,OAAO,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC;CAClC,CAAC,CAAC;AAEH;;;GAGG;AACI,0BAAiB,qCAA4B","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {createInjector} from './create_injector';\nimport {THROW_IF_NOT_FOUND, ɵɵinject} from './injector_compatibility';\nimport {InjectorMarkers} from './injector_marker';\nimport {INJECTOR} from './injector_token';\nimport {ɵɵdefineInjectable} from './interface/defs';\nimport {InjectOptions} from './interface/injector';\nimport {Provider, StaticProvider} from './interface/provider';\nimport {NullInjector} from './null_injector';\nimport {ProviderToken} from './provider_token';\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/di/dependency-injection-providers) that associate\n * dependencies of various types with [injection tokens](guide/di/dependency-injection-providers).\n *\n * @see [DI Providers](guide/di/dependency-injection-providers).\n * @see {@link StaticProvider}\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n  static NULL: Injector = /* @__PURE__ */ new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(\n    token: ProviderToken<T>,\n    notFoundValue: undefined,\n    options: InjectOptions & {\n      optional?: false;\n    },\n  ): T;\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(\n    token: ProviderToken<T>,\n    notFoundValue: null | undefined,\n    options: InjectOptions,\n  ): T | null;\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions): T;\n  /**\n   * @deprecated from v4.0.0 use ProviderToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get<T>(token: string | ProviderToken<T>, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  /**\n   * Creates a new injector instance that provides one or more dependencies,\n   * according to a given type or types of `StaticProvider`.\n   *\n   * @param options An object with the following properties:\n   * * `providers`: An array of providers of the [StaticProvider type](api/core/StaticProvider).\n   * * `parent`: (optional) A parent injector.\n   * * `name`: (optional) A developer-defined identifying name for the new injector.\n   *\n   * @returns The new injector instance.\n   *\n   */\n  static create(options: {\n    providers: Array<Provider | StaticProvider>;\n    parent?: Injector;\n    name?: string;\n  }): DestroyableInjector;\n\n  static create(\n    options:\n      | StaticProvider[]\n      | {providers: Array<Provider | StaticProvider>; parent?: Injector; name?: string},\n    parent?: Injector,\n  ): Injector {\n    if (Array.isArray(options)) {\n      return createInjector({name: ''}, parent, options, '');\n    } else {\n      const name = options.name ?? '';\n      return createInjector({name}, options.parent, options.providers, name);\n    }\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: Injector,\n    providedIn: 'any',\n    factory: () => ɵɵinject(INJECTOR),\n  });\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = InjectorMarkers.Injector;\n}\n\n/**\n * An Injector that the owner can destroy and trigger the DestroyRef.destroy hooks.\n *\n * @publicApi\n */\nexport interface DestroyableInjector extends Injector {\n  destroy(): void;\n}\n"]}