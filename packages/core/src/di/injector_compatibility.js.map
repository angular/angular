{"version":3,"file":"injector_compatibility.js","sourceRoot":"","sources":["injector_compatibility.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport {emitInjectEvent} from '../render3/debug/injector_profiler';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {getInjectImplementation, injectRootLimpMode} from './inject_switch';\nimport type {Injector} from './injector';\nimport {DecoratorFlags, InternalInjectFlags, InjectOptions} from './interface/injector';\nimport {ProviderToken} from './provider_token';\nimport type {HostAttributeToken} from './host_attribute_token';\nimport {\n  Injector as PrimitivesInjector,\n  isNotFound,\n  NotFound,\n  InjectionToken as PrimitivesInjectionToken,\n  getCurrentInjector,\n} from '../../primitives/di';\n\nimport {InjectionToken} from './injection_token';\n\nconst _THROW_IF_NOT_FOUND = {};\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\nexport {getCurrentInjector, setCurrentInjector} from '../../primitives/di';\n\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\n\n/**\n * A wrapper around an `Injector` that implements the `PrimitivesInjector` interface.\n *\n * This is used to allow the `inject` function to be used with the new primitives-based DI system.\n */\nexport class RetrievingInjector implements PrimitivesInjector {\n  constructor(readonly injector: Injector) {}\n  retrieve<T>(token: PrimitivesInjectionToken<T>, options: unknown): T | NotFound {\n    const flags: InternalInjectFlags =\n      convertToBitFlags(options as InjectOptions | undefined) || InternalInjectFlags.Default;\n    try {\n      return (this.injector as BackwardsCompatibleInjector).get(\n        token as unknown as InjectionToken<T>,\n        // When a dependency is requested with an optional flag, DI returns null as the default value.\n        (flags & InternalInjectFlags.Optional ? null : THROW_IF_NOT_FOUND) as T,\n        flags,\n      ) as T;\n    } catch (e: any) {\n      if (isNotFound(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n}\n\nexport const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\nexport const SOURCE = '__source';\n\n/**\n * Temporary type to allow internal symbols to use inject flags. This should be\n * removed once we consolidate the flags and the object literal approach.\n */\nexport type BackwardsCompatibleInjector = Injector & {\n  get<T>(\n    token: ProviderToken<T>,\n    notFoundValue?: T,\n    options?: InternalInjectFlags | InjectOptions,\n  ): T;\n};\n\nexport function injectInjectorOnly<T>(token: ProviderToken<T>): T;\nexport function injectInjectorOnly<T>(\n  token: ProviderToken<T>,\n  flags?: InternalInjectFlags,\n): T | null;\nexport function injectInjectorOnly<T>(\n  token: ProviderToken<T>,\n  flags = InternalInjectFlags.Default,\n): T | null {\n  const currentInjector = getCurrentInjector();\n  if (currentInjector === undefined) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISSING_INJECTION_CONTEXT,\n      ngDevMode &&\n        `The \\`${stringify(token)}\\` token injection failed. \\`inject()\\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`,\n    );\n  } else if (currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    const options = convertToInjectOptions(flags);\n    // TODO: improve the typings here.\n    // `token` can be a multi: true provider definition, which is considered as a Token but not represented in the typings\n    const value = currentInjector.retrieve(token as PrimitivesInjectionToken<T>, options) as T;\n    ngDevMode && emitInjectEvent(token as Type<unknown>, value, flags);\n    if (isNotFound(value)) {\n      if (options.optional) {\n        return null;\n      }\n      throw value;\n    }\n    return value;\n  }\n}\n\n/**\n * Generated instruction: injects a token from the currently active injector.\n *\n * (Additional documentation moved to `inject`, as it is the public API, and an alias for this\n * instruction)\n *\n * @see inject\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nexport function ɵɵinject<T>(token: ProviderToken<T>): T;\nexport function ɵɵinject<T>(token: ProviderToken<T>, flags?: InternalInjectFlags): T | null;\nexport function ɵɵinject(token: HostAttributeToken): string;\nexport function ɵɵinject(token: HostAttributeToken, flags?: InternalInjectFlags): string | null;\nexport function ɵɵinject<T>(\n  token: ProviderToken<T> | HostAttributeToken,\n  flags?: InternalInjectFlags,\n): string | null;\nexport function ɵɵinject<T>(\n  token: ProviderToken<T> | HostAttributeToken,\n  flags = InternalInjectFlags.Default,\n): T | null {\n  return (getInjectImplementation() || injectInjectorOnly)(\n    resolveForwardRef(token as Type<T>),\n    flags,\n  );\n}\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport function ɵɵinvalidFactoryDep(index: number): never {\n  throw new RuntimeError(\n    RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY,\n    ngDevMode &&\n      `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`,\n  );\n}\n\n/**\n * @param token A token that represents a dependency that should be injected.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T>): T;\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param options Control how injection is executed. Options correspond to injection strategies\n *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and\n *     `@Optional`.\n * @returns the injected value if operation is successful.\n * @throws if called outside of a supported context, or if the token is not found.\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T>, options: InjectOptions & {optional?: false}): T;\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param options Control how injection is executed. Options correspond to injection strategies\n *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and\n *     `@Optional`.\n * @returns the injected value if operation is successful,  `null` if the token is not\n *     found and optional injection has been requested.\n * @throws if called outside of a supported context, or if the token is not found and optional\n *     injection was not requested.\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T>, options: InjectOptions): T | null;\n/**\n * @param token A token that represents a static attribute on the host node that should be injected.\n * @returns Value of the attribute if it exists.\n * @throws If called outside of a supported context or the attribute does not exist.\n *\n * @publicApi\n */\nexport function inject(token: HostAttributeToken): string;\n/**\n * @param token A token that represents a static attribute on the host node that should be injected.\n * @returns Value of the attribute if it exists, otherwise `null`.\n * @throws If called outside of a supported context.\n *\n * @publicApi\n */\nexport function inject(token: HostAttributeToken, options: {optional: true}): string | null;\n/**\n * @param token A token that represents a static attribute on the host node that should be injected.\n * @returns Value of the attribute if it exists.\n * @throws If called outside of a supported context or the attribute does not exist.\n *\n * @publicApi\n */\nexport function inject(token: HostAttributeToken, options: {optional: false}): string;\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported in an [injection context](guide/di/dependency-injection-context). It\n * can be used during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n * - In a stackframe of a function call in a DI context\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```ts\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```ts\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```ts\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T> | HostAttributeToken, options?: InjectOptions) {\n  // The `as any` here _shouldn't_ be necessary, but without it JSCompiler\n  // throws a disambiguation  error due to the multiple signatures.\n  return ɵɵinject(token as any, convertToBitFlags(options));\n}\n\n// Converts object-based DI flags (`InjectOptions`) to bit flags (`InjectFlags`).\nexport function convertToBitFlags(\n  flags: InjectOptions | InternalInjectFlags | undefined,\n): InternalInjectFlags | undefined {\n  if (typeof flags === 'undefined' || typeof flags === 'number') {\n    return flags;\n  }\n\n  // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\n  // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\n  // `InjectOptions` to `InjectFlags`.\n  return (InternalInjectFlags.Default | // comment to force a line break in the formatter\n    ((flags.optional && InternalInjectFlags.Optional) as number) |\n    ((flags.host && InternalInjectFlags.Host) as number) |\n    ((flags.self && InternalInjectFlags.Self) as number) |\n    ((flags.skipSelf && InternalInjectFlags.SkipSelf) as number)) as InternalInjectFlags;\n}\n\n// Converts bitflags to inject options\nfunction convertToInjectOptions(flags: InternalInjectFlags): InjectOptions {\n  return {\n    optional: !!(flags & InternalInjectFlags.Optional),\n    host: !!(flags & InternalInjectFlags.Host),\n    self: !!(flags & InternalInjectFlags.Self),\n    skipSelf: !!(flags & InternalInjectFlags.SkipSelf),\n  };\n}\n\nexport function injectArgs(types: (ProviderToken<any> | any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_DIFFER_INPUT,\n          ngDevMode && 'Arguments array must have arguments.',\n        );\n      }\n      let type: Type<any> | undefined = undefined;\n      let flags: InternalInjectFlags = InternalInjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        const flag = getInjectFlag(meta);\n        if (typeof flag === 'number') {\n          // Special case when we handle @Inject decorator.\n          if (flag === DecoratorFlags.Inject) {\n            type = meta.token;\n          } else {\n            flags |= flag;\n          }\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(ɵɵinject(type!, flags));\n    } else {\n      args.push(ɵɵinject(arg));\n    }\n  }\n  return args;\n}\n\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nexport function attachInjectFlag(decorator: any, flag: InternalInjectFlags | DecoratorFlags): any {\n  decorator[DI_DECORATOR_FLAG] = flag;\n  decorator.prototype[DI_DECORATOR_FLAG] = flag;\n  return decorator;\n}\n\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nexport function getInjectFlag(token: any): number | undefined {\n  return token[DI_DECORATOR_FLAG];\n}\n\nexport function formatError(\n  text: string,\n  obj: any,\n  injectorErrorName: string,\n  source: string | null = null,\n): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n  let context = stringify(obj);\n  if (Array.isArray(obj)) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n          key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)),\n        );\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(\n    NEW_LINE,\n    '\\n  ',\n  )}`;\n}\n"]}