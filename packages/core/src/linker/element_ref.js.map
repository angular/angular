{"version":3,"file":"element_ref.js","sourceRoot":"","sources":["element_ref.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAKH,OAAO,EAAC,eAAe,EAAE,QAAQ,EAAC,MAAM,kBAAkB,CAAC;AAC3D,OAAO,EAAC,gBAAgB,EAAC,MAAM,4BAA4B,CAAC;AAE5D;;;;GAIG;AACH,MAAM,UAAU,gBAAgB;IAC9B,OAAO,gBAAgB,CAAC,eAAe,EAAG,EAAE,QAAQ,EAAE,CAAC,CAAC;AAC1D,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,gBAAgB,CAAC,KAAY,EAAE,KAAY;IACzD,OAAO,IAAI,UAAU,CAAC,gBAAgB,CAAC,KAAK,EAAE,KAAK,CAAa,CAAC,CAAC;AACpE,CAAC;AAED;;;;;;;;;;;GAWG;AACH,2EAA2E;AAC3E,2FAA2F;AAC3F,6CAA6C;AAC7C,MAAM,OAAO,UAAU;IAcrB,YAAY,aAAgB;QAC1B,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;IACrC,CAAC;;AAED;;;GAGG;AACI,4BAAiB,GAAqB,gBAAgB,CAAC;AAGhE;;;;;GAKG;AACH,MAAM,UAAU,gBAAgB,CAAO,KAAwB;IAC7D,OAAO,KAAK,YAAY,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC;AACnE,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {TNode} from '../render3/interfaces/node';\nimport {RElement} from '../render3/interfaces/renderer_dom';\nimport {LView} from '../render3/interfaces/view';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {getNativeByTNode} from '../render3/util/view_utils';\n\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nexport function injectElementRef(): ElementRef {\n  return createElementRef(getCurrentTNode()!, getLView());\n}\n\n/**\n * Creates an ElementRef given a node.\n *\n * @param tNode The node for which you'd like an ElementRef\n * @param lView The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nexport function createElementRef(tNode: TNode, lView: LView): ElementRef {\n  return new ElementRef(getNativeByTNode(tNode, lView) as RElement);\n}\n\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nexport class ElementRef<T = any> {\n  /**\n   * <div class=\"docs-alert docs-alert-important\">\n   *   <header>Use with caution</header>\n   *   <p>\n   *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n   *    data-binding provided by Angular instead. If used, it is recommended in combination with\n   *    {@link /best-practices/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls DomSanitizer}\n   *    for maxiumum security;\n   *   </p>\n   * </div>\n   */\n  public nativeElement: T;\n\n  constructor(nativeElement: T) {\n    this.nativeElement = nativeElement;\n  }\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => ElementRef = injectElementRef;\n}\n\n/**\n * Unwraps `ElementRef` and return the `nativeElement`.\n *\n * @param value value to unwrap\n * @returns `nativeElement` if `ElementRef` otherwise returns value as is.\n */\nexport function unwrapElementRef<T, R>(value: T | ElementRef<R>): T | R {\n  return value instanceof ElementRef ? value.nativeElement : value;\n}\n"]}