{"version":3,"file":"destroy_ref.js","sourceRoot":"","sources":["destroy_ref.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,WAAW,EAAC,MAAM,mCAAmC,CAAC;AAE9D,OAAO,EAAC,QAAQ,EAAC,MAAM,kBAAkB,CAAC;AAC1C,OAAO,EAAC,oBAAoB,EAAE,mBAAmB,EAAC,MAAM,4BAA4B,CAAC;AAErF,MAAM,qCAAqC,GAAG,KAAK,CAAC;AAEpD;;;;;;;GAOG;AACH,MAAM,OAAgB,UAAU;;AA6B9B;;;GAGG;AACI,4BAAiB,GAAqB,gBAAgB,CAAC;AAE9D;;;GAGG;AACI,wBAAa,GAAkD,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC;AAG/F,MAAM,OAAO,sBAAuB,SAAQ,UAAU;IACpD,YAAqB,MAAa;QAChC,KAAK,EAAE,CAAC;QADW,WAAM,GAAN,MAAM,CAAO;IAElC,CAAC;IAED,IAAa,SAAS;QACpB,OAAO,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAClC,CAAC;IAEQ,SAAS,CAAC,QAAoB;QACrC,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAE1B,oDAAoD;QACpD,IAAI,qCAAqC,IAAI,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC;YAChE,QAAQ,EAAE,CAAC;YACX,OAAO,GAAG,EAAE,GAAE,CAAC,CAAC;QAClB,CAAC;QAED,mBAAmB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QACrC,OAAO,GAAG,EAAE,CAAC,oBAAoB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IACrD,CAAC;CACF;AAED,SAAS,gBAAgB;IACvB,OAAO,IAAI,sBAAsB,CAAC,QAAQ,EAAE,CAAC,CAAC;AAChD,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector} from '../di';\nimport {isDestroyed} from '../render3/interfaces/type_checks';\nimport {LView} from '../render3/interfaces/view';\nimport {getLView} from '../render3/state';\nimport {removeLViewOnDestroy, storeLViewOnDestroy} from '../render3/util/view_utils';\n\nconst EXECUTE_CALLBACK_IF_ALREADY_DESTROYED = false;\n\n/**\n * `DestroyRef` lets you set callbacks to run for any cleanup or destruction behavior.\n * The scope of this destruction depends on where `DestroyRef` is injected. If `DestroyRef`\n * is injected in a component or directive, the callbacks run when that component or\n * directive is destroyed. Otherwise the callbacks run when a corresponding injector is destroyed.\n *\n * @publicApi\n */\nexport abstract class DestroyRef {\n  // Here the `DestroyRef` acts primarily as a DI token. There are (currently) types of objects that\n  // can be returned from the injector when asking for this token:\n  // - `NodeInjectorDestroyRef` when retrieved from a node injector;\n  // - `EnvironmentInjector` when retrieved from an environment injector\n\n  /**\n   * Registers a destroy callback in a given lifecycle scope.  Returns a cleanup function that can\n   * be invoked to unregister the callback.\n   *\n   * @usageNotes\n   * ### Example\n   * ```ts\n   * const destroyRef = inject(DestroyRef);\n   *\n   * // register a destroy callback\n   * const unregisterFn = destroyRef.onDestroy(() => doSomethingOnDestroy());\n   *\n   * // stop the destroy callback from executing if needed\n   * unregisterFn();\n   * ```\n   */\n  abstract onDestroy(callback: () => void): () => void;\n\n  /**\n   * Indicates whether the instance has already been destroyed.\n   */\n  abstract get destroyed(): boolean;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => DestroyRef = injectDestroyRef;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ENV_ID__: (injector: EnvironmentInjector) => DestroyRef = (injector) => injector;\n}\n\nexport class NodeInjectorDestroyRef extends DestroyRef {\n  constructor(readonly _lView: LView) {\n    super();\n  }\n\n  override get destroyed() {\n    return isDestroyed(this._lView);\n  }\n\n  override onDestroy(callback: () => void): () => void {\n    const lView = this._lView;\n\n    // TODO(atscott): Remove once g3 cleanup is complete\n    if (EXECUTE_CALLBACK_IF_ALREADY_DESTROYED && isDestroyed(lView)) {\n      callback();\n      return () => {};\n    }\n\n    storeLViewOnDestroy(lView, callback);\n    return () => removeLViewOnDestroy(lView, callback);\n  }\n}\n\nfunction injectDestroyRef(): DestroyRef {\n  return new NodeInjectorDestroyRef(getLView());\n}\n"]}