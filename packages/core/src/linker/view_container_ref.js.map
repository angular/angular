{"version":3,"file":"view_container_ref.js","sourceRoot":"","sources":["view_container_ref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector} from '../di/injector';\nimport {EnvironmentInjector} from '../di/r3_injector';\nimport {validateMatchingNode} from '../hydration/error_handling';\nimport {CONTAINERS} from '../hydration/interfaces';\nimport {isInSkipHydrationBlock} from '../hydration/skip_hydration';\nimport {\n  getSegmentHead,\n  isDisconnectedNode,\n  markRNodeAsClaimedByHydration,\n} from '../hydration/utils';\nimport {findMatchingDehydratedView, locateDehydratedViewsInContainer} from '../hydration/views';\nimport {isType, Type} from '../interface/type';\nimport {assertNodeInjector} from '../render3/assert';\nimport {ComponentFactory as R3ComponentFactory} from '../render3/component_ref';\nimport {getComponentDef} from '../render3/def_getters';\nimport {getParentInjectorLocation, NodeInjector} from '../render3/di';\nimport {\n  CONTAINER_HEADER_OFFSET,\n  DEHYDRATED_VIEWS,\n  LContainer,\n  NATIVE,\n  VIEW_REFS,\n} from '../render3/interfaces/container';\nimport {NodeInjectorOffset} from '../render3/interfaces/injector';\nimport {\n  TContainerNode,\n  TDirectiveHostNode,\n  TElementContainerNode,\n  TElementNode,\n  TNode,\n  TNodeType,\n} from '../render3/interfaces/node';\nimport {RComment, RNode} from '../render3/interfaces/renderer_dom';\nimport {isLContainer} from '../render3/interfaces/type_checks';\nimport {\n  HEADER_OFFSET,\n  HYDRATION,\n  LView,\n  PARENT,\n  RENDERER,\n  T_HOST,\n  TVIEW,\n} from '../render3/interfaces/view';\nimport {assertTNodeType} from '../render3/node_assert';\nimport {destroyLView} from '../render3/node_manipulation';\nimport {nativeInsertBefore} from '../render3/dom_node_manipulation';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {\n  getParentInjectorIndex,\n  getParentInjectorView,\n  hasParentInjector,\n} from '../render3/util/injector_utils';\nimport {getNativeByTNode, unwrapRNode, viewAttachedToContainer} from '../render3/util/view_utils';\nimport {shouldAddViewToDom} from '../render3/view_manipulation';\nimport {ViewRef as R3ViewRef} from '../render3/view_ref';\nimport {addToArray, removeFromArray} from '../util/array_utils';\nimport {\n  assertDefined,\n  assertEqual,\n  assertGreaterThan,\n  assertLessThan,\n  throwError,\n} from '../util/assert';\n\nimport {ComponentFactory, ComponentRef} from './component_factory';\nimport {createElementRef, ElementRef} from './element_ref';\nimport {NgModuleRef} from './ng_module_factory';\nimport {TemplateRef} from './template_ref';\nimport {EmbeddedViewRef, ViewRef} from './view_ref';\nimport {addLViewToLContainer, createLContainer, detachView} from '../render3/view/container';\nimport {addToEndOfViewTree} from '../render3/view/construction';\nimport {Binding, DirectiveWithBindings} from '../render3/dynamic_bindings';\n\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a view hierarchy.\n *\n * @usageNotes\n *\n * The example below demonstrates how the `createComponent` function can be used\n * to create an instance of a ComponentRef dynamically and attach it to an ApplicationRef,\n * so that it gets included into change detection cycles.\n *\n * Note: the example uses standalone components, but the function can also be used for\n * non-standalone components (declared in an NgModule) as well.\n *\n * ```angular-ts\n * @Component({\n *   selector: 'dynamic',\n *   template: `<span>This is a content of a dynamic component.</span>`,\n * })\n * class DynamicComponent {\n *   vcr = inject(ViewContainerRef);\n * }\n *\n * @Component({\n *   selector: 'app',\n *   template: `<main>Hi! This is the main content.</main>`,\n * })\n * class AppComponent {\n *   vcr = inject(ViewContainerRef);\n *\n *   ngAfterViewInit() {\n *     const compRef = this.vcr.createComponent(DynamicComponent);\n *     compRef.changeDetectorRef.detectChanges();\n *   }\n * }\n * ```\n *\n * @see {@link ComponentRef}\n * @see {@link EmbeddedViewRef}\n *\n * @publicApi\n */\nexport abstract class ViewContainerRef {\n  /**\n   * Anchor element that specifies the location of this container in the containing view.\n   * Each view container can have only one anchor element, and each anchor element\n   * can have only a single view container.\n   *\n   * Root elements of views attached to this container become siblings of the anchor element in\n   * the rendered view.\n   *\n   * Access the `ViewContainerRef` of an element by placing a `Directive` injected\n   * with `ViewContainerRef` on the element, or use a `ViewChild` query.\n   *\n   * <!-- TODO: rename to anchorElement -->\n   */\n  abstract get element(): ElementRef;\n\n  /**\n   * The dependency injector for this view container.\n   */\n  abstract get injector(): Injector;\n\n  /** @deprecated No replacement */\n  abstract get parentInjector(): Injector;\n\n  /**\n   * Destroys all views in this container.\n   */\n  abstract clear(): void;\n\n  /**\n   * Retrieves a view from this container.\n   * @param index The 0-based index of the view to retrieve.\n   * @returns The `ViewRef` instance, or null if the index is out of range.\n   */\n  abstract get(index: number): ViewRef | null;\n\n  /**\n   * Reports how many views are currently attached to this container.\n   * @returns The number of views.\n   */\n  abstract get length(): number;\n\n  /**\n   * Instantiates an embedded view and inserts it\n   * into this container.\n   * @param templateRef The HTML template that defines the view.\n   * @param context The data-binding context of the embedded view, as declared\n   * in the `<ng-template>` usage.\n   * @param options Extra configuration for the created view. Includes:\n   *  * index: The 0-based index at which to insert the new view into this container.\n   *           If not specified, appends the new view as the last entry.\n   *  * injector: Injector to be used within the embedded view.\n   *\n   * @returns The `ViewRef` instance for the newly created view.\n   */\n  abstract createEmbeddedView<C>(\n    templateRef: TemplateRef<C>,\n    context?: C,\n    options?: {\n      index?: number;\n      injector?: Injector;\n    },\n  ): EmbeddedViewRef<C>;\n\n  /**\n   * Instantiates an embedded view and inserts it\n   * into this container.\n   * @param templateRef The HTML template that defines the view.\n   * @param context The data-binding context of the embedded view, as declared\n   * in the `<ng-template>` usage.\n   * @param index The 0-based index at which to insert the new view into this container.\n   * If not specified, appends the new view as the last entry.\n   *\n   * @returns The `ViewRef` instance for the newly created view.\n   */\n  abstract createEmbeddedView<C>(\n    templateRef: TemplateRef<C>,\n    context?: C,\n    index?: number,\n  ): EmbeddedViewRef<C>;\n\n  /**\n   * Instantiates a component and inserts its host view into this view container.\n   *\n   * @param componentType Component Type to use.\n   * @param options An object that contains extra parameters:\n   *  * index: the index at which to insert the new component's host view into this container.\n   *           If not specified, appends the new view as the last entry.\n   *  * injector: the injector to use as the parent for the new component.\n   *  * ngModuleRef: an NgModuleRef of the component's NgModule, you should almost always provide\n   *                 this to ensure that all expected providers are available for the component\n   *                 instantiation.\n   *  * environmentInjector: an EnvironmentInjector which will provide the component's environment.\n   *                 you should almost always provide this to ensure that all expected providers\n   *                 are available for the component instantiation. This option is intended to\n   *                 replace the `ngModuleRef` parameter.\n   *  * projectableNodes: list of DOM nodes that should be projected through\n   *                      [`<ng-content>`](api/core/ng-content) of the new component instance.\n   *  * directives: Directives that should be applied to the component.\n   *  * bindings: Bindings that should be applied to the component.\n   *\n   * @returns The new `ComponentRef` which contains the component instance and the host view.\n   */\n  abstract createComponent<C>(\n    componentType: Type<C>,\n    options?: {\n      index?: number;\n      injector?: Injector;\n      ngModuleRef?: NgModuleRef<unknown>;\n      environmentInjector?: EnvironmentInjector | NgModuleRef<unknown>;\n      projectableNodes?: Node[][];\n      directives?: (Type<unknown> | DirectiveWithBindings<unknown>)[];\n      bindings?: Binding[];\n    },\n  ): ComponentRef<C>;\n\n  /**\n   * Instantiates a single component and inserts its host view into this container.\n   *\n   * @param componentFactory Component factory to use.\n   * @param index The index at which to insert the new component's host view into this container.\n   * If not specified, appends the new view as the last entry.\n   * @param injector The injector to use as the parent for the new component.\n   * @param projectableNodes List of DOM nodes that should be projected through\n   *     [`<ng-content>`](api/core/ng-content) of the new component instance.\n   * @param ngModuleRef An instance of the NgModuleRef that represent an NgModule.\n   * This information is used to retrieve corresponding NgModule injector.\n   * @param directives Directives that should be applied to the component.\n   * @param bindings Bindings that should be applied to the component.\n   *\n   * @returns The new `ComponentRef` which contains the component instance and the host view.\n   *\n   * @deprecated Angular no longer requires component factories to dynamically create components.\n   *     Use different signature of the `createComponent` method, which allows passing\n   *     Component class directly.\n   */\n  abstract createComponent<C>(\n    componentFactory: ComponentFactory<C>,\n    index?: number,\n    injector?: Injector,\n    projectableNodes?: any[][],\n    environmentInjector?: EnvironmentInjector | NgModuleRef<any>,\n    directives?: (Type<unknown> | DirectiveWithBindings<unknown>)[],\n    bindings?: Binding[],\n  ): ComponentRef<C>;\n\n  /**\n   * Inserts a view into this container.\n   * @param viewRef The view to insert.\n   * @param index The 0-based index at which to insert the view.\n   * If not specified, appends the new view as the last entry.\n   * @returns The inserted `ViewRef` instance.\n   *\n   */\n  abstract insert(viewRef: ViewRef, index?: number): ViewRef;\n\n  /**\n   * Moves a view to a new location in this container.\n   * @param viewRef The view to move.\n   * @param index The 0-based index of the new location.\n   * @returns The moved `ViewRef` instance.\n   */\n  abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;\n\n  /**\n   * Returns the index of a view within the current container.\n   * @param viewRef The view to query.\n   * @returns The 0-based index of the view's position in this container,\n   * or `-1` if this container doesn't contain the view.\n   */\n  abstract indexOf(viewRef: ViewRef): number;\n\n  /**\n   * Destroys a view attached to this container\n   * @param index The 0-based index of the view to destroy.\n   * If not specified, the last view in the container is removed.\n   */\n  abstract remove(index?: number): void;\n\n  /**\n   * Detaches a view from this container without destroying it.\n   * Use along with `insert()` to move a view within the current container.\n   * @param index The 0-based index of the view to detach.\n   * If not specified, the last view in the container is detached.\n   */\n  abstract detach(index?: number): ViewRef | null;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => ViewContainerRef = injectViewContainerRef;\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function injectViewContainerRef(): ViewContainerRef {\n  const previousTNode = getCurrentTNode() as TElementNode | TElementContainerNode | TContainerNode;\n  return createContainerRef(previousTNode, getLView());\n}\n\nconst VE_ViewContainerRef = ViewContainerRef;\n\n// TODO(alxhub): cleaning up this indirection triggers a subtle bug in Closure in g3. Once the fix\n// for that lands, this can be cleaned up.\nconst R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {\n  constructor(\n    private _lContainer: LContainer,\n    private _hostTNode: TElementNode | TContainerNode | TElementContainerNode,\n    private _hostLView: LView,\n  ) {\n    super();\n  }\n\n  override get element(): ElementRef {\n    return createElementRef(this._hostTNode, this._hostLView);\n  }\n\n  override get injector(): Injector {\n    return new NodeInjector(this._hostTNode, this._hostLView);\n  }\n\n  /** @deprecated No replacement */\n  override get parentInjector(): Injector {\n    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);\n    if (hasParentInjector(parentLocation)) {\n      const parentView = getParentInjectorView(parentLocation, this._hostLView);\n      const injectorIndex = getParentInjectorIndex(parentLocation);\n      ngDevMode && assertNodeInjector(parentView, injectorIndex);\n      const parentTNode = parentView[TVIEW].data[\n        injectorIndex + NodeInjectorOffset.TNODE\n      ] as TElementNode;\n      return new NodeInjector(parentTNode, parentView);\n    } else {\n      return new NodeInjector(null, this._hostLView);\n    }\n  }\n\n  override clear(): void {\n    while (this.length > 0) {\n      this.remove(this.length - 1);\n    }\n  }\n\n  override get(index: number): ViewRef | null {\n    const viewRefs = getViewRefs(this._lContainer);\n    return (viewRefs !== null && viewRefs[index]) || null;\n  }\n\n  override get length(): number {\n    return this._lContainer.length - CONTAINER_HEADER_OFFSET;\n  }\n\n  override createEmbeddedView<C>(\n    templateRef: TemplateRef<C>,\n    context?: C,\n    options?: {\n      index?: number;\n      injector?: Injector;\n    },\n  ): EmbeddedViewRef<C>;\n  override createEmbeddedView<C>(\n    templateRef: TemplateRef<C>,\n    context?: C,\n    index?: number,\n  ): EmbeddedViewRef<C>;\n  override createEmbeddedView<C>(\n    templateRef: TemplateRef<C>,\n    context?: C,\n    indexOrOptions?:\n      | number\n      | {\n          index?: number;\n          injector?: Injector;\n        },\n  ): EmbeddedViewRef<C> {\n    let index: number | undefined;\n    let injector: Injector | undefined;\n\n    if (typeof indexOrOptions === 'number') {\n      index = indexOrOptions;\n    } else if (indexOrOptions != null) {\n      index = indexOrOptions.index;\n      injector = indexOrOptions.injector;\n    }\n\n    const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);\n    const viewRef = templateRef.createEmbeddedViewImpl(\n      context || <any>{},\n      injector,\n      dehydratedView,\n    );\n    this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));\n    return viewRef;\n  }\n\n  override createComponent<C>(\n    componentType: Type<C>,\n    options?: {\n      index?: number;\n      injector?: Injector;\n      projectableNodes?: Node[][];\n      ngModuleRef?: NgModuleRef<unknown>;\n      directives?: (Type<unknown> | DirectiveWithBindings<unknown>)[];\n      bindings?: Binding[];\n    },\n  ): ComponentRef<C>;\n  /**\n   * @deprecated Angular no longer requires component factories to dynamically create components.\n   *     Use different signature of the `createComponent` method, which allows passing\n   *     Component class directly.\n   */\n  override createComponent<C>(\n    componentFactory: ComponentFactory<C>,\n    index?: number | undefined,\n    injector?: Injector | undefined,\n    projectableNodes?: any[][] | undefined,\n    environmentInjector?: EnvironmentInjector | NgModuleRef<any> | undefined,\n    directives?: (Type<unknown> | DirectiveWithBindings<unknown>)[],\n    bindings?: Binding[],\n  ): ComponentRef<C>;\n  override createComponent<C>(\n    componentFactoryOrType: ComponentFactory<C> | Type<C>,\n    indexOrOptions?:\n      | number\n      | undefined\n      | {\n          index?: number;\n          injector?: Injector;\n          ngModuleRef?: NgModuleRef<unknown>;\n          environmentInjector?: EnvironmentInjector | NgModuleRef<unknown>;\n          projectableNodes?: Node[][];\n          directives?: (Type<unknown> | DirectiveWithBindings<unknown>)[];\n          bindings?: Binding[];\n        },\n    injector?: Injector | undefined,\n    projectableNodes?: any[][] | undefined,\n    environmentInjector?: EnvironmentInjector | NgModuleRef<any> | undefined,\n    directives?: (Type<unknown> | DirectiveWithBindings<unknown>)[],\n    bindings?: Binding[],\n  ): ComponentRef<C> {\n    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);\n    let index: number | undefined;\n\n    // This function supports 2 signatures and we need to handle options correctly for both:\n    //   1. When first argument is a Component type. This signature also requires extra\n    //      options to be provided as object (more ergonomic option).\n    //   2. First argument is a Component factory. In this case extra options are represented as\n    //      positional arguments. This signature is less ergonomic and will be deprecated.\n    if (isComponentFactory) {\n      if (ngDevMode) {\n        assertEqual(\n          typeof indexOrOptions !== 'object',\n          true,\n          'It looks like Component factory was provided as the first argument ' +\n            'and an options object as the second argument. This combination of arguments ' +\n            'is incompatible. You can either change the first argument to provide Component ' +\n            'type or change the second argument to be a number (representing an index at ' +\n            \"which to insert the new component's host view into this container)\",\n        );\n      }\n      index = indexOrOptions as number | undefined;\n    } else {\n      if (ngDevMode) {\n        assertDefined(\n          getComponentDef(componentFactoryOrType),\n          `Provided Component class doesn't contain Component definition. ` +\n            `Please check whether provided class has @Component decorator.`,\n        );\n        assertEqual(\n          typeof indexOrOptions !== 'number',\n          true,\n          'It looks like Component type was provided as the first argument ' +\n            \"and a number (representing an index at which to insert the new component's \" +\n            'host view into this container as the second argument. This combination of arguments ' +\n            'is incompatible. Please use an object as the second argument instead.',\n        );\n      }\n      const options = (indexOrOptions || {}) as {\n        index?: number;\n        injector?: Injector;\n        ngModuleRef?: NgModuleRef<unknown>;\n        environmentInjector?: EnvironmentInjector | NgModuleRef<unknown>;\n        projectableNodes?: Node[][];\n        directives?: (Type<unknown> | DirectiveWithBindings<unknown>)[];\n        bindings?: Binding[];\n      };\n      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {\n        throwError(\n          `Cannot pass both environmentInjector and ngModuleRef options to createComponent().`,\n        );\n      }\n      index = options.index;\n      injector = options.injector;\n      projectableNodes = options.projectableNodes;\n      environmentInjector = options.environmentInjector || options.ngModuleRef;\n      directives = options.directives;\n      bindings = options.bindings;\n    }\n\n    const componentFactory: ComponentFactory<C> = isComponentFactory\n      ? (componentFactoryOrType as ComponentFactory<C>)\n      : new R3ComponentFactory(getComponentDef(componentFactoryOrType)!);\n    const contextInjector = injector || this.parentInjector;\n\n    // If an `NgModuleRef` is not provided explicitly, try retrieving it from the DI tree.\n    if (!environmentInjector && (componentFactory as any).ngModule == null) {\n      // For the `ComponentFactory` case, entering this logic is very unlikely, since we expect that\n      // an instance of a `ComponentFactory`, resolved via `ComponentFactoryResolver` would have an\n      // `ngModule` field. This is possible in some test scenarios and potentially in some JIT-based\n      // use-cases. For the `ComponentFactory` case we preserve backwards-compatibility and try\n      // using a provided injector first, then fall back to the parent injector of this\n      // `ViewContainerRef` instance.\n      //\n      // For the factory-less case, it's critical to establish a connection with the module\n      // injector tree (by retrieving an instance of an `NgModuleRef` and accessing its injector),\n      // so that a component can use DI tokens provided in MgModules. For this reason, we can not\n      // rely on the provided injector, since it might be detached from the DI tree (for example, if\n      // it was created via `Injector.create` without specifying a parent injector, or if an\n      // injector is retrieved from an `NgModuleRef` created via `createNgModule` using an\n      // NgModule outside of a module tree). Instead, we always use `ViewContainerRef`'s parent\n      // injector, which is normally connected to the DI tree, which includes module injector\n      // subtree.\n      const _injector = isComponentFactory ? contextInjector : this.parentInjector;\n\n      // DO NOT REFACTOR. The code here used to have a `injector.get(NgModuleRef, null) ||\n      // undefined` expression which seems to cause internal google apps to fail. This is documented\n      // in the following internal bug issue: go/b/142967802\n      const result = _injector.get(EnvironmentInjector, null);\n      if (result) {\n        environmentInjector = result;\n      }\n    }\n\n    const componentDef = getComponentDef(componentFactory.componentType ?? {});\n    const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);\n    const rNode = dehydratedView?.firstChild ?? null;\n    const componentRef = componentFactory.create(\n      contextInjector,\n      projectableNodes,\n      rNode,\n      environmentInjector,\n      directives,\n      bindings,\n    );\n    this.insertImpl(\n      componentRef.hostView,\n      index,\n      shouldAddViewToDom(this._hostTNode, dehydratedView),\n    );\n    return componentRef;\n  }\n\n  override insert(viewRef: ViewRef, index?: number): ViewRef {\n    return this.insertImpl(viewRef, index, true);\n  }\n\n  private insertImpl(viewRef: ViewRef, index?: number, addToDOM?: boolean): ViewRef {\n    const lView = (viewRef as R3ViewRef<any>)._lView!;\n\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n    }\n\n    if (viewAttachedToContainer(lView)) {\n      // If view is already attached, detach it first so we clean up references appropriately.\n\n      const prevIdx = this.indexOf(viewRef);\n\n      // A view might be attached either to this or a different container. The `prevIdx` for\n      // those cases will be:\n      // equal to -1 for views attached to this ViewContainerRef\n      // >= 0 for views attached to a different ViewContainerRef\n      if (prevIdx !== -1) {\n        this.detach(prevIdx);\n      } else {\n        const prevLContainer = lView[PARENT] as LContainer;\n        ngDevMode &&\n          assertEqual(\n            isLContainer(prevLContainer),\n            true,\n            'An attached view should have its PARENT point to a container.',\n          );\n\n        // We need to re-create a R3ViewContainerRef instance since those are not stored on\n        // LView (nor anywhere else).\n        const prevVCRef = new R3ViewContainerRef(\n          prevLContainer,\n          prevLContainer[T_HOST] as TDirectiveHostNode,\n          prevLContainer[PARENT],\n        );\n\n        prevVCRef.detach(prevVCRef.indexOf(viewRef));\n      }\n    }\n\n    // Logical operation of adding `LView` to `LContainer`\n    const adjustedIdx = this._adjustIndex(index);\n    const lContainer = this._lContainer;\n\n    addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);\n\n    (viewRef as R3ViewRef<any>).attachToViewContainerRef();\n    addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);\n\n    return viewRef;\n  }\n\n  override move(viewRef: ViewRef, newIndex: number): ViewRef {\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error('Cannot move a destroyed View in a ViewContainer!');\n    }\n    return this.insert(viewRef, newIndex);\n  }\n\n  override indexOf(viewRef: ViewRef): number {\n    const viewRefsArr = getViewRefs(this._lContainer);\n    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;\n  }\n\n  override remove(index?: number): void {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    const detachedView = detachView(this._lContainer, adjustedIdx);\n\n    if (detachedView) {\n      // Before destroying the view, remove it from the container's array of `ViewRef`s.\n      // This ensures the view container length is updated before calling\n      // `destroyLView`, which could recursively call view container methods that\n      // rely on an accurate container length.\n      // (e.g. a method on this view container being called by a child directive's OnDestroy\n      // lifecycle hook)\n      removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);\n      destroyLView(detachedView[TVIEW], detachedView);\n    }\n  }\n\n  override detach(index?: number): ViewRef | null {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    const view = detachView(this._lContainer, adjustedIdx);\n\n    const wasDetached =\n      view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;\n    return wasDetached ? new R3ViewRef(view!) : null;\n  }\n\n  private _adjustIndex(index?: number, shift: number = 0) {\n    if (index == null) {\n      return this.length + shift;\n    }\n    if (ngDevMode) {\n      assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);\n      // +1 because it's legal to insert at the end.\n      assertLessThan(index, this.length + 1 + shift, 'index');\n    }\n    return index;\n  }\n};\n\nfunction getViewRefs(lContainer: LContainer): ViewRef[] | null {\n  return lContainer[VIEW_REFS] as ViewRef[];\n}\n\nfunction getOrCreateViewRefs(lContainer: LContainer): ViewRef[] {\n  return (lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = [])) as ViewRef[];\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostLView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\nexport function createContainerRef(\n  hostTNode: TElementNode | TContainerNode | TElementContainerNode,\n  hostLView: LView,\n): ViewContainerRef {\n  ngDevMode && assertTNodeType(hostTNode, TNodeType.AnyContainer | TNodeType.AnyRNode);\n\n  let lContainer: LContainer;\n  const slotValue = hostLView[hostTNode.index];\n  if (isLContainer(slotValue)) {\n    // If the host is a container, we don't need to create a new LContainer\n    lContainer = slotValue;\n  } else {\n    // An LContainer anchor can not be `null`, but we set it here temporarily\n    // and update to the actual value later in this function (see\n    // `_locateOrCreateAnchorNode`).\n    lContainer = createLContainer(slotValue, hostLView, null!, hostTNode);\n    hostLView[hostTNode.index] = lContainer;\n    addToEndOfViewTree(hostLView, lContainer);\n  }\n  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);\n\n  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);\n}\n\n/**\n * Creates and inserts a comment node that acts as an anchor for a view container.\n *\n * If the host is a regular element, we have to insert a comment node manually which will\n * be used as an anchor when inserting elements. In this specific case we use low-level DOM\n * manipulation to insert it.\n */\nfunction insertAnchorNode(hostLView: LView, hostTNode: TNode): RComment {\n  const renderer = hostLView[RENDERER];\n  const commentNode = renderer.createComment(ngDevMode ? 'container' : '');\n\n  const hostNative = getNativeByTNode(hostTNode, hostLView)!;\n  const parentOfHostNative = renderer.parentNode(hostNative);\n  nativeInsertBefore(\n    renderer,\n    parentOfHostNative!,\n    commentNode,\n    renderer.nextSibling(hostNative),\n    false,\n  );\n  return commentNode;\n}\n\nlet _locateOrCreateAnchorNode = createAnchorNode;\nlet _populateDehydratedViewsInLContainer: typeof populateDehydratedViewsInLContainerImpl = () =>\n  false; // noop by default\n\n/**\n * Looks up dehydrated views that belong to a given LContainer and populates\n * this information into the `LContainer[DEHYDRATED_VIEWS]` slot. When running\n * in client-only mode, this function is a noop.\n *\n * @param lContainer LContainer that should be populated.\n * @param tNode Corresponding TNode.\n * @param hostLView LView that hosts LContainer.\n * @returns a boolean flag that indicates whether a populating operation\n *   was successful. The operation might be unsuccessful in case is has completed\n *   previously, we are rendering in client-only mode or this content is located\n *   in a skip hydration section.\n */\nexport function populateDehydratedViewsInLContainer(\n  lContainer: LContainer,\n  tNode: TNode,\n  hostLView: LView,\n): boolean {\n  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);\n}\n\n/**\n * Regular creation mode: an anchor is created and\n * assigned to the `lContainer[NATIVE]` slot.\n */\nfunction createAnchorNode(\n  lContainer: LContainer,\n  hostLView: LView,\n  hostTNode: TNode,\n  slotValue: any,\n) {\n  // We already have a native element (anchor) set, return.\n  if (lContainer[NATIVE]) return;\n\n  let commentNode: RComment;\n  // If the host is an element container, the native host element is guaranteed to be a\n  // comment and we can reuse that comment as anchor element for the new LContainer.\n  // The comment node in question is already part of the DOM structure so we don't need to append\n  // it again.\n  if (hostTNode.type & TNodeType.ElementContainer) {\n    commentNode = unwrapRNode(slotValue) as RComment;\n  } else {\n    commentNode = insertAnchorNode(hostLView, hostTNode);\n  }\n  lContainer[NATIVE] = commentNode;\n}\n\n/**\n * Hydration logic that looks up all dehydrated views in this container\n * and puts them into `lContainer[DEHYDRATED_VIEWS]` slot.\n *\n * @returns a boolean flag that indicates whether a populating operation\n *   was successful. The operation might be unsuccessful in case is has completed\n *   previously, we are rendering in client-only mode or this content is located\n *   in a skip hydration section.\n */\nfunction populateDehydratedViewsInLContainerImpl(\n  lContainer: LContainer,\n  tNode: TNode,\n  hostLView: LView,\n): boolean {\n  // We already have a native element (anchor) set and the process\n  // of finding dehydrated views happened (so the `lContainer[DEHYDRATED_VIEWS]`\n  // is not null), exit early.\n  if (lContainer[NATIVE] && lContainer[DEHYDRATED_VIEWS]) {\n    return true;\n  }\n\n  const hydrationInfo = hostLView[HYDRATION];\n  const noOffsetIndex = tNode.index - HEADER_OFFSET;\n  const isNodeCreationMode =\n    !hydrationInfo ||\n    isInSkipHydrationBlock(tNode) ||\n    isDisconnectedNode(hydrationInfo, noOffsetIndex);\n\n  // Regular creation mode.\n  if (isNodeCreationMode) {\n    return false;\n  }\n\n  // Hydration mode, looking up an anchor node and dehydrated views in DOM.\n  const currentRNode: RNode | null = getSegmentHead(hydrationInfo, noOffsetIndex);\n\n  const serializedViews = hydrationInfo.data[CONTAINERS]?.[noOffsetIndex];\n  ngDevMode &&\n    assertDefined(\n      serializedViews,\n      'Unexpected state: no hydration info available for a given TNode, ' +\n        'which represents a view container.',\n    );\n\n  const [commentNode, dehydratedViews] = locateDehydratedViewsInContainer(\n    currentRNode!,\n    serializedViews!,\n  );\n\n  if (ngDevMode) {\n    validateMatchingNode(commentNode, Node.COMMENT_NODE, null, hostLView, tNode, true);\n    // Do not throw in case this node is already claimed (thus `false` as a second\n    // argument). If this container is created based on an `<ng-template>`, the comment\n    // node would be already claimed from the `template` instruction. If an element acts\n    // as an anchor (e.g. <div #vcRef>), a separate comment node would be created/located,\n    // so we need to claim it here.\n    markRNodeAsClaimedByHydration(commentNode, false);\n  }\n\n  lContainer[NATIVE] = commentNode as RComment;\n  lContainer[DEHYDRATED_VIEWS] = dehydratedViews;\n\n  return true;\n}\n\nfunction locateOrCreateAnchorNode(\n  lContainer: LContainer,\n  hostLView: LView,\n  hostTNode: TNode,\n  slotValue: any,\n): void {\n  if (!_populateDehydratedViewsInLContainer(lContainer, hostTNode, hostLView)) {\n    // Populating dehydrated views operation returned `false`, which indicates\n    // that the logic was running in client-only mode, this an anchor comment\n    // node should be created for this container.\n    createAnchorNode(lContainer, hostLView, hostTNode, slotValue);\n  }\n}\n\nexport function enableLocateOrCreateContainerRefImpl() {\n  _locateOrCreateAnchorNode = locateOrCreateAnchorNode;\n  _populateDehydratedViewsInLContainer = populateDehydratedViewsInLContainerImpl;\n}\n"]}