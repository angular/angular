{"version":3,"file":"html_sanitizer.js","sourceRoot":"","sources":["html_sanitizer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {XSS_SECURITY_URL} from '../error_details_base_url';\nimport {TrustedHTML} from '../util/security/trusted_type_defs';\nimport {trustedHTMLFromString} from '../util/security/trusted_types';\n\nimport {getInertBodyHelper, InertBodyHelper} from './inert_body';\nimport {_sanitizeUrl} from './url_sanitizer';\n\nfunction tagSet(tags: string): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const t of tags.split(',')) res[t] = true;\n  return res;\n}\n\nfunction merge(...sets: {[k: string]: boolean}[]): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const s of sets) {\n    for (const v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n  return res;\n}\n\n// Good source of info about elements and attributes\n// https://html.spec.whatwg.org/#semantics\n// https://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// https://html.spec.whatwg.org/#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// https://html.spec.whatwg.org/#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS = merge(\n  OPTIONAL_END_TAG_INLINE_ELEMENTS,\n  OPTIONAL_END_TAG_BLOCK_ELEMENTS,\n);\n\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(\n  OPTIONAL_END_TAG_BLOCK_ELEMENTS,\n  tagSet(\n    'address,article,' +\n      'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n      'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul',\n  ),\n);\n\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(\n  OPTIONAL_END_TAG_INLINE_ELEMENTS,\n  tagSet(\n    'a,abbr,acronym,audio,b,' +\n      'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\n      'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video',\n  ),\n);\n\nexport const VALID_ELEMENTS: {[k: string]: boolean} = merge(\n  VOID_ELEMENTS,\n  BLOCK_ELEMENTS,\n  INLINE_ELEMENTS,\n  OPTIONAL_END_TAG_ELEMENTS,\n);\n\n// Attributes that have href and hence need to be sanitized\nexport const URI_ATTRS: {[k: string]: boolean} = tagSet(\n  'background,cite,href,itemtype,longdesc,poster,src,xlink:href',\n);\n\nconst HTML_ATTRS = tagSet(\n  'abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\n    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\n    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,' +\n    'valign,value,vspace,width',\n);\n\n// Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\nconst ARIA_ATTRS = tagSet(\n  'aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' +\n    'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' +\n    'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' +\n    'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' +\n    'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' +\n    'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' +\n    'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext',\n);\n\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\n\nexport const VALID_ATTRS: {[k: string]: boolean} = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);\n\n// Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\n//\n// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\n// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\n// don't want to preserve the content, if the elements themselves are going to be removed.\nconst SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\n\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n  // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n  // because characters were re-encoded.\n  public sanitizedSomething = false;\n  private buf: string[] = [];\n\n  sanitizeChildren(el: Element): string {\n    // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n    // However this code never accesses properties off of `document` before deleting its contents\n    // again, so it shouldn't be vulnerable to DOM clobbering.\n    let current: Node = el.firstChild!;\n    let traverseContent = true;\n    let parentNodes = [];\n    while (current) {\n      if (current.nodeType === Node.ELEMENT_NODE) {\n        traverseContent = this.startElement(current as Element);\n      } else if (current.nodeType === Node.TEXT_NODE) {\n        this.chars(current.nodeValue!);\n      } else {\n        // Strip non-element, non-text nodes.\n        this.sanitizedSomething = true;\n      }\n      if (traverseContent && current.firstChild) {\n        // Push current node to the parent stack before entering its content.\n        parentNodes.push(current);\n        current = getFirstChild(current)!;\n        continue;\n      }\n      while (current) {\n        // Leaving the element.\n        // Walk up and to the right, closing tags as we go.\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          this.endElement(current as Element);\n        }\n\n        let next = getNextSibling(current)!;\n\n        if (next) {\n          current = next;\n          break;\n        }\n\n        // There was no next sibling, walk up to the parent node (extract it from the stack).\n        current = parentNodes.pop()!;\n      }\n    }\n    return this.buf.join('');\n  }\n\n  /**\n   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n   * be traversed. Element content must always be traversed (even if the element itself is not\n   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n   *\n   * @param element The element to sanitize.\n   * @return True if the element's contents should be traversed.\n   */\n  private startElement(element: Element): boolean {\n    const tagName = getNodeName(element).toLowerCase();\n    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.sanitizedSomething = true;\n      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n    }\n    this.buf.push('<');\n    this.buf.push(tagName);\n    const elAttrs = element.attributes;\n    for (let i = 0; i < elAttrs.length; i++) {\n      const elAttr = elAttrs.item(i);\n      const attrName = elAttr!.name;\n      const lower = attrName.toLowerCase();\n      if (!VALID_ATTRS.hasOwnProperty(lower)) {\n        this.sanitizedSomething = true;\n        continue;\n      }\n      let value = elAttr!.value;\n      // TODO(martinprobst): Special case image URIs for data:image/...\n      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);\n      this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n    }\n    this.buf.push('>');\n    return true;\n  }\n\n  private endElement(current: Element) {\n    const tagName = getNodeName(current).toLowerCase();\n    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.buf.push('</');\n      this.buf.push(tagName);\n      this.buf.push('>');\n    }\n  }\n\n  private chars(chars: string) {\n    this.buf.push(encodeEntities(chars));\n  }\n}\n\n/**\n * Verifies whether a given child node is a descendant of a given parent node.\n * It may not be the case when properties like `.firstChild` are clobbered and\n * accessing `.firstChild` results in an unexpected node returned.\n */\nfunction isClobberedElement(parentNode: Node, childNode: Node): boolean {\n  return (\n    (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !==\n    Node.DOCUMENT_POSITION_CONTAINED_BY\n  );\n}\n\n/**\n * Retrieves next sibling node and makes sure that there is no\n * clobbering of the `nextSibling` property happening.\n */\nfunction getNextSibling(node: Node): Node | null {\n  const nextSibling = node.nextSibling;\n  // Make sure there is no `nextSibling` clobbering: navigating to\n  // the next sibling and going back to the previous one should result\n  // in the original node.\n  if (nextSibling && node !== nextSibling.previousSibling) {\n    throw clobberedElementError(nextSibling);\n  }\n  return nextSibling;\n}\n\n/**\n * Retrieves first child node and makes sure that there is no\n * clobbering of the `firstChild` property happening.\n */\nfunction getFirstChild(node: Node): Node | null {\n  const firstChild = node.firstChild;\n  if (firstChild && isClobberedElement(node, firstChild)) {\n    throw clobberedElementError(firstChild);\n  }\n  return firstChild;\n}\n\n/** Gets a reasonable nodeName, even for clobbered nodes. */\nexport function getNodeName(node: Node): string {\n  const nodeName = node.nodeName;\n  // If the property is clobbered, assume it is an `HTMLFormElement`.\n  return typeof nodeName === 'string' ? nodeName : 'FORM';\n}\n\nfunction clobberedElementError(node: Node) {\n  return new Error(\n    `Failed to sanitize html because the element is clobbered: ${(node as Element).outerHTML}`,\n  );\n}\n\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\nfunction encodeEntities(value: string) {\n  return value\n    .replace(/&/g, '&amp;')\n    .replace(SURROGATE_PAIR_REGEXP, function (match: string) {\n      const hi = match.charCodeAt(0);\n      const low = match.charCodeAt(1);\n      return '&#' + ((hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000) + ';';\n    })\n    .replace(NON_ALPHANUMERIC_REGEXP, function (match: string) {\n      return '&#' + match.charCodeAt(0) + ';';\n    })\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n}\n\nlet inertBodyHelper: InertBodyHelper;\n\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nexport function _sanitizeHtml(defaultDoc: any, unsafeHtmlInput: string): TrustedHTML | string {\n  let inertBodyElement: HTMLElement | null = null;\n  try {\n    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);\n    // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n\n    // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n    // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n    let mXSSAttempts = 5;\n    let parsedHtml = unsafeHtml;\n\n    do {\n      if (mXSSAttempts === 0) {\n        throw new Error('Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n\n      unsafeHtml = parsedHtml;\n      parsedHtml = inertBodyElement!.innerHTML;\n      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    } while (unsafeHtml !== parsedHtml);\n\n    const sanitizer = new SanitizingHtmlSerializer();\n    const safeHtml = sanitizer.sanitizeChildren(\n      (getTemplateContent(inertBodyElement!) as Element) || inertBodyElement,\n    );\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {\n      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);\n    }\n\n    return trustedHTMLFromString(safeHtml);\n  } finally {\n    // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n    if (inertBodyElement) {\n      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n      while (parent.firstChild) {\n        parent.firstChild.remove();\n      }\n    }\n  }\n}\n\nexport function getTemplateContent(el: Node): Node | null {\n  return 'content' in (el as any) /** Microsoft/TypeScript#21517 */ && isTemplateElement(el)\n    ? el.content\n    : null;\n}\nfunction isTemplateElement(el: Node): el is HTMLTemplateElement {\n  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n"]}