{"version":3,"file":"model.js","sourceRoot":"","sources":["model.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,wBAAwB,EAAC,MAAM,UAAU,CAAC;AAClD,OAAO,EAAC,oBAAoB,EAAC,MAAM,4BAA4B,CAAC;AAEhE,OAAO,EAAC,iBAAiB,EAA4B,MAAM,gBAAgB,CAAC;AAE5E,MAAM,UAAU,aAAa,CAC3B,YAAgB,EAChB,IAAmB;IAEnB,SAAS,IAAI,wBAAwB,CAAC,KAAK,CAAC,CAAC;IAE7C,OAAO,iBAAiB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;AAC/C,CAAC;AAED,MAAM,UAAU,qBAAqB,CAAI,IAAmB;IAC1D,SAAS,IAAI,wBAAwB,CAAC,KAAK,CAAC,CAAC;IAE7C,OAAO,iBAAiB,CAAC,oBAAyB,EAAE,IAAI,CAAC,CAAC;AAC5D,CAAC;AAiCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8CG;AACH,MAAM,CAAC,MAAM,KAAK,GAAkB,CAAC,GAAG,EAAE;IACxC,yEAAyE;IACzE,2EAA2E;IAC3E,8EAA8E;IAC7E,aAAqB,CAAC,QAAQ,GAAG,qBAAqB,CAAC;IACxD,OAAO,aAAgF,CAAC;AAC1F,CAAC,CAAC,EAAE,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext} from '../../di';\nimport {REQUIRED_UNSET_VALUE} from '../input/input_signal_node';\n\nimport {createModelSignal, ModelOptions, ModelSignal} from './model_signal';\n\nexport function modelFunction<T>(\n  initialValue?: T,\n  opts?: ModelOptions,\n): ModelSignal<T | undefined> {\n  ngDevMode && assertInInjectionContext(model);\n\n  return createModelSignal(initialValue, opts);\n}\n\nexport function modelRequiredFunction<T>(opts?: ModelOptions): ModelSignal<T> {\n  ngDevMode && assertInInjectionContext(model);\n\n  return createModelSignal(REQUIRED_UNSET_VALUE as T, opts);\n}\n\n/**\n * `model` declares a writeable signal that is exposed as an input/output pair on the containing\n * directive. The input name is taken either from the class member or from the `alias` option.\n * The output name is generated by taking the input name and appending `Change`.\n *\n * The function exposes an API for also declaring required models via the\n * `model.required` function.\n *\n * @publicAPI\n * @docsPrivate Ignored because `model` is the canonical API entry.\n */\nexport interface ModelFunction {\n  /**\n   * Initializes a model of type `T` with an initial value of `undefined`.\n   * Angular will implicitly use `undefined` as initial value.\n   */\n  <T>(): ModelSignal<T | undefined>;\n  /** Initializes a model of type `T` with the given initial value. */\n  <T>(initialValue: T, opts?: ModelOptions): ModelSignal<T>;\n\n  required: {\n    /**\n     * Initializes a required model.\n     *\n     * Users of your directive/component need to bind to the input side of the model.\n     * If unset, a compile time error will be reported.\n     */\n    <T>(opts?: ModelOptions): ModelSignal<T>;\n  };\n}\n\n/**\n * `model` declares a writeable signal that is exposed as an input/output\n * pair on the containing directive.\n *\n * The input name is taken either from the class member or from the `alias` option.\n * The output name is generated by taking the input name and appending `Change`.\n *\n * @usageNotes\n *\n * To use `model()`, import the function from `@angular/core`.\n *\n * ```ts\n * import {model} from '@angular/core';\n * ```\n *\n * Inside your component, introduce a new class member and initialize\n * it with a call to `model` or `model.required`.\n *\n * ```ts\n * @Directive({\n *   ...\n * })\n * export class MyDir {\n *   firstName = model<string>();            // ModelSignal<string|undefined>\n *   lastName  = model.required<string>();   // ModelSignal<string>\n *   age       = model(0);                   // ModelSignal<number>\n * }\n * ```\n *\n * Inside your component template, you can display the value of a `model`\n * by calling the signal.\n *\n * ```html\n * <span>{{firstName()}}</span>\n * ```\n *\n * Updating the `model` is equivalent to updating a writable signal.\n *\n * ```ts\n * updateName(newFirstName: string): void {\n *   this.firstName.set(newFirstName);\n * }\n * ```\n *\n * @publicApi 19.0\n * @initializerApiFunction\n */\nexport const model: ModelFunction = (() => {\n  // Note: This may be considered a side-effect, but nothing will depend on\n  // this assignment, unless this `model` constant export is accessed. It's a\n  // self-contained side effect that is local to the user facing `model` export.\n  (modelFunction as any).required = modelRequiredFunction;\n  return modelFunction as typeof modelFunction & {required: typeof modelRequiredFunction};\n})();\n"]}