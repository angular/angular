{"version":3,"file":"model_signal.js","sourceRoot":"","sources":["model_signal.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,gBAAgB,EAAE,MAAM,EAAE,WAAW,EAAC,MAAM,6BAA6B,CAAC;AAElF,OAAO,EAAC,YAAY,EAAmB,MAAM,cAAc,CAAC;AAE5D,OAAO,EACL,kBAAkB,GAGnB,MAAM,iCAAiC,CAAC;AAMzC,OAAO,EAAC,iBAAiB,EAAmB,oBAAoB,EAAC,MAAM,4BAA4B,CAAC;AACpG,OAAO,EAAC,gBAAgB,EAAC,MAAM,8BAA8B,CAAC;AAiC9D;;;;;;GAMG;AACH,MAAM,UAAU,iBAAiB,CAAI,YAAe,EAAE,IAAmB;IACvE,MAAM,IAAI,GAA0B,MAAM,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;IACrE,MAAM,UAAU,GAAG,IAAI,gBAAgB,EAAK,CAAC;IAE7C,IAAI,CAAC,KAAK,GAAG,YAAY,CAAC;IAE1B,SAAS,MAAM;QACb,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACvB,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC3B,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;IACtB,MAAM,CAAC,UAAU,GAAG,kBAAkB,CAAC,IAAI,CAAC,MAAa,CAAoB,CAAC;IAE9E,kEAAkE;IAClE,MAAM,CAAC,GAAG,GAAG,CAAC,QAAW,EAAE,EAAE;QAC3B,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,EAAE,CAAC;YACtC,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;YAC5B,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC5B,CAAC;IACH,CAAC,CAAC;IAEF,MAAM,CAAC,MAAM,GAAG,CAAC,QAAyB,EAAE,EAAE;QAC5C,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC3B,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IACnC,CAAC,CAAC;IAEF,MAAM,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACzD,MAAM,CAAC,UAAU,GAAG,UAAU,CAAC,UAAU,CAAC;IAE1C,IAAI,SAAS,EAAE,CAAC;QACd,MAAM,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,kBAAkB,MAAM,EAAE,GAAG,CAAC;QACtD,IAAI,CAAC,SAAS,GAAG,IAAI,EAAE,SAAS,CAAC;IACnC,CAAC;IAED,OAAO,MAMJ,CAAC;AACN,CAAC;AAED,2CAA2C;AAC3C,SAAS,cAAc,CAAC,KAAc;IACpC,IAAI,KAAK,KAAK,oBAAoB,EAAE,CAAC;QACnC,MAAM,IAAI,YAAY,qDAEpB,SAAS,IAAI,kDAAkD,CAChE,CAAC;IACJ,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {producerAccessed, SIGNAL, signalSetFn} from '../../../primitives/signals';\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Signal} from '../../render3/reactivity/api';\nimport {\n  signalAsReadonlyFn,\n  WritableSignal,\n  ɵWRITABLE_SIGNAL,\n} from '../../render3/reactivity/signal';\nimport {\n  InputSignal,\n  ɵINPUT_SIGNAL_BRAND_READ_TYPE,\n  ɵINPUT_SIGNAL_BRAND_WRITE_TYPE,\n} from '../input/input_signal';\nimport {INPUT_SIGNAL_NODE, InputSignalNode, REQUIRED_UNSET_VALUE} from '../input/input_signal_node';\nimport {OutputEmitterRef} from '../output/output_emitter_ref';\nimport {OutputRef} from '../output/output_ref';\n\n/**\n * @publicAPI\n *\n * Options for model signals.\n */\nexport interface ModelOptions {\n  /**\n   * Optional public name of the input side of the model. The output side will have the same\n   * name as the input, but suffixed with `Change`. By default, the class field name is used.\n   */\n  alias?: string;\n\n  /**\n   * A debug name for the model signal. Used in Angular DevTools to identify the signal.\n   */\n  debugName?: string;\n}\n\n/**\n * `ModelSignal` represents a special `Signal` for a directive/component model field.\n *\n * A model signal is a writeable signal that can be exposed as an output.\n * Whenever its value is updated, it emits to the output.\n *\n * @publicAPI\n */\nexport interface ModelSignal<T> extends WritableSignal<T>, InputSignal<T>, OutputRef<T> {\n  [SIGNAL]: InputSignalNode<T, T>;\n}\n\n/**\n * Creates a model signal.\n *\n * @param initialValue The initial value.\n *   Can be set to {@link REQUIRED_UNSET_VALUE} for required model signals.\n * @param options Additional options for the model.\n */\nexport function createModelSignal<T>(initialValue: T, opts?: ModelOptions): ModelSignal<T> {\n  const node: InputSignalNode<T, T> = Object.create(INPUT_SIGNAL_NODE);\n  const emitterRef = new OutputEmitterRef<T>();\n\n  node.value = initialValue;\n\n  function getter(): T {\n    producerAccessed(node);\n    assertModelSet(node.value);\n    return node.value;\n  }\n\n  getter[SIGNAL] = node;\n  getter.asReadonly = signalAsReadonlyFn.bind(getter as any) as () => Signal<T>;\n\n  // TODO: Should we throw an error when updating a destroyed model?\n  getter.set = (newValue: T) => {\n    if (!node.equal(node.value, newValue)) {\n      signalSetFn(node, newValue);\n      emitterRef.emit(newValue);\n    }\n  };\n\n  getter.update = (updateFn: (value: T) => T) => {\n    assertModelSet(node.value);\n    getter.set(updateFn(node.value));\n  };\n\n  getter.subscribe = emitterRef.subscribe.bind(emitterRef);\n  getter.destroyRef = emitterRef.destroyRef;\n\n  if (ngDevMode) {\n    getter.toString = () => `[Model Signal: ${getter()}]`;\n    node.debugName = opts?.debugName;\n  }\n\n  return getter as typeof getter &\n    Pick<\n      ModelSignal<T>,\n      | typeof ɵINPUT_SIGNAL_BRAND_READ_TYPE\n      | typeof ɵINPUT_SIGNAL_BRAND_WRITE_TYPE\n      | typeof ɵWRITABLE_SIGNAL\n    >;\n}\n\n/** Asserts that a model's value is set. */\nfunction assertModelSet(value: unknown): void {\n  if (value === REQUIRED_UNSET_VALUE) {\n    throw new RuntimeError(\n      RuntimeErrorCode.REQUIRED_MODEL_NO_VALUE,\n      ngDevMode && 'Model is required but no value is available yet.',\n    );\n  }\n}\n"]}