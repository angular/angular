{"version":3,"file":"input_signal.js","sourceRoot":"","sources":["input_signal.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,gBAAgB,EAAE,MAAM,EAAC,MAAM,6BAA6B,CAAC;AAErE,OAAO,EAAC,YAAY,EAAmB,MAAM,cAAc,CAAC;AAG5D,OAAO,EAAC,iBAAiB,EAAmB,oBAAoB,EAAC,MAAM,qBAAqB,CAAC;AA8C7F,MAAM,CAAC,MAAM,6BAA6B,GAAkB,eAAe,CAAC,MAAM,EAAE,CAAC;AACrF,MAAM,CAAC,MAAM,8BAA8B,GAAkB,eAAe,CAAC,MAAM,EAAE,CAAC;AA6CtF;;;;;;GAMG;AACH,MAAM,UAAU,iBAAiB,CAC/B,YAAe,EACf,OAAqC;IAErC,MAAM,IAAI,GAAmC,MAAM,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;IAE9E,IAAI,CAAC,KAAK,GAAG,YAAY,CAAC;IAE1B,wEAAwE;IACxE,4EAA4E;IAC5E,IAAI,CAAC,WAAW,GAAG,OAAO,EAAE,SAAS,CAAC;IAEtC,SAAS,YAAY;QACnB,6CAA6C;QAC7C,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAEvB,IAAI,IAAI,CAAC,KAAK,KAAK,oBAAoB,EAAE,CAAC;YACxC,IAAI,OAAO,GAAkB,IAAI,CAAC;YAClC,IAAI,SAAS,EAAE,CAAC;gBACd,MAAM,IAAI,GAAG,OAAO,EAAE,SAAS,IAAI,OAAO,EAAE,KAAK,CAAC;gBAClD,OAAO,GAAG,QAAQ,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE,6CAA6C,CAAC;YAC1F,CAAC;YACD,MAAM,IAAI,YAAY,sDAA2C,OAAO,CAAC,CAAC;QAC5E,CAAC;QAED,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAEA,YAAoB,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;IAErC,IAAI,SAAS,EAAE,CAAC;QACd,YAAY,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,kBAAkB,YAAY,EAAE,GAAG,CAAC;QAClE,IAAI,CAAC,SAAS,GAAG,OAAO,EAAE,SAAS,CAAC;IACtC,CAAC;IAED,OAAO,YAAuD,CAAC;AACjE,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {producerAccessed, SIGNAL} from '../../../primitives/signals';\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Signal} from '../../render3/reactivity/api';\n\nimport {INPUT_SIGNAL_NODE, InputSignalNode, REQUIRED_UNSET_VALUE} from './input_signal_node';\n\n/**\n * @publicAPI\n *\n * Options for signal inputs.\n */\nexport interface InputOptions<T, TransformT> {\n  /** Optional public name for the input. By default, the class field name is used. */\n  alias?: string;\n  /**\n   * Optional transform that runs whenever a new value is bound. Can be used to\n   * transform the input value before the input is updated.\n   *\n   * The transform function can widen the type of the input. For example, consider\n   * an input for `disabled`. In practice, as the component author, you want to only\n   * deal with a boolean, but users may want to bind a string if they just use the\n   * attribute form to bind to the input via `<my-dir input>`. A transform can then\n   * handle such string values and convert them to `boolean`. See: {@link booleanAttribute}.\n   */\n  transform?: (v: TransformT) => T;\n\n  /**\n   * A debug name for the input signal. Used in Angular DevTools to identify the signal.\n   */\n  debugName?: string;\n}\n\n/**\n * Signal input options without the transform option.\n *\n * @publicApi 19.0\n */\nexport type InputOptionsWithoutTransform<T> =\n  // Note: We still keep a notion of `transform` for auto-completion.\n  Omit<InputOptions<T, T>, 'transform'> & {transform?: undefined};\n/**\n * Signal input options with the transform option required.\n *\n * @publicAPI\n */\nexport type InputOptionsWithTransform<T, TransformT> = Required<\n  Pick<InputOptions<T, TransformT>, 'transform'>\n> &\n  InputOptions<T, TransformT>;\n\nexport const ɵINPUT_SIGNAL_BRAND_READ_TYPE: unique symbol = /* @__PURE__ */ Symbol();\nexport const ɵINPUT_SIGNAL_BRAND_WRITE_TYPE: unique symbol = /* @__PURE__ */ Symbol();\n\n/**\n * `InputSignalWithTransform` represents a special `Signal` for a\n * directive/component input with a `transform` function.\n *\n * Signal inputs with transforms capture an extra generic for their transform write\n * type. Transforms can expand the accepted bound values for an input while ensuring\n * value retrievals of the signal input are still matching the generic input type.\n *\n * ```ts\n * class MyDir {\n *   disabled = input(false, {\n *     transform: (v: string|boolean) => convertToBoolean(v),\n *   }); // InputSignalWithTransform<boolean, string|boolean>\n *\n *   click() {\n *     this.disabled() // always returns a `boolean`.\n *   }\n * }\n * ```\n *\n * @see {@link InputSignal} for additional information.\n *\n * @publicApi 19.0\n */\nexport interface InputSignalWithTransform<T, TransformT> extends Signal<T> {\n  [SIGNAL]: InputSignalNode<T, TransformT>;\n  [ɵINPUT_SIGNAL_BRAND_READ_TYPE]: T;\n  [ɵINPUT_SIGNAL_BRAND_WRITE_TYPE]: TransformT;\n}\n\n/**\n * `InputSignal` represents a special `Signal` for a directive/component input.\n *\n * An input signal is similar to a non-writable signal except that it also\n * carries additional type-information for transforms, and that Angular internally\n * updates the signal whenever a new value is bound.\n *\n * @see {@link InputOptionsWithTransform} for inputs with transforms.\n *\n * @publicApi 19.0\n */\nexport interface InputSignal<T> extends InputSignalWithTransform<T, T> {}\n\n/**\n * Creates an input signal.\n *\n * @param initialValue The initial value.\n *   Can be set to {@link REQUIRED_UNSET_VALUE} for required inputs.\n * @param options Additional options for the input. e.g. a transform, or an alias.\n */\nexport function createInputSignal<T, TransformT>(\n  initialValue: T,\n  options?: InputOptions<T, TransformT>,\n): InputSignalWithTransform<T, TransformT> {\n  const node: InputSignalNode<T, TransformT> = Object.create(INPUT_SIGNAL_NODE);\n\n  node.value = initialValue;\n\n  // Perf note: Always set `transformFn` here to ensure that `node` always\n  // has the same v8 class shape, allowing monomorphic reads on input signals.\n  node.transformFn = options?.transform;\n\n  function inputValueFn() {\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n\n    if (node.value === REQUIRED_UNSET_VALUE) {\n      let message: string | null = null;\n      if (ngDevMode) {\n        const name = options?.debugName ?? options?.alias;\n        message = `Input${name ? ` \"${name}\"` : ''} is required but no value is available yet.`;\n      }\n      throw new RuntimeError(RuntimeErrorCode.REQUIRED_INPUT_NO_VALUE, message);\n    }\n\n    return node.value;\n  }\n\n  (inputValueFn as any)[SIGNAL] = node;\n\n  if (ngDevMode) {\n    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;\n    node.debugName = options?.debugName;\n  }\n\n  return inputValueFn as InputSignalWithTransform<T, TransformT>;\n}\n"]}