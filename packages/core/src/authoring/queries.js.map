{"version":3,"file":"queries.js","sourceRoot":"","sources":["queries.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,wBAAwB,EAAC,MAAM,OAAO,CAAC;AAE/C,OAAO,EACL,8BAA8B,EAC9B,uCAAuC,EACvC,uCAAuC,GACxC,MAAM,mCAAmC,CAAC;AAG3C,SAAS,WAAW,CAClB,OAAyC,EACzC,IAAwD;IAExD,SAAS,IAAI,wBAAwB,CAAC,SAAS,CAAC,CAAC;IACjD,OAAO,uCAAuC,CAAQ,IAAI,CAAC,CAAC;AAC9D,CAAC;AAED,SAAS,mBAAmB,CAC1B,OAAyC,EACzC,IAAwD;IAExD,SAAS,IAAI,wBAAwB,CAAC,SAAS,CAAC,CAAC;IACjD,OAAO,uCAAuC,CAAQ,IAAI,CAAC,CAAC;AAC9D,CAAC;AAyDD;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,MAAM,CAAC,MAAM,SAAS,GAAsB,CAAC,GAAG,EAAE;IAChD,yEAAyE;IACzE,+EAA+E;IAC/E,kFAAkF;IACjF,WAAmB,CAAC,QAAQ,GAAG,mBAAmB,CAAC;IACpD,OAAO,WAA0E,CAAC;AACpF,CAAC,CAAC,EAAE,CAAC;AAcL;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,UAAU,YAAY,CAC1B,OAAyC,EACzC,IAGC;IAED,SAAS,IAAI,wBAAwB,CAAC,YAAY,CAAC,CAAC;IACpD,OAAO,8BAA8B,CAAQ,IAAI,CAAC,CAAC;AACrD,CAAC;AAED,MAAM,UAAU,cAAc,CAC5B,OAAyC,EACzC,IAIC;IAED,SAAS,IAAI,wBAAwB,CAAC,YAAY,CAAC,CAAC;IACpD,OAAO,uCAAuC,CAAQ,IAAI,CAAC,CAAC;AAC9D,CAAC;AAED,SAAS,sBAAsB,CAC7B,OAAyC,EACzC,IAIC;IAED,SAAS,IAAI,wBAAwB,CAAC,eAAe,CAAC,CAAC;IACvD,OAAO,uCAAuC,CAAQ,IAAI,CAAC,CAAC;AAC9D,CAAC;AA4DD;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,MAAM,CAAC,MAAM,YAAY,GAAyB,CAAC,GAAG,EAAE;IACtD,yEAAyE;IACzE,+EAA+E;IAC/E,kFAAkF;IACjF,cAAsB,CAAC,QAAQ,GAAG,sBAAsB,CAAC;IAC1D,OAAO,cAAmF,CAAC;AAC7F,CAAC,CAAC,EAAE,CAAC;AAmBL;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,MAAM,UAAU,eAAe,CAC7B,OAAyC,EACzC,IAIC;IAED,OAAO,8BAA8B,CAAQ,IAAI,CAAC,CAAC;AACrD,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext} from '../di';\nimport {ProviderToken} from '../di/provider_token';\nimport {\n  createMultiResultQuerySignalFn,\n  createSingleResultOptionalQuerySignalFn,\n  createSingleResultRequiredQuerySignalFn,\n} from '../render3/queries/query_reactive';\nimport {Signal} from '../render3/reactivity/api';\n\nfunction viewChildFn<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {read?: ProviderToken<ReadT>; debugName?: string},\n): Signal<ReadT | undefined> {\n  ngDevMode && assertInInjectionContext(viewChild);\n  return createSingleResultOptionalQuerySignalFn<ReadT>(opts);\n}\n\nfunction viewChildRequiredFn<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {read?: ProviderToken<ReadT>; debugName?: string},\n): Signal<ReadT> {\n  ngDevMode && assertInInjectionContext(viewChild);\n  return createSingleResultRequiredQuerySignalFn<ReadT>(opts);\n}\n\n/**\n * Type of the `viewChild` function. The viewChild function creates a singular view query.\n *\n * It is a special function that also provides access to required query results via the `.required`\n * property.\n *\n * @publicApi\n * @docsPrivate Ignored because `viewChild` is the canonical API entry.\n */\nexport interface ViewChildFunction {\n  /**\n   * Initializes a view child query. Consider using `viewChild.required` for queries that should\n   * always match.\n   *\n   * @publicAPI\n   */\n\n  <LocatorT, ReadT>(\n    locator: ProviderToken<LocatorT> | string,\n    opts: {\n      read: ProviderToken<ReadT>;\n      debugName?: string;\n    },\n  ): Signal<ReadT | undefined>;\n\n  <LocatorT>(\n    locator: ProviderToken<LocatorT> | string,\n    opts?: {\n      debugName?: string;\n    },\n  ): Signal<LocatorT | undefined>;\n\n  /**\n   * Initializes a view child query that is expected to always match an element.\n   *\n   * @publicAPI\n   */\n  required: {\n    <LocatorT>(\n      locator: ProviderToken<LocatorT> | string,\n      opts?: {\n        debugName?: string;\n      },\n    ): Signal<LocatorT>;\n\n    <LocatorT, ReadT>(\n      locator: ProviderToken<LocatorT> | string,\n      opts: {\n        read: ProviderToken<ReadT>;\n        debugName?: string;\n      },\n    ): Signal<ReadT>;\n  };\n}\n\n/**\n * Initializes a view child query.\n *\n * Consider using `viewChild.required` for queries that should always match.\n *\n * @usageNotes\n * Create a child query in your component by declaring a\n * class field and initializing it with the `viewChild()` function.\n *\n * ```angular-ts\n * @Component({template: '<div #el></div><my-component #cmp />'})\n * export class TestComponent {\n *   divEl = viewChild<ElementRef>('el');                   // Signal<ElementRef|undefined>\n *   divElRequired = viewChild.required<ElementRef>('el');  // Signal<ElementRef>\n *   cmp = viewChild(MyComponent);                          // Signal<MyComponent|undefined>\n *   cmpRequired = viewChild.required(MyComponent);         // Signal<MyComponent>\n * }\n * ```\n *\n * @publicApi 19.0\n * @initializerApiFunction\n */\nexport const viewChild: ViewChildFunction = (() => {\n  // Note: This may be considered a side-effect, but nothing will depend on\n  // this assignment, unless this `viewChild` constant export is accessed. It's a\n  // self-contained side effect that is local to the user facing `viewChild` export.\n  (viewChildFn as any).required = viewChildRequiredFn;\n  return viewChildFn as typeof viewChildFn & {required: typeof viewChildRequiredFn};\n})();\n\nexport function viewChildren<LocatorT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {debugName?: string},\n): Signal<ReadonlyArray<LocatorT>>;\nexport function viewChildren<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts: {\n    read: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<ReadT>>;\n\n/**\n * Initializes a view children query.\n *\n * Query results are represented as a signal of a read-only collection containing all matched\n * elements.\n *\n * @usageNotes\n * Create a children query in your component by declaring a\n * class field and initializing it with the `viewChildren()` function.\n *\n * ```ts\n * @Component({...})\n * export class TestComponent {\n *   divEls = viewChildren<ElementRef>('el');   // Signal<ReadonlyArray<ElementRef>>\n * }\n * ```\n *\n * @initializerApiFunction\n * @publicApi 19.0\n */\nexport function viewChildren<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    read?: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<ReadT>> {\n  ngDevMode && assertInInjectionContext(viewChildren);\n  return createMultiResultQuerySignalFn<ReadT>(opts);\n}\n\nexport function contentChildFn<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    descendants?: boolean;\n    read?: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadT | undefined> {\n  ngDevMode && assertInInjectionContext(contentChild);\n  return createSingleResultOptionalQuerySignalFn<ReadT>(opts);\n}\n\nfunction contentChildRequiredFn<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    descendants?: boolean;\n    read?: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadT> {\n  ngDevMode && assertInInjectionContext(contentChildren);\n  return createSingleResultRequiredQuerySignalFn<ReadT>(opts);\n}\n\n/**\n * Type of the `contentChild` function.\n *\n * The contentChild function creates a singular content query. It is a special function that also\n * provides access to required query results via the `.required` property.\n *\n * @publicApi 19.0\n * @docsPrivate Ignored because `contentChild` is the canonical API entry.\n */\nexport interface ContentChildFunction {\n  /**\n   * Initializes a content child query.\n   *\n   * Consider using `contentChild.required` for queries that should always match.\n   * @publicAPI\n   */\n  <LocatorT>(\n    locator: ProviderToken<LocatorT> | string,\n    opts?: {\n      descendants?: boolean;\n      read?: undefined;\n      debugName?: string;\n    },\n  ): Signal<LocatorT | undefined>;\n\n  <LocatorT, ReadT>(\n    locator: ProviderToken<LocatorT> | string,\n    opts: {\n      descendants?: boolean;\n      read: ProviderToken<ReadT>;\n      debugName?: string;\n    },\n  ): Signal<ReadT | undefined>;\n\n  /**\n   * Initializes a content child query that is always expected to match.\n   */\n  required: {\n    <LocatorT>(\n      locator: ProviderToken<LocatorT> | string,\n      opts?: {\n        descendants?: boolean;\n        read?: undefined;\n        debugName?: string;\n      },\n    ): Signal<LocatorT>;\n\n    <LocatorT, ReadT>(\n      locator: ProviderToken<LocatorT> | string,\n      opts: {\n        descendants?: boolean;\n        read: ProviderToken<ReadT>;\n        debugName?: string;\n      },\n    ): Signal<ReadT>;\n  };\n}\n\n/**\n * Initializes a content child query. Consider using `contentChild.required` for queries that should\n * always match.\n *\n * @usageNotes\n * Create a child query in your component by declaring a\n * class field and initializing it with the `contentChild()` function.\n *\n * ```ts\n * @Component({...})\n * export class TestComponent {\n *   headerEl = contentChild<ElementRef>('h');                    // Signal<ElementRef|undefined>\n *   headerElElRequired = contentChild.required<ElementRef>('h'); // Signal<ElementRef>\n *   header = contentChild(MyHeader);                             // Signal<MyHeader|undefined>\n *   headerRequired = contentChild.required(MyHeader);            // Signal<MyHeader>\n * }\n * ```\n *\n * Note: By default `descendants` is `true` which means the query will traverse all descendants in the same template.\n *\n * @initializerApiFunction\n * @publicApi 19.0\n */\nexport const contentChild: ContentChildFunction = (() => {\n  // Note: This may be considered a side-effect, but nothing will depend on\n  // this assignment, unless this `viewChild` constant export is accessed. It's a\n  // self-contained side effect that is local to the user facing `viewChild` export.\n  (contentChildFn as any).required = contentChildRequiredFn;\n  return contentChildFn as typeof contentChildFn & {required: typeof contentChildRequiredFn};\n})();\n\nexport function contentChildren<LocatorT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    descendants?: boolean;\n    read?: undefined;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<LocatorT>>;\nexport function contentChildren<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts: {\n    descendants?: boolean;\n    read: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<ReadT>>;\n\n/**\n * Initializes a content children query.\n *\n * Query results are represented as a signal of a read-only collection containing all matched\n * elements.\n *\n * @usageNotes\n * Create a children query in your component by declaring a\n * class field and initializing it with the `contentChildren()` function.\n *\n * ```ts\n * @Component({...})\n * export class TestComponent {\n *   headerEl = contentChildren<ElementRef>('h');   // Signal<ReadonlyArray<ElementRef>>\n * }\n * ```\n *\n * Note: By default `descendants` is `false` which means the query will not traverse all descendants in the same template.\n *\n * @initializerApiFunction\n * @publicApi 19.0\n */\nexport function contentChildren<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    descendants?: boolean;\n    read?: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<ReadT>> {\n  return createMultiResultQuerySignalFn<ReadT>(opts);\n}\n"]}