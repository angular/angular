{"version":3,"file":"interfaces.js","sourceRoot":"","sources":["interfaces.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AA4CH;;GAEG;AACH,MAAM,CAAN,IAAY,6BAYX;AAZD,WAAY,6BAA6B;IACvC,6DAA6D;IAC7D,+FAAW,CAAA;IAEX,wCAAwC;IACxC,+FAAW,CAAA;IAEX,oDAAoD;IACpD,yFAAQ,CAAA;IAER,oCAAoC;IACpC,qFAAM,CAAA;AACR,CAAC,EAZW,6BAA6B,KAA7B,6BAA6B,QAYxC;AAED,4DAA4D;AAC5D,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,CAAC;AAE9B,0DAA0D;AAC1D,MAAM,CAAC,MAAM,kBAAkB,GAAG,CAAC,CAAC;AAqGpC;;;;GAIG;AACH,MAAM,CAAN,IAAY,eAYX;AAZD,WAAY,eAAe;IACzB,gDAAgD;IAChD,mEAAe,CAAA;IAEf,4CAA4C;IAC5C,2DAAW,CAAA;IAEX,iDAAiD;IACjD,6DAAY,CAAA;IAEZ,0CAA0C;IAC1C,uDAAS,CAAA;AACX,CAAC,EAZW,eAAe,KAAf,eAAe,QAY1B;AAwBD;;;;;GAKG;AACH,MAAM,CAAN,IAAY,uBAGX;AAHD,WAAY,uBAAuB;IACjC,8CAA8C;IAC9C,4EAAY,CAAA;AACd,CAAC,EAHW,uBAAuB,KAAvB,uBAAuB,QAGlC;AAED,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAAC,CAAC;AACxC,2EAA2E;AAC3E,4EAA4E;AAC5E,6EAA6E;AAC7E,8CAA8C;AAC9C,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,CAAC;AACnC,MAAM,CAAC,MAAM,qBAAqB,GAAG,CAAC,CAAC;AACvC,MAAM,CAAC,MAAM,wBAAwB,GAAG,CAAC,CAAC;AAC1C,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,CAAC;AACrC,MAAM,CAAC,MAAM,4BAA4B,GAAG,CAAC,CAAC;AAC9C,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,CAAC;AAC/B,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,CAAC;AACjC,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,CAAC;AACjC,MAAM,CAAC,MAAM,2BAA2B,GAAG,CAAC,CAAC;AAuE7C;;;GAGG;AACH,MAAM,CAAN,IAAY,kBAYX;AAZD,WAAY,kBAAkB;IAC5B;;;OAGG;IACH,+DAAM,CAAA;IAEN;;;OAGG;IACH,yEAAW,CAAA;AACb,CAAC,EAZW,kBAAkB,KAAlB,kBAAkB,QAY7B","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {Provider} from '../di/interface/provider';\nimport type {LContainer} from '../render3/interfaces/container';\nimport type {DependencyType} from '../render3/interfaces/definition';\nimport type {TNode} from '../render3/interfaces/node';\nimport type {LView} from '../render3/interfaces/view';\n\n/**\n * Basic set of data structures used for identifying a defer block\n * and triggering defer blocks\n */\nexport interface DehydratedDeferBlock {\n  lView: LView;\n  tNode: TNode;\n  lContainer: LContainer;\n}\n\n/**\n * Describes the shape of a function generated by the compiler\n * to download dependencies that can be defer-loaded.\n */\nexport type DependencyResolverFn = () => Array<Promise<DependencyType>>;\n\n/**\n * Defines types of defer block triggers.\n */\nexport const enum TriggerType {\n  /**\n   * Represents regular triggers (e.g. `@defer (on idle) { ... }`).\n   */\n  Regular,\n\n  /**\n   * Represents prefetch triggers (e.g. `@defer (prefetch on idle) { ... }`).\n   */\n  Prefetch,\n\n  /**\n   * Represents hydrate triggers (e.g. `@defer (hydrate on idle) { ... }`).\n   */\n  Hydrate,\n}\n\n/**\n * Describes the state of defer block dependency loading.\n */\nexport enum DeferDependenciesLoadingState {\n  /** Initial state, dependency loading is not yet triggered */\n  NOT_STARTED,\n\n  /** Dependency loading is in progress */\n  IN_PROGRESS,\n\n  /** Dependency loading has completed successfully */\n  COMPLETE,\n\n  /** Dependency loading has failed */\n  FAILED,\n}\n\n/** Slot index where `minimum` parameter value is stored. */\nexport const MINIMUM_SLOT = 0;\n\n/** Slot index where `after` parameter value is stored. */\nexport const LOADING_AFTER_SLOT = 1;\n\n/** Configuration object for a loading block as it is stored in the component constants. */\nexport type DeferredLoadingBlockConfig = [minimumTime: number | null, afterTime: number | null];\n\n/** Configuration object for a placeholder block as it is stored in the component constants. */\nexport type DeferredPlaceholderBlockConfig = [minimumTime: number | null];\n\n/**\n * Describes the data shared across all instances of a defer block.\n */\nexport interface TDeferBlockDetails {\n  /**\n   * Index in an LView and TData arrays where a template for the primary content\n   * can be found.\n   */\n  primaryTmplIndex: number;\n\n  /**\n   * Index in an LView and TData arrays where a template for the loading block can be found.\n   */\n  loadingTmplIndex: number | null;\n\n  /**\n   * Extra configuration parameters (such as `after` and `minimum`) for the loading block.\n   */\n  loadingBlockConfig: DeferredLoadingBlockConfig | null;\n\n  /**\n   * Index in an LView and TData arrays where a template for the placeholder block can be found.\n   */\n  placeholderTmplIndex: number | null;\n\n  /**\n   * Extra configuration parameters (such as `after` and `minimum`) for the placeholder block.\n   */\n  placeholderBlockConfig: DeferredPlaceholderBlockConfig | null;\n\n  /**\n   * Index in an LView and TData arrays where a template for the error block can be found.\n   */\n  errorTmplIndex: number | null;\n\n  /**\n   * Compiler-generated function that loads all dependencies for a defer block.\n   */\n  dependencyResolverFn: DependencyResolverFn | null;\n\n  /**\n   * Keeps track of the current loading state of defer block dependencies.\n   */\n  loadingState: DeferDependenciesLoadingState;\n\n  /**\n   * Dependency loading Promise. This Promise is helpful for cases when there\n   * are multiple instances of a defer block (e.g. if it was used inside of an *ngFor),\n   * which all await the same set of dependencies.\n   */\n  loadingPromise: Promise<unknown> | null;\n\n  /**\n   * List of providers collected from all NgModules that were imported by\n   * standalone components used within this defer block.\n   */\n  providers: Provider[] | null;\n\n  /**\n   * List of hydrate triggers for a given block\n   */\n  hydrateTriggers: Map<DeferBlockTrigger, HydrateTriggerDetails | null> | null;\n\n  /**\n   * Defer block flags, which should be used for all\n   * instances of a given defer block (the flags that should be\n   * placed into the `TDeferDetails` at runtime).\n   */\n  flags: TDeferDetailsFlags;\n\n  /**\n   * Tracks debugging information about the deferred block.\n   */\n  debug: {\n    /** Text representations of the block's triggers. */\n    triggers?: Set<string>;\n  } | null;\n}\n\n/**\n * Specifies defer block flags, which should be used for all\n * instances of a given defer block (the flags that should be\n * placed into the `TDeferDetails` at runtime).\n */\nexport const enum TDeferDetailsFlags {\n  Default = 0,\n\n  /**\n   * Whether or not the defer block has hydrate triggers.\n   */\n  HasHydrateTriggers = 1 << 0,\n}\n\n/**\n * Describes the current state of this defer block instance.\n *\n * @publicApi\n */\nexport enum DeferBlockState {\n  /** The placeholder block content is rendered */\n  Placeholder = 0,\n\n  /** The loading block content is rendered */\n  Loading = 1,\n\n  /** The main content block content is rendered */\n  Complete = 2,\n\n  /** The error block content is rendered */\n  Error = 3,\n}\n\n/**\n * Represents defer trigger types.\n */\nexport const enum DeferBlockTrigger {\n  Idle,\n  Immediate,\n  Viewport,\n  Interaction,\n  Hover,\n  Timer,\n  When,\n  Never,\n}\n\n/** * Describes specified delay (in ms) in the `hydrate on timer()` trigger. */\nexport interface HydrateTimerTriggerDetails {\n  delay: number;\n}\n\n/** * Describes all possible hydration trigger details specified in a template. */\nexport type HydrateTriggerDetails = HydrateTimerTriggerDetails;\n\n/**\n * Describes the initial state of this defer block instance.\n *\n * Note: this state is internal only and *must* be represented\n * with a number lower than any value in the `DeferBlockState` enum.\n */\nexport enum DeferBlockInternalState {\n  /** Initial state. Nothing is rendered yet. */\n  Initial = -1,\n}\n\nexport const NEXT_DEFER_BLOCK_STATE = 0;\n// Note: it's *important* to keep the state in this slot, because this slot\n// is used by runtime logic to differentiate between LViews, LContainers and\n// other types (see `isLView` and `isLContainer` functions). In case of defer\n// blocks, this slot would always be a number.\nexport const DEFER_BLOCK_STATE = 1;\nexport const STATE_IS_FROZEN_UNTIL = 2;\nexport const LOADING_AFTER_CLEANUP_FN = 3;\nexport const TRIGGER_CLEANUP_FNS = 4;\nexport const PREFETCH_TRIGGER_CLEANUP_FNS = 5;\nexport const SSR_UNIQUE_ID = 6;\nexport const SSR_BLOCK_STATE = 7;\nexport const ON_COMPLETE_FNS = 8;\nexport const HYDRATE_TRIGGER_CLEANUP_FNS = 9;\n\n/**\n * Describes instance-specific defer block data.\n *\n * Note: currently there is only the `state` slot, but more slots\n * would be added later to keep track of `after` and `maximum` features\n * (which would require per-instance state).\n */\nexport interface LDeferBlockDetails extends Array<unknown> {\n  /**\n   * Currently rendered block state.\n   */\n  [DEFER_BLOCK_STATE]: DeferBlockState | DeferBlockInternalState;\n\n  /**\n   * Block state that was requested when another state was rendered.\n   */\n  [NEXT_DEFER_BLOCK_STATE]: DeferBlockState | null;\n\n  /**\n   * Timestamp indicating when the current state can be switched to\n   * the next one, in case teh current state has `minimum` parameter.\n   */\n  [STATE_IS_FROZEN_UNTIL]: number | null;\n\n  /**\n   * Contains a reference to a cleanup function which cancels a timeout\n   * when Angular waits before rendering loading state. This is used when\n   * the loading block has the `after` parameter configured.\n   */\n  [LOADING_AFTER_CLEANUP_FN]: VoidFunction | null;\n\n  /**\n   * List of cleanup functions for regular triggers.\n   */\n  [TRIGGER_CLEANUP_FNS]: VoidFunction[] | null;\n\n  /**\n   * List of cleanup functions for prefetch triggers.\n   */\n  [PREFETCH_TRIGGER_CLEANUP_FNS]: VoidFunction[] | null;\n\n  /**\n   * Unique id of this defer block assigned during SSR.\n   */\n  [SSR_UNIQUE_ID]: string | null;\n\n  /**\n   * Defer block state after SSR.\n   */\n  [SSR_BLOCK_STATE]: number | null;\n\n  /**\n   * A set of callbacks to be invoked once the main content is rendered.\n   */\n  [ON_COMPLETE_FNS]: VoidFunction[] | null;\n\n  /**\n   * List of cleanup functions for hydrate triggers.\n   */\n  [HYDRATE_TRIGGER_CLEANUP_FNS]: VoidFunction[] | null;\n}\n\n/**\n * Internal structure used for configuration of defer block behavior.\n * */\nexport interface DeferBlockConfig {\n  behavior: DeferBlockBehavior;\n}\n\n/**\n * Options for configuring defer blocks behavior.\n * @publicApi\n */\nexport enum DeferBlockBehavior {\n  /**\n   * Manual triggering mode for defer blocks. Provides control over when defer blocks render\n   * and which state they render.\n   */\n  Manual,\n\n  /**\n   * Playthrough mode for defer blocks. This mode behaves like defer blocks would in a browser.\n   * This is the default behavior in test environments.\n   */\n  Playthrough,\n}\n\n/**\n * **INTERNAL**, avoid referencing it in application code.\n *\n * Describes a helper class that allows to intercept a call to retrieve current\n * dependency loading function and replace it with a different implementation.\n * This interceptor class is needed to allow testing blocks in different states\n * by simulating loading response.\n */\nexport interface DeferBlockDependencyInterceptor {\n  /**\n   * Invoked for each defer block when dependency loading function is accessed.\n   */\n  intercept(dependencyFn: DependencyResolverFn | null): DependencyResolverFn | null;\n\n  /**\n   * Allows to configure an interceptor function.\n   */\n  setInterceptor(interceptorFn: (current: DependencyResolverFn) => DependencyResolverFn): void;\n}\n"]}