{"version":3,"file":"dom_triggers.js","sourceRoot":"","sources":["dom_triggers.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {Injector} from '../di';\nimport {AfterRenderRef} from '../render3/after_render/api';\nimport {afterEveryRender} from '../render3/after_render/hooks';\nimport {assertLContainer, assertLView} from '../render3/assert';\nimport {CONTAINER_HEADER_OFFSET} from '../render3/interfaces/container';\nimport {TNode} from '../render3/interfaces/node';\nimport {isDestroyed} from '../render3/interfaces/type_checks';\nimport {HEADER_OFFSET, INJECTOR, LView} from '../render3/interfaces/view';\nimport {\n  getNativeByIndex,\n  removeLViewOnDestroy,\n  storeLViewOnDestroy,\n  walkUpViews,\n} from '../render3/util/view_utils';\nimport {assertElement, assertEqual} from '../util/assert';\nimport {NgZone} from '../zone';\nimport {storeTriggerCleanupFn} from './cleanup';\nimport {onViewport, createIntersectionObserver} from '../../primitives/defer/src/triggers';\nimport {\n  DEFER_BLOCK_STATE,\n  DeferBlockInternalState,\n  DeferBlockState,\n  TriggerType,\n} from './interfaces';\nimport {getLDeferBlockDetails} from './utils';\n\n/**\n * Wrapper for onViewport trigger with angular specific Injector for resolving NgZone instance\n * and creating an IntersectionObserver which can run outside of Angular zone.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger comes into the viewport.\n * @param injector Injector that can be used by the trigger to resolve DI tokens.\n */\nexport function onViewportWrapper(trigger: Element, callback: VoidFunction, injector: Injector) {\n  const ngZone = injector.get(NgZone);\n  return onViewport(\n    trigger,\n    () => ngZone.run(callback),\n    () => ngZone.runOutsideAngular(() => createIntersectionObserver()),\n  );\n}\n\n/**\n * Helper function to get the LView in which a deferred block's trigger is rendered.\n * @param deferredHostLView LView in which the deferred block is defined.\n * @param deferredTNode TNode defining the deferred block.\n * @param walkUpTimes Number of times to go up in the view hierarchy to find the trigger's view.\n *   A negative value means that the trigger is inside the block's placeholder, while an undefined\n *   value means that the trigger is in the same LView as the deferred block.\n */\nexport function getTriggerLView(\n  deferredHostLView: LView,\n  deferredTNode: TNode,\n  walkUpTimes: number | undefined,\n): LView | null {\n  // The trigger is in the same view, we don't need to traverse.\n  if (walkUpTimes == null) {\n    return deferredHostLView;\n  }\n\n  // A positive value or zero means that the trigger is in a parent view.\n  if (walkUpTimes >= 0) {\n    return walkUpViews(walkUpTimes, deferredHostLView);\n  }\n\n  // If the value is negative, it means that the trigger is inside the placeholder.\n  const deferredContainer = deferredHostLView[deferredTNode.index];\n  ngDevMode && assertLContainer(deferredContainer);\n  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;\n\n  // We need to null check, because the placeholder might not have been rendered yet.\n  if (ngDevMode && triggerLView !== null) {\n    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);\n    const renderedState = lDetails[DEFER_BLOCK_STATE];\n    assertEqual(\n      renderedState,\n      DeferBlockState.Placeholder,\n      'Expected a placeholder to be rendered in this defer block.',\n    );\n    assertLView(triggerLView);\n  }\n\n  return triggerLView;\n}\n\n/**\n * Gets the element that a deferred block's trigger is pointing to.\n * @param triggerLView LView in which the trigger is defined.\n * @param triggerIndex Index at which the trigger element should've been rendered.\n */\nexport function getTriggerElement(triggerLView: LView, triggerIndex: number): Element {\n  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);\n  ngDevMode && assertElement(element);\n  return element as Element;\n}\n\n/**\n * Registers a DOM-node based trigger.\n * @param initialLView LView in which the defer block is rendered.\n * @param tNode TNode representing the defer block.\n * @param triggerIndex Index at which to find the trigger element.\n * @param walkUpTimes Number of times to go up/down in the view hierarchy to find the trigger.\n * @param registerFn Function that will register the DOM events.\n * @param callback Callback to be invoked when the trigger receives the event that should render\n *     the deferred block.\n * @param type Trigger type to distinguish between regular and prefetch triggers.\n */\nexport function registerDomTrigger(\n  initialLView: LView,\n  tNode: TNode,\n  triggerIndex: number,\n  walkUpTimes: number | undefined,\n  registerFn: (element: Element, callback: VoidFunction, injector: Injector) => VoidFunction,\n  callback: VoidFunction,\n  type: TriggerType,\n) {\n  const injector = initialLView[INJECTOR];\n  const zone = injector.get(NgZone);\n  let poll: AfterRenderRef;\n  function pollDomTrigger() {\n    // If the initial view was destroyed, we don't need to do anything.\n    if (isDestroyed(initialLView)) {\n      poll.destroy();\n      return;\n    }\n\n    const lDetails = getLDeferBlockDetails(initialLView, tNode);\n    const renderedState = lDetails[DEFER_BLOCK_STATE];\n\n    // If the block was loaded before the trigger was resolved, we don't need to do anything.\n    if (\n      renderedState !== DeferBlockInternalState.Initial &&\n      renderedState !== DeferBlockState.Placeholder\n    ) {\n      poll.destroy();\n      return;\n    }\n\n    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);\n\n    // Keep polling until we resolve the trigger's LView.\n    if (!triggerLView) {\n      // Keep polling.\n      return;\n    }\n\n    poll.destroy();\n\n    // It's possible that the trigger's view was destroyed before we resolved the trigger element.\n    if (isDestroyed(triggerLView)) {\n      return;\n    }\n\n    const element = getTriggerElement(triggerLView, triggerIndex);\n    const cleanup = registerFn(\n      element,\n      () => {\n        // `pollDomTrigger` runs outside the zone (because of `afterNextRender`) and registers its\n        // listeners outside the zone, so we jump back into the zone prior to running the callback.\n        zone.run(() => {\n          if (initialLView !== triggerLView) {\n            removeLViewOnDestroy(triggerLView, cleanup);\n          }\n          callback();\n        });\n      },\n      injector,\n    );\n\n    // The trigger and deferred block might be in different LViews.\n    // For the main LView the cleanup would happen as a part of\n    // `storeTriggerCleanupFn` logic. For trigger LView we register\n    // a cleanup function there to remove event handlers in case an\n    // LView gets destroyed before a trigger is invoked.\n    if (initialLView !== triggerLView) {\n      storeLViewOnDestroy(triggerLView, cleanup);\n    }\n\n    storeTriggerCleanupFn(type, lDetails, cleanup);\n  }\n\n  // Begin polling for the trigger.\n  poll = afterEveryRender({read: pollDomTrigger}, {injector});\n}\n"]}