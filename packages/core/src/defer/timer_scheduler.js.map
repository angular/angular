{"version":3,"file":"timer_scheduler.js","sourceRoot":"","sources":["timer_scheduler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, ɵɵdefineInjectable} from '../di';\nimport {arrayInsert2, arraySplice} from '../util/array_utils';\nimport {NgZone} from '../zone';\n\n/**\n * Returns a function that captures a provided delay.\n * Invoking the returned function schedules a trigger.\n */\nexport function onTimer(delay: number) {\n  return (callback: VoidFunction, injector: Injector) =>\n    scheduleTimerTrigger(delay, callback, injector);\n}\n\n/**\n * Schedules a callback to be invoked after a given timeout.\n *\n * @param delay A number of ms to wait until firing a callback.\n * @param callback A function to be invoked after a timeout.\n * @param injector injector for the app.\n */\nexport function scheduleTimerTrigger(delay: number, callback: VoidFunction, injector: Injector) {\n  const scheduler = injector.get(TimerScheduler);\n  const ngZone = injector.get(NgZone);\n  const cleanupFn = () => scheduler.remove(callback);\n  scheduler.add(delay, callback, ngZone);\n  return cleanupFn;\n}\n\n/**\n * Helper service to schedule `setTimeout`s for batches of defer blocks,\n * to avoid calling `setTimeout` for each defer block (e.g. if defer blocks\n * are created inside a for loop).\n */\nexport class TimerScheduler {\n  // Indicates whether current callbacks are being invoked.\n  executingCallbacks = false;\n\n  // Currently scheduled `setTimeout` id.\n  timeoutId: number | null = null;\n\n  // When currently scheduled timer would fire.\n  invokeTimerAt: number | null = null;\n\n  // List of callbacks to be invoked.\n  // For each callback we also store a timestamp on when the callback\n  // should be invoked. We store timestamps and callback functions\n  // in a flat array to avoid creating new objects for each entry.\n  // [timestamp1, callback1, timestamp2, callback2, ...]\n  current: Array<number | VoidFunction> = [];\n\n  // List of callbacks collected while invoking current set of callbacks.\n  // Those callbacks are added to the \"current\" queue at the end of\n  // the current callback invocation. The shape of this list is the same\n  // as the shape of the `current` list.\n  deferred: Array<number | VoidFunction> = [];\n\n  add(delay: number, callback: VoidFunction, ngZone: NgZone) {\n    const target = this.executingCallbacks ? this.deferred : this.current;\n    this.addToQueue(target, Date.now() + delay, callback);\n    this.scheduleTimer(ngZone);\n  }\n\n  remove(callback: VoidFunction) {\n    const {current, deferred} = this;\n    const callbackIndex = this.removeFromQueue(current, callback);\n    if (callbackIndex === -1) {\n      // Try cleaning up deferred queue only in case\n      // we didn't find a callback in the \"current\" queue.\n      this.removeFromQueue(deferred, callback);\n    }\n    // If the last callback was removed and there is a pending timeout - cancel it.\n    if (current.length === 0 && deferred.length === 0) {\n      this.clearTimeout();\n    }\n  }\n\n  private addToQueue(\n    target: Array<number | VoidFunction>,\n    invokeAt: number,\n    callback: VoidFunction,\n  ) {\n    let insertAtIndex = target.length;\n    for (let i = 0; i < target.length; i += 2) {\n      const invokeQueuedCallbackAt = target[i] as number;\n      if (invokeQueuedCallbackAt > invokeAt) {\n        // We've reached a first timer that is scheduled\n        // for a later time than what we are trying to insert.\n        // This is the location at which we need to insert,\n        // no need to iterate further.\n        insertAtIndex = i;\n        break;\n      }\n    }\n    arrayInsert2(target, insertAtIndex, invokeAt, callback);\n  }\n\n  private removeFromQueue(target: Array<number | VoidFunction>, callback: VoidFunction) {\n    let index = -1;\n    for (let i = 0; i < target.length; i += 2) {\n      const queuedCallback = target[i + 1];\n      if (queuedCallback === callback) {\n        index = i;\n        break;\n      }\n    }\n    if (index > -1) {\n      // Remove 2 elements: a timestamp slot and\n      // the following slot with a callback function.\n      arraySplice(target, index, 2);\n    }\n    return index;\n  }\n\n  private scheduleTimer(ngZone: NgZone) {\n    const callback = () => {\n      this.clearTimeout();\n\n      this.executingCallbacks = true;\n\n      // Clone the current state of the queue, since it might be altered\n      // as we invoke callbacks.\n      const current = [...this.current];\n\n      // Invoke callbacks that were scheduled to run before the current time.\n      const now = Date.now();\n      for (let i = 0; i < current.length; i += 2) {\n        const invokeAt = current[i] as number;\n        const callback = current[i + 1] as VoidFunction;\n        if (invokeAt <= now) {\n          callback();\n        } else {\n          // We've reached a timer that should not be invoked yet.\n          break;\n        }\n      }\n      // The state of the queue might've changed after callbacks invocation,\n      // run the cleanup logic based on the *current* state of the queue.\n      let lastCallbackIndex = -1;\n      for (let i = 0; i < this.current.length; i += 2) {\n        const invokeAt = this.current[i] as number;\n        if (invokeAt <= now) {\n          // Add +1 to account for a callback function that\n          // goes after the timestamp in events array.\n          lastCallbackIndex = i + 1;\n        } else {\n          // We've reached a timer that should not be invoked yet.\n          break;\n        }\n      }\n      if (lastCallbackIndex >= 0) {\n        arraySplice(this.current, 0, lastCallbackIndex + 1);\n      }\n\n      this.executingCallbacks = false;\n\n      // If there are any callbacks added during an invocation\n      // of the current ones - move them over to the \"current\"\n      // queue.\n      if (this.deferred.length > 0) {\n        for (let i = 0; i < this.deferred.length; i += 2) {\n          const invokeAt = this.deferred[i] as number;\n          const callback = this.deferred[i + 1] as VoidFunction;\n          this.addToQueue(this.current, invokeAt, callback);\n        }\n        this.deferred.length = 0;\n      }\n      this.scheduleTimer(ngZone);\n    };\n\n    // Avoid running timer callbacks more than once per\n    // average frame duration. This is needed for better\n    // batching and to avoid kicking off excessive change\n    // detection cycles.\n    const FRAME_DURATION_MS = 16; // 1000ms / 60fps\n\n    if (this.current.length > 0) {\n      const now = Date.now();\n      // First element in the queue points at the timestamp\n      // of the first (earliest) event.\n      const invokeAt = this.current[0] as number;\n      if (\n        this.timeoutId === null ||\n        // Reschedule a timer in case a queue contains an item with\n        // an earlier timestamp and the delta is more than an average\n        // frame duration.\n        (this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS)\n      ) {\n        // There was a timeout already, but an earlier event was added\n        // into the queue. In this case we drop an old timer and setup\n        // a new one with an updated (smaller) timeout.\n        this.clearTimeout();\n\n        const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);\n        this.invokeTimerAt = invokeAt;\n        this.timeoutId = ngZone.runOutsideAngular(() => {\n          return setTimeout(() => ngZone.run(callback), timeout) as unknown as number;\n        });\n      }\n    }\n  }\n\n  private clearTimeout() {\n    if (this.timeoutId !== null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n  }\n\n  ngOnDestroy() {\n    this.clearTimeout();\n    this.current.length = 0;\n    this.deferred.length = 0;\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: TimerScheduler,\n    providedIn: 'root',\n    factory: () => new TimerScheduler(),\n  });\n}\n"]}