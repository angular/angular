{"version":3,"file":"triggering.js","sourceRoot":"","sources":["triggering.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {afterNextRender} from '../render3/after_render/hooks';\nimport {Injector} from '../di';\nimport {internalImportProvidersFrom} from '../di/provider_collection';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {\n  cleanupHydratedDeferBlocks,\n  cleanupLContainer,\n  removeDehydratedViewList,\n} from '../hydration/cleanup';\nimport {BlockSummary, ElementTrigger, NUM_ROOT_NODES} from '../hydration/interfaces';\nimport {\n  assertSsrIdDefined,\n  getParentBlockHydrationQueue,\n  isIncrementalHydrationEnabled,\n} from '../hydration/utils';\nimport {PendingTasks} from '../pending_tasks';\nimport {PendingTasksInternal} from '../pending_tasks_internal';\nimport {assertLContainer} from '../render3/assert';\nimport {getComponentDef, getDirectiveDef, getPipeDef} from '../render3/def_getters';\nimport {getTemplateLocationDetails} from '../render3/instructions/element_validation';\nimport {handleUncaughtError} from '../render3/instructions/shared';\nimport {DirectiveDefList, PipeDefList} from '../render3/interfaces/definition';\nimport {TNode} from '../render3/interfaces/node';\nimport {INJECTOR, LView, TView, TVIEW} from '../render3/interfaces/view';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {throwError} from '../util/assert';\nimport {\n  invokeAllTriggerCleanupFns,\n  invokeTriggerCleanupFns,\n  storeTriggerCleanupFn,\n} from './cleanup';\nimport {onViewportWrapper} from './dom_triggers';\nimport {onIdle} from './idle_scheduler';\nimport {\n  DEFER_BLOCK_STATE,\n  DeferBlockBehavior,\n  DeferBlockState,\n  DeferBlockTrigger,\n  DeferDependenciesLoadingState,\n  DehydratedDeferBlock,\n  HydrateTriggerDetails,\n  LDeferBlockDetails,\n  ON_COMPLETE_FNS,\n  SSR_UNIQUE_ID,\n  TDeferBlockDetails,\n  TDeferDetailsFlags,\n  TriggerType,\n} from './interfaces';\nimport {DEHYDRATED_BLOCK_REGISTRY, DehydratedBlockRegistry} from './registry';\nimport {\n  DEFER_BLOCK_CONFIG,\n  DEFER_BLOCK_DEPENDENCY_INTERCEPTOR,\n  renderDeferBlockState,\n  renderDeferStateAfterResourceLoading,\n  renderPlaceholder,\n} from './rendering';\nimport {onTimer} from './timer_scheduler';\nimport {\n  addDepsToRegistry,\n  assertDeferredDependenciesLoaded,\n  getLDeferBlockDetails,\n  getPrimaryBlockTNode,\n  getTDeferBlockDetails,\n} from './utils';\nimport {ApplicationRef} from '../application/application_ref';\nimport {promiseWithResolvers} from '../util/promise_with_resolvers';\n\n/**\n * Schedules triggering of a defer block for `on idle` and `on timer` conditions.\n */\nexport function scheduleDelayedTrigger(\n  scheduleFn: (callback: VoidFunction, injector: Injector) => VoidFunction,\n) {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n\n  renderPlaceholder(lView, tNode);\n\n  // Exit early to avoid invoking `scheduleFn`, which would\n  // add `setTimeout` call and potentially delay serialization\n  // on the server unnecessarily.\n  if (!shouldTriggerDeferBlock(TriggerType.Regular, lView)) return;\n\n  const injector = lView[INJECTOR];\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n\n  const cleanupFn = scheduleFn(\n    () => triggerDeferBlock(TriggerType.Regular, lView, tNode),\n    injector,\n  );\n  storeTriggerCleanupFn(TriggerType.Regular, lDetails, cleanupFn);\n}\n\n/**\n * Schedules prefetching for `on idle` and `on timer` triggers.\n *\n * @param scheduleFn A function that does the scheduling.\n */\nexport function scheduleDelayedPrefetching(\n  scheduleFn: (callback: VoidFunction, injector: Injector) => VoidFunction,\n  trigger: DeferBlockTrigger,\n) {\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) return;\n\n  const lView = getLView();\n  const injector = lView[INJECTOR];\n\n  // Only trigger the scheduled trigger on the browser\n  // since we don't want to delay the server response.\n  const tNode = getCurrentTNode()!;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    const lDetails = getLDeferBlockDetails(lView, tNode);\n    const prefetch = () => triggerPrefetching(tDetails, lView, tNode);\n    const cleanupFn = scheduleFn(prefetch, injector);\n    storeTriggerCleanupFn(TriggerType.Prefetch, lDetails, cleanupFn);\n  }\n}\n\n/**\n * Schedules hydration triggering of a defer block for `on idle` and `on timer` conditions.\n */\nexport function scheduleDelayedHydrating(\n  scheduleFn: (callback: VoidFunction, injector: Injector) => VoidFunction,\n  lView: LView,\n  tNode: TNode,\n) {\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) return;\n\n  // Only trigger the scheduled trigger on the browser\n  // since we don't want to delay the server response.\n  const injector = lView[INJECTOR];\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const ssrUniqueId = lDetails[SSR_UNIQUE_ID]!;\n  ngDevMode && assertSsrIdDefined(ssrUniqueId);\n\n  const cleanupFn = scheduleFn(\n    () => triggerHydrationFromBlockName(injector, ssrUniqueId),\n    injector,\n  );\n  storeTriggerCleanupFn(TriggerType.Hydrate, lDetails, cleanupFn);\n}\n\n/**\n * Trigger prefetching of dependencies for a defer block.\n *\n * @param tDetails Static information about this defer block.\n * @param lView LView of a host view.\n * @param tNode TNode that represents a defer block.\n */\nexport function triggerPrefetching(tDetails: TDeferBlockDetails, lView: LView, tNode: TNode) {\n  triggerResourceLoading(tDetails, lView, tNode);\n}\n\n/**\n * Trigger loading of defer block dependencies if the process hasn't started yet.\n *\n * @param tDetails Static information about this defer block.\n * @param lView LView of a host view.\n */\nexport function triggerResourceLoading(\n  tDetails: TDeferBlockDetails,\n  lView: LView,\n  tNode: TNode,\n): Promise<unknown> {\n  const injector = lView[INJECTOR];\n  const tView = lView[TVIEW];\n\n  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {\n    // If the loading status is different from initial one, it means that\n    // the loading of dependencies is in progress and there is nothing to do\n    // in this function. All details can be obtained from the `tDetails` object.\n    return tDetails.loadingPromise ?? Promise.resolve();\n  }\n\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);\n\n  // Switch from NOT_STARTED -> IN_PROGRESS state.\n  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;\n\n  // Prefetching is triggered, cleanup all registered prefetch triggers.\n  invokeTriggerCleanupFns(TriggerType.Prefetch, lDetails);\n\n  let dependenciesFn = tDetails.dependencyResolverFn;\n\n  if (ngDevMode) {\n    // Check if dependency function interceptor is configured.\n    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {\n      optional: true,\n    });\n\n    if (deferDependencyInterceptor) {\n      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);\n    }\n  }\n\n  // Indicate that an application is not stable and has a pending task.\n  const removeTask = injector.get(PendingTasks).add();\n\n  // The `dependenciesFn` might be `null` when all dependencies within\n  // a given defer block were eagerly referenced elsewhere in a file,\n  // thus no dynamic `import()`s were produced.\n  if (!dependenciesFn) {\n    tDetails.loadingPromise = Promise.resolve().then(() => {\n      tDetails.loadingPromise = null;\n      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;\n      removeTask();\n    });\n    return tDetails.loadingPromise;\n  }\n\n  // Start downloading of defer block dependencies.\n  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {\n    let failed = false;\n    const directiveDefs: DirectiveDefList = [];\n    const pipeDefs: PipeDefList = [];\n\n    for (const result of results) {\n      if (result.status === 'fulfilled') {\n        const dependency = result.value;\n        const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);\n        if (directiveDef) {\n          directiveDefs.push(directiveDef);\n        } else {\n          const pipeDef = getPipeDef(dependency);\n          if (pipeDef) {\n            pipeDefs.push(pipeDef);\n          }\n        }\n      } else {\n        failed = true;\n        break;\n      }\n    }\n\n    if (failed) {\n      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;\n\n      if (tDetails.errorTmplIndex === null) {\n        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : '';\n        const error = new RuntimeError(\n          RuntimeErrorCode.DEFER_LOADING_FAILED,\n          ngDevMode &&\n            'Loading dependencies for `@defer` block failed, ' +\n              `but no \\`@error\\` block was configured${templateLocation}. ` +\n              'Consider using the `@error` block to render an error state.',\n        );\n        handleUncaughtError(lView, error);\n      }\n    } else {\n      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;\n\n      // Update directive and pipe registries to add newly downloaded dependencies.\n      const primaryBlockTView = primaryBlockTNode.tView!;\n      if (directiveDefs.length > 0) {\n        primaryBlockTView.directiveRegistry = addDepsToRegistry<DirectiveDefList>(\n          primaryBlockTView.directiveRegistry,\n          directiveDefs,\n        );\n\n        // Extract providers from all NgModules imported by standalone components\n        // used within this defer block.\n        const directiveTypes = directiveDefs.map((def) => def.type);\n        const providers = internalImportProvidersFrom(false, ...directiveTypes);\n        tDetails.providers = providers;\n      }\n      if (pipeDefs.length > 0) {\n        primaryBlockTView.pipeRegistry = addDepsToRegistry<PipeDefList>(\n          primaryBlockTView.pipeRegistry,\n          pipeDefs,\n        );\n      }\n    }\n  });\n\n  return tDetails.loadingPromise.finally(() => {\n    // Loading is completed, we no longer need the loading Promise\n    // and a pending task should also be removed.\n    tDetails.loadingPromise = null;\n    removeTask();\n  });\n}\n\n/**\n * Defines whether we should proceed with triggering a given defer block.\n */\nfunction shouldTriggerDeferBlock(triggerType: TriggerType, lView: LView): boolean {\n  // prevents triggering regular triggers when on the server.\n  if (triggerType === TriggerType.Regular && typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return false;\n  }\n\n  // prevents triggering in the case of a test run with manual defer block configuration.\n  const injector = lView[INJECTOR];\n  const config = injector.get(DEFER_BLOCK_CONFIG, null, {optional: true});\n  if (config?.behavior === DeferBlockBehavior.Manual) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Attempts to trigger loading of defer block dependencies.\n * If the block is already in a loading, completed or an error state -\n * no additional actions are taken.\n */\nexport function triggerDeferBlock(triggerType: TriggerType, lView: LView, tNode: TNode) {\n  const tView = lView[TVIEW];\n  const lContainer = lView[tNode.index];\n  ngDevMode && assertLContainer(lContainer);\n\n  if (!shouldTriggerDeferBlock(triggerType, lView)) return;\n\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  // Defer block is triggered, cleanup all registered trigger functions.\n  invokeAllTriggerCleanupFns(lDetails);\n\n  switch (tDetails.loadingState) {\n    case DeferDependenciesLoadingState.NOT_STARTED:\n      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);\n      triggerResourceLoading(tDetails, lView, tNode);\n\n      // The `loadingState` might have changed to \"loading\".\n      if (\n        (tDetails.loadingState as DeferDependenciesLoadingState) ===\n        DeferDependenciesLoadingState.IN_PROGRESS\n      ) {\n        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);\n      }\n      break;\n    case DeferDependenciesLoadingState.IN_PROGRESS:\n      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);\n      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);\n      break;\n    case DeferDependenciesLoadingState.COMPLETE:\n      ngDevMode && assertDeferredDependenciesLoaded(tDetails);\n      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);\n      break;\n    case DeferDependenciesLoadingState.FAILED:\n      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);\n      break;\n    default:\n      if (ngDevMode) {\n        throwError('Unknown defer block state');\n      }\n  }\n}\n\n/**\n * The core mechanism for incremental hydration. This triggers or\n * queues hydration for all the blocks in the tree that need to be hydrated\n * and keeps track of all those blocks that were hydrated along the way.\n *\n * Note: the `replayQueuedEventsFn` is only provided when hydration is invoked\n * as a result of an event replay (via JsAction). When hydration is invoked from\n * an instruction set (e.g. `deferOnImmediate`) - there is no need to replay any\n * events.\n */\nexport async function triggerHydrationFromBlockName(\n  injector: Injector,\n  blockName: string,\n  replayQueuedEventsFn?: Function,\n) {\n  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n  const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;\n\n  // Make sure we don't hydrate/trigger the same thing multiple times\n  if (blocksBeingHydrated.has(blockName)) {\n    return;\n  }\n\n  // Trigger resource loading and hydration for the blocks in the queue in the order of highest block\n  // to lowest block. Once a block has finished resource loading, after next render fires after hydration\n  // finishes. The new block will have its defer instruction called and will be in the registry.\n  // Due to timing related to potential nested control flow, this has to be scheduled after the next render.\n  const {parentBlockPromise, hydrationQueue} = getParentBlockHydrationQueue(blockName, injector);\n  if (hydrationQueue.length === 0) return;\n\n  // It's possible that the hydrationQueue topmost item is actually in the process of hydrating and has\n  // a promise already. In that case, we don't want to destroy that promise and queue it again.\n  if (parentBlockPromise !== null) {\n    hydrationQueue.shift();\n  }\n\n  // The hydrating map in the registry prevents re-triggering hydration for a block that's already in\n  // the hydration queue. Here we generate promises for each of the blocks about to be hydrated\n  populateHydratingStateForQueue(dehydratedBlockRegistry, hydrationQueue);\n\n  // We await this after populating the hydration state so we can prevent re-triggering hydration for\n  // the same blocks while this promise is being awaited.\n  if (parentBlockPromise !== null) {\n    await parentBlockPromise;\n  }\n\n  const topmostParentBlock = hydrationQueue[0];\n  if (dehydratedBlockRegistry.has(topmostParentBlock)) {\n    // the topmost parent block is already in the registry and we can proceed\n    // with hydration.\n    await triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);\n  } else {\n    // the topmost parent block is not yet in the registry, which may mean\n    // a lazy loaded route, a control flow branch was taken, a route has\n    // been navigated, etc. So we need to queue up the hydration process\n    // so that it can be finished after the top block has had its defer\n    // instruction executed.\n    dehydratedBlockRegistry.awaitParentBlock(\n      topmostParentBlock,\n      async () =>\n        await triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn),\n    );\n  }\n}\n\n/**\n * The core mechanism for incremental hydration. This triggers\n * hydration for all the blocks in the tree that need to be hydrated\n * and keeps track of all those blocks that were hydrated along the way.\n *\n * Note: the `replayQueuedEventsFn` is only provided when hydration is invoked\n * as a result of an event replay (via JsAction). When hydration is invoked from\n * an instruction set (e.g. `deferOnImmediate`) - there is no need to replay any\n * events.\n */\nexport async function triggerHydrationForBlockQueue(\n  injector: Injector,\n  hydrationQueue: string[],\n  replayQueuedEventsFn?: Function,\n): Promise<void> {\n  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n  const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;\n\n  // Indicate that we have some pending async work.\n  const pendingTasks = injector.get(PendingTasksInternal);\n  const taskId = pendingTasks.add();\n\n  // Actually do the triggering and hydration of the queue of blocks\n  for (let blockQueueIdx = 0; blockQueueIdx < hydrationQueue.length; blockQueueIdx++) {\n    const dehydratedBlockId = hydrationQueue[blockQueueIdx];\n    const dehydratedDeferBlock = dehydratedBlockRegistry.get(dehydratedBlockId);\n\n    if (dehydratedDeferBlock != null) {\n      // trigger the block resources and await next render for hydration. This should result\n      // in the next block ɵɵdefer instruction being called and that block being added to the dehydrated registry.\n      await triggerResourceLoadingForHydration(dehydratedDeferBlock);\n      await nextRender(injector);\n\n      // if the content has changed since server rendering, we need to check for the expected block\n      // being in the registry or if errors occurred. In that case, we need to clean up the remaining expected\n      // content that won't be rendered or fetched.\n      if (deferBlockHasErrored(dehydratedDeferBlock)) {\n        // Either the expected block has not yet had its ɵɵdefer instruction called or the block errored out when fetching\n        // resources. In the former case, either we're hydrating too soon or the client and server differ. In both cases,\n        // we need to clean up child content and promises.\n        removeDehydratedViewList(dehydratedDeferBlock);\n        cleanupRemainingHydrationQueue(\n          hydrationQueue.slice(blockQueueIdx),\n          dehydratedBlockRegistry,\n        );\n        break;\n      }\n      // The defer block has not errored and we've finished fetching resources and rendering.\n      // At this point it is safe to resolve the hydration promise.\n      blocksBeingHydrated.get(dehydratedBlockId)!.resolve();\n    } else {\n      // The expected block has not yet had its ɵɵdefer instruction called. This is likely due to content changing between\n      // client and server. We need to clean up the dehydrated DOM in the container since it no longer is valid.\n      cleanupParentContainer(blockQueueIdx, hydrationQueue, dehydratedBlockRegistry);\n      cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);\n      break;\n    }\n  }\n\n  const lastBlockName = hydrationQueue[hydrationQueue.length - 1];\n\n  // Await hydration completion for the last block.\n  await blocksBeingHydrated.get(lastBlockName)?.promise;\n\n  // All async work is done, remove the taskId from the registry.\n  pendingTasks.remove(taskId);\n\n  // Replay any queued events, if any exist and the replay operation was requested.\n  if (replayQueuedEventsFn) {\n    replayQueuedEventsFn(hydrationQueue);\n  }\n\n  // Cleanup after hydration of all affected defer blocks.\n  cleanupHydratedDeferBlocks(\n    dehydratedBlockRegistry.get(lastBlockName),\n    hydrationQueue,\n    dehydratedBlockRegistry,\n    injector.get(ApplicationRef),\n  );\n}\n\nexport function deferBlockHasErrored(deferBlock: DehydratedDeferBlock): boolean {\n  return (\n    getLDeferBlockDetails(deferBlock.lView, deferBlock.tNode)[DEFER_BLOCK_STATE] ===\n    DeferBlockState.Error\n  );\n}\n\n/**\n * Clean up the parent container of a block where content changed between server and client.\n * The parent of a block going through `triggerHydrationFromBlockName` will contain the\n * dehydrated content that needs to be cleaned up. So we have to do the clean up from that location\n * in the tree.\n */\nfunction cleanupParentContainer(\n  currentBlockIdx: number,\n  hydrationQueue: string[],\n  dehydratedBlockRegistry: DehydratedBlockRegistry,\n) {\n  // If a parent block exists, it's in the hydration queue in front of the current block.\n  const parentDeferBlockIdx = currentBlockIdx - 1;\n  const parentDeferBlock =\n    parentDeferBlockIdx > -1\n      ? dehydratedBlockRegistry.get(hydrationQueue[parentDeferBlockIdx])\n      : null;\n  if (parentDeferBlock) {\n    cleanupLContainer(parentDeferBlock.lContainer);\n  }\n}\n\nfunction cleanupRemainingHydrationQueue(\n  hydrationQueue: string[],\n  dehydratedBlockRegistry: DehydratedBlockRegistry,\n) {\n  const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;\n  for (const dehydratedBlockId in hydrationQueue) {\n    blocksBeingHydrated.get(dehydratedBlockId)?.reject();\n  }\n  dehydratedBlockRegistry.cleanup(hydrationQueue);\n}\n\n/**\n * Generates a new promise for every defer block in the hydrating queue\n */\nfunction populateHydratingStateForQueue(registry: DehydratedBlockRegistry, queue: string[]) {\n  for (let blockId of queue) {\n    registry.hydrating.set(blockId, promiseWithResolvers<void>());\n  }\n}\n\n// Waits for the next render cycle to complete\nfunction nextRender(injector: Injector): Promise<void> {\n  return new Promise<void>((resolveFn) => afterNextRender(resolveFn, {injector}));\n}\n\nasync function triggerResourceLoadingForHydration(\n  dehydratedBlock: DehydratedDeferBlock,\n): Promise<void> {\n  const {tNode, lView} = dehydratedBlock;\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n\n  return new Promise<void>((resolve) => {\n    onDeferBlockCompletion(lDetails, resolve);\n    triggerDeferBlock(TriggerType.Hydrate, lView, tNode);\n  });\n}\n\n/**\n * Registers cleanup functions for a defer block when the block has finished\n * fetching and rendering\n */\nfunction onDeferBlockCompletion(lDetails: LDeferBlockDetails, callback: VoidFunction) {\n  if (!Array.isArray(lDetails[ON_COMPLETE_FNS])) {\n    lDetails[ON_COMPLETE_FNS] = [];\n  }\n  lDetails[ON_COMPLETE_FNS].push(callback);\n}\n\n/**\n * Determines whether specific trigger types should be attached during an instruction firing\n * to ensure the proper triggers for a given type are used.\n */\nexport function shouldAttachTrigger(triggerType: TriggerType, lView: LView, tNode: TNode): boolean {\n  if (triggerType === TriggerType.Regular) {\n    return shouldAttachRegularTrigger(lView, tNode);\n  } else if (triggerType === TriggerType.Hydrate) {\n    return !shouldAttachRegularTrigger(lView, tNode);\n  }\n  // TriggerType.Prefetch is active only on the client\n  return !(typeof ngServerMode !== 'undefined' && ngServerMode);\n}\n\n/** Whether a given defer block has `hydrate` triggers. */\nexport function hasHydrateTriggers(flags: TDeferDetailsFlags | null | undefined): boolean {\n  return (\n    flags != null &&\n    (flags & TDeferDetailsFlags.HasHydrateTriggers) === TDeferDetailsFlags.HasHydrateTriggers\n  );\n}\n\n/**\n * Defines whether a regular trigger logic (e.g. \"on viewport\") should be attached\n * to a defer block. This function defines a condition, which mutually excludes\n * `deferOn*` and `deferHydrateOn*` triggers, to make sure only one of the trigger\n * types is active for a block with the current state.\n */\nfunction shouldAttachRegularTrigger(lView: LView, tNode: TNode): boolean {\n  const injector = lView[INJECTOR];\n\n  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);\n  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);\n  const _hasHydrateTriggers = hasHydrateTriggers(tDetails.flags);\n\n  // On the server:\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    // Regular triggers are activated on the server when:\n    //  - Either Incremental Hydration is *not* enabled\n    //  - Or Incremental Hydration is enabled, but a given block doesn't have \"hydrate\" triggers\n    return !incrementalHydrationEnabled || !_hasHydrateTriggers;\n  }\n\n  // On the client:\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const wasServerSideRendered = lDetails[SSR_UNIQUE_ID] !== null;\n\n  if (_hasHydrateTriggers && wasServerSideRendered && incrementalHydrationEnabled) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Retrives a Defer Block's list of hydration triggers\n */\nexport function getHydrateTriggers(\n  tView: TView,\n  tNode: TNode,\n): Map<DeferBlockTrigger, HydrateTriggerDetails | null> {\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  return (tDetails.hydrateTriggers ??= new Map());\n}\n\n/**\n * Loops through all defer block summaries and ensures all the blocks triggers are\n * properly initialized\n */\nexport function processAndInitTriggers(\n  injector: Injector,\n  blockData: Map<string, BlockSummary>,\n  nodes: Map<string, Comment>,\n) {\n  const idleElements: ElementTrigger[] = [];\n  const timerElements: ElementTrigger[] = [];\n  const viewportElements: ElementTrigger[] = [];\n  const immediateElements: ElementTrigger[] = [];\n  for (let [blockId, blockSummary] of blockData) {\n    const commentNode = nodes.get(blockId);\n    if (commentNode !== undefined) {\n      const numRootNodes = blockSummary.data[NUM_ROOT_NODES];\n      let currentNode: Comment | HTMLElement = commentNode;\n      for (let i = 0; i < numRootNodes; i++) {\n        currentNode = currentNode.previousSibling as HTMLElement;\n        if (currentNode.nodeType !== Node.ELEMENT_NODE) {\n          continue;\n        }\n        const elementTrigger: ElementTrigger = {el: currentNode, blockName: blockId};\n        // hydrate\n        if (blockSummary.hydrate.idle) {\n          idleElements.push(elementTrigger);\n        }\n        if (blockSummary.hydrate.immediate) {\n          immediateElements.push(elementTrigger);\n        }\n        if (blockSummary.hydrate.timer !== null) {\n          elementTrigger.delay = blockSummary.hydrate.timer;\n          timerElements.push(elementTrigger);\n        }\n        if (blockSummary.hydrate.viewport) {\n          viewportElements.push(elementTrigger);\n        }\n      }\n    }\n  }\n\n  setIdleTriggers(injector, idleElements);\n  setImmediateTriggers(injector, immediateElements);\n  setViewportTriggers(injector, viewportElements);\n  setTimerTriggers(injector, timerElements);\n}\n\nfunction setIdleTriggers(injector: Injector, elementTriggers: ElementTrigger[]) {\n  for (const elementTrigger of elementTriggers) {\n    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n    const onInvoke = () => triggerHydrationFromBlockName(injector, elementTrigger.blockName);\n    const cleanupFn = onIdle(onInvoke, injector);\n    registry.addCleanupFn(elementTrigger.blockName, cleanupFn);\n  }\n}\n\nfunction setViewportTriggers(injector: Injector, elementTriggers: ElementTrigger[]) {\n  if (elementTriggers.length > 0) {\n    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n    for (let elementTrigger of elementTriggers) {\n      const cleanupFn = onViewportWrapper(\n        elementTrigger.el,\n        () => triggerHydrationFromBlockName(injector, elementTrigger.blockName),\n        injector,\n      );\n      registry.addCleanupFn(elementTrigger.blockName, cleanupFn);\n    }\n  }\n}\n\nfunction setTimerTriggers(injector: Injector, elementTriggers: ElementTrigger[]) {\n  for (const elementTrigger of elementTriggers) {\n    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n    const onInvoke = () => triggerHydrationFromBlockName(injector, elementTrigger.blockName);\n    const timerFn = onTimer(elementTrigger.delay!);\n    const cleanupFn = timerFn(onInvoke, injector);\n    registry.addCleanupFn(elementTrigger.blockName, cleanupFn);\n  }\n}\n\nfunction setImmediateTriggers(injector: Injector, elementTriggers: ElementTrigger[]) {\n  for (const elementTrigger of elementTriggers) {\n    // Note: we intentionally avoid awaiting each call and instead kick off\n    // the hydration process simultaneously for all defer blocks with this trigger;\n    triggerHydrationFromBlockName(injector, elementTrigger.blockName);\n  }\n}\n"]}