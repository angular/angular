{"version":3,"file":"registry.js","sourceRoot":"","sources":["registry.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {inject} from '../di';\nimport {InjectionToken} from '../di/injection_token';\nimport {ɵɵdefineInjectable} from '../di/interface/defs';\nimport {\n  EventContractDetails,\n  JSACTION_EVENT_CONTRACT,\n  removeListenersFromBlocks,\n} from '../event_delegation_utils';\nimport {JSACTION_BLOCK_ELEMENT_MAP} from '../hydration/tokens';\nimport {DehydratedDeferBlock} from './interfaces';\nimport type {PromiseWithResolvers} from '../util/promise_with_resolvers';\n\n/**\n * An internal injection token to reference `DehydratedBlockRegistry` implementation\n * in a tree-shakable way.\n */\nexport const DEHYDRATED_BLOCK_REGISTRY = new InjectionToken<DehydratedBlockRegistry>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'DEHYDRATED_BLOCK_REGISTRY' : '',\n);\n\n/**\n * The DehydratedBlockRegistry is used for incremental hydration purposes. It keeps\n * track of the Defer Blocks that need hydration so we can effectively\n * navigate up to the top dehydrated defer block and fire appropriate cleanup\n * functions post hydration.\n */\nexport class DehydratedBlockRegistry {\n  private registry = new Map<string, DehydratedDeferBlock>();\n  private cleanupFns = new Map<string, Function[]>();\n  private jsActionMap: Map<string, Set<Element>> = inject(JSACTION_BLOCK_ELEMENT_MAP);\n  private contract: EventContractDetails = inject(JSACTION_EVENT_CONTRACT);\n\n  add(blockId: string, info: DehydratedDeferBlock) {\n    this.registry.set(blockId, info);\n    // It's possible that hydration is queued that's waiting for the\n    // resolution of a lazy loaded route. In this case, we ensure\n    // the callback function is called to continue the hydration process\n    // for the queued block set.\n    if (this.awaitingCallbacks.has(blockId)) {\n      const awaitingCallbacks = this.awaitingCallbacks.get(blockId)!;\n      for (const cb of awaitingCallbacks) {\n        cb();\n      }\n    }\n  }\n\n  get(blockId: string): DehydratedDeferBlock | null {\n    return this.registry.get(blockId) ?? null;\n  }\n\n  has(blockId: string): boolean {\n    return this.registry.has(blockId);\n  }\n\n  cleanup(hydratedBlocks: string[]) {\n    removeListenersFromBlocks(hydratedBlocks, this.jsActionMap);\n    for (let blockId of hydratedBlocks) {\n      this.registry.delete(blockId);\n      this.jsActionMap.delete(blockId);\n      this.invokeTriggerCleanupFns(blockId);\n      this.hydrating.delete(blockId);\n      this.awaitingCallbacks.delete(blockId);\n    }\n    if (this.size === 0) {\n      this.contract.instance?.cleanUp();\n    }\n  }\n\n  get size(): number {\n    return this.registry.size;\n  }\n\n  // we have to leave the lowest block Id in the registry\n  // unless that block has no children\n  addCleanupFn(blockId: string, fn: Function) {\n    let cleanupFunctions: Function[] = [];\n    if (this.cleanupFns.has(blockId)) {\n      cleanupFunctions = this.cleanupFns.get(blockId)!;\n    }\n    cleanupFunctions.push(fn);\n    this.cleanupFns.set(blockId, cleanupFunctions);\n  }\n\n  invokeTriggerCleanupFns(blockId: string) {\n    const fns = this.cleanupFns.get(blockId) ?? [];\n    for (let fn of fns) {\n      fn();\n    }\n    this.cleanupFns.delete(blockId);\n  }\n\n  // Blocks that are being hydrated.\n  hydrating = new Map<string, PromiseWithResolvers<void>>();\n\n  // Blocks that are awaiting a defer instruction finish.\n  private awaitingCallbacks = new Map<string, Function[]>();\n\n  awaitParentBlock(topmostParentBlock: string, callback: Function) {\n    const parentBlockAwaitCallbacks = this.awaitingCallbacks.get(topmostParentBlock) ?? [];\n    parentBlockAwaitCallbacks.push(callback);\n    this.awaitingCallbacks.set(topmostParentBlock, parentBlockAwaitCallbacks);\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: DehydratedBlockRegistry,\n    providedIn: null,\n    factory: () => new DehydratedBlockRegistry(),\n  });\n}\n"]}