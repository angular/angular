{"version":3,"file":"event_delegation_utils.js","sourceRoot":"","sources":["event_delegation_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// tslint:disable:no-duplicate-imports\nimport type {EventContract} from '../primitives/event-dispatch';\nimport {Attribute} from '../primitives/event-dispatch';\nimport {APP_ID} from './application/application_tokens';\nimport {InjectionToken} from './di';\nimport type {RElement, RNode} from './render3/interfaces/renderer_dom';\nimport {INJECTOR, type LView} from './render3/interfaces/view';\n\nexport const DEFER_BLOCK_SSR_ID_ATTRIBUTE = 'ngb';\n\ndeclare global {\n  interface Element {\n    __jsaction_fns: Map<string, Function[]> | undefined;\n  }\n}\n\nexport function setJSActionAttributes(\n  nativeElement: Element,\n  eventTypes: string[],\n  parentDeferBlockId: string | null = null,\n) {\n  // jsaction attributes specifically should be applied to elements and not comment nodes.\n  // Comment nodes also have no setAttribute function. So this avoids errors.\n  if (eventTypes.length === 0 || nativeElement.nodeType !== Node.ELEMENT_NODE) {\n    return;\n  }\n  const existingAttr = nativeElement.getAttribute(Attribute.JSACTION);\n  // we dedupe cases where hydrate triggers are used as it's possible that\n  // someone may have added an event binding to the root node that matches what the\n  // hydrate trigger adds.\n  const parts = eventTypes.reduce((prev, curr) => {\n    // if there is no existing attribute OR it's not in the existing one, we need to add it\n    return (existingAttr?.indexOf(curr) ?? -1) === -1 ? prev + curr + ':;' : prev;\n  }, '');\n  //  This is required to be a module accessor to appease security tests on setAttribute.\n  nativeElement.setAttribute(Attribute.JSACTION, `${existingAttr ?? ''}${parts}`);\n\n  const blockName = parentDeferBlockId ?? '';\n  if (blockName !== '' && parts.length > 0) {\n    nativeElement.setAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE, blockName);\n  }\n}\n\nexport const sharedStashFunction = (rEl: RElement, eventType: string, listenerFn: Function) => {\n  const el = rEl as unknown as Element;\n  const eventListenerMap = el.__jsaction_fns ?? new Map();\n  const eventListeners = eventListenerMap.get(eventType) ?? [];\n  eventListeners.push(listenerFn);\n  eventListenerMap.set(eventType, eventListeners);\n  el.__jsaction_fns = eventListenerMap;\n};\n\nexport const sharedMapFunction = (rEl: RElement, jsActionMap: Map<string, Set<Element>>) => {\n  const el = rEl as unknown as Element;\n  let blockName = el.getAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE) ?? '';\n  const blockSet = jsActionMap.get(blockName) ?? new Set<Element>();\n  if (!blockSet.has(el)) {\n    blockSet.add(el);\n  }\n  jsActionMap.set(blockName, blockSet);\n};\n\nexport function removeListenersFromBlocks(\n  blockNames: string[],\n  jsActionMap: Map<string, Set<Element>>,\n) {\n  if (blockNames.length > 0) {\n    let blockList: Element[] = [];\n    for (let blockName of blockNames) {\n      if (jsActionMap.has(blockName)) {\n        blockList = [...blockList, ...jsActionMap.get(blockName)!];\n      }\n    }\n    const replayList = new Set(blockList);\n    replayList.forEach(removeListeners);\n  }\n}\n\nexport const removeListeners = (el: Element) => {\n  el.removeAttribute(Attribute.JSACTION);\n  el.removeAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE);\n  el.__jsaction_fns = undefined;\n};\n\nexport interface EventContractDetails {\n  instance?: EventContract;\n}\n\nexport const JSACTION_EVENT_CONTRACT = new InjectionToken<EventContractDetails>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'EVENT_CONTRACT_DETAILS' : '',\n  {\n    providedIn: 'root',\n    factory: () => ({}),\n  },\n);\n\nexport function invokeListeners(event: Event, currentTarget: Element | null) {\n  const handlerFns = currentTarget?.__jsaction_fns?.get(event.type);\n  if (!handlerFns || !currentTarget?.isConnected) {\n    return;\n  }\n  for (const handler of handlerFns) {\n    handler(event);\n  }\n}\n\n/** Shorthand for an event listener callback function to reduce duplication. */\nexport type EventCallback = (event?: any) => any;\n\n/** Utility type used to make it harder to swap a wrapped and unwrapped callback. */\nexport type WrappedEventCallback = EventCallback & {__wrapped: boolean};\n\n/**\n * Represents a signature of a function that disables event replay feature\n * for server-side rendered applications. This function is overridden with\n * an actual implementation when the event replay feature is enabled via\n * `withEventReplay()` call.\n */\ntype StashEventListener = (el: RNode, eventName: string, listenerFn: EventCallback) => void;\n\nconst stashEventListeners = new Map<string, StashEventListener>();\n\n/**\n * Registers a stashing function for a specific application ID.\n *\n * @param appId The unique identifier for the application instance.\n * @param fn The stashing function to associate with this app ID.\n * @returns A cleanup function that removes the stashing function when called.\n */\nexport function setStashFn(appId: string, fn: StashEventListener) {\n  stashEventListeners.set(appId, fn);\n  return () => stashEventListeners.delete(appId);\n}\n\n/**\n * Indicates whether the stashing code was added, prevents adding it multiple times.\n */\nlet isStashEventListenerImplEnabled = false;\n\nlet _stashEventListenerImpl = (\n  lView: LView,\n  target: RElement | EventTarget,\n  eventName: string,\n  wrappedListener: WrappedEventCallback,\n) => {};\n\n/**\n * Optionally stashes an event listener for later replay during hydration.\n *\n * This function delegates to an internal `_stashEventListenerImpl`, which may\n * be a no-op unless the event replay feature is enabled. When active, this\n * allows capturing event listener metadata before hydration completes, so that\n * user interactions during SSR can be replayed.\n *\n * @param lView The logical view (LView) where the listener is being registered.\n * @param target The DOM element or event target the listener is attached to.\n * @param eventName The name of the event being listened for (e.g., 'click').\n * @param wrappedListener The event handler that was registered.\n */\nexport function stashEventListenerImpl(\n  lView: LView,\n  target: RElement | EventTarget,\n  eventName: string,\n  wrappedListener: WrappedEventCallback,\n): void {\n  _stashEventListenerImpl(lView, target, eventName, wrappedListener);\n}\n\n/**\n * Enables the event listener stashing logic in a tree-shakable way.\n *\n * This function lazily sets the implementation of `_stashEventListenerImpl`\n * so that it becomes active only when `withEventReplay` is invoked. This ensures\n * that the stashing logic is excluded from production builds unless needed.\n */\nexport function enableStashEventListenerImpl(): void {\n  if (!isStashEventListenerImplEnabled) {\n    _stashEventListenerImpl = (\n      lView: LView,\n      target: RElement | EventTarget,\n      eventName: string,\n      wrappedListener: EventCallback,\n    ) => {\n      const appId = lView[INJECTOR].get(APP_ID);\n      const stashEventListener = stashEventListeners.get(appId);\n      stashEventListener?.(target as RElement, eventName, wrappedListener);\n    };\n\n    isStashEventListenerImplEnabled = true;\n  }\n}\n"]}