{"version":3,"file":"ng_zone.js","sourceRoot":"","sources":["ng_zone.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Needed for the global `Zone` ambient types to be available.\nimport type {} from 'zone.js';\n\nimport {SCHEDULE_IN_ROOT_ZONE_DEFAULT} from '../change_detection/scheduling/flags';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {EventEmitter} from '../event_emitter';\nimport {scheduleCallbackWithRafRace} from '../util/callback_scheduler';\nimport {noop} from '../util/noop';\n\nimport {AsyncStackTaggingZoneSpec} from './async-stack-tagging';\n\n// The below is needed as otherwise a number of targets fail in G3 due to:\n// ERROR - [JSC_UNDEFINED_VARIABLE] variable Zone is undeclared\ndeclare const Zone: any;\n\nconst isAngularZoneProperty = 'isAngularZone';\nexport const angularZoneInstanceIdProperty = isAngularZoneProperty + '_ID';\n\nlet ngZoneInstanceId = 0;\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * import {Component, NgZone} from '@angular/core';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     @if(progress >= 100) {\n *        <p>Done processing {{label}} of Angular zone!</p>\n *     }\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class NgZone {\n  readonly hasPendingMacrotasks: boolean = false;\n  readonly hasPendingMicrotasks: boolean = false;\n\n  /**\n   * Whether there are no outstanding microtasks or macrotasks.\n   */\n  readonly isStable: boolean = true;\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  readonly onUnstable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when there is no more microtasks enqueued in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  readonly onStable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies that an error has been delivered.\n   */\n  readonly onError: EventEmitter<any> = new EventEmitter(false);\n\n  constructor(options: {\n    enableLongStackTrace?: boolean;\n    shouldCoalesceEventChangeDetection?: boolean;\n    shouldCoalesceRunChangeDetection?: boolean;\n  }) {\n    const {\n      enableLongStackTrace = false,\n      shouldCoalesceEventChangeDetection = false,\n      shouldCoalesceRunChangeDetection = false,\n      scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT,\n    } = options as InternalNgZoneOptions;\n\n    if (typeof Zone == 'undefined') {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_ZONEJS,\n        ngDevMode && `In this configuration Angular requires Zone.js`,\n      );\n    }\n\n    Zone.assertZonePatched();\n    const self = this as any as NgZonePrivate;\n    self._nesting = 0;\n\n    self._outer = self._inner = Zone.current;\n\n    // AsyncStackTaggingZoneSpec provides `linked stack traces` to show\n    // where the async operation is scheduled. For more details, refer\n    // to this article, https://developer.chrome.com/blog/devtools-better-angular-debugging/\n    // And we only import this AsyncStackTaggingZoneSpec in development mode,\n    // in the production mode, the AsyncStackTaggingZoneSpec will be tree shaken away.\n    if (ngDevMode) {\n      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));\n    }\n\n    if ((Zone as any)['TaskTrackingZoneSpec']) {\n      self._inner = self._inner.fork(new ((Zone as any)['TaskTrackingZoneSpec'] as any)());\n    }\n\n    if (enableLongStackTrace && (Zone as any)['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork((Zone as any)['longStackTraceZoneSpec']);\n    }\n    // if shouldCoalesceRunChangeDetection is true, all tasks including event tasks will be\n    // coalesced, so shouldCoalesceEventChangeDetection option is not necessary and can be skipped.\n    self.shouldCoalesceEventChangeDetection =\n      !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n    self.callbackScheduled = false;\n    self.scheduleInRootZone = scheduleInRootZone;\n    forkInnerZoneWithAngularBehavior(self);\n  }\n\n  /**\n    This method checks whether the method call happens within an Angular Zone instance.\n  */\n  static isInAngularZone(): boolean {\n    // Zone needs to be checked, because this method might be called even when NoopNgZone is used.\n    return typeof Zone !== 'undefined' && Zone.current.get(isAngularZoneProperty) === true;\n  }\n\n  /**\n    Assures that the method is called within the Angular Zone, otherwise throws an error.\n  */\n  static assertInAngularZone(): void {\n    if (!NgZone.isInAngularZone()) {\n      throw new RuntimeError(\n        RuntimeErrorCode.UNEXPECTED_ZONE_STATE,\n        ngDevMode && 'Expected to be in Angular Zone, but it is not!',\n      );\n    }\n  }\n\n  /**\n    Assures that the method is called outside of the Angular Zone, otherwise throws an error.\n  */\n  static assertNotInAngularZone(): void {\n    if (NgZone.isInAngularZone()) {\n      throw new RuntimeError(\n        RuntimeErrorCode.UNEXPECTED_ZONE_STATE,\n        ngDevMode && 'Expected to not be in Angular Zone, but it is!',\n      );\n    }\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.run(fn, applyThis, applyArgs);\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n   * returned by the function.\n   *\n   * Running functions via `runTask` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T {\n    const zone = (this as any as NgZonePrivate)._inner;\n    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return zone.runTask(task, applyThis, applyArgs);\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n\n  /**\n   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n   * rethrown.\n   */\n  runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.runGuarded(fn, applyThis, applyArgs);\n  }\n\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n   * work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return (this as any as NgZonePrivate)._outer.run(fn);\n  }\n}\n\nconst EMPTY_PAYLOAD = {};\n\nexport interface NgZonePrivate extends NgZone {\n  _outer: Zone;\n  _inner: Zone;\n  _nesting: number;\n  _hasPendingMicrotasks: boolean;\n\n  hasPendingMacrotasks: boolean;\n  hasPendingMicrotasks: boolean;\n  callbackScheduled: boolean;\n  /**\n   * A flag to indicate if NgZone is currently inside\n   * checkStable and to prevent re-entry. The flag is\n   * needed because it is possible to invoke the change\n   * detection from within change detection leading to\n   * incorrect behavior.\n   *\n   * For detail, please refer here,\n   * https://github.com/angular/angular/pull/40540\n   */\n  isCheckStableRunning: boolean;\n  isStable: boolean;\n  /**\n   * Optionally specify coalescing event change detections or not.\n   * Consider the following case.\n   *\n   * <div (click)=\"doSomething()\">\n   *   <button (click)=\"doSomethingElse()\"></button>\n   * </div>\n   *\n   * When button is clicked, because of the event bubbling, both\n   * event handlers will be called and 2 change detections will be\n   * triggered. We can coalesce such kind of events to trigger\n   * change detection only once.\n   *\n   * By default, this option will be false. So the events will not be\n   * coalesced and the change detection will be triggered multiple times.\n   * And if this option be set to true, the change detection will be\n   * triggered async by scheduling it in an animation frame. So in the case above,\n   * the change detection will only be trigged once.\n   */\n  shouldCoalesceEventChangeDetection: boolean;\n  /**\n   * Optionally specify if `NgZone#run()` method invocations should be coalesced\n   * into a single change detection.\n   *\n   * Consider the following case.\n   *\n   * for (let i = 0; i < 10; i ++) {\n   *   ngZone.run(() => {\n   *     // do something\n   *   });\n   * }\n   *\n   * This case triggers the change detection multiple times.\n   * With ngZoneRunCoalescing options, all change detections in an event loops trigger only once.\n   * In addition, the change detection executes in requestAnimation.\n   *\n   */\n  shouldCoalesceRunChangeDetection: boolean;\n\n  /**\n   * Whether to schedule the coalesced change detection in the root zone\n   */\n  scheduleInRootZone: boolean;\n}\n\nfunction checkStable(zone: NgZonePrivate) {\n  // TODO: @JiaLiPassion, should check zone.isCheckStableRunning to prevent\n  // re-entry. The case is:\n  //\n  // @Component({...})\n  // export class AppComponent {\n  // constructor(private ngZone: NgZone) {\n  //   this.ngZone.onStable.subscribe(() => {\n  //     this.ngZone.run(() => console.log('stable'););\n  //   });\n  // }\n  //\n  // The onStable subscriber run another function inside ngZone\n  // which causes `checkStable()` re-entry.\n  // But this fix causes some issues in g3, so this fix will be\n  // launched in another PR.\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\n\nfunction delayChangeDetectionForEvents(zone: NgZonePrivate) {\n  /**\n   * We also need to check _nesting here\n   * Consider the following case with shouldCoalesceRunChangeDetection = true\n   *\n   * ngZone.run(() => {});\n   * ngZone.run(() => {});\n   *\n   * We want the two `ngZone.run()` only trigger one change detection\n   * when shouldCoalesceRunChangeDetection is true.\n   * And because in this case, change detection run in async way(requestAnimationFrame),\n   * so we also need to check the _nesting here to prevent multiple\n   * change detections.\n   */\n  if (zone.isCheckStableRunning || zone.callbackScheduled) {\n    return;\n  }\n  zone.callbackScheduled = true;\n  function scheduleCheckStable() {\n    scheduleCallbackWithRafRace(() => {\n      zone.callbackScheduled = false;\n      updateMicroTaskStatus(zone);\n      zone.isCheckStableRunning = true;\n      checkStable(zone);\n      zone.isCheckStableRunning = false;\n    });\n  }\n  if (zone.scheduleInRootZone) {\n    Zone.root.run(() => {\n      scheduleCheckStable();\n    });\n  } else {\n    zone._outer.run(() => {\n      scheduleCheckStable();\n    });\n  }\n  updateMicroTaskStatus(zone);\n}\n\nfunction forkInnerZoneWithAngularBehavior(zone: NgZonePrivate) {\n  const delayChangeDetectionForEventsDelegate = () => {\n    delayChangeDetectionForEvents(zone);\n  };\n  const instanceId = ngZoneInstanceId++;\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: <any>{\n      [isAngularZoneProperty]: true,\n      [angularZoneInstanceIdProperty]: instanceId,\n      [angularZoneInstanceIdProperty + instanceId]: true,\n    },\n    onInvokeTask: (\n      delegate: ZoneDelegate,\n      current: Zone,\n      target: Zone,\n      task: Task,\n      applyThis: any,\n      applyArgs: any,\n    ): any => {\n      // Prevent triggering change detection when the flag is detected.\n      if (shouldBeIgnoredByZone(applyArgs)) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      }\n\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        if (\n          (zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask') ||\n          zone.shouldCoalesceRunChangeDetection\n        ) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n\n    onInvoke: (\n      delegate: ZoneDelegate,\n      current: Zone,\n      target: Zone,\n      callback: Function,\n      applyThis: any,\n      applyArgs?: any[],\n      source?: string,\n    ): any => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        if (\n          zone.shouldCoalesceRunChangeDetection &&\n          // Do not delay change detection when the task is the scheduler's tick.\n          // We need to synchronously trigger the stability logic so that the\n          // zone-based scheduler can prevent a duplicate ApplicationRef.tick\n          // by first checking if the scheduler tick is running. This does seem a bit roundabout,\n          // but we _do_ still want to trigger all the correct events when we exit the zone.run\n          // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which\n          // relies on these events happening after change detection runs).\n          // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate\n          // but is added here as well to prevent reads of applyArgs when not necessary\n          !zone.callbackScheduled &&\n          !isSchedulerTick(applyArgs)\n        ) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n\n    onHasTask: (\n      delegate: ZoneDelegate,\n      current: Zone,\n      target: Zone,\n      hasTaskState: HasTaskState,\n    ) => {\n      delegate.hasTask(target, hasTaskState);\n      if (current === target) {\n        // We are only interested in hasTask events which originate from our zone\n        // (A child hasTask event is not interesting to us)\n        if (hasTaskState.change == 'microTask') {\n          zone._hasPendingMicrotasks = hasTaskState.microTask;\n          updateMicroTaskStatus(zone);\n          checkStable(zone);\n        } else if (hasTaskState.change == 'macroTask') {\n          zone.hasPendingMacrotasks = hasTaskState.macroTask;\n        }\n      }\n    },\n\n    onHandleError: (delegate: ZoneDelegate, current: Zone, target: Zone, error: any): boolean => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    },\n  });\n}\n\nfunction updateMicroTaskStatus(zone: NgZonePrivate) {\n  if (\n    zone._hasPendingMicrotasks ||\n    ((zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) &&\n      zone.callbackScheduled === true)\n  ) {\n    zone.hasPendingMicrotasks = true;\n  } else {\n    zone.hasPendingMicrotasks = false;\n  }\n}\n\nfunction onEnter(zone: NgZonePrivate) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\n\nfunction onLeave(zone: NgZonePrivate) {\n  zone._nesting--;\n  checkStable(zone);\n}\n\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nexport class NoopNgZone implements NgZone {\n  readonly hasPendingMicrotasks = false;\n  readonly hasPendingMacrotasks = false;\n  readonly isStable = true;\n  readonly onUnstable = new EventEmitter<any>();\n  readonly onMicrotaskEmpty = new EventEmitter<any>();\n  readonly onStable = new EventEmitter<any>();\n  readonly onError = new EventEmitter<any>();\n\n  run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any): T {\n    return fn.apply(applyThis, applyArgs);\n  }\n\n  runGuarded<T>(fn: (...args: any[]) => any, applyThis?: any, applyArgs?: any): T {\n    return fn.apply(applyThis, applyArgs);\n  }\n\n  runOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return fn();\n  }\n\n  runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any, name?: string): T {\n    return fn.apply(applyThis, applyArgs);\n  }\n}\n\nfunction shouldBeIgnoredByZone(applyArgs: unknown): boolean {\n  return hasApplyArgsData(applyArgs, '__ignore_ng_zone__');\n}\n\nfunction isSchedulerTick(applyArgs: unknown): boolean {\n  return hasApplyArgsData(applyArgs, '__scheduler_tick__');\n}\n\nfunction hasApplyArgsData(applyArgs: unknown, key: string) {\n  if (!Array.isArray(applyArgs)) {\n    return false;\n  }\n\n  // We should only ever get 1 arg passed through to invokeTask.\n  // Short circuit here incase that behavior changes.\n  if (applyArgs.length !== 1) {\n    return false;\n  }\n\n  return applyArgs[0]?.data?.[key] === true;\n}\n\n// Set of options recognized by the NgZone.\nexport interface InternalNgZoneOptions {\n  enableLongStackTrace?: boolean;\n  shouldCoalesceEventChangeDetection?: boolean;\n  shouldCoalesceRunChangeDetection?: boolean;\n  scheduleInRootZone?: boolean;\n}\n\nexport function getNgZone(\n  ngZoneToUse: NgZone | 'zone.js' | 'noop' = 'zone.js',\n  options: InternalNgZoneOptions,\n): NgZone {\n  if (ngZoneToUse === 'noop') {\n    return new NoopNgZone();\n  }\n  if (ngZoneToUse === 'zone.js') {\n    return new NgZone(options);\n  }\n  return ngZoneToUse;\n}\n"]}