{"version":3,"file":"utils.js","sourceRoot":"","sources":["utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {stringify} from '../util/stringify'; // Adjust imports as per actual location\nimport {ANIMATIONS_DISABLED, LongestAnimation} from './interfaces';\nimport {INJECTOR, LView, DECLARATION_LCONTAINER, ANIMATIONS} from '../render3/interfaces/view';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Renderer} from '../render3/interfaces/renderer';\nimport {RElement} from '../render3/interfaces/renderer_dom';\nimport {TNode} from '../render3/interfaces/node';\nimport {getBeforeNodeForView} from '../render3/node_manipulation';\n\nconst DEFAULT_ANIMATIONS_DISABLED = false;\n\nexport const areAnimationSupported =\n  (typeof ngServerMode === 'undefined' || !ngServerMode) &&\n  typeof document !== 'undefined' &&\n  // tslint:disable-next-line:no-toplevel-property-access\n  typeof document?.documentElement?.getAnimations === 'function';\n\n/**\n * Helper function to check if animations are disabled via injection token\n */\nexport function areAnimationsDisabled(lView: LView): boolean {\n  const injector = lView[INJECTOR]!;\n  return injector.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n}\n\n/**\n * Asserts a value passed in is actually an animation type and not something else\n */\nexport function assertAnimationTypes(value: string | Function, instruction: string) {\n  if (value == null || (typeof value !== 'string' && typeof value !== 'function')) {\n    throw new RuntimeError(\n      RuntimeErrorCode.ANIMATE_INVALID_VALUE,\n      `'${instruction}' value must be a string of CSS classes or an animation function, got ${stringify(value)}`,\n    );\n  }\n}\n\n/**\n * Asserts a given native element is an actual Element node and not something like a comment node.\n */\nexport function assertElementNodes(nativeElement: Element, instruction: string) {\n  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n    throw new RuntimeError(\n      RuntimeErrorCode.ANIMATE_INVALID_VALUE,\n      `'${instruction}' can only be used on an element node, got ${stringify((nativeElement as Node).nodeType)}`,\n    );\n  }\n}\n\n/**\n * trackEnterClasses is necessary in the case of composition where animate.enter\n * is used on the same element in multiple places, like on the element and in a\n * host binding. When removing classes, we need the entire list of animation classes\n * added to properly remove them when the longest animation fires.\n */\nexport function trackEnterClasses(el: HTMLElement, classList: string[], cleanupFns: Function[]) {\n  const elementData = enterClassMap.get(el);\n  if (elementData) {\n    for (const klass of classList) {\n      elementData.classList.push(klass);\n    }\n    for (const fn of cleanupFns) {\n      elementData.cleanupFns.push(fn);\n    }\n  } else {\n    enterClassMap.set(el, {classList, cleanupFns});\n  }\n}\n\n/**\n * Helper function to cleanup enterClassMap data safely\n */\nexport function cleanupEnterClassData(element: HTMLElement): void {\n  const elementData = enterClassMap.get(element);\n  if (elementData) {\n    for (const fn of elementData.cleanupFns) {\n      fn();\n    }\n    enterClassMap.delete(element);\n  }\n  longestAnimations.delete(element);\n}\n\nexport const noOpAnimationComplete = () => {};\n\n// Tracks the list of classes added to a DOM node from `animate.enter` calls to ensure\n// we remove all of the classes in the case of animation composition via host bindings.\nexport const enterClassMap = new WeakMap<\n  HTMLElement,\n  {classList: string[]; cleanupFns: Function[]}\n>();\nexport const longestAnimations = new WeakMap<HTMLElement, LongestAnimation>();\n\n// Tracks nodes that are animating away for the duration of the animation. This is\n// used to prevent duplicate nodes from showing up when nodes have been toggled quickly\n// from an `@if` or `@for`.\nexport const leavingNodes = new WeakMap<TNode, HTMLElement[]>();\n\n/**\n * This actually removes the leaving HTML Element in the TNode\n */\nexport function clearLeavingNodes(tNode: TNode, el: HTMLElement): void {\n  const nodes = leavingNodes.get(tNode);\n  if (nodes && nodes.length > 0) {\n    const ix = nodes.findIndex((node) => node === el);\n    if (ix > -1) nodes.splice(ix, 1);\n  }\n  if (nodes?.length === 0) {\n    leavingNodes.delete(tNode);\n  }\n}\n\n/**\n * In the case that we have an existing node that's animating away, like when\n * an `@if` toggles quickly, we need to end the animation for the former node\n * and remove it right away to prevent duplicate nodes showing up.\n */\nexport function cancelLeavingNodes(tNode: TNode, lView: LView): void {\n  const leavingEl = leavingNodes.get(tNode)?.shift();\n  const lContainer = lView[DECLARATION_LCONTAINER];\n  if (lContainer) {\n    // this is the insertion point for the new TNode element.\n    // it will be inserted before the declaring containers anchor.\n    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);\n    // here we need to check the previous sibling of that anchor. The first\n    // previousSibling node will be the new element added. The second\n    // previousSibling will be the one that's being removed.\n    const previousNode = beforeNode?.previousSibling;\n    // We really only want to cancel animations if the leaving node is the\n    // same as the node before where the new node will be inserted. This is\n    // the control flow scenario where an if was toggled.\n    if (leavingEl && previousNode && leavingEl === previousNode) {\n      leavingEl.dispatchEvent(new CustomEvent('animationend', {detail: {cancel: true}}));\n    }\n  }\n}\n\n/**\n * Tracks the nodes list of nodes that are leaving the DOM so we can cancel any leave animations\n * and remove the node before adding a new entering instance of the DOM node. This prevents\n * duplicates from showing up on screen mid-animation.\n */\nexport function trackLeavingNodes(tNode: TNode, el: HTMLElement): void {\n  // We need to track this tNode's element just to be sure we don't add\n  // a new RNode for this TNode while this one is still animating away.\n  // once the animation is complete, we remove this reference.\n  if (leavingNodes.has(tNode)) {\n    leavingNodes.get(tNode)?.push(el);\n  } else {\n    leavingNodes.set(tNode, [el]);\n  }\n}\n\n/**\n * Retrieves the list of specified enter animations from the lView\n */\nexport function getLViewEnterAnimations(lView: LView): Function[] {\n  const animationData = (lView[ANIMATIONS] ??= {});\n  return (animationData.enter ??= []);\n}\n\n/**\n * Retrieves the list of specified leave animations from the lView\n */\nexport function getLViewLeaveAnimations(lView: LView): Function[] {\n  const animationData = (lView[ANIMATIONS] ??= {});\n  return (animationData.leave ??= []);\n}\n\n/**\n * Gets the list of classes from a passed in value\n */\nexport function getClassListFromValue(value: string | Function | string[]): string[] | null {\n  const classes = typeof value === 'function' ? value() : value;\n  let classList: string[] | null = Array.isArray(classes) ? classes : null;\n  if (typeof classes === 'string') {\n    classList = classes\n      .trim()\n      .split(/\\s+/)\n      .filter((k) => k);\n  }\n  return classList;\n}\n\n/**\n * Cancels any running enter animations on a given element to prevent them from interfering\n * with leave animations.\n */\nexport function cancelAnimationsIfRunning(element: HTMLElement, renderer: Renderer): void {\n  if (!areAnimationSupported) return;\n  const elementData = enterClassMap.get(element);\n  if (\n    elementData &&\n    elementData.classList.length > 0 &&\n    elementHasClassList(element, elementData.classList)\n  ) {\n    for (const klass of elementData.classList) {\n      renderer.removeClass(element as unknown as RElement, klass);\n    }\n  }\n  // We need to prevent any enter animation listeners from firing if they exist.\n  cleanupEnterClassData(element);\n}\n\n/**\n * Checks if a given element contains the classes is a provided list\n */\nexport function elementHasClassList(element: HTMLElement, classList: string[]): boolean {\n  for (const className of classList) {\n    if (element.classList.contains(className)) return true;\n  }\n  return false;\n}\n\n/**\n * Determines if the animation or transition event is currently the expected longest animation\n * based on earlier determined data in `longestAnimations`\n *\n * @param event\n * @param nativeElement\n * @returns\n */\nexport function isLongestAnimation(\n  event: AnimationEvent | TransitionEvent,\n  nativeElement: HTMLElement,\n): boolean {\n  const longestAnimation = longestAnimations.get(nativeElement);\n  return (\n    nativeElement === event.target &&\n    longestAnimation !== undefined &&\n    ((longestAnimation.animationName !== undefined &&\n      (event as AnimationEvent).animationName === longestAnimation.animationName) ||\n      (longestAnimation.propertyName !== undefined &&\n        (event as TransitionEvent).propertyName === longestAnimation.propertyName))\n  );\n}\n\n/**\n * Determines if a given tNode is a content projection root node.\n */\nexport function isTNodeContentProjectionRoot(tNode: TNode): boolean {\n  return Array.isArray(tNode.projection);\n}\n"]}