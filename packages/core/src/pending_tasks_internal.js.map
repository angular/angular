{"version":3,"file":"pending_tasks_internal.js","sourceRoot":"","sources":["pending_tasks_internal.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,eAAe,EAAE,UAAU,EAAC,MAAM,MAAM,CAAC;AAEjD,OAAO,EAAC,kBAAkB,EAAC,MAAM,qBAAqB,CAAC;AAGvD;;GAEG;AAEH,MAAM,OAAO,oBAAoB;IAAjC;QACU,WAAM,GAAG,CAAC,CAAC;QACX,iBAAY,GAAG,IAAI,GAAG,EAAU,CAAC;QACjC,cAAS,GAAG,KAAK,CAAC;QAElB,gBAAW,GAAG,IAAI,eAAe,CAAU,KAAK,CAAC,CAAC;IAgE5D,CAAC;IA9DC,IAAI,eAAe;QACjB,qEAAqE;QACrE,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;IACzD,CAAC;IAED;;;OAGG;IACH,IAAI,yBAAyB;QAC3B,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACnB,kFAAkF;YAClF,OAAO,IAAI,UAAU,CAAU,CAAC,UAAU,EAAE,EAAE;gBAC5C,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACvB,UAAU,CAAC,QAAQ,EAAE,CAAC;YACxB,CAAC,CAAC,CAAC;QACL,CAAC;QAED,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,GAAG;QACD,wDAAwD;QACxD,IAAI,CAAC,IAAI,CAAC,eAAe,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YAC7C,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9B,CAAC;QACD,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;QAC7B,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC9B,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,GAAG,CAAC,MAAc;QAChB,OAAO,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACvC,CAAC;IAED,MAAM,CAAC,MAAc;QACnB,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACjC,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,KAAK,CAAC,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YACzD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC/B,CAAC;IACH,CAAC;IAED,WAAW;QACT,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;QAC1B,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YACzB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC/B,CAAC;QACD,uEAAuE;QACvE,sEAAsE;QACtE,6EAA6E;QAC7E,iEAAiE;QACjE,4BAA4B;QAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,CAAC;IACjC,CAAC;;AAED,kBAAkB;AACX,0BAAK,GAA6C,kBAAkB,CAAC;IAC1E,KAAK,EAAE,oBAAoB;IAC3B,UAAU,EAAE,MAAM;IAClB,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,oBAAoB,EAAE;CAC1C,CAAC,AAJU,CAIT","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BehaviorSubject, Observable} from 'rxjs';\n\nimport {ɵɵdefineInjectable} from './di/interface/defs';\nimport {OnDestroy} from './interface/lifecycle_hooks';\n\n/**\n * Internal implementation of the pending tasks service.\n */\n\nexport class PendingTasksInternal implements OnDestroy {\n  private taskId = 0;\n  private pendingTasks = new Set<number>();\n  private destroyed = false;\n\n  private pendingTask = new BehaviorSubject<boolean>(false);\n\n  get hasPendingTasks(): boolean {\n    // Accessing the value of a closed `BehaviorSubject` throws an error.\n    return this.destroyed ? false : this.pendingTask.value;\n  }\n\n  /**\n   * In case the service is about to be destroyed, return a self-completing observable.\n   * Otherwise, return the observable that emits the current state of pending tasks.\n   */\n  get hasPendingTasksObservable(): Observable<boolean> {\n    if (this.destroyed) {\n      // Manually creating the observable pulls less symbols from RxJS than `of(false)`.\n      return new Observable<boolean>((subscriber) => {\n        subscriber.next(false);\n        subscriber.complete();\n      });\n    }\n\n    return this.pendingTask;\n  }\n\n  add(): number {\n    // Emitting a value to a closed subject throws an error.\n    if (!this.hasPendingTasks && !this.destroyed) {\n      this.pendingTask.next(true);\n    }\n    const taskId = this.taskId++;\n    this.pendingTasks.add(taskId);\n    return taskId;\n  }\n\n  has(taskId: number): boolean {\n    return this.pendingTasks.has(taskId);\n  }\n\n  remove(taskId: number): void {\n    this.pendingTasks.delete(taskId);\n    if (this.pendingTasks.size === 0 && this.hasPendingTasks) {\n      this.pendingTask.next(false);\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.pendingTasks.clear();\n    if (this.hasPendingTasks) {\n      this.pendingTask.next(false);\n    }\n    // We call `unsubscribe()` to release observers, as users may forget to\n    // unsubscribe manually when subscribing to `isStable`. We do not call\n    // `complete()` because it is unsafe; if someone subscribes using the `first`\n    // operator and the observable completes before emitting a value,\n    // RxJS will throw an error.\n    this.destroyed = true;\n    this.pendingTask.unsubscribe();\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: PendingTasksInternal,\n    providedIn: 'root',\n    factory: () => new PendingTasksInternal(),\n  });\n}\n"]}