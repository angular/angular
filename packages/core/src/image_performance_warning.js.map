{"version":3,"file":"image_performance_warning.js","sourceRoot":"","sources":["image_performance_warning.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {IMAGE_CONFIG, ImageConfig} from './application/application_tokens';\nimport {Injectable} from './di';\nimport {inject} from './di/injector_compatibility';\nimport {formatRuntimeError, RuntimeErrorCode} from './errors';\nimport {OnDestroy} from './interface/lifecycle_hooks';\nimport {getDocument} from './render3/interfaces/document';\n\n// A delay in milliseconds before the scan is run after onLoad, to avoid any\n// potential race conditions with other LCP-related functions. This delay\n// happens outside of the main JavaScript execution and will only effect the timing\n// on when the warning becomes visible in the console.\nconst SCAN_DELAY = 200;\n\nconst OVERSIZED_IMAGE_TOLERANCE = 1200;\n\n@Injectable({providedIn: 'root'})\nexport class ImagePerformanceWarning implements OnDestroy {\n  // Map of full image URLs -> original `ngSrc` values.\n  private window: Window | null = null;\n  private observer: PerformanceObserver | null = null;\n  private options: ImageConfig = inject(IMAGE_CONFIG);\n  private lcpImageUrl?: string;\n\n  public start() {\n    if (\n      (typeof ngServerMode !== 'undefined' && ngServerMode) ||\n      typeof PerformanceObserver === 'undefined' ||\n      (this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning)\n    ) {\n      return;\n    }\n    this.observer = this.initPerformanceObserver();\n    const doc = getDocument();\n    const win = doc.defaultView;\n    if (win) {\n      this.window = win;\n      // Wait to avoid race conditions where LCP image triggers\n      // load event before it's recorded by the performance observer\n      const waitToScan = () => {\n        setTimeout(this.scanImages.bind(this), SCAN_DELAY);\n      };\n      const setup = () => {\n        // Consider the case when the application is created and destroyed multiple times.\n        // Typically, applications are created instantly once the page is loaded, and the\n        // `window.load` listener is always triggered. However, the `window.load` event will never\n        // be fired if the page is loaded, and the application is created later. Checking for\n        // `readyState` is the easiest way to determine whether the page has been loaded or not.\n        if (doc.readyState === 'complete') {\n          waitToScan();\n        } else {\n          this.window?.addEventListener('load', waitToScan, {once: true});\n        }\n      };\n      // Angular doesn't have to run change detection whenever any asynchronous tasks are invoked in\n      // the scope of this functionality.\n      if (typeof Zone !== 'undefined') {\n        Zone.root.run(() => setup());\n      } else {\n        setup();\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this.observer?.disconnect();\n  }\n\n  private initPerformanceObserver(): PerformanceObserver | null {\n    if (typeof PerformanceObserver === 'undefined') {\n      return null;\n    }\n    const observer = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries();\n      if (entries.length === 0) return;\n      // We use the latest entry produced by the `PerformanceObserver` as the best\n      // signal on which element is actually an LCP one. As an example, the first image to load on\n      // a page, by virtue of being the only thing on the page so far, is often a LCP candidate\n      // and gets reported by PerformanceObserver, but isn't necessarily the LCP element.\n      const lcpElement = entries[entries.length - 1];\n\n      // Cast to `any` due to missing `element` on the `LargestContentfulPaint` type of entry.\n      // See https://developer.mozilla.org/en-US/docs/Web/API/LargestContentfulPaint\n      const imgSrc = (lcpElement as any).element?.src ?? '';\n\n      // Exclude `data:` and `blob:` URLs, since they are fetched resources.\n      if (imgSrc.startsWith('data:') || imgSrc.startsWith('blob:')) return;\n      this.lcpImageUrl = imgSrc;\n    });\n    observer.observe({type: 'largest-contentful-paint', buffered: true});\n    return observer;\n  }\n\n  private scanImages(): void {\n    const images = getDocument().querySelectorAll('img');\n    let lcpElementFound,\n      lcpElementLoadedCorrectly = false;\n    // Important: do not refactor this to use `images.forEach` or\n    // `for (const ... of ...)`, because images might be a custom internal\n    // data structure — such as a lazily evaluated query result in Domino.\n    // (This naturally would never be a case in any browser).\n    for (let index = 0; index < images.length; index++) {\n      const image = images[index];\n\n      if (!image) {\n        continue;\n      }\n\n      if (!this.options?.disableImageSizeWarning) {\n        // Image elements using the NgOptimizedImage directive are excluded,\n        // as that directive has its own version of this check.\n        if (!image.getAttribute('ng-img') && this.isOversized(image)) {\n          logOversizedImageWarning(image.src);\n        }\n      }\n      if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {\n        if (image.src === this.lcpImageUrl) {\n          lcpElementFound = true;\n          if (image.loading !== 'lazy' || image.getAttribute('ng-img')) {\n            // This variable is set to true and never goes back to false to account\n            // for the case where multiple images have the same src url, and some\n            // have lazy loading while others don't.\n            // Also ignore NgOptimizedImage because there's a different warning for that.\n            lcpElementLoadedCorrectly = true;\n          }\n        }\n      }\n    }\n    if (\n      lcpElementFound &&\n      !lcpElementLoadedCorrectly &&\n      this.lcpImageUrl &&\n      !this.options?.disableImageLazyLoadWarning\n    ) {\n      logLazyLCPWarning(this.lcpImageUrl);\n    }\n  }\n\n  private isOversized(image: HTMLImageElement): boolean {\n    if (!this.window) {\n      return false;\n    }\n\n    // The `isOversized` check may not be applicable or may require adjustments\n    // for several types of image formats or scenarios. Currently, we specify only\n    // `svg`, but this may also include `gif` since their quality isn’t tied to\n    // dimensions in the same way as raster images.\n    const nonOversizedImageExtentions = [\n      // SVG images are vector-based, which means they can scale\n      // to any size without losing quality.\n      '.svg',\n    ];\n\n    // Convert it to lowercase because this may have uppercase\n    // extensions, such as `IMAGE.SVG`.\n    // We fallback to an empty string because `src` may be `undefined`\n    // if it is explicitly set to `null` by some third-party code\n    // (e.g., `image.src = null`).\n    const imageSource = (image.src || '').toLowerCase();\n\n    if (nonOversizedImageExtentions.some((extension) => imageSource.endsWith(extension))) {\n      return false;\n    }\n\n    const computedStyle = this.window.getComputedStyle(image);\n    let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));\n    let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));\n    const boxSizing = computedStyle.getPropertyValue('box-sizing');\n    const objectFit = computedStyle.getPropertyValue('object-fit');\n\n    if (objectFit === `cover`) {\n      // Object fit cover may indicate a use case such as a sprite sheet where\n      // this warning does not apply.\n      return false;\n    }\n\n    if (boxSizing === 'border-box') {\n      // If the image `box-sizing` is set to `border-box`, we adjust the rendered\n      // dimensions by subtracting padding values.\n      const paddingTop = computedStyle.getPropertyValue('padding-top');\n      const paddingRight = computedStyle.getPropertyValue('padding-right');\n      const paddingBottom = computedStyle.getPropertyValue('padding-bottom');\n      const paddingLeft = computedStyle.getPropertyValue('padding-left');\n      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);\n      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);\n    }\n\n    const intrinsicWidth = image.naturalWidth;\n    const intrinsicHeight = image.naturalHeight;\n\n    const recommendedWidth = this.window.devicePixelRatio * renderedWidth;\n    const recommendedHeight = this.window.devicePixelRatio * renderedHeight;\n    const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;\n    const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;\n    return oversizedWidth || oversizedHeight;\n  }\n}\n\nfunction logLazyLCPWarning(src: string) {\n  console.warn(\n    formatRuntimeError(\n      RuntimeErrorCode.IMAGE_PERFORMANCE_WARNING,\n      `An image with src ${src} is the Largest Contentful Paint (LCP) element ` +\n        `but was given a \"loading\" value of \"lazy\", which can negatively impact ` +\n        `application loading performance. This warning can be addressed by ` +\n        `changing the loading value of the LCP image to \"eager\", or by using the ` +\n        `NgOptimizedImage directive's prioritization utilities. For more ` +\n        `information about addressing or disabling this warning, see ` +\n        `https://angular.dev/errors/NG0913`,\n    ),\n  );\n}\n\nfunction logOversizedImageWarning(src: string) {\n  console.warn(\n    formatRuntimeError(\n      RuntimeErrorCode.IMAGE_PERFORMANCE_WARNING,\n      `An image with src ${src} has intrinsic file dimensions much larger than its ` +\n        `rendered size. This can negatively impact application loading performance. ` +\n        `For more information about addressing or disabling this warning, see ` +\n        `https://angular.dev/errors/NG0913`,\n    ),\n  );\n}\n"]}