{"version":3,"file":"application_ref.js","sourceRoot":"","sources":["application_ref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport '../util/ng_hmr_mode';\nimport '../util/ng_jit_mode';\nimport '../util/ng_server_mode';\n\nimport {\n  setActiveConsumer,\n  getActiveConsumer,\n  setThrowInvalidWriteToSignalError,\n} from '../../primitives/signals';\nimport {type Observable, Subject, type Subscription} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {ZONELESS_ENABLED} from '../change_detection/scheduling/zoneless_scheduling';\nimport {Console} from '../console';\nimport {inject} from '../di';\nimport {Injectable} from '../di/injectable';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {EnvironmentInjector, type R3Injector} from '../di/r3_injector';\nimport {formatRuntimeError, RuntimeError, RuntimeErrorCode} from '../errors';\nimport {INTERNAL_APPLICATION_ERROR_HANDLER} from '../error_handler';\nimport {Type} from '../interface/type';\nimport {ComponentFactory, ComponentRef} from '../linker/component_factory';\nimport {ComponentFactoryResolver} from '../linker/component_factory_resolver';\nimport {NgModuleRef} from '../linker/ng_module_factory';\nimport {ViewRef} from '../linker/view_ref';\nimport {PendingTasksInternal} from '../pending_tasks_internal';\nimport {RendererFactory2} from '../render/api';\nimport {AfterRenderManager} from '../render3/after_render/manager';\nimport {ComponentFactory as R3ComponentFactory} from '../render3/component_ref';\nimport {isStandalone} from '../render3/def_getters';\nimport {ChangeDetectionMode, detectChangesInternal} from '../render3/instructions/change_detection';\nimport {LView} from '../render3/interfaces/view';\nimport {publishDefaultGlobalUtils as _publishDefaultGlobalUtils} from '../render3/util/global_utils';\nimport {requiresRefreshOrTraversal} from '../render3/util/view_utils';\nimport {ViewRef as InternalViewRef} from '../render3/view_ref';\nimport {TESTABILITY} from '../testability/testability';\nimport {NgZone} from '../zone/ng_zone';\n\nimport {profiler} from '../render3/profiler';\nimport {ProfilerEvent} from '../render3/profiler_types';\nimport {EffectScheduler} from '../render3/reactivity/root_effect_scheduler';\nimport {isReactiveLViewConsumer} from '../render3/reactive_lview_consumer';\nimport {ApplicationInitStatus} from './application_init';\nimport {TracingAction, TracingService, TracingSnapshot} from './tracing';\n\n/**\n * A DI token that provides a set of callbacks to\n * be called for every component that is bootstrapped.\n *\n * Each callback must take a `ComponentRef` instance and return nothing.\n *\n * `(componentRef: ComponentRef) => void`\n *\n * @publicApi\n */\nexport const APP_BOOTSTRAP_LISTENER = new InjectionToken<\n  ReadonlyArray<(compRef: ComponentRef<any>) => void>\n>(ngDevMode ? 'appBootstrapListener' : '');\n\nexport function publishDefaultGlobalUtils() {\n  ngDevMode && _publishDefaultGlobalUtils();\n}\n\n/**\n * Sets the error for an invalid write to a signal to be an Angular `RuntimeError`.\n */\nexport function publishSignalConfiguration(): void {\n  setThrowInvalidWriteToSignalError(() => {\n    let errorMessage = '';\n    if (ngDevMode) {\n      const activeConsumer = getActiveConsumer();\n      errorMessage =\n        activeConsumer && isReactiveLViewConsumer(activeConsumer)\n          ? 'Writing to signals is not allowed while Angular renders the template (eg. interpolations)'\n          : 'Writing to signals is not allowed in a `computed`';\n    }\n    throw new RuntimeError(RuntimeErrorCode.SIGNAL_WRITE_FROM_ILLEGAL_CONTEXT, errorMessage);\n  });\n}\n\nexport function isBoundToModule<C>(cf: ComponentFactory<C>): boolean {\n  return (cf as R3ComponentFactory<C>).isBoundToModule;\n}\n\n/**\n * Provides additional options to the bootstrapping process.\n *\n * @publicApi\n * @deprecated 20.2 Configure `NgZone` in the `providers` array of the application module instead.\n */\nexport interface BootstrapOptions {\n  /**\n   * Optionally specify which `NgZone` should be used when not configured in the providers.\n   *\n   * - Provide your own `NgZone` instance.\n   * - `zone.js` - Use default `NgZone` which requires `Zone.js`.\n   * - `noop` - Use `NoopNgZone` which does nothing.\n   *\n   * @deprecated BootstrapOptions is deprecated. Provide `NgZone` in the `providers` array of the module instead.\n   */\n  ngZone?: NgZone | 'zone.js' | 'noop';\n\n  /**\n   * Optionally specify coalescing event change detections or not.\n   * Consider the following case.\n   *\n   * ```html\n   * <div (click)=\"doSomething()\">\n   *   <button (click)=\"doSomethingElse()\"></button>\n   * </div>\n   * ```\n   *\n   * When button is clicked, because of the event bubbling, both\n   * event handlers will be called and 2 change detections will be\n   * triggered. We can coalesce such kind of events to only trigger\n   * change detection only once.\n   *\n   * By default, this option will be false. So the events will not be\n   * coalesced and the change detection will be triggered multiple times.\n   * And if this option be set to true, the change detection will be\n   * triggered async by scheduling a animation frame. So in the case above,\n   * the change detection will only be triggered once.\n   *\n   * @deprecated BootstrapOptions is deprecated. Use `provideZoneChangeDetection` instead to configure coalescing.\n   */\n  ngZoneEventCoalescing?: boolean;\n\n  /**\n   * Optionally specify if `NgZone#run()` method invocations should be coalesced\n   * into a single change detection.\n   *\n   * Consider the following case.\n   * ```ts\n   * for (let i = 0; i < 10; i ++) {\n   *   ngZone.run(() => {\n   *     // do something\n   *   });\n   * }\n   * ```\n   *\n   * This case triggers the change detection multiple times.\n   * With ngZoneRunCoalescing options, all change detections in an event loop trigger only once.\n   * In addition, the change detection executes in requestAnimation.\n   *\n   * @deprecated BootstrapOptions is deprecated. Use `provideZoneChangeDetection` instead to configure coalescing.\n   */\n  ngZoneRunCoalescing?: boolean;\n}\n\n/** Maximum number of times ApplicationRef will refresh all attached views in a single tick. */\nconst MAXIMUM_REFRESH_RERUNS = 10;\n\nexport function optionsReducer<T extends Object>(dst: T, objs: T | T[]): T {\n  if (Array.isArray(objs)) {\n    return objs.reduce(optionsReducer, dst);\n  }\n  return {...dst, ...objs};\n}\n\n/**\n * A reference to an Angular application running on a page.\n *\n * @usageNotes\n * ### isStable examples and caveats\n *\n * Note two important points about `isStable`, demonstrated in the examples below:\n * - the application will never be stable if you start any kind\n * of recurrent asynchronous task when the application starts\n * (for example for a polling process, started with a `setInterval`, a `setTimeout`\n * or using RxJS operators like `interval`);\n * - the `isStable` Observable runs outside of the Angular zone.\n *\n * Let's imagine that you start a recurrent task\n * (here incrementing a counter, using RxJS `interval`),\n * and at the same time subscribe to `isStable`.\n *\n * ```ts\n * constructor(appRef: ApplicationRef) {\n *   appRef.isStable.pipe(\n *      filter(stable => stable)\n *   ).subscribe(() => console.log('App is stable now');\n *   interval(1000).subscribe(counter => console.log(counter));\n * }\n * ```\n * In this example, `isStable` will never emit `true`,\n * and the trace \"App is stable now\" will never get logged.\n *\n * If you want to execute something when the app is stable,\n * you have to wait for the application to be stable\n * before starting your polling process.\n *\n * ```ts\n * constructor(appRef: ApplicationRef) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     tap(stable => console.log('App is stable now')),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => console.log(counter));\n * }\n * ```\n * In this example, the trace \"App is stable now\" will be logged\n * and then the counter starts incrementing every second.\n *\n * Note also that this Observable runs outside of the Angular zone,\n * which means that the code in the subscription\n * to this Observable will not trigger the change detection.\n *\n * Let's imagine that instead of logging the counter value,\n * you update a field of your component\n * and display it in its template.\n *\n * ```ts\n * constructor(appRef: ApplicationRef) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => this.value = counter);\n * }\n * ```\n * As the `isStable` Observable runs outside the zone,\n * the `value` field will be updated properly,\n * but the template will not be refreshed!\n *\n * You'll have to manually trigger the change detection to update the template.\n *\n * ```ts\n * constructor(appRef: ApplicationRef, cd: ChangeDetectorRef) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => {\n *     this.value = counter;\n *     cd.detectChanges();\n *   });\n * }\n * ```\n *\n * Or make the subscription callback run inside the zone.\n *\n * ```ts\n * constructor(appRef: ApplicationRef, zone: NgZone) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => zone.run(() => this.value = counter));\n * }\n * ```\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class ApplicationRef {\n  /** @internal */\n  _runningTick: boolean = false;\n  private _destroyed = false;\n  private _destroyListeners: Array<() => void> = [];\n  /** @internal */\n  _views: InternalViewRef<unknown>[] = [];\n  private readonly internalErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n  private readonly afterRenderManager = inject(AfterRenderManager);\n  private readonly zonelessEnabled = inject(ZONELESS_ENABLED);\n  private readonly rootEffectScheduler = inject(EffectScheduler);\n\n  /**\n   * Current dirty state of the application across a number of dimensions (views, afterRender hooks,\n   * etc).\n   *\n   * A flag set here means that `tick()` will attempt to resolve the dirtiness when executed.\n   *\n   * @internal\n   */\n  dirtyFlags = ApplicationRefDirtyFlags.None;\n\n  /**\n   * Most recent snapshot from the `TracingService`, if any.\n   *\n   * This snapshot attempts to capture the context when `tick()` was first\n   * scheduled. It then runs wrapped in this context.\n   *\n   * @internal\n   */\n  tracingSnapshot: TracingSnapshot | null = null;\n\n  // Needed for ComponentFixture temporarily during migration of autoDetect behavior\n  // Eventually the hostView of the fixture should just attach to ApplicationRef.\n  private allTestViews: Set<InternalViewRef<unknown>> = new Set();\n  private autoDetectTestViews: Set<InternalViewRef<unknown>> = new Set();\n  private includeAllTestViews = false;\n  /** @internal */\n  afterTick = new Subject<void>();\n  /** @internal */\n  get allViews(): Array<InternalViewRef<unknown>> {\n    return [\n      ...(this.includeAllTestViews ? this.allTestViews : this.autoDetectTestViews).keys(),\n      ...this._views,\n    ];\n  }\n\n  /**\n   * Indicates whether this instance was destroyed.\n   */\n  get destroyed() {\n    return this._destroyed;\n  }\n\n  /**\n   * Get a list of component types registered to this application.\n   * This list is populated even before the component is created.\n   */\n  public readonly componentTypes: Type<any>[] = [];\n\n  /**\n   * Get a list of components registered to this application.\n   */\n  public readonly components: ComponentRef<any>[] = [];\n\n  private internalPendingTask = inject(PendingTasksInternal);\n\n  /**\n   * Returns an Observable that indicates when the application is stable or unstable.\n   */\n  public get isStable(): Observable<boolean> {\n    // This is a getter because it might be invoked after the application has been destroyed.\n    return this.internalPendingTask.hasPendingTasksObservable.pipe(map((pending) => !pending));\n  }\n\n  constructor() {\n    // Inject the tracing service to initialize it.\n    inject(TracingService, {optional: true});\n  }\n\n  /**\n   * @returns A promise that resolves when the application becomes stable\n   */\n  whenStable(): Promise<void> {\n    let subscription: Subscription;\n    return new Promise<void>((resolve) => {\n      subscription = this.isStable.subscribe({\n        next: (stable) => {\n          if (stable) {\n            resolve();\n          }\n        },\n      });\n    }).finally(() => {\n      subscription.unsubscribe();\n    });\n  }\n\n  private readonly _injector = inject(EnvironmentInjector);\n  private _rendererFactory: RendererFactory2 | null = null;\n\n  /**\n   * The `EnvironmentInjector` used to create this application.\n   */\n  get injector(): EnvironmentInjector {\n    return this._injector;\n  }\n\n  /**\n   * Bootstrap a component onto the element identified by its selector or, optionally, to a\n   * specified element.\n   *\n   * @usageNotes\n   * ### Bootstrap process\n   *\n   * When bootstrapping a component, Angular mounts it onto a target DOM element\n   * and kicks off automatic change detection. The target DOM element can be\n   * provided using the `rootSelectorOrNode` argument.\n   *\n   * If the target DOM element is not provided, Angular tries to find one on a page\n   * using the `selector` of the component that is being bootstrapped\n   * (first matched element is used).\n   *\n   * ### Example\n   *\n   * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,\n   * but it requires us to know the component while writing the application code.\n   *\n   * Imagine a situation where we have to wait for an API call to decide about the component to\n   * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to\n   * dynamically bootstrap a component.\n   *\n   * {@example core/ts/platform/platform.ts region='componentSelector'}\n   *\n   * Optionally, a component can be mounted onto a DOM element that does not match the\n   * selector of the bootstrapped component.\n   *\n   * In the following example, we are providing a CSS selector to match the target element.\n   *\n   * {@example core/ts/platform/platform.ts region='cssSelector'}\n   *\n   * While in this example, we are providing reference to a DOM node.\n   *\n   * {@example core/ts/platform/platform.ts region='domNode'}\n   */\n  bootstrap<C>(component: Type<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;\n\n  /**\n   * Bootstrap a component onto the element identified by its selector or, optionally, to a\n   * specified element.\n   *\n   * @usageNotes\n   * ### Bootstrap process\n   *\n   * When bootstrapping a component, Angular mounts it onto a target DOM element\n   * and kicks off automatic change detection. The target DOM element can be\n   * provided using the `rootSelectorOrNode` argument.\n   *\n   * If the target DOM element is not provided, Angular tries to find one on a page\n   * using the `selector` of the component that is being bootstrapped\n   * (first matched element is used).\n   *\n   * ### Example\n   *\n   * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,\n   * but it requires us to know the component while writing the application code.\n   *\n   * Imagine a situation where we have to wait for an API call to decide about the component to\n   * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to\n   * dynamically bootstrap a component.\n   *\n   * {@example core/ts/platform/platform.ts region='componentSelector'}\n   *\n   * Optionally, a component can be mounted onto a DOM element that does not match the\n   * selector of the bootstrapped component.\n   *\n   * In the following example, we are providing a CSS selector to match the target element.\n   *\n   * {@example core/ts/platform/platform.ts region='cssSelector'}\n   *\n   * While in this example, we are providing reference to a DOM node.\n   *\n   * {@example core/ts/platform/platform.ts region='domNode'}\n   *\n   * @deprecated Passing Component factories as the `Application.bootstrap` function argument is\n   *     deprecated. Pass Component Types instead.\n   */\n  bootstrap<C>(\n    componentFactory: ComponentFactory<C>,\n    rootSelectorOrNode?: string | any,\n  ): ComponentRef<C>;\n\n  /**\n   * Bootstrap a component onto the element identified by its selector or, optionally, to a\n   * specified element.\n   *\n   * @usageNotes\n   * ### Bootstrap process\n   *\n   * When bootstrapping a component, Angular mounts it onto a target DOM element\n   * and kicks off automatic change detection. The target DOM element can be\n   * provided using the `rootSelectorOrNode` argument.\n   *\n   * If the target DOM element is not provided, Angular tries to find one on a page\n   * using the `selector` of the component that is being bootstrapped\n   * (first matched element is used).\n   *\n   * ### Example\n   *\n   * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,\n   * but it requires us to know the component while writing the application code.\n   *\n   * Imagine a situation where we have to wait for an API call to decide about the component to\n   * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to\n   * dynamically bootstrap a component.\n   *\n   * {@example core/ts/platform/platform.ts region='componentSelector'}\n   *\n   * Optionally, a component can be mounted onto a DOM element that does not match the\n   * selector of the bootstrapped component.\n   *\n   * In the following example, we are providing a CSS selector to match the target element.\n   *\n   * {@example core/ts/platform/platform.ts region='cssSelector'}\n   *\n   * While in this example, we are providing reference to a DOM node.\n   *\n   * {@example core/ts/platform/platform.ts region='domNode'}\n   */\n  bootstrap<C>(\n    componentOrFactory: ComponentFactory<C> | Type<C>,\n    rootSelectorOrNode?: string | any,\n  ): ComponentRef<C> {\n    return this.bootstrapImpl(componentOrFactory, rootSelectorOrNode);\n  }\n\n  private bootstrapImpl<C>(\n    componentOrFactory: ComponentFactory<C> | Type<C>,\n    rootSelectorOrNode?: string | any,\n    injector: Injector = Injector.NULL,\n  ): ComponentRef<C> {\n    const ngZone = this._injector.get(NgZone);\n    return ngZone.run(() => {\n      profiler(ProfilerEvent.BootstrapComponentStart);\n\n      (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);\n      const isComponentFactory = componentOrFactory instanceof ComponentFactory;\n      const initStatus = this._injector.get(ApplicationInitStatus);\n\n      if (!initStatus.done) {\n        let errorMessage = '';\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          const standalone = !isComponentFactory && isStandalone(componentOrFactory);\n          errorMessage =\n            'Cannot bootstrap as there are still asynchronous initializers running.' +\n            (standalone\n              ? ''\n              : ' Bootstrap components in the `ngDoBootstrap` method of the root module.');\n        }\n        throw new RuntimeError(RuntimeErrorCode.ASYNC_INITIALIZERS_STILL_RUNNING, errorMessage);\n      }\n\n      let componentFactory: ComponentFactory<C>;\n      if (isComponentFactory) {\n        componentFactory = componentOrFactory;\n      } else {\n        const resolver = this._injector.get(ComponentFactoryResolver);\n        componentFactory = resolver.resolveComponentFactory(componentOrFactory)!;\n      }\n      this.componentTypes.push(componentFactory.componentType);\n\n      // Create a factory associated with the current module if it's not bound to some other\n      const ngModule = isBoundToModule(componentFactory)\n        ? undefined\n        : this._injector.get(NgModuleRef);\n      const selectorOrNode = rootSelectorOrNode || componentFactory.selector;\n      const compRef = componentFactory.create(injector, [], selectorOrNode, ngModule);\n      const nativeElement = compRef.location.nativeElement;\n      const testability = compRef.injector.get(TESTABILITY, null);\n      testability?.registerApplication(nativeElement);\n\n      compRef.onDestroy(() => {\n        this.detachView(compRef.hostView);\n        remove(this.components, compRef);\n        testability?.unregisterApplication(nativeElement);\n      });\n\n      this._loadComponent(compRef);\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        const _console = this._injector.get(Console);\n        _console.log(`Angular is running in development mode.`);\n      }\n\n      profiler(ProfilerEvent.BootstrapComponentEnd, compRef);\n\n      return compRef;\n    });\n  }\n\n  /**\n   * Invoke this method to explicitly process change detection and its side-effects.\n   *\n   * In development mode, `tick()` also performs a second change detection cycle to ensure that no\n   * further changes are detected. If additional changes are picked up during this second cycle,\n   * bindings in the app have side-effects that cannot be resolved in a single change detection\n   * pass.\n   * In this case, Angular throws an error, since an Angular application can only have one change\n   * detection pass during which all change detection must complete.\n   */\n  tick(): void {\n    if (!this.zonelessEnabled) {\n      this.dirtyFlags |= ApplicationRefDirtyFlags.ViewTreeGlobal;\n    }\n    this._tick();\n  }\n\n  /** @internal */\n  _tick(): void {\n    profiler(ProfilerEvent.ChangeDetectionStart);\n\n    if (this.tracingSnapshot !== null) {\n      // Ensure we always run `tickImpl()` in the context of the most recent snapshot,\n      // if one exists. Snapshots may be reference counted by the implementation so\n      // we want to ensure that if we request a snapshot that we use it.\n      this.tracingSnapshot.run(TracingAction.CHANGE_DETECTION, this.tickImpl);\n    } else {\n      this.tickImpl();\n    }\n  }\n\n  private tickImpl = (): void => {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);\n    if (this._runningTick) {\n      throw new RuntimeError(\n        RuntimeErrorCode.RECURSIVE_APPLICATION_REF_TICK,\n        ngDevMode && 'ApplicationRef.tick is called recursively',\n      );\n    }\n\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      this._runningTick = true;\n      this.synchronize();\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        for (let view of this.allViews) {\n          view.checkNoChanges();\n        }\n      }\n    } finally {\n      this._runningTick = false;\n      this.tracingSnapshot?.dispose();\n      this.tracingSnapshot = null;\n      setActiveConsumer(prevConsumer);\n      this.afterTick.next();\n\n      profiler(ProfilerEvent.ChangeDetectionEnd);\n    }\n  };\n\n  /**\n   * Performs the core work of synchronizing the application state with the UI, resolving any\n   * pending dirtiness (potentially in a loop).\n   */\n  private synchronize(): void {\n    if (this._rendererFactory === null && !(this._injector as R3Injector).destroyed) {\n      this._rendererFactory = this._injector.get(RendererFactory2, null, {optional: true});\n    }\n\n    let runs = 0;\n    while (this.dirtyFlags !== ApplicationRefDirtyFlags.None && runs++ < MAXIMUM_REFRESH_RERUNS) {\n      profiler(ProfilerEvent.ChangeDetectionSyncStart);\n      this.synchronizeOnce();\n      profiler(ProfilerEvent.ChangeDetectionSyncEnd);\n    }\n\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INFINITE_CHANGE_DETECTION,\n        ngDevMode &&\n          'Infinite change detection while refreshing application views. ' +\n            'Ensure views are not calling `markForCheck` on every template execution or ' +\n            'that afterRender hooks always mark views for check.',\n      );\n    }\n  }\n\n  /**\n   * Perform a single synchronization pass.\n   */\n  private synchronizeOnce(): void {\n    // First, process any dirty root effects.\n    if (this.dirtyFlags & ApplicationRefDirtyFlags.RootEffects) {\n      this.dirtyFlags &= ~ApplicationRefDirtyFlags.RootEffects;\n      this.rootEffectScheduler.flush();\n    }\n\n    // First check dirty views, if there are any.\n    let ranDetectChanges = false;\n    if (this.dirtyFlags & ApplicationRefDirtyFlags.ViewTreeAny) {\n      // Change detection on views starts in targeted mode (only check components if they're\n      // marked as dirty) unless global checking is specifically requested via APIs like\n      // `ApplicationRef.tick()` and the `NgZone` integration.\n      const useGlobalCheck = Boolean(this.dirtyFlags & ApplicationRefDirtyFlags.ViewTreeGlobal);\n\n      // Clear the view-related dirty flags.\n      this.dirtyFlags &= ~ApplicationRefDirtyFlags.ViewTreeAny;\n\n      // Set the AfterRender bit, as we're checking views and will need to run afterRender hooks.\n      this.dirtyFlags |= ApplicationRefDirtyFlags.AfterRender;\n\n      // Check all potentially dirty views.\n      for (let {_lView} of this.allViews) {\n        // When re-checking, only check views which actually need it.\n        if (!useGlobalCheck && !requiresRefreshOrTraversal(_lView)) {\n          continue;\n        }\n\n        const mode =\n          useGlobalCheck && !this.zonelessEnabled\n            ? // Global mode includes `CheckAlways` views.\n              // When using zoneless, all root views must be explicitly marked for refresh, even if they are\n              // `CheckAlways`.\n              ChangeDetectionMode.Global\n            : // Only refresh views with the `RefreshView` flag or views is a changed signal\n              ChangeDetectionMode.Targeted;\n        detectChangesInternal(_lView, mode);\n        ranDetectChanges = true;\n      }\n\n      // If `markForCheck()` was called during view checking, it will have set the `ViewTreeCheck`\n      // flag. We clear the flag here because, for backwards compatibility, `markForCheck()`\n      // during view checking doesn't cause the view to be re-checked.\n      this.dirtyFlags &= ~ApplicationRefDirtyFlags.ViewTreeCheck;\n\n      // Check if any views are still dirty after checking and we need to loop back.\n      this.syncDirtyFlagsWithViews();\n      if (\n        this.dirtyFlags &\n        (ApplicationRefDirtyFlags.ViewTreeAny | ApplicationRefDirtyFlags.RootEffects)\n      ) {\n        // If any views or effects are still dirty after checking, loop back before running render\n        // hooks.\n        return;\n      }\n    }\n    if (!ranDetectChanges) {\n      // If we skipped refreshing views above, there might still be unflushed animations\n      // because we never called `detectChangesInternal` on the views.\n      this._rendererFactory?.begin?.();\n      this._rendererFactory?.end?.();\n    }\n\n    // Even if there were no dirty views, afterRender hooks might still be dirty.\n    if (this.dirtyFlags & ApplicationRefDirtyFlags.AfterRender) {\n      this.dirtyFlags &= ~ApplicationRefDirtyFlags.AfterRender;\n      this.afterRenderManager.execute();\n\n      // afterRender hooks might influence dirty flags.\n    }\n    this.syncDirtyFlagsWithViews();\n  }\n\n  /**\n   * Checks `allViews` for views which require refresh/traversal, and updates `dirtyFlags`\n   * accordingly, with two potential behaviors:\n   *\n   * 1. If any of our views require updating, then this adds the `ViewTreeTraversal` dirty flag.\n   *    This _should_ be a no-op, since the scheduler should've added the flag at the same time the\n   *    view was marked as needing updating.\n   *\n   *    TODO(alxhub): figure out if this behavior is still needed for edge cases.\n   *\n   * 2. If none of our views require updating, then clear the view-related `dirtyFlag`s. This\n   *    happens when the scheduler is notified of a view becoming dirty, but the view itself isn't\n   *    reachable through traversal from our roots (e.g. it's detached from the CD tree).\n   */\n  private syncDirtyFlagsWithViews(): void {\n    if (this.allViews.some(({_lView}) => requiresRefreshOrTraversal(_lView))) {\n      // If after running all afterRender callbacks new views are dirty, ensure we loop back.\n      this.dirtyFlags |= ApplicationRefDirtyFlags.ViewTreeTraversal;\n      return;\n    } else {\n      // Even though this flag may be set, none of _our_ views require traversal, and so the\n      // `ApplicationRef` doesn't require any repeated checking.\n      this.dirtyFlags &= ~ApplicationRefDirtyFlags.ViewTreeAny;\n    }\n  }\n\n  /**\n   * Attaches a view so that it will be dirty checked.\n   * The view will be automatically detached when it is destroyed.\n   * This will throw if the view is already attached to a ViewContainer.\n   */\n  attachView(viewRef: ViewRef): void {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);\n    const view = viewRef as InternalViewRef<unknown>;\n    this._views.push(view);\n    view.attachToAppRef(this);\n  }\n\n  /**\n   * Detaches a view from dirty checking again.\n   */\n  detachView(viewRef: ViewRef): void {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);\n    const view = viewRef as InternalViewRef<unknown>;\n    remove(this._views, view);\n    view.detachFromAppRef();\n  }\n\n  private _loadComponent(componentRef: ComponentRef<any>): void {\n    this.attachView(componentRef.hostView);\n    try {\n      this.tick();\n    } catch (e) {\n      this.internalErrorHandler(e);\n    }\n    this.components.push(componentRef);\n    // Get the listeners lazily to prevent DI cycles.\n    const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);\n    if (ngDevMode && !Array.isArray(listeners)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_MULTI_PROVIDER,\n        'Unexpected type of the `APP_BOOTSTRAP_LISTENER` token value ' +\n          `(expected an array, but got ${typeof listeners}). ` +\n          'Please check that the `APP_BOOTSTRAP_LISTENER` token is configured as a ' +\n          '`multi: true` provider.',\n      );\n    }\n    listeners.forEach((listener) => listener(componentRef));\n  }\n\n  /** @internal */\n  ngOnDestroy() {\n    if (this._destroyed) return;\n\n    try {\n      // Call all the lifecycle hooks.\n      this._destroyListeners.forEach((listener) => listener());\n\n      // Destroy all registered views.\n      this._views.slice().forEach((view) => view.destroy());\n    } finally {\n      // Indicate that this instance is destroyed.\n      this._destroyed = true;\n\n      // Release all references.\n      this._views = [];\n      this._destroyListeners = [];\n    }\n  }\n\n  /**\n   * Registers a listener to be called when an instance is destroyed.\n   *\n   * @param callback A callback function to add as a listener.\n   * @returns A function which unregisters a listener.\n   */\n  onDestroy(callback: () => void): VoidFunction {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);\n    this._destroyListeners.push(callback);\n    return () => remove(this._destroyListeners, callback);\n  }\n\n  /**\n   * Destroys an Angular application represented by this `ApplicationRef`. Calling this function\n   * will destroy the associated environment injectors as well as all the bootstrapped components\n   * with their views.\n   */\n  destroy(): void {\n    if (this._destroyed) {\n      throw new RuntimeError(\n        RuntimeErrorCode.APPLICATION_REF_ALREADY_DESTROYED,\n        ngDevMode && 'This instance of the `ApplicationRef` has already been destroyed.',\n      );\n    }\n\n    const injector = this._injector as R3Injector;\n\n    // Check that this injector instance supports destroy operation.\n    if (injector.destroy && !injector.destroyed) {\n      // Destroying an underlying injector will trigger the `ngOnDestroy` lifecycle\n      // hook, which invokes the remaining cleanup actions.\n      injector.destroy();\n    }\n  }\n\n  /**\n   * Returns the number of attached views.\n   */\n  get viewCount() {\n    return this._views.length;\n  }\n}\n\nfunction warnIfDestroyed(destroyed: boolean): void {\n  if (destroyed) {\n    console.warn(\n      formatRuntimeError(\n        RuntimeErrorCode.APPLICATION_REF_ALREADY_DESTROYED,\n        'This instance of the `ApplicationRef` has already been destroyed.',\n      ),\n    );\n  }\n}\n\nexport function remove<T>(list: T[], el: T): void {\n  const index = list.indexOf(el);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n}\n\nexport const enum ApplicationRefDirtyFlags {\n  None = 0,\n\n  /**\n   * A global change detection round has been requested.\n   */\n  ViewTreeGlobal = 0b00000001,\n\n  /**\n   * Part of the view tree is marked for traversal.\n   */\n  ViewTreeTraversal = 0b00000010,\n\n  /**\n   * Part of the view tree is marked to be checked (dirty).\n   */\n  ViewTreeCheck = 0b00000100,\n\n  /**\n   * Helper for any view tree bit being set.\n   */\n  ViewTreeAny = ViewTreeGlobal | ViewTreeTraversal | ViewTreeCheck,\n\n  /**\n   * After render hooks need to run.\n   */\n  AfterRender = 0b00001000,\n\n  /**\n   * Effects at the `ApplicationRef` level.\n   */\n  RootEffects = 0b00010000,\n}\n"]}