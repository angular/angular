{"version":3,"file":"event_emitter.js","sourceRoot":"","sources":["event_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {setActiveConsumer} from '../primitives/signals';\nimport {PartialObserver, Subject, Subscription} from 'rxjs';\n\nimport {OutputRef} from './authoring/output/output_ref';\nimport {isInInjectionContext} from './di/contextual';\nimport {inject} from './di/injector_compatibility';\nimport {DestroyRef} from './linker/destroy_ref';\nimport {PendingTasksInternal} from './pending_tasks_internal';\n\n/**\n * Use in components with the `@Output` directive to emit custom events\n * synchronously or asynchronously, and register handlers for those events\n * by subscribing to an instance.\n *\n * @usageNotes\n *\n * Extends\n * [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject)\n * for Angular by adding the `emit()` method.\n *\n * In the following example, a component defines two output properties\n * that create event emitters. When the title is clicked, the emitter\n * emits an open or close event to toggle the current visibility state.\n *\n * ```angular-ts\n * @Component({\n *   selector: 'zippy',\n *   template: `\n *   <div class=\"zippy\">\n *     <div (click)=\"toggle()\">Toggle</div>\n *     <div [hidden]=\"!visible\">\n *       <ng-content></ng-content>\n *     </div>\n *  </div>`})\n * export class Zippy {\n *   visible: boolean = true;\n *   @Output() open: EventEmitter<any> = new EventEmitter();\n *   @Output() close: EventEmitter<any> = new EventEmitter();\n *\n *   toggle() {\n *     this.visible = !this.visible;\n *     if (this.visible) {\n *       this.open.emit(null);\n *     } else {\n *       this.close.emit(null);\n *     }\n *   }\n * }\n * ```\n *\n * Access the event object with the `$event` argument passed to the output event\n * handler:\n *\n * ```html\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n * ```\n *\n * @publicApi\n */\nexport interface EventEmitter<T> extends Subject<T>, OutputRef<T> {\n  /**\n   * @internal\n   */\n  __isAsync: boolean;\n\n  /**\n   * Creates an instance of this class that can\n   * deliver events synchronously or asynchronously.\n   *\n   * @param [isAsync=false] When true, deliver events asynchronously.\n   *\n   */\n  new (isAsync?: boolean): EventEmitter<T>;\n\n  /**\n   * Emits an event containing a given value.\n   * @param value The value to emit.\n   */\n  emit(value?: T): void;\n\n  /**\n   * Registers handlers for events emitted by this instance.\n   * @param next When supplied, a custom handler for emitted events.\n   * @param error When supplied, a custom handler for an error notification from this emitter.\n   * @param complete When supplied, a custom handler for a completion notification from this\n   *     emitter.\n   */\n  subscribe(\n    next?: (value: T) => void,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): Subscription;\n  /**\n   * Registers handlers for events emitted by this instance.\n   * @param observerOrNext When supplied, a custom handler for emitted events, or an observer\n   *     object.\n   * @param error When supplied, a custom handler for an error notification from this emitter.\n   * @param complete When supplied, a custom handler for a completion notification from this\n   *     emitter.\n   */\n  subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription;\n}\n\nclass EventEmitter_ extends Subject<any> implements OutputRef<any> {\n  // tslint:disable-next-line:require-internal-with-underscore\n  __isAsync: boolean;\n  destroyRef: DestroyRef | undefined = undefined;\n  private readonly pendingTasks: PendingTasksInternal | undefined = undefined;\n\n  constructor(isAsync: boolean = false) {\n    super();\n    this.__isAsync = isAsync;\n\n    // Attempt to retrieve a `DestroyRef` and `PendingTasks` optionally.\n    // For backwards compatibility reasons, this cannot be required.\n    if (isInInjectionContext()) {\n      // `DestroyRef` is optional because it is not available in all contexts.\n      // But it is useful to properly complete the `EventEmitter` if used with `outputToObservable`\n      // when the component/directive is destroyed. (See `outputToObservable` for more details.)\n      this.destroyRef = inject(DestroyRef, {optional: true}) ?? undefined;\n      this.pendingTasks = inject(PendingTasksInternal, {optional: true}) ?? undefined;\n    }\n  }\n\n  emit(value?: any) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      super.next(value);\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n\n  override subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription {\n    let nextFn = observerOrNext;\n    let errorFn = error || (() => null);\n    let completeFn = complete;\n\n    if (observerOrNext && typeof observerOrNext === 'object') {\n      const observer = observerOrNext as PartialObserver<unknown>;\n      nextFn = observer.next?.bind(observer);\n      errorFn = observer.error?.bind(observer);\n      completeFn = observer.complete?.bind(observer);\n    }\n\n    if (this.__isAsync) {\n      errorFn = this.wrapInTimeout(errorFn);\n\n      if (nextFn) {\n        nextFn = this.wrapInTimeout(nextFn);\n      }\n\n      if (completeFn) {\n        completeFn = this.wrapInTimeout(completeFn);\n      }\n    }\n\n    const sink = super.subscribe({next: nextFn, error: errorFn, complete: completeFn});\n\n    if (observerOrNext instanceof Subscription) {\n      observerOrNext.add(sink);\n    }\n\n    return sink;\n  }\n\n  private wrapInTimeout(fn: (value: unknown) => any) {\n    return (value: unknown) => {\n      const taskId = this.pendingTasks?.add();\n      setTimeout(() => {\n        try {\n          fn(value);\n        } finally {\n          if (taskId !== undefined) {\n            this.pendingTasks?.remove(taskId);\n          }\n        }\n      });\n    };\n  }\n}\n\n/**\n * @publicApi\n */\nexport const EventEmitter: {\n  new (isAsync?: boolean): EventEmitter<any>;\n  new <T>(isAsync?: boolean): EventEmitter<T>;\n  readonly prototype: EventEmitter<any>;\n} = EventEmitter_ as any;\n"]}