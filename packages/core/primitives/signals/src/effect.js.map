{"version":3,"file":"effect.js","sourceRoot":"","sources":["effect.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EACL,wBAAwB,EACxB,yBAAyB,EACzB,8BAA8B,EAC9B,aAAa,GAEd,MAAM,SAAS,CAAC;AAqBjB,MAAM,CAAC,MAAM,gBAAgB;AAC3B,eAAe,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;IACtB,GAAG,aAAa;IAChB,oBAAoB,EAAE,IAAI;IAC1B,yBAAyB,EAAE,IAAI;IAC/B,KAAK,EAAE,IAAI;IACX,IAAI,EAAE,QAAQ;CACf,CAAC,CAAC,EAAE,CAAC;AAER,MAAM,UAAU,SAAS,CAAC,IAAoB;IAC5C,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACnB,IAAI,IAAI,CAAC,OAAO,GAAG,CAAC,IAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC,EAAE,CAAC;QAC9D,OAAO;IACT,CAAC;IACD,IAAI,CAAC,OAAO,EAAE,CAAC;IACf,MAAM,QAAQ,GAAG,yBAAyB,CAAC,IAAI,CAAC,CAAC;IACjD,IAAI,CAAC;QACH,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,IAAI,CAAC,EAAE,EAAE,CAAC;IACZ,CAAC;YAAS,CAAC;QACT,wBAAwB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC3C,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  consumerPollProducersForChange,\n  REACTIVE_NODE,\n  ReactiveNode,\n} from './graph';\n\n/**\n * An effect can, optionally, register a cleanup function. If registered, the cleanup is executed\n * before the next effect run. The cleanup function makes it possible to \"cancel\" any work that the\n * previous effect run might have started.\n */\nexport type EffectCleanupFn = () => void;\n\n/**\n * A callback passed to the effect function that makes it possible to register cleanup logic.\n */\nexport type EffectCleanupRegisterFn = (cleanupFn: EffectCleanupFn) => void;\n\nexport interface BaseEffectNode extends ReactiveNode {\n  fn: () => void;\n  destroy(): void;\n  cleanup(): void;\n  run(): void;\n}\n\nexport const BASE_EFFECT_NODE: Omit<BaseEffectNode, 'fn' | 'destroy' | 'cleanup' | 'run'> =\n  /* @__PURE__ */ (() => ({\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: true,\n    dirty: true,\n    kind: 'effect',\n  }))();\n\nexport function runEffect(node: BaseEffectNode) {\n  node.dirty = false;\n  if (node.version > 0 && !consumerPollProducersForChange(node)) {\n    return;\n  }\n  node.version++;\n  const prevNode = consumerBeforeComputation(node);\n  try {\n    node.cleanup();\n    node.fn();\n  } finally {\n    consumerAfterComputation(node, prevNode);\n  }\n}\n"]}