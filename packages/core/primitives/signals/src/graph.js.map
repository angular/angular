{"version":3,"file":"graph.js","sourceRoot":"","sources":["graph.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAMH;;;;GAIG;AACH,IAAI,cAAc,GAAwB,IAAI,CAAC;AAC/C,IAAI,mBAAmB,GAAG,KAAK,CAAC;AAIhC;;GAEG;AACH,IAAI,KAAK,GAAY,CAAY,CAAC;AAIlC;;GAEG;AACH,IAAI,qBAAqB,GAA0B,IAAI,CAAC;AAExD;;;;GAIG;AACH,MAAM,CAAC,MAAM,MAAM,GAAkB,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAEtE,MAAM,UAAU,iBAAiB,CAAC,QAA6B;IAC7D,MAAM,IAAI,GAAG,cAAc,CAAC;IAC5B,cAAc,GAAG,QAAQ,CAAC;IAC1B,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,UAAU,iBAAiB;IAC/B,OAAO,cAAc,CAAC;AACxB,CAAC;AAED,MAAM,UAAU,qBAAqB;IACnC,OAAO,mBAAmB,CAAC;AAC7B,CAAC;AAMD,MAAM,UAAU,UAAU,CAAC,KAAc;IACvC,OAAQ,KAA2B,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC;AAC5D,CAAC;AAED,MAAM,CAAC,MAAM,aAAa,GAAiB;IACzC,OAAO,EAAE,CAAY;IACrB,cAAc,EAAE,CAAY;IAC5B,KAAK,EAAE,KAAK;IACZ,SAAS,EAAE,SAAS;IACpB,aAAa,EAAE,SAAS;IACxB,SAAS,EAAE,SAAS;IACpB,aAAa,EAAE,SAAS;IACxB,WAAW,EAAE,KAAK;IAClB,yBAAyB,EAAE,KAAK;IAChC,oBAAoB,EAAE,KAAK;IAC3B,IAAI,EAAE,SAAS;IACf,qBAAqB,EAAE,GAAG,EAAE,CAAC,KAAK;IAClC,sBAAsB,EAAE,GAAG,EAAE,GAAE,CAAC;IAChC,mBAAmB,EAAE,GAAG,EAAE,GAAE,CAAC;IAC7B,oBAAoB,EAAE,GAAG,EAAE,GAAE,CAAC;CAC/B,CAAC;AAgHF;;GAEG;AACH,MAAM,UAAU,gBAAgB,CAAC,IAAkB;IACjD,IAAI,mBAAmB,EAAE,CAAC;QACxB,MAAM,IAAI,KAAK,CACb,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS;YAC3C,CAAC,CAAC,wDAAwD;YAC1D,CAAC,CAAC,EAAE,CACP,CAAC;IACJ,CAAC;IAED,IAAI,cAAc,KAAK,IAAI,EAAE,CAAC;QAC5B,gEAAgE;QAChE,OAAO;IACT,CAAC;IAED,cAAc,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;IAE1C,MAAM,gBAAgB,GAAG,cAAc,CAAC,aAAa,CAAC;IAEtD,4FAA4F;IAC5F,OAAO;IACP,IAAI,gBAAgB,KAAK,SAAS,IAAI,gBAAgB,CAAC,QAAQ,KAAK,IAAI,EAAE,CAAC;QACzE,OAAO;IACT,CAAC;IAED,IAAI,gBAAgB,GAA6B,SAAS,CAAC;IAC3D,MAAM,aAAa,GAAG,cAAc,CAAC,WAAW,CAAC;IACjD,IAAI,aAAa,EAAE,CAAC;QAClB,8FAA8F;QAC9F,0DAA0D;QAE1D,+FAA+F;QAC/F,mIAAmI;QACnI,gBAAgB;YACd,gBAAgB,KAAK,SAAS,CAAC,CAAC,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC,CAAC,cAAc,CAAC,SAAS,CAAC;QAC5F,IAAI,gBAAgB,KAAK,SAAS,IAAI,gBAAgB,CAAC,QAAQ,KAAK,IAAI,EAAE,CAAC;YACzE,0FAA0F;YAC1F,sFAAsF;YACtF,cAAc,CAAC,aAAa,GAAG,gBAAgB,CAAC;YAChD,gBAAgB,CAAC,eAAe,GAAG,IAAI,CAAC,OAAO,CAAC;YAChD,OAAO;QACT,CAAC;IACH,CAAC;IAED,MAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa,CAAC;IAE5C,gGAAgG;IAChG,0HAA0H;IAC1H,IACE,gBAAgB,KAAK,SAAS;QAC9B,gBAAgB,CAAC,QAAQ,KAAK,cAAc;QAC5C,oIAAoI;QACpI,CAAC,CAAC,aAAa,IAAI,WAAW,CAAC,gBAAgB,EAAE,cAAc,CAAC,CAAC,EACjE,CAAC;QACD,mEAAmE;QACnE,OAAO;IACT,CAAC;IAED,oGAAoG;IACpG,MAAM,MAAM,GAAG,cAAc,CAAC,cAAc,CAAC,CAAC;IAC9C,MAAM,OAAO,GAAG;QACd,QAAQ,EAAE,IAAI;QACd,QAAQ,EAAE,cAAc;QACxB,6FAA6F;QAC7F,2EAA2E;QAC3E,YAAY,EAAE,gBAAgB;QAC9B,YAAY,EAAE,gBAAgB;QAC9B,eAAe,EAAE,IAAI,CAAC,OAAO;QAC7B,YAAY,EAAE,SAAS;KACxB,CAAC;IACF,cAAc,CAAC,aAAa,GAAG,OAAO,CAAC;IACvC,IAAI,gBAAgB,KAAK,SAAS,EAAE,CAAC;QACnC,gBAAgB,CAAC,YAAY,GAAG,OAAO,CAAC;IAC1C,CAAC;SAAM,CAAC;QACN,cAAc,CAAC,SAAS,GAAG,OAAO,CAAC;IACrC,CAAC;IAED,IAAI,MAAM,EAAE,CAAC;QACX,uBAAuB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACzC,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,sBAAsB;IACpC,KAAK,EAAE,CAAC;AACV,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,0BAA0B,CAAC,IAAkB;IAC3D,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;QACxC,6FAA6F;QAC7F,kCAAkC;QAClC,OAAO;IACT,CAAC;IAED,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,EAAE,CAAC;QACjD,8FAA8F;QAC9F,6FAA6F;QAC7F,iCAAiC;QACjC,OAAO;IACT,CAAC;IAED,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC,EAAE,CAAC;QAC/E,kFAAkF;QAClF,gFAAgF;QAChF,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACxB,OAAO;IACT,CAAC;IAED,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;IAElC,sDAAsD;IACtD,iBAAiB,CAAC,IAAI,CAAC,CAAC;AAC1B,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,uBAAuB,CAAC,IAAkB;IACxD,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;QACjC,OAAO;IACT,CAAC;IAED,qDAAqD;IACrD,MAAM,IAAI,GAAG,mBAAmB,CAAC;IACjC,mBAAmB,GAAG,IAAI,CAAC;IAC3B,IAAI,CAAC;QACH,KACE,IAAI,IAAI,GAA6B,IAAI,CAAC,SAAS,EACnD,IAAI,KAAK,SAAS,EAClB,IAAI,GAAG,IAAI,CAAC,YAAY,EACxB,CAAC;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;gBACpB,iBAAiB,CAAC,QAAQ,CAAC,CAAC;YAC9B,CAAC;QACH,CAAC;IACH,CAAC;YAAS,CAAC;QACT,mBAAmB,GAAG,IAAI,CAAC;IAC7B,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,sBAAsB;IACpC,OAAO,cAAc,EAAE,yBAAyB,KAAK,KAAK,CAAC;AAC7D,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAC,IAAkB;IAClD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IAClB,uBAAuB,CAAC,IAAI,CAAC,CAAC;IAC9B,IAAI,CAAC,mBAAmB,EAAE,CAAC,IAAI,CAAC,CAAC;AACnC,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAC,IAAkB;IAClD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACnB,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;AAC9B,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,yBAAyB,CAAC,IAAyB;IACjE,IAAI,IAAI;QAAE,8BAA8B,CAAC,IAAI,CAAC,CAAC;IAE/C,OAAO,iBAAiB,CAAC,IAAI,CAAC,CAAC;AACjC,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,8BAA8B,CAAC,IAAkB;IAC/D,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;IAC/B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;AAC1B,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,wBAAwB,CACtC,IAAyB,EACzB,YAAiC;IAEjC,iBAAiB,CAAC,YAAY,CAAC,CAAC;IAEhC,IAAI,IAAI;QAAE,gCAAgC,CAAC,IAAI,CAAC,CAAC;AACnD,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,gCAAgC,CAAC,IAAkB;IACjE,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;IAEzB,6FAA6F;IAC7F,sEAAsE;IACtE,MAAM,aAAa,GAAG,IAAI,CAAC,aAAyC,CAAC;IACrE,IAAI,QAAQ,GAAG,aAAa,KAAK,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC;IACzF,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;QAC3B,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;YACzB,+EAA+E;YAC/E,GAAG,CAAC;gBACF,QAAQ,GAAG,8BAA8B,CAAC,QAAQ,CAAC,CAAC;YACtD,CAAC,QAAQ,QAAQ,KAAK,SAAS,EAAE;QACnC,CAAC;QAED,qEAAqE;QACrE,IAAI,aAAa,KAAK,SAAS,EAAE,CAAC;YAChC,aAAa,CAAC,YAAY,GAAG,SAAS,CAAC;QACzC,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC7B,CAAC;IACH,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,8BAA8B,CAAC,IAAkB;IAC/D,6BAA6B;IAC7B,KAAK,IAAI,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,KAAK,SAAS,EAAE,IAAI,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAC7E,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,MAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC;QAEzC,wFAAwF;QACxF,0CAA0C;QAC1C,IAAI,WAAW,KAAK,QAAQ,CAAC,OAAO,EAAE,CAAC;YACrC,OAAO,IAAI,CAAC;QACd,CAAC;QAED,yFAAyF;QACzF,6FAA6F;QAC7F,0BAA0B,CAAC,QAAQ,CAAC,CAAC;QAErC,0FAA0F;QAC1F,+EAA+E;QAC/E,IAAI,WAAW,KAAK,QAAQ,CAAC,OAAO,EAAE,CAAC;YACrC,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,eAAe,CAAC,IAAkB;IAChD,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;QACzB,oDAAoD;QACpD,IAAI,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC;QAC1B,OAAO,IAAI,KAAK,SAAS,EAAE,CAAC;YAC1B,IAAI,GAAG,8BAA8B,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;IACH,CAAC;IAED,oFAAoF;IACpF,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC3B,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;IAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC3B,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;AACjC,CAAC;AAED;;;;;GAKG;AACH,SAAS,uBAAuB,CAAC,IAAkB,EAAE,IAAkB;IACrE,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;IACzC,MAAM,OAAO,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;IACrC,IAAI,aAAa,KAAK,SAAS,EAAE,CAAC;QAChC,IAAI,CAAC,YAAY,GAAG,aAAa,CAAC,YAAY,CAAC;QAC/C,aAAa,CAAC,YAAY,GAAG,IAAI,CAAC;IACpC,CAAC;SAAM,CAAC;QACN,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;QAC9B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;IACD,IAAI,CAAC,YAAY,GAAG,aAAa,CAAC;IAClC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;IAC1B,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,KACE,IAAI,IAAI,GAA6B,IAAI,CAAC,SAAS,EACnD,IAAI,KAAK,SAAS,EAClB,IAAI,GAAG,IAAI,CAAC,YAAY,EACxB,CAAC;YACD,uBAAuB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAC/C,CAAC;IACH,CAAC;AACH,CAAC;AAED,SAAS,8BAA8B,CAAC,IAAkB;IACxD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;IAC/B,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;IACvC,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;IACvC,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;IACvC,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;IAC9B,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;IAC9B,IAAI,YAAY,KAAK,SAAS,EAAE,CAAC;QAC/B,YAAY,CAAC,YAAY,GAAG,YAAY,CAAC;IAC3C,CAAC;SAAM,CAAC;QACN,QAAQ,CAAC,aAAa,GAAG,YAAY,CAAC;IACxC,CAAC;IACD,IAAI,YAAY,KAAK,SAAS,EAAE,CAAC;QAC/B,YAAY,CAAC,YAAY,GAAG,YAAY,CAAC;IAC3C,CAAC;SAAM,CAAC;QACN,QAAQ,CAAC,SAAS,GAAG,YAAY,CAAC;QAClC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC9B,IAAI,YAAY,GAAG,QAAQ,CAAC,SAAS,CAAC;YACtC,OAAO,YAAY,KAAK,SAAS,EAAE,CAAC;gBAClC,YAAY,GAAG,8BAA8B,CAAC,YAAY,CAAC,CAAC;YAC9D,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,YAAY,CAAC;AACtB,CAAC;AAED,SAAS,cAAc,CAAC,IAAkB;IACxC,OAAO,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC;AACnE,CAAC;AAED,MAAM,UAAU,wBAAwB,CAAC,IAAkB;IACzD,qBAAqB,EAAE,CAAC,IAAI,CAAC,CAAC;AAChC,CAAC;AAED,MAAM,UAAU,wBAAwB,CAAC,EAAyB;IAChE,MAAM,IAAI,GAAG,qBAAqB,CAAC;IACnC,qBAAqB,GAAG,EAAE,CAAC;IAC3B,OAAO,IAAI,CAAC;AACd,CAAC;AAED,gFAAgF;AAChF,2JAA2J;AAC3J,SAAS,WAAW,CAAC,SAAuB,EAAE,QAAsB;IAClE,MAAM,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAC;IAC7C,IAAI,aAAa,KAAK,SAAS,EAAE,CAAC;QAChC,IAAI,IAAI,GAAG,QAAQ,CAAC,SAAU,CAAC;QAC/B,GAAG,CAAC;YACF,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;gBACvB,OAAO,IAAI,CAAC;YACd,CAAC;YACD,IAAI,IAAI,KAAK,aAAa,EAAE,CAAC;gBAC3B,MAAM;YACR,CAAC;YACD,IAAI,GAAG,IAAI,CAAC,YAAa,CAAC;QAC5B,CAAC,QAAQ,IAAI,KAAK,SAAS,EAAE;IAC/B,CAAC;IACD,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer: ReactiveNode | null = null;\nlet inNotificationPhase = false;\n\ntype Version = number & {__brand: 'Version'};\n\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch: Version = 1 as Version;\n\nexport type ReactiveHookFn = (node: ReactiveNode) => void;\n\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn: ReactiveHookFn | null = null;\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nexport const SIGNAL: unique symbol = /* @__PURE__ */ Symbol('SIGNAL');\n\nexport function setActiveConsumer(consumer: ReactiveNode | null): ReactiveNode | null {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n\nexport function getActiveConsumer(): ReactiveNode | null {\n  return activeConsumer;\n}\n\nexport function isInNotificationPhase(): boolean {\n  return inNotificationPhase;\n}\n\nexport interface Reactive {\n  [SIGNAL]: ReactiveNode;\n}\n\nexport function isReactive(value: unknown): value is Reactive {\n  return (value as Partial<Reactive>)[SIGNAL] !== undefined;\n}\n\nexport const REACTIVE_NODE: ReactiveNode = {\n  version: 0 as Version,\n  lastCleanEpoch: 0 as Version,\n  dirty: false,\n  producers: undefined,\n  producersTail: undefined,\n  consumers: undefined,\n  consumersTail: undefined,\n  recomputing: false,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: 'unknown',\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {},\n};\n\ninterface ReactiveLink {\n  producer: ReactiveNode;\n  consumer: ReactiveNode;\n  lastReadVersion: number;\n  prevConsumer: ReactiveLink | undefined;\n  nextConsumer: ReactiveLink | undefined;\n  nextProducer: ReactiveLink | undefined;\n}\n\n/**\n * A producer and/or consumer which participates in the reactive graph.\n *\n * Producer `ReactiveNode`s which are accessed when a consumer `ReactiveNode` is the\n * `activeConsumer` are tracked as dependencies of that consumer.\n *\n * Certain consumers are also tracked as \"live\" consumers and create edges in the other direction,\n * from producer to consumer. These edges are used to propagate change notifications when a\n * producer's value is updated.\n *\n * A `ReactiveNode` may be both a producer and consumer.\n */\nexport interface ReactiveNode {\n  /**\n   * Version of the value that this node produces.\n   *\n   * This is incremented whenever a new value is produced by this node which is not equal to the\n   * previous value (by whatever definition of equality is in use).\n   */\n  version: Version;\n\n  /**\n   * Epoch at which this node is verified to be clean.\n   *\n   * This allows skipping of some polling operations in the case where no signals have been set\n   * since this node was last read.\n   */\n  lastCleanEpoch: Version;\n\n  /**\n   * Whether this node (in its consumer capacity) is dirty.\n   *\n   * Only live consumers become dirty, when receiving a change notification from a dependency\n   * producer.\n   */\n  dirty: boolean;\n\n  /**\n   * Whether this node is currently rebuilding its producer list.\n   */\n  recomputing: boolean;\n\n  /**\n   * Producers which are dependencies of this consumer.\n   */\n  producers: ReactiveLink | undefined;\n\n  /**\n   * Points to the last linked list node in the `producers` linked list.\n   *\n   * When this node is recomputing, this is used to track the producers that we have accessed so far.\n   */\n  producersTail: ReactiveLink | undefined;\n\n  /**\n   * Linked list of consumers of this producer that are \"live\" (they require push notifications).\n   *\n   * The length of this list is effectively our reference count for this node.\n   */\n  consumers: ReactiveLink | undefined;\n  consumersTail: ReactiveLink | undefined;\n\n  /**\n   * Whether writes to signals are allowed when this consumer is the `activeConsumer`.\n   *\n   * This is used to enforce guardrails such as preventing writes to writable signals in the\n   * computation function of computed signals, which is supposed to be pure.\n   */\n  consumerAllowSignalWrites: boolean;\n\n  readonly consumerIsAlwaysLive: boolean;\n\n  /**\n   * Tracks whether producers need to recompute their value independently of the reactive graph (for\n   * example, if no initial value has been computed).\n   */\n  producerMustRecompute(node: unknown): boolean;\n  producerRecomputeValue(node: unknown): void;\n  consumerMarkedDirty(node: unknown): void;\n\n  /**\n   * Called when a signal is read within this consumer.\n   */\n  consumerOnSignalRead(node: unknown): void;\n\n  /**\n   * A debug name for the reactive node. Used in Angular DevTools to identify the node.\n   */\n  debugName?: string;\n\n  /**\n   * Kind of node. Example: 'signal', 'computed', 'input', 'effect'.\n   *\n   * ReactiveNode has this as 'unknown' by default, but derived node types should override this to\n   * make available the kind of signal that particular instance of a ReactiveNode represents.\n   *\n   * Used in Angular DevTools to identify the kind of signal.\n   */\n  kind: string;\n}\n\n/**\n * Called by implementations when a producer's signal is read.\n */\nexport function producerAccessed(node: ReactiveNode): void {\n  if (inNotificationPhase) {\n    throw new Error(\n      typeof ngDevMode !== 'undefined' && ngDevMode\n        ? `Assertion error: signal read during notification phase`\n        : '',\n    );\n  }\n\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n\n  activeConsumer.consumerOnSignalRead(node);\n\n  const prevProducerLink = activeConsumer.producersTail;\n\n  // If the last producer we accessed is the same as the current one, we can skip adding a new\n  // link\n  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n    return;\n  }\n\n  let nextProducerLink: ReactiveLink | undefined = undefined;\n  const isRecomputing = activeConsumer.recomputing;\n  if (isRecomputing) {\n    // If we're incrementally rebuilding the producers list, we want to check if the next producer\n    // in the list is the same as the one we're trying to add.\n\n    // If the previous producer is defined, then the next producer is just the one that follows it.\n    // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n    nextProducerLink =\n      prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n      // If the next producer is the same as the one we're trying to add, we can just update the\n      // last read version, update the tail of the producers list of this rerun, and return.\n      activeConsumer.producersTail = nextProducerLink;\n      nextProducerLink.lastReadVersion = node.version;\n      return;\n    }\n  }\n\n  const prevConsumerLink = node.consumersTail;\n\n  // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n  // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n  if (\n    prevConsumerLink !== undefined &&\n    prevConsumerLink.consumer === activeConsumer &&\n    // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n    (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))\n  ) {\n    // If we found an existing link to the consumer we can just return.\n    return;\n  }\n\n  // If we got here, it means that we need to create a new link between the producer and the consumer.\n  const isLive = consumerIsLive(activeConsumer);\n  const newLink = {\n    producer: node,\n    consumer: activeConsumer,\n    // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n    // the producers list, so that we can destroy all of the old links at once.\n    nextProducer: nextProducerLink,\n    prevConsumer: prevConsumerLink,\n    lastReadVersion: node.version,\n    nextConsumer: undefined,\n  };\n  activeConsumer.producersTail = newLink;\n  if (prevProducerLink !== undefined) {\n    prevProducerLink.nextProducer = newLink;\n  } else {\n    activeConsumer.producers = newLink;\n  }\n\n  if (isLive) {\n    producerAddLiveConsumer(node, newLink);\n  }\n}\n\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nexport function producerIncrementEpoch(): void {\n  epoch++;\n}\n\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nexport function producerUpdateValueVersion(node: ReactiveNode): void {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    // Even non-live consumers can skip polling if they previously found themselves to be clean at\n    // the current epoch, since their dependencies could not possibly have changed (such a change\n    // would've increased the epoch).\n    return;\n  }\n\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    producerMarkClean(node);\n    return;\n  }\n\n  node.producerRecomputeValue(node);\n\n  // After recomputing the value, we're no longer dirty.\n  producerMarkClean(node);\n}\n\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nexport function producerNotifyConsumers(node: ReactiveNode): void {\n  if (node.consumers === undefined) {\n    return;\n  }\n\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (\n      let link: ReactiveLink | undefined = node.consumers;\n      link !== undefined;\n      link = link.nextConsumer\n    ) {\n      const consumer = link.consumer;\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nexport function producerUpdatesAllowed(): boolean {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\n\nexport function consumerMarkDirty(node: ReactiveNode): void {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\n\nexport function producerMarkClean(node: ReactiveNode): void {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n\n/**\n * Prepare this consumer to run a computation in its reactive context and set\n * it as the active consumer.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nexport function consumerBeforeComputation(node: ReactiveNode | null): ReactiveNode | null {\n  if (node) resetConsumerBeforeComputation(node);\n\n  return setActiveConsumer(node);\n}\n\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerBeforeComputation` instead of calling this directly.\n */\nexport function resetConsumerBeforeComputation(node: ReactiveNode): void {\n  node.producersTail = undefined;\n  node.recomputing = true;\n}\n\n/**\n * Finalize this consumer's state and set previous consumer as the active consumer after a\n * reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nexport function consumerAfterComputation(\n  node: ReactiveNode | null,\n  prevConsumer: ReactiveNode | null,\n): void {\n  setActiveConsumer(prevConsumer);\n\n  if (node) finalizeConsumerAfterComputation(node);\n}\n\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerAfterComputation` instead of calling this directly.\n */\nexport function finalizeConsumerAfterComputation(node: ReactiveNode): void {\n  node.recomputing = false;\n\n  // We've finished incrementally rebuilding the producers list, now if there are any producers\n  // that are after producersTail, they are stale and should be removed.\n  const producersTail = node.producersTail as ReactiveLink | undefined;\n  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n  if (toRemove !== undefined) {\n    if (consumerIsLive(node)) {\n      // For each stale link, we first unlink it from the producers list of consumers\n      do {\n        toRemove = producerRemoveLiveConsumerLink(toRemove);\n      } while (toRemove !== undefined);\n    }\n\n    // Now, we can truncate the producers list to remove all stale links.\n    if (producersTail !== undefined) {\n      producersTail.nextProducer = undefined;\n    } else {\n      node.producers = undefined;\n    }\n  }\n}\n\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nexport function consumerPollProducersForChange(node: ReactiveNode): boolean {\n  // Poll producers for change.\n  for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n    const producer = link.producer;\n    const seenVersion = link.lastReadVersion;\n\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Disconnect this consumer from the graph.\n */\nexport function consumerDestroy(node: ReactiveNode): void {\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    let link = node.producers;\n    while (link !== undefined) {\n      link = producerRemoveLiveConsumerLink(link);\n    }\n  }\n\n  // Truncate all the linked lists to drop all connection from this node to the graph.\n  node.producers = undefined;\n  node.producersTail = undefined;\n  node.consumers = undefined;\n  node.consumersTail = undefined;\n}\n\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node: ReactiveNode, link: ReactiveLink): void {\n  const consumersTail = node.consumersTail;\n  const wasLive = consumerIsLive(node);\n  if (consumersTail !== undefined) {\n    link.nextConsumer = consumersTail.nextConsumer;\n    consumersTail.nextConsumer = link;\n  } else {\n    link.nextConsumer = undefined;\n    node.consumers = link;\n  }\n  link.prevConsumer = consumersTail;\n  node.consumersTail = link;\n  if (!wasLive) {\n    for (\n      let link: ReactiveLink | undefined = node.producers;\n      link !== undefined;\n      link = link.nextProducer\n    ) {\n      producerAddLiveConsumer(link.producer, link);\n    }\n  }\n}\n\nfunction producerRemoveLiveConsumerLink(link: ReactiveLink): ReactiveLink | undefined {\n  const producer = link.producer;\n  const nextProducer = link.nextProducer;\n  const nextConsumer = link.nextConsumer;\n  const prevConsumer = link.prevConsumer;\n  link.nextConsumer = undefined;\n  link.prevConsumer = undefined;\n  if (nextConsumer !== undefined) {\n    nextConsumer.prevConsumer = prevConsumer;\n  } else {\n    producer.consumersTail = prevConsumer;\n  }\n  if (prevConsumer !== undefined) {\n    prevConsumer.nextConsumer = nextConsumer;\n  } else {\n    producer.consumers = nextConsumer;\n    if (!consumerIsLive(producer)) {\n      let producerLink = producer.producers;\n      while (producerLink !== undefined) {\n        producerLink = producerRemoveLiveConsumerLink(producerLink);\n      }\n    }\n  }\n  return nextProducer;\n}\n\nfunction consumerIsLive(node: ReactiveNode): boolean {\n  return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\n\nexport function runPostProducerCreatedFn(node: ReactiveNode): void {\n  postProducerCreatedFn?.(node);\n}\n\nexport function setPostProducerCreatedFn(fn: ReactiveHookFn | null): ReactiveHookFn | null {\n  const prev = postProducerCreatedFn;\n  postProducerCreatedFn = fn;\n  return prev;\n}\n\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink: ReactiveLink, consumer: ReactiveNode): boolean {\n  const producersTail = consumer.producersTail;\n  if (producersTail !== undefined) {\n    let link = consumer.producers!;\n    do {\n      if (link === checkLink) {\n        return true;\n      }\n      if (link === producersTail) {\n        break;\n      }\n      link = link.nextProducer!;\n    } while (link !== undefined);\n  }\n  return false;\n}\n"]}