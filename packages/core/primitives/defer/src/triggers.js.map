{"version":3,"file":"triggers.js","sourceRoot":"","sources":["triggers.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/** Configuration object used to register passive and capturing events. */\nconst eventListenerOptions: AddEventListenerOptions = {\n  passive: true,\n  capture: true,\n};\n\n/** Keeps track of the currently-registered `on hover` triggers. */\nconst hoverTriggers = new WeakMap<Element, DeferEventEntry>();\n\n/** Keeps track of the currently-registered `on interaction` triggers. */\nconst interactionTriggers = new WeakMap<Element, DeferEventEntry>();\n\n/** Currently-registered `viewport` triggers. */\nexport const viewportTriggers = new WeakMap<Element, DeferEventEntry>();\n\n/** Names of the events considered as interaction events. */\nexport const interactionEventNames = ['click', 'keydown'] as const;\n\n/** Names of the events considered as hover events. */\nexport const hoverEventNames = ['mouseenter', 'mouseover', 'focusin'] as const;\n\n/** `IntersectionObserver` used to observe `viewport` triggers. */\nlet intersectionObserver: IntersectionObserver | null = null;\n\n/** Number of elements currently observed with `viewport` triggers. */\nlet observedViewportElements = 0;\n\n/** Object keeping track of registered callbacks for a deferred block trigger. */\nclass DeferEventEntry {\n  callbacks = new Set<VoidFunction>();\n\n  listener = () => {\n    for (const callback of this.callbacks) {\n      callback();\n    }\n  };\n}\n\n/**\n * Registers an interaction trigger.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger is interacted with.\n * @return cleanup function which removes trigger Element from interactionTriggers map\n * and interaction event listeners from the trigger Element\n */\nexport function onInteraction(trigger: Element, callback: VoidFunction): VoidFunction {\n  let entry = interactionTriggers.get(trigger);\n\n  // If this is the first entry for this element, add the listeners.\n  if (!entry) {\n    // Note that managing events centrally like this lends itself well to using global\n    // event delegation. It currently does delegation at the element level, rather than the\n    // document level, because:\n    // 1. Global delegation is the most effective when there are a lot of events being registered\n    // at the same time. Deferred blocks are unlikely to be used in such a way.\n    // 2. Matching events to their target isn't free. For each `click` and `keydown` event we\n    // would have look through all the triggers and check if the target either is the element\n    // itself or it's contained within the element. Given that `click` and `keydown` are some\n    // of the most common events, this may end up introducing a lot of runtime overhead.\n    // 3. We're still registering only two events per element, no matter how many deferred blocks\n    // are referencing it.\n    entry = new DeferEventEntry();\n    interactionTriggers.set(trigger, entry);\n\n    for (const name of interactionEventNames) {\n      trigger.addEventListener(name, entry!.listener, eventListenerOptions);\n    }\n  }\n\n  entry.callbacks.add(callback);\n\n  return () => {\n    const {callbacks, listener} = entry!;\n    callbacks.delete(callback);\n\n    if (callbacks.size === 0) {\n      interactionTriggers.delete(trigger);\n\n      for (const name of interactionEventNames) {\n        trigger.removeEventListener(name, listener, eventListenerOptions);\n      }\n    }\n  };\n}\n\n/**\n * Registers a hover trigger.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger is hovered over.\n * @return cleanup function which removes trigger element from hoverTriggers map\n * and removes hover interaction event listeners from the trigger element\n */\nexport function onHover(trigger: Element, callback: VoidFunction): VoidFunction {\n  let entry = hoverTriggers.get(trigger);\n\n  // If this is the first entry for this element, add the listener.\n  if (!entry) {\n    entry = new DeferEventEntry();\n    hoverTriggers.set(trigger, entry);\n\n    for (const name of hoverEventNames) {\n      trigger.addEventListener(name, entry!.listener, eventListenerOptions);\n    }\n  }\n\n  entry.callbacks.add(callback);\n\n  return () => {\n    const {callbacks, listener} = entry!;\n    callbacks.delete(callback);\n\n    if (callbacks.size === 0) {\n      for (const name of hoverEventNames) {\n        trigger.removeEventListener(name, listener, eventListenerOptions);\n      }\n      hoverTriggers.delete(trigger);\n    }\n  };\n}\n\n/**\n * Used to create an IntersectionObserver instance.\n * @return IntersectionObserver that is used by onViewport\n */\nexport function createIntersectionObserver() {\n  return new IntersectionObserver((entries) => {\n    for (const current of entries) {\n      if (current.isIntersecting && viewportTriggers.has(current.target)) {\n        viewportTriggers.get(current.target)!.listener();\n      }\n    }\n  });\n}\n\n/**\n * Registers a viewport trigger.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger comes into the viewport.\n * @param observerFactoryFn Factory function which returns an IntersectionObserver\n * @return cleanup function which removes trigger Element from viewportTriggers map\n * and tells the intersection observer to stop observing trigger Element and set\n * intersectionObserver to null if there are no more Elements to observe\n */\nexport function onViewport(\n  trigger: Element,\n  callback: VoidFunction,\n  observerFactoryFn: () => IntersectionObserver,\n): VoidFunction {\n  let entry = viewportTriggers.get(trigger);\n\n  intersectionObserver = intersectionObserver || observerFactoryFn();\n\n  if (!entry) {\n    entry = new DeferEventEntry();\n    intersectionObserver!.observe(trigger);\n    viewportTriggers.set(trigger, entry);\n    observedViewportElements++;\n  }\n\n  entry.callbacks.add(callback);\n\n  return () => {\n    if (!viewportTriggers.has(trigger)) {\n      return;\n    }\n\n    entry!.callbacks.delete(callback);\n\n    if (entry!.callbacks.size === 0) {\n      intersectionObserver?.unobserve(trigger);\n      viewportTriggers.delete(trigger);\n      observedViewportElements--;\n    }\n\n    if (observedViewportElements === 0) {\n      intersectionObserver?.disconnect();\n      intersectionObserver = null;\n    }\n  };\n}\n"]}