{"version":3,"file":"event_contract_container.js","sourceRoot":"","sources":["event_contract_container.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,KAAK,QAAQ,MAAM,SAAS,CAAC;AAiBpC;;GAEG;AACH,MAAM,KAAK,GAAG,OAAO,SAAS,KAAK,WAAW,IAAI,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;AAE/F;;;;GAIG;AACH,MAAM,OAAO,sBAAsB;IAQjC;;OAEG;IACH,YAAqB,OAAgB;QAAhB,YAAO,GAAP,OAAO,CAAS;QAVrC;;;;WAIG;QACK,iBAAY,GAAuB,EAAE,CAAC;IAKN,CAAC;IAEzC;;;;OAIG;IACH,gBAAgB,CACd,SAAiB,EACjB,UAAwD,EACxD,OAAiB;QAEjB,0EAA0E;QAC1E,0EAA0E;QAC1E,sEAAsE;QACtE,mCAAmC;QACnC,EAAE;QACF,6EAA6E;QAC7E,2EAA2E;QAC3E,yEAAyE;QACzE,EAAE;QACF,0EAA0E;QAC1E,qEAAqE;QACrE,IAAI,KAAK,EAAE,CAAC;YACT,IAAI,CAAC,OAAuB,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;QACzD,CAAC;QACD,IAAI,CAAC,YAAY,CAAC,IAAI,CACpB,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,CACtF,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,OAAO;QACL,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAClD,QAAQ,CAAC,mBAAmB,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;QACnE,CAAC;QAED,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;IACzB,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as eventLib from './event';\nimport {EventHandlerInfo} from './event_handler';\n\n/**\n * An `EventContractContainerManager` provides the common interface for managing\n * containers.\n */\nexport interface EventContractContainerManager {\n  addEventListener(\n    eventType: string,\n    getHandler: (element: Element) => (event: Event) => void,\n    passive?: boolean,\n  ): void;\n\n  cleanUp(): void;\n}\n\n/**\n * Whether the user agent is running on iOS.\n */\nconst isIos = typeof navigator !== 'undefined' && /iPhone|iPad|iPod/.test(navigator.userAgent);\n\n/**\n * A class representing a container node and all the event handlers\n * installed on it. Used so that handlers can be cleaned up if the\n * container is removed from the contract.\n */\nexport class EventContractContainer implements EventContractContainerManager {\n  /**\n   * Array of event handlers and their corresponding event types that are\n   * installed on this container.\n   *\n   */\n  private handlerInfos: EventHandlerInfo[] = [];\n\n  /**\n   * @param element The container Element.\n   */\n  constructor(readonly element: Element) {}\n\n  /**\n   * Installs the provided installer on the element owned by this container,\n   * and maintains a reference to resulting handler in order to remove it\n   * later if desired.\n   */\n  addEventListener(\n    eventType: string,\n    getHandler: (element: Element) => (event: Event) => void,\n    passive?: boolean,\n  ) {\n    // In iOS, event bubbling doesn't happen automatically in any DOM element,\n    // unless it has an onclick attribute or DOM event handler attached to it.\n    // This breaks JsAction in some cases. See \"Making Elements Clickable\"\n    // section at http://goo.gl/2VoGnB.\n    //\n    // A workaround for this issue is to change the CSS cursor style to 'pointer'\n    // for the container element, which magically turns on event bubbling. This\n    // solution is described in the comments section at http://goo.gl/6pEO1z.\n    //\n    // We use a navigator.userAgent check here as this problem is present both\n    // on Mobile Safari and thin WebKit wrappers, such as Chrome for iOS.\n    if (isIos) {\n      (this.element as HTMLElement).style.cursor = 'pointer';\n    }\n    this.handlerInfos.push(\n      eventLib.addEventListener(this.element, eventType, getHandler(this.element), passive),\n    );\n  }\n\n  /**\n   * Removes all the handlers installed on this container.\n   */\n  cleanUp() {\n    for (let i = 0; i < this.handlerInfos.length; i++) {\n      eventLib.removeEventListener(this.element, this.handlerInfos[i]);\n    }\n\n    this.handlerInfos = [];\n  }\n}\n"]}