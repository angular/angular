{"version":3,"file":"dispatcher.js","sourceRoot":"","sources":["dispatcher.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAY,gBAAgB,EAAC,MAAM,cAAc,CAAC;AACzD,OAAO,EAAC,SAAS,EAAC,MAAM,cAAc,CAAC;AACvC,OAAO,EAAC,WAAW,EAAC,MAAM,eAAe,CAAC;AAE1C,OAAO,KAAK,QAAQ,MAAM,SAAS,CAAC;AASpC;;;;GAIG;AACH,MAAM,OAAO,UAAU;IAarB;;;;;;OAMG;IACH,YACmB,gBAA8D,EAC/E,EACE,cAAc,EACd,aAAa,MACkD,EAAE;QAJlD,qBAAgB,GAAhB,gBAAgB,CAA8C;QAdjF,6CAA6C;QACrC,yBAAoB,GAAG,KAAK,CAAC;QAErC,2BAA2B;QACV,4BAAuB,GAAuB,EAAE,CAAC;QAgBhE,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;IACrC,CAAC;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IACH,QAAQ,CAAC,SAAoB;QAC3B,MAAM,gBAAgB,GAAG,IAAI,gBAAgB,CAAC,SAAS,CAAC,CAAC;QACzD,IAAI,CAAC,cAAc,EAAE,gBAAgB,CAAC,SAAS,CAAC,CAAC;QACjD,IAAI,CAAC,cAAc,EAAE,aAAa,CAAC,SAAS,CAAC,CAAC;QAC9C,MAAM,MAAM,GAAG,gBAAgB,CAAC,SAAS,EAAE,CAAC;QAC5C,IAAI,MAAM,IAAI,qCAAqC,CAAC,MAAM,CAAC,OAAO,EAAE,gBAAgB,CAAC,EAAE,CAAC;YACtF,QAAQ,CAAC,cAAc,CAAC,gBAAgB,CAAC,QAAQ,EAAE,CAAC,CAAC;QACvD,CAAC;QACD,IAAI,IAAI,CAAC,aAAa,IAAI,gBAAgB,CAAC,WAAW,EAAE,EAAE,CAAC;YACzD,IAAI,CAAC,8BAA8B,CAAC,gBAAgB,CAAC,CAAC;YACtD,OAAO;QACT,CAAC;QACD,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,CAAC;IAC1C,CAAC;IAED;;;;OAIG;IACK,8BAA8B,CAAC,gBAAkC;QACvE,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACpD,IAAI,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAC9B,OAAO;QACT,CAAC;QACD,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC;QACjC,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE;YAC1B,IAAI,CAAC,oBAAoB,GAAG,KAAK,CAAC;YAClC,IAAI,CAAC,aAAc,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;QACpD,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAED;;;GAGG;AACH,MAAM,UAAU,mBAAmB,CAAC,MAAoD;IACtF,OAAO,CAAC,iBAAqC,EAAE,EAAE;QAC/C,KAAK,MAAM,gBAAgB,IAAI,iBAAiB,EAAE,CAAC;YACjD,MAAM,CAAC,gBAAgB,CAAC,CAAC;QAC3B,CAAC;IACH,CAAC,CAAC;AACJ,CAAC;AAED;;;GAGG;AACH,SAAS,qCAAqC,CAC5C,aAAsB,EACtB,gBAAkC;IAElC,yEAAyE;IACzE,4EAA4E;IAC5E,yEAAyE;IACzE,iEAAiE;IACjE,OAAO,CACL,aAAa,CAAC,OAAO,KAAK,GAAG;QAC7B,CAAC,gBAAgB,CAAC,YAAY,EAAE,KAAK,SAAS,CAAC,KAAK;YAClD,gBAAgB,CAAC,YAAY,EAAE,KAAK,SAAS,CAAC,QAAQ,CAAC,CAC1D,CAAC;AACJ,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,kBAAkB,CAAC,aAAqC,EAAE,UAAsB;IAC9F,aAAa,CAAC,IAAI,CAAC,CAAC,SAAoB,EAAE,EAAE;QAC1C,UAAU,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;IACjC,CAAC,EAAE,WAAW,CAAC,2BAA2B,CAAC,CAAC;AAC9C,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EventInfo, EventInfoWrapper} from './event_info';\nimport {EventType} from './event_type';\nimport {Restriction} from './restriction';\nimport {UnrenamedEventContract} from './eventcontract';\nimport * as eventLib from './event';\nimport {ActionResolver} from './action_resolver';\n\n/**\n * A replayer is a function that is called when there are queued events,\n * either from the `EventContract` or when there are no detected handlers.\n */\nexport type Replayer = (eventInfoWrappers: EventInfoWrapper[]) => void;\n\n/**\n * Receives a DOM event, determines the jsaction associated with the source\n * element of the DOM event, and invokes the handler associated with the\n * jsaction.\n */\nexport class Dispatcher {\n  // The ActionResolver to use to resolve actions.\n  private actionResolver?: ActionResolver;\n\n  /** The replayer function to be called when there are queued events. */\n  private eventReplayer?: Replayer;\n\n  /** Whether the event replay is scheduled. */\n  private eventReplayScheduled = false;\n\n  /** The queue of events. */\n  private readonly replayEventInfoWrappers: EventInfoWrapper[] = [];\n\n  /**\n   * Options are:\n   *   - `eventReplayer`: When the event contract dispatches replay events\n   *      to the Dispatcher, the Dispatcher collects them and in the next tick\n   *      dispatches them to the `eventReplayer`. Defaults to dispatching to `dispatchDelegate`.\n   * @param dispatchDelegate A function that should handle dispatching an `EventInfoWrapper` to handlers.\n   */\n  constructor(\n    private readonly dispatchDelegate: (eventInfoWrapper: EventInfoWrapper) => void,\n    {\n      actionResolver,\n      eventReplayer,\n    }: {actionResolver?: ActionResolver; eventReplayer?: Replayer} = {},\n  ) {\n    this.actionResolver = actionResolver;\n    this.eventReplayer = eventReplayer;\n  }\n\n  /**\n   * Receives an event or the event queue from the EventContract. The event\n   * queue is copied and it attempts to replay.\n   * If event info is passed in it looks for an action handler that can handle\n   * the given event.  If there is no handler registered queues the event and\n   * checks if a loader is registered for the given namespace. If so, calls it.\n   *\n   * Alternatively, if in global dispatch mode, calls all registered global\n   * handlers for the appropriate event type.\n   *\n   * The three functionalities of this call are deliberately not split into\n   * three methods (and then declared as an abstract interface), because the\n   * interface is used by EventContract, which lives in a different jsbinary.\n   * Therefore the interface between the three is defined entirely in terms that\n   * are invariant under jscompiler processing (Function and Array, as opposed\n   * to a custom type with method names).\n   *\n   * @param eventInfo The info for the event that triggered this call or the\n   *     queue of events from EventContract.\n   */\n  dispatch(eventInfo: EventInfo): void {\n    const eventInfoWrapper = new EventInfoWrapper(eventInfo);\n    this.actionResolver?.resolveEventType(eventInfo);\n    this.actionResolver?.resolveAction(eventInfo);\n    const action = eventInfoWrapper.getAction();\n    if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {\n      eventLib.preventDefault(eventInfoWrapper.getEvent());\n    }\n    if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {\n      this.scheduleEventInfoWrapperReplay(eventInfoWrapper);\n      return;\n    }\n    this.dispatchDelegate(eventInfoWrapper);\n  }\n\n  /**\n   * Schedules an `EventInfoWrapper` for replay. The replaying will happen in its own\n   * stack once the current flow cedes control. This is done to mimic\n   * browser event handling.\n   */\n  private scheduleEventInfoWrapperReplay(eventInfoWrapper: EventInfoWrapper) {\n    this.replayEventInfoWrappers.push(eventInfoWrapper);\n    if (this.eventReplayScheduled) {\n      return;\n    }\n    this.eventReplayScheduled = true;\n    Promise.resolve().then(() => {\n      this.eventReplayScheduled = false;\n      this.eventReplayer!(this.replayEventInfoWrappers);\n    });\n  }\n}\n\n/**\n * Creates an `EventReplayer` that calls the `replay` function for every `eventInfoWrapper` in\n * the queue.\n */\nexport function createEventReplayer(replay: (eventInfoWrapper: EventInfoWrapper) => void) {\n  return (eventInfoWrappers: EventInfoWrapper[]) => {\n    for (const eventInfoWrapper of eventInfoWrappers) {\n      replay(eventInfoWrapper);\n    }\n  };\n}\n\n/**\n * Returns true if the default action of this event should be prevented before\n * this event is dispatched.\n */\nfunction shouldPreventDefaultBeforeDispatching(\n  actionElement: Element,\n  eventInfoWrapper: EventInfoWrapper,\n): boolean {\n  // Prevent browser from following <a> node links if a jsaction is present\n  // and we are dispatching the action now. Note that the targetElement may be\n  // a child of an anchor that has a jsaction attached. For that reason, we\n  // need to check the actionElement rather than the targetElement.\n  return (\n    actionElement.tagName === 'A' &&\n    (eventInfoWrapper.getEventType() === EventType.CLICK ||\n      eventInfoWrapper.getEventType() === EventType.CLICKMOD)\n  );\n}\n\n/**\n * Registers deferred functionality for an EventContract and a Jsaction\n * Dispatcher.\n */\nexport function registerDispatcher(eventContract: UnrenamedEventContract, dispatcher: Dispatcher) {\n  eventContract.ecrd((eventInfo: EventInfo) => {\n    dispatcher.dispatch(eventInfo);\n  }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\n}\n"]}