{"version":3,"file":"output_from_observable.js","sourceRoot":"","sources":["output_from_observable.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EACL,wBAAwB,EACxB,UAAU,EACV,MAAM,EAIN,aAAa,GAEd,MAAM,gBAAgB,CAAC;AAGxB,OAAO,EAAC,kBAAkB,EAAC,MAAM,wBAAwB,CAAC;AAE1D;;;;;GAKG;AACH,MAAM,uBAAuB;IAK3B,YAAoB,MAAqB;QAArB,WAAM,GAAN,MAAM,CAAe;QAJjC,cAAS,GAAG,KAAK,CAAC;QAE1B,eAAU,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC;QAG9B,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,EAAE;YAC7B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACxB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,SAAS,CAAC,UAA8B;QACtC,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACnB,MAAM,IAAI,aAAa,mDAErB,SAAS;gBACP,oDAAoD;oBAClD,8CAA8C,CACnD,CAAC;QACJ,CAAC;QAED,+EAA+E;QAC/E,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC;YACnF,IAAI,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC;SACnC,CAAC,CAAC;QAEH,OAAO;YACL,WAAW,EAAE,GAAG,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE;SAC9C,CAAC;IACJ,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,UAAU,oBAAoB,CAClC,UAAyB,EACzB,IAAoB;IAEpB,SAAS,IAAI,wBAAwB,CAAC,oBAAoB,CAAC,CAAC;IAC5D,OAAO,IAAI,uBAAuB,CAAI,UAAU,CAAC,CAAC;AACpD,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  DestroyRef,\n  inject,\n  OutputOptions,\n  OutputRef,\n  OutputRefSubscription,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n} from '../../src/core';\nimport {Observable} from 'rxjs';\n\nimport {takeUntilDestroyed} from './take_until_destroyed';\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef<T> implements OutputRef<T> {\n  private destroyed = false;\n\n  destroyRef = inject(DestroyRef);\n\n  constructor(private source: Observable<T>) {\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n\n  subscribe(callbackFn: (value: T) => void): OutputRefSubscription {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(\n        ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED,\n        ngDevMode &&\n          'Unexpected subscription to destroyed `OutputRef`. ' +\n            'The owning directive/component is destroyed.',\n      );\n    }\n\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: (value) => callbackFn(value),\n    });\n\n    return {\n      unsubscribe: () => subscription.unsubscribe(),\n    };\n  }\n}\n\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi 19.0\n */\nexport function outputFromObservable<T>(\n  observable: Observable<T>,\n  opts?: OutputOptions,\n): OutputRef<T> {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef<T>(observable);\n}\n"]}