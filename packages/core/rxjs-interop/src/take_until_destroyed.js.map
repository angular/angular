{"version":3,"file":"take_until_destroyed.js","sourceRoot":"","sources":["take_until_destroyed.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,wBAAwB,EAAE,UAAU,EAAE,MAAM,EAAC,MAAM,gBAAgB,CAAC;AAC5E,OAAO,EAA2B,UAAU,EAAC,MAAM,MAAM,CAAC;AAC1D,OAAO,EAAC,SAAS,EAAC,MAAM,gBAAgB,CAAC;AAEzC;;;;;;;;;GASG;AACH,MAAM,UAAU,kBAAkB,CAAI,UAAuB;IAC3D,IAAI,CAAC,UAAU,EAAE,CAAC;QAChB,SAAS,IAAI,wBAAwB,CAAC,kBAAkB,CAAC,CAAC;QAC1D,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC;IAClC,CAAC;IAED,MAAM,UAAU,GAAG,IAAI,UAAU,CAAO,CAAC,UAAU,EAAE,EAAE;QACrD,IAAI,UAAU,CAAC,SAAS,EAAE,CAAC;YACzB,UAAU,CAAC,IAAI,EAAE,CAAC;YAClB,OAAO;QACT,CAAC;QACD,MAAM,YAAY,GAAG,UAAU,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;QAC5E,OAAO,YAAY,CAAC;IACtB,CAAC,CAAC,CAAC;IAEH,OAAO,CAAI,MAAqB,EAAE,EAAE;QAClC,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC;IAC5C,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext, DestroyRef, inject} from '../../src/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi 19.0\n */\nexport function takeUntilDestroyed<T>(destroyRef?: DestroyRef): MonoTypeOperatorFunction<T> {\n  if (!destroyRef) {\n    ngDevMode && assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n\n  const destroyed$ = new Observable<void>((subscriber) => {\n    if (destroyRef.destroyed) {\n      subscriber.next();\n      return;\n    }\n    const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));\n    return unregisterFn;\n  });\n\n  return <T>(source: Observable<T>) => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n"]}