{"version":3,"file":"pending_until_event.js","sourceRoot":"","sources":["pending_until_event.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAC,wBAAwB,EAAE,YAAY,EAAE,MAAM,EAAE,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AACxF,OAAO,EAA2B,UAAU,EAAC,MAAM,MAAM,CAAC;AAE1D;;;;;;;;GAQG;AACH,MAAM,UAAU,iBAAiB,CAAI,QAAmB;IACtD,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;QAC3B,SAAS,IAAI,wBAAwB,CAAC,iBAAiB,CAAC,CAAC;QACzD,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC9B,CAAC;IACD,MAAM,WAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IAE/C,OAAO,CAAC,gBAAgB,EAAE,EAAE;QAC1B,OAAO,IAAI,UAAU,CAAI,CAAC,kBAAkB,EAAE,EAAE;YAC9C,oCAAoC;YACpC,MAAM,UAAU,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;YAErC,IAAI,SAAS,GAAG,KAAK,CAAC;YACtB,SAAS,WAAW;gBAClB,IAAI,SAAS,EAAE,CAAC;oBACd,OAAO;gBACT,CAAC;gBAED,UAAU,EAAE,CAAC;gBACb,SAAS,GAAG,IAAI,CAAC;YACnB,CAAC;YAED,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,SAAS,CAAC;gBACnD,IAAI,EAAE,CAAC,CAAC,EAAE,EAAE;oBACV,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC3B,WAAW,EAAE,CAAC;gBAChB,CAAC;gBACD,QAAQ,EAAE,GAAG,EAAE;oBACb,kBAAkB,CAAC,QAAQ,EAAE,CAAC;oBAC9B,WAAW,EAAE,CAAC;gBAChB,CAAC;gBACD,KAAK,EAAE,CAAC,CAAC,EAAE,EAAE;oBACX,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC5B,WAAW,EAAE,CAAC;gBAChB,CAAC;aACF,CAAC,CAAC;YACH,iBAAiB,CAAC,GAAG,CAAC,GAAG,EAAE;gBACzB,kBAAkB,CAAC,WAAW,EAAE,CAAC;gBACjC,WAAW,EAAE,CAAC;YAChB,CAAC,CAAC,CAAC;YACH,OAAO,iBAAiB,CAAC;QAC3B,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext, PendingTasks, inject, Injector} from '../../src/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\n\n/**\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @developerPreview 20.0\n */\nexport function pendingUntilEvent<T>(injector?: Injector): MonoTypeOperatorFunction<T> {\n  if (injector === undefined) {\n    ngDevMode && assertInInjectionContext(pendingUntilEvent);\n    injector = inject(Injector);\n  }\n  const taskService = injector.get(PendingTasks);\n\n  return (sourceObservable) => {\n    return new Observable<T>((originalSubscriber) => {\n      // create a new task on subscription\n      const removeTask = taskService.add();\n\n      let cleanedUp = false;\n      function cleanupTask() {\n        if (cleanedUp) {\n          return;\n        }\n\n        removeTask();\n        cleanedUp = true;\n      }\n\n      const innerSubscription = sourceObservable.subscribe({\n        next: (v) => {\n          originalSubscriber.next(v);\n          cleanupTask();\n        },\n        complete: () => {\n          originalSubscriber.complete();\n          cleanupTask();\n        },\n        error: (e) => {\n          originalSubscriber.error(e);\n          cleanupTask();\n        },\n      });\n      innerSubscription.add(() => {\n        originalSubscriber.unsubscribe();\n        cleanupTask();\n      });\n      return innerSubscription;\n    });\n  };\n}\n"]}