{"version":3,"file":"to_signal.js","sourceRoot":"","sources":["to_signal.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  assertNotInReactiveContext,\n  computed,\n  DestroyRef,\n  inject,\n  Injector,\n  signal,\n  Signal,\n  WritableSignal,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n} from '../../src/core';\nimport {ValueEqualityFn} from '../../primitives/signals';\nimport {Observable, Subscribable} from 'rxjs';\n\n/**\n * Options for `toSignal`.\n *\n * @publicApi 20.0\n */\nexport interface ToSignalOptions<T> {\n  /**\n   * Initial value for the signal produced by `toSignal`.\n   *\n   * This will be the value of the signal until the observable emits its first value.\n   */\n  initialValue?: unknown;\n\n  /**\n   * Whether to require that the observable emits synchronously when `toSignal` subscribes.\n   *\n   * If this is `true`, `toSignal` will assert that the observable produces a value immediately upon\n   * subscription. Setting this option removes the need to either deal with `undefined` in the\n   * signal type or provide an `initialValue`, at the cost of a runtime error if this requirement is\n   * not met.\n   */\n  requireSync?: boolean;\n\n  /**\n   * `Injector` which will provide the `DestroyRef` used to clean up the Observable subscription.\n   *\n   * If this is not provided, a `DestroyRef` will be retrieved from the current [injection\n   * context](guide/di/dependency-injection-context), unless manual cleanup is requested.\n   */\n  injector?: Injector;\n\n  /**\n   * Whether the subscription should be automatically cleaned up (via `DestroyRef`) when\n   * `toSignal`'s creation context is destroyed.\n   *\n   * If manual cleanup is enabled, then `DestroyRef` is not used, and the subscription will persist\n   * until the `Observable` itself completes.\n   */\n  manualCleanup?: boolean;\n\n  /**\n   * A comparison function which defines equality for values emitted by the observable.\n   *\n   * Equality comparisons are executed against the initial value if one is provided.\n   */\n  equal?: ValueEqualityFn<T>;\n}\n\n// Base case: no options -> `undefined` in the result type.\nexport function toSignal<T>(source: Observable<T> | Subscribable<T>): Signal<T | undefined>;\n// Options with `undefined` initial value and no `requiredSync` -> `undefined`.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | undefined>> & {\n    initialValue?: undefined;\n    requireSync?: false;\n  },\n): Signal<T | undefined>;\n// Options with `null` initial value -> `null`.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | null>> & {initialValue?: null; requireSync?: false},\n): Signal<T | null>;\n// Options with `undefined` initial value and `requiredSync` -> strict result type.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T>> & {initialValue?: undefined; requireSync: true},\n): Signal<T>;\n// Options with a more specific initial value type.\nexport function toSignal<T, const U extends T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | U>> & {initialValue: U; requireSync?: false},\n): Signal<T | U>;\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n */\nexport function toSignal<T, U = undefined>(\n  source: Observable<T> | Subscribable<T>,\n  options?: ToSignalOptions<T | U> & {initialValue?: U},\n): Signal<T | U> {\n  typeof ngDevMode !== 'undefined' &&\n    ngDevMode &&\n    assertNotInReactiveContext(\n      toSignal,\n      'Invoking `toSignal` causes new subscriptions every time. ' +\n        'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.',\n    );\n\n  const requiresCleanup = !options?.manualCleanup;\n\n  if (ngDevMode && requiresCleanup && !options?.injector) {\n    assertInInjectionContext(toSignal);\n  }\n\n  const cleanupRef = requiresCleanup\n    ? (options?.injector?.get(DestroyRef) ?? inject(DestroyRef))\n    : null;\n\n  const equal = makeToSignalEqual(options?.equal);\n\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state: WritableSignal<State<T | U>>;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({kind: StateKind.NoValue}, {equal});\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal<State<T | U>>(\n      {kind: StateKind.Value, value: options?.initialValue as U},\n      {equal},\n    );\n  }\n\n  let destroyUnregisterFn: (() => void) | undefined;\n\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: (value) => state.set({kind: StateKind.Value, value}),\n    error: (error) => {\n      state.set({kind: StateKind.Error, error});\n      destroyUnregisterFn?.();\n    },\n    complete: () => {\n      destroyUnregisterFn?.();\n    },\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n\n  if (options?.requireSync && state().kind === StateKind.NoValue) {\n    throw new ɵRuntimeError(\n      ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.',\n    );\n  }\n\n  // Unsubscribe when the current context is destroyed, if requested.\n  destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(\n    () => {\n      const current = state();\n      switch (current.kind) {\n        case StateKind.Value:\n          return current.value;\n        case StateKind.Error:\n          throw current.error;\n        case StateKind.NoValue:\n          // This shouldn't really happen because the error is thrown on creation.\n          throw new ɵRuntimeError(\n            ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.',\n          );\n      }\n    },\n    {equal: options?.equal},\n  );\n}\n\nfunction makeToSignalEqual<T>(\n  userEquality: ValueEqualityFn<T> = Object.is,\n): ValueEqualityFn<State<T>> {\n  return (a, b) =>\n    a.kind === StateKind.Value && b.kind === StateKind.Value && userEquality(a.value, b.value);\n}\n\nconst enum StateKind {\n  NoValue,\n  Value,\n  Error,\n}\n\ninterface NoValueState {\n  kind: StateKind.NoValue;\n}\n\ninterface ValueState<T> {\n  kind: StateKind.Value;\n  value: T;\n}\n\ninterface ErrorState {\n  kind: StateKind.Error;\n  error: unknown;\n}\n\ntype State<T> = NoValueState | ValueState<T> | ErrorState;\n"]}