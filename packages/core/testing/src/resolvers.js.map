{"version":3,"file":"resolvers.js","sourceRoot":"","sources":["resolvers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Component,\n  Directive,\n  NgModule,\n  Pipe,\n  Type,\n  ÉµReflectionCapabilities as ReflectionCapabilities,\n} from '../../src/core';\n\nimport {MetadataOverride} from './metadata_override';\nimport {MetadataOverrider} from './metadata_overrider';\n\nconst reflection = new ReflectionCapabilities();\n\n/**\n * Base interface to resolve `@Component`, `@Directive`, `@Pipe` and `@NgModule`.\n */\nexport interface Resolver<T> {\n  addOverride(type: Type<any>, override: MetadataOverride<T>): void;\n  setOverrides(overrides: Array<[Type<any>, MetadataOverride<T>]>): void;\n  resolve(type: Type<any>): T | null;\n}\n\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nabstract class OverrideResolver<T> implements Resolver<T> {\n  private overrides = new Map<Type<any>, MetadataOverride<T>[]>();\n  private resolved = new Map<Type<any>, T | null>();\n\n  abstract get type(): any;\n\n  addOverride(type: Type<any>, override: MetadataOverride<T>) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n\n  setOverrides(overrides: Array<[Type<any>, MetadataOverride<T>]>) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n\n  getAnnotation(type: Type<any>): T | null {\n    const annotations = reflection.annotations(type);\n    // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType =\n        annotation instanceof Directive ||\n        annotation instanceof Component ||\n        annotation instanceof Pipe ||\n        annotation instanceof NgModule;\n      if (isKnownType) {\n        return annotation instanceof this.type ? (annotation as unknown as T) : null;\n      }\n    }\n    return null;\n  }\n\n  resolve(type: Type<any>): T | null {\n    let resolved: T | null = this.resolved.get(type) || null;\n\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach((override) => {\n            resolved = overrider.overrideMetadata(this.type, resolved!, override);\n          });\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n\n    return resolved;\n  }\n}\n\nexport class DirectiveResolver extends OverrideResolver<Directive> {\n  override get type() {\n    return Directive;\n  }\n}\n\nexport class ComponentResolver extends OverrideResolver<Component> {\n  override get type() {\n    return Component;\n  }\n}\n\nexport class PipeResolver extends OverrideResolver<Pipe> {\n  override get type() {\n    return Pipe;\n  }\n}\n\nexport class NgModuleResolver extends OverrideResolver<NgModule> {\n  override get type() {\n    return NgModule;\n  }\n}\n"]}