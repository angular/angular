{"version":3,"file":"test_bed_compiler.js","sourceRoot":"","sources":["test_bed_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ResourceLoader} from '@angular/compiler';\nimport {\n  ApplicationInitStatus,\n  ɵINTERNAL_APPLICATION_ERROR_HANDLER as INTERNAL_APPLICATION_ERROR_HANDLER,\n  Compiler,\n  COMPILER_OPTIONS,\n  Component,\n  Directive,\n  Injector,\n  inject,\n  InjectorType,\n  LOCALE_ID,\n  ModuleWithComponentFactories,\n  ModuleWithProviders,\n  NgModule,\n  NgModuleFactory,\n  Pipe,\n  PlatformRef,\n  Provider,\n  resolveForwardRef,\n  StaticProvider,\n  Type,\n  ɵclearResolutionOfComponentResourcesQueue,\n  ɵcompileComponent as compileComponent,\n  ɵcompileDirective as compileDirective,\n  ɵcompileNgModuleDefs as compileNgModuleDefs,\n  ɵcompilePipe as compilePipe,\n  ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID,\n  ɵDEFER_BLOCK_CONFIG as DEFER_BLOCK_CONFIG,\n  ɵdepsTracker as depsTracker,\n  ɵDirectiveDef as DirectiveDef,\n  ɵgenerateStandaloneInDeclarationsError,\n  ɵgetAsyncClassMetadataFn as getAsyncClassMetadataFn,\n  ɵgetInjectableDef as getInjectableDef,\n  ɵInternalEnvironmentProviders as InternalEnvironmentProviders,\n  ɵprovideZonelessChangeDetectionInternal as provideZonelessChangeDetectionInternal,\n  ɵinternalProvideZoneChangeDetection as internalProvideZoneChangeDetection,\n  ɵisComponentDefPendingResolution,\n  ɵisEnvironmentProviders as isEnvironmentProviders,\n  ɵNG_COMP_DEF as NG_COMP_DEF,\n  ɵNG_DIR_DEF as NG_DIR_DEF,\n  ɵNG_INJ_DEF as NG_INJ_DEF,\n  ɵNG_MOD_DEF as NG_MOD_DEF,\n  ɵNG_PIPE_DEF as NG_PIPE_DEF,\n  ɵNgModuleFactory as R3NgModuleFactory,\n  ɵNgModuleTransitiveScopes as NgModuleTransitiveScopes,\n  ɵNgModuleType as NgModuleType,\n  ɵpatchComponentDefWithScope as patchComponentDefWithScope,\n  ɵRender3ComponentFactory as ComponentFactory,\n  ɵRender3NgModuleRef as NgModuleRef,\n  ɵresolveComponentResources,\n  ɵrestoreComponentResolutionQueue,\n  ɵsetLocaleId as setLocaleId,\n  ɵtransitiveScopesFor as transitiveScopesFor,\n  ɵɵInjectableDeclaration as InjectableDeclaration,\n  NgZone,\n  ErrorHandler,\n  ENVIRONMENT_INITIALIZER,\n  ɵANIMATIONS_DISABLED as ANIMATIONS_DISABLED,\n} from '../../src/core';\n\nimport {ComponentDef, ComponentType} from '../../src/render3';\n\nimport {MetadataOverride} from './metadata_override';\nimport {\n  ComponentResolver,\n  DirectiveResolver,\n  NgModuleResolver,\n  PipeResolver,\n  Resolver,\n} from './resolvers';\nimport {\n  ANIMATIONS_ENABLED_DEFAULT,\n  DEFER_BLOCK_DEFAULT_BEHAVIOR,\n  TestModuleMetadata,\n} from './test_bed_common';\nimport {\n  RETHROW_APPLICATION_ERRORS_DEFAULT,\n  TestBedApplicationErrorHandler,\n} from './application_error_handler';\n\nenum TestingModuleOverride {\n  DECLARATION,\n  OVERRIDE_TEMPLATE,\n}\n\nconst ZONELESS_BY_DEFAULT = true;\n\nfunction isTestingModuleOverride(value: unknown): value is TestingModuleOverride {\n  return (\n    value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE\n  );\n}\n\nfunction assertNoStandaloneComponents(\n  types: Type<any>[],\n  resolver: Resolver<any>,\n  location: string,\n) {\n  types.forEach((type) => {\n    if (!getAsyncClassMetadataFn(type)) {\n      const component = resolver.resolve(type);\n      if (component && (component.standalone == null || component.standalone)) {\n        throw new Error(ɵgenerateStandaloneInDeclarationsError(type, location));\n      }\n    }\n  });\n}\n\n// Resolvers for Angular decorators\ntype Resolvers = {\n  module: Resolver<NgModule>;\n  component: Resolver<Directive>;\n  directive: Resolver<Component>;\n  pipe: Resolver<Pipe>;\n};\n\ninterface CleanupOperation {\n  fieldName: string;\n  object: any;\n  originalValue: unknown;\n}\n\nexport class TestBedCompiler {\n  private originalComponentResolutionQueue: Map<Type<any>, Component> | null = null;\n\n  // Testing module configuration\n  private declarations: Type<any>[] = [];\n  private imports: Type<any>[] = [];\n  private providers: Provider[] = [];\n  private schemas: any[] = [];\n\n  // Queues of components/directives/pipes that should be recompiled.\n  private pendingComponents = new Set<Type<any>>();\n  private pendingDirectives = new Set<Type<any>>();\n  private pendingPipes = new Set<Type<any>>();\n\n  // Set of components with async metadata, i.e. components with `@defer` blocks\n  // in their templates.\n  private componentsWithAsyncMetadata = new Set<Type<unknown>>();\n\n  // Keep track of all components and directives, so we can patch Providers onto defs later.\n  private seenComponents = new Set<Type<any>>();\n  private seenDirectives = new Set<Type<any>>();\n\n  // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n  private overriddenModules = new Set<NgModuleType<any>>();\n\n  // Store resolved styles for Components that have template overrides present and `styleUrls`\n  // defined at the same time.\n  private existingComponentStyles = new Map<Type<any>, string[]>();\n\n  private resolvers: Resolvers = initResolvers();\n\n  // Map of component type to an NgModule that declares it.\n  //\n  // There are a couple special cases:\n  // - for standalone components, the module scope value is `null`\n  // - when a component is declared in `TestBed.configureTestingModule()` call or\n  //   a component's template is overridden via `TestBed.overrideTemplateUsingTestingModule()`.\n  //   we use a special value from the `TestingModuleOverride` enum.\n  private componentToModuleScope = new Map<Type<any>, Type<any> | TestingModuleOverride | null>();\n\n  // Map that keeps initial version of component/directive/pipe defs in case\n  // we compile a Type again, thus overriding respective static fields. This is\n  // required to make sure we restore defs to their initial states between test runs.\n  // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n  // NgModule), store all of them in a map.\n  private initialNgDefs = new Map<Type<any>, Map<string, PropertyDescriptor | undefined>>();\n\n  // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n  // defs in case TestBed makes changes to the originals.\n  private defCleanupOps: CleanupOperation[] = [];\n\n  private _injector: Injector | null = null;\n  private compilerProviders: Provider[] | null = null;\n\n  private providerOverrides: Provider[] = [];\n  private rootProviderOverrides: Provider[] = [];\n  // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n  // module's provider list.\n  private providerOverridesByModule = new Map<InjectorType<any>, Provider[]>();\n  private providerOverridesByToken = new Map<any, Provider>();\n  private scopesWithOverriddenProviders = new Set<Type<any>>();\n\n  private testModuleType: NgModuleType<any>;\n  private testModuleRef: NgModuleRef<any> | null = null;\n\n  private animationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n  private deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  private rethrowApplicationTickErrors = RETHROW_APPLICATION_ERRORS_DEFAULT;\n\n  constructor(\n    private platform: PlatformRef,\n    private additionalModuleTypes: Type<any> | Type<any>[],\n  ) {\n    class DynamicTestModule {}\n    this.testModuleType = DynamicTestModule as any;\n  }\n\n  setCompilerProviders(providers: Provider[] | null): void {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n\n  configureTestingModule(moduleDef: TestModuleMetadata): void {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      // Verify that there are no standalone components\n      assertNoStandaloneComponents(\n        moduleDef.declarations,\n        this.resolvers.component,\n        '\"TestBed.configureTestingModule\" call',\n      );\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    }\n\n    // Enqueue any compilation tasks for imported modules.\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n\n    this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    this.animationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n    this.rethrowApplicationTickErrors =\n      moduleDef.rethrowApplicationErrors ?? RETHROW_APPLICATION_ERRORS_DEFAULT;\n  }\n\n  overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void {\n    depsTracker.clearScopeCacheFor(ngModule);\n    this.overriddenModules.add(ngModule as NgModuleType<any>);\n\n    // Compile the module right away.\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n\n    this.recompileNgModule(ngModule, metadata);\n\n    // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n\n  overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void {\n    this.verifyNoStandaloneFlagOverrides(component, override);\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(component);\n  }\n\n  overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void {\n    this.verifyNoStandaloneFlagOverrides(directive, override);\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n\n  overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void {\n    this.verifyNoStandaloneFlagOverrides(pipe, override);\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n\n  private verifyNoStandaloneFlagOverrides(\n    type: Type<any>,\n    override: MetadataOverride<Component | Directive | Pipe>,\n  ) {\n    if (\n      override.add?.hasOwnProperty('standalone') ||\n      override.set?.hasOwnProperty('standalone') ||\n      override.remove?.hasOwnProperty('standalone')\n    ) {\n      throw new Error(\n        `An override for the ${type.name} class has the \\`standalone\\` flag. ` +\n          `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`,\n      );\n    }\n  }\n\n  overrideProvider(\n    token: any,\n    provider: {useFactory?: Function; useValue?: any; deps?: any[]; multi?: boolean},\n  ): void {\n    let providerDef: Provider;\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi,\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {provide: token, useValue: provider.useValue, multi: provider.multi};\n    } else {\n      providerDef = {provide: token};\n    }\n\n    const injectableDef: InjectableDeclaration<any> | null =\n      typeof token !== 'string' ? getInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n    const overridesBucket =\n      providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef);\n\n    // Keep overrides grouped by token as well for fast lookups using token\n    this.providerOverridesByToken.set(token, providerDef);\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n\n  overrideTemplateUsingTestingModule(type: Type<any>, template: string): void {\n    const def = (type as any)[NG_COMP_DEF];\n    const hasStyleUrls = (): boolean => {\n      const metadata = this.resolvers.component.resolve(type)! as Component;\n      return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n    };\n    const overrideStyleUrls = !!def && !ɵisComponentDefPendingResolution(type) && hasStyleUrls();\n\n    // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n    const override = overrideStyleUrls\n      ? {template, styles: [], styleUrls: [], styleUrl: undefined}\n      : {template};\n    this.overrideComponent(type, {set: override});\n\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    }\n\n    // Set the component's scope to be the testing module.\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n\n  private async resolvePendingComponentsWithAsyncMetadata() {\n    if (this.componentsWithAsyncMetadata.size === 0) return;\n\n    const promises = [];\n    for (const component of this.componentsWithAsyncMetadata) {\n      const asyncMetadataFn = getAsyncClassMetadataFn(component);\n      if (asyncMetadataFn) {\n        promises.push(asyncMetadataFn());\n      }\n    }\n    this.componentsWithAsyncMetadata.clear();\n\n    const resolvedDeps = await Promise.all(promises);\n    const flatResolvedDeps = resolvedDeps.flat(2);\n    this.queueTypesFromModulesArray(flatResolvedDeps);\n\n    // Loaded standalone components might contain imports of NgModules\n    // with providers, make sure we override providers there too.\n    for (const component of flatResolvedDeps) {\n      this.applyProviderOverridesInScope(component);\n    }\n  }\n\n  async compileComponents(): Promise<void> {\n    this.clearComponentResolutionQueue();\n\n    // Wait for all async metadata for components that were\n    // overridden, we need resolved metadata to perform an override\n    // and re-compile a component.\n    await this.resolvePendingComponentsWithAsyncMetadata();\n\n    // Verify that there were no standalone components present in the `declarations` field\n    // during the `TestBed.configureTestingModule` call. We perform this check here in addition\n    // to the logic in the `configureTestingModule` function, since at this point we have\n    // all async metadata resolved.\n    assertNoStandaloneComponents(\n      this.declarations,\n      this.resolvers.component,\n      '\"TestBed.configureTestingModule\" call',\n    );\n\n    // Run compilers for all queued types.\n    let needsAsyncResources = this.compileTypesSync();\n\n    // compileComponents() should not be async unless it needs to be.\n    if (needsAsyncResources) {\n      let resourceLoader: ResourceLoader;\n      let resolver = (url: string): Promise<string> => {\n        if (!resourceLoader) {\n          resourceLoader = this.injector.get(ResourceLoader);\n        }\n        return Promise.resolve(resourceLoader.get(url));\n      };\n      await ɵresolveComponentResources(resolver);\n    }\n  }\n\n  finalize(): NgModuleRef<any> {\n    // One last compile\n    this.compileTypesSync();\n\n    // Create the testing module itself.\n    this.compileTestModule();\n\n    this.applyTransitiveScopes();\n\n    this.applyProviderOverrides();\n\n    // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n    this.patchComponentsWithExistingStyles();\n\n    // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n    this.componentToModuleScope.clear();\n\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new NgModuleRef(this.testModuleType, parentInjector, []);\n\n    // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n    (this.testModuleRef.injector.get(ApplicationInitStatus) as any).runInitializers();\n\n    // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n    setLocaleId(localeId);\n\n    return this.testModuleRef;\n  }\n\n  /**\n   * @internal\n   */\n  _compileNgModuleSync(moduleType: Type<any>): void {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n\n  /**\n   * @internal\n   */\n  async _compileNgModuleAsync(moduleType: Type<any>): Promise<void> {\n    this.queueTypesFromModulesArray([moduleType]);\n    await this.compileComponents();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n\n  /**\n   * @internal\n   */\n  _getModuleResolver(): Resolver<NgModule> {\n    return this.resolvers.module;\n  }\n\n  /**\n   * @internal\n   */\n  _getComponentFactories(moduleType: NgModuleType): ComponentFactory<any>[] {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = (declaration as any).ɵcmp;\n      componentDef && factories.push(new ComponentFactory(componentDef, this.testModuleRef!));\n      return factories;\n    }, [] as ComponentFactory<any>[]);\n  }\n\n  private compileTypesSync(): boolean {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach((declaration) => {\n      if (getAsyncClassMetadataFn(declaration)) {\n        throw new Error(\n          `Component '${declaration.name}' has unresolved metadata. ` +\n            `Please call \\`await TestBed.compileComponents()\\` before running this test.`,\n        );\n      }\n\n      needsAsyncResources = needsAsyncResources || ɵisComponentDefPendingResolution(declaration);\n\n      const metadata = this.resolvers.component.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n\n      this.maybeStoreNgDef(NG_COMP_DEF, declaration);\n      depsTracker.clearScopeCacheFor(declaration);\n      compileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n\n    this.pendingDirectives.forEach((declaration) => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n      this.maybeStoreNgDef(NG_DIR_DEF, declaration);\n      compileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n\n    this.pendingPipes.forEach((declaration) => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n      this.maybeStoreNgDef(NG_PIPE_DEF, declaration);\n      compilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n\n    return needsAsyncResources;\n  }\n\n  private applyTransitiveScopes(): void {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculation.\n      const testingModuleDef = (this.testModuleType as any)[NG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n      if (affectedModules.size > 0) {\n        affectedModules.forEach((moduleType) => {\n          depsTracker.clearScopeCacheFor(moduleType);\n        });\n      }\n    }\n\n    const moduleToScope = new Map<Type<any> | TestingModuleOverride, NgModuleTransitiveScopes>();\n    const getScopeOfModule = (\n      moduleType: Type<any> | TestingModuleOverride,\n    ): NgModuleTransitiveScopes => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : (moduleType as Type<any>);\n        moduleToScope.set(moduleType, transitiveScopesFor(realType));\n      }\n      return moduleToScope.get(moduleType)!;\n    };\n\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      if (moduleType !== null) {\n        const moduleScope = getScopeOfModule(moduleType);\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'directiveDefs');\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'pipeDefs');\n        patchComponentDefWithScope(getComponentDef(componentType)!, moduleScope);\n      }\n      // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n      // Resetting `tView` is also needed for cases when we apply provider overrides and those\n      // providers are defined on component's level, in which case they may end up included into\n      // `tView.blueprint`.\n      this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'tView');\n    });\n\n    this.componentToModuleScope.clear();\n  }\n\n  private applyProviderOverrides(): void {\n    const maybeApplyOverrides = (field: string) => (type: Type<any>) => {\n      const resolver = field === NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type)!;\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n    this.seenComponents.forEach(maybeApplyOverrides(NG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(NG_DIR_DEF));\n\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n\n  /**\n   * Applies provider overrides to a given type (either an NgModule or a standalone component)\n   * and all imported NgModules and standalone components recursively.\n   */\n  private applyProviderOverridesInScope(type: Type<any>): void {\n    const hasScope = isStandaloneComponent(type) || isNgModule(type);\n\n    // The function can be re-entered recursively while inspecting dependencies\n    // of an NgModule or a standalone component. Exit early if we come across a\n    // type that can not have a scope (directive or pipe) or the type is already\n    // processed earlier.\n    if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n      return;\n    }\n    this.scopesWithOverriddenProviders.add(type);\n\n    // NOTE: the line below triggers JIT compilation of the module injector,\n    // which also invokes verification of the NgModule semantics, which produces\n    // detailed error messages. The fact that the code relies on this line being\n    // present here is suspicious and should be refactored in a way that the line\n    // below can be moved (for ex. after an early exit check below).\n    const injectorDef: any = (type as any)[NG_INJ_DEF];\n\n    // No provider overrides, exit early.\n    if (this.providerOverridesByToken.size === 0) return;\n\n    if (isStandaloneComponent(type)) {\n      // Visit all component dependencies and override providers there.\n      const def = getComponentDef(type);\n      const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n      for (const dependency of dependencies) {\n        this.applyProviderOverridesInScope(dependency);\n      }\n    } else {\n      const providers: Array<Provider | InternalEnvironmentProviders> = [\n        ...injectorDef.providers,\n        ...(this.providerOverridesByModule.get(type as InjectorType<any>) || []),\n      ];\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(NG_INJ_DEF, type);\n\n        this.storeFieldOfDefOnType(type, NG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      }\n\n      // Apply provider overrides to imported modules recursively\n      const moduleDef = (type as any)[NG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n      for (const importedModule of imports) {\n        this.applyProviderOverridesInScope(importedModule);\n      }\n      // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers,\n          });\n          importedModule.providers = this.getOverriddenProviders(\n            importedModule.providers as Array<Provider | InternalEnvironmentProviders>,\n          );\n        }\n      }\n    }\n  }\n\n  private patchComponentsWithExistingStyles(): void {\n    this.existingComponentStyles.forEach(\n      (styles, type) => ((type as any)[NG_COMP_DEF].styles = styles),\n    );\n    this.existingComponentStyles.clear();\n  }\n\n  private queueTypeArray(arr: any[], moduleType: Type<any> | TestingModuleOverride): void {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n\n  private recompileNgModule(ngModule: Type<any>, metadata: NgModule): void {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(NG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(NG_INJ_DEF, ngModule);\n\n    compileNgModuleDefs(ngModule as NgModuleType<any>, metadata);\n  }\n\n  private maybeRegisterComponentWithAsyncMetadata(type: Type<unknown>) {\n    const asyncMetadataFn = getAsyncClassMetadataFn(type);\n    if (asyncMetadataFn) {\n      this.componentsWithAsyncMetadata.add(type);\n    }\n  }\n\n  private queueType(type: Type<any>, moduleType: Type<any> | TestingModuleOverride | null): void {\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(type);\n\n    const component = this.resolvers.component.resolve(type);\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (ɵisComponentDefPendingResolution(type) || !type.hasOwnProperty(NG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n      this.seenComponents.add(type);\n\n      // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n      if (\n        !this.componentToModuleScope.has(type) ||\n        this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION\n      ) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n      return;\n    }\n\n    const directive = this.resolvers.directive.resolve(type);\n    if (directive) {\n      if (!type.hasOwnProperty(NG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n      this.seenDirectives.add(type);\n      return;\n    }\n\n    const pipe = this.resolvers.pipe.resolve(type);\n    if (pipe && !type.hasOwnProperty(NG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n\n  private queueTypesFromModulesArray(arr: any[]): void {\n    // Because we may encounter the same NgModule or a standalone Component while processing\n    // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n    // can skip ones that have already been seen encountered. In some test setups, this caching\n    // resulted in 10X runtime improvement.\n    const processedDefs = new Set();\n    const queueTypesFromModulesArrayRecur = (arr: any[]): void => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          // Look through declarations, imports, and exports, and queue\n          // everything found there.\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        } else if (isStandaloneComponent(value)) {\n          this.queueType(value, null);\n          const def = getComponentDef(value);\n\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n\n          const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n          dependencies.forEach((dependency) => {\n            // Note: in AOT, the `dependencies` might also contain regular\n            // (NgModule-based) Component, Directive and Pipes, so we handle\n            // them separately and proceed with recursive process for standalone\n            // Components and NgModules only.\n            if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n              queueTypesFromModulesArrayRecur([dependency]);\n            } else {\n              this.queueType(dependency, null);\n            }\n          });\n        }\n      }\n    };\n    queueTypesFromModulesArrayRecur(arr);\n  }\n\n  // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n  private collectModulesAffectedByOverrides(arr: any[]): Set<NgModuleType<any>> {\n    const seenModules = new Set<NgModuleType<any>>();\n    const affectedModules = new Set<NgModuleType<any>>();\n    const calcAffectedModulesRecur = (arr: any[], path: NgModuleType<any>[]): void => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach((item) => affectedModules.add(item));\n            }\n            continue;\n          }\n          seenModules.add(value);\n          if (this.overriddenModules.has(value)) {\n            path.forEach((item) => affectedModules.add(item));\n          }\n          // Examine module imports recursively to look for overridden modules.\n          const moduleDef = (value as any)[NG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n\n  /**\n   * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\n   * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\n   * an NgModule). If there is a def in a set already, don't override it, since\n   * an original one should be restored at the end of a test.\n   */\n  private maybeStoreNgDef(prop: string, type: Type<any>) {\n    if (!this.initialNgDefs.has(type)) {\n      this.initialNgDefs.set(type, new Map());\n    }\n    const currentDefs = this.initialNgDefs.get(type)!;\n    if (!currentDefs.has(prop)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      currentDefs.set(prop, currentDef);\n    }\n  }\n\n  private storeFieldOfDefOnType(type: Type<any>, defField: string, fieldName: string): void {\n    const def: any = (type as any)[defField];\n    const originalValue: any = def[fieldName];\n    this.defCleanupOps.push({object: def, fieldName, originalValue});\n  }\n\n  /**\n   * Clears current components resolution queue, but stores the state of the queue, so we can\n   * restore it later. Clearing the queue is required before we try to compile components (via\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n   */\n  private clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n    ɵclearResolutionOfComponentResourcesQueue().forEach((value, key) =>\n      this.originalComponentResolutionQueue!.set(key, value),\n    );\n  }\n\n  /*\n   * Restores component resolution queue to the previously saved state. This operation is performed\n   * as a part of restoring the state after completion of the current set of tests (that might\n   * potentially mutate the state).\n   */\n  private restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      ɵrestoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n\n  restoreOriginalState(): void {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, (op: CleanupOperation) => {\n      op.object[op.fieldName] = op.originalValue;\n    });\n    // Restore initial component/directive/pipe defs\n    this.initialNgDefs.forEach(\n      (defs: Map<string, PropertyDescriptor | undefined>, type: Type<any>) => {\n        depsTracker.clearScopeCacheFor(type);\n        defs.forEach((descriptor, prop) => {\n          if (!descriptor) {\n            // Delete operations are generally undesirable since they have performance\n            // implications on objects they were applied to. In this particular case, situations\n            // where this code is invoked should be quite rare to cause any noticeable impact,\n            // since it's applied only to some test cases (for example when class with no\n            // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n            // class to restore its original state (before applying overrides and running tests).\n            delete (type as any)[prop];\n          } else {\n            Object.defineProperty(type, prop, descriptor);\n          }\n        });\n      },\n    );\n    this.initialNgDefs.clear();\n    this.scopesWithOverriddenProviders.clear();\n    this.restoreComponentResolutionQueue();\n    // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n    setLocaleId(DEFAULT_LOCALE_ID);\n  }\n\n  private compileTestModule(): void {\n    class RootScopeModule {}\n    compileNgModuleDefs(RootScopeModule as NgModuleType<any>, {\n      providers: [\n        ...this.rootProviderOverrides,\n        provideZonelessChangeDetectionInternal(),\n        ZONELESS_BY_DEFAULT ? [] : internalProvideZoneChangeDetection({}),\n        TestBedApplicationErrorHandler,\n        {\n          provide: ENVIRONMENT_INITIALIZER,\n          multi: true,\n          useValue: () => {\n            inject(ErrorHandler);\n          },\n        },\n      ],\n    });\n\n    const providers = [\n      {provide: Compiler, useFactory: () => new R3TestCompiler(this)},\n      {provide: DEFER_BLOCK_CONFIG, useValue: {behavior: this.deferBlockBehavior}},\n      {\n        provide: ANIMATIONS_DISABLED,\n        useValue: !this.animationsEnabled,\n      },\n      {\n        provide: INTERNAL_APPLICATION_ERROR_HANDLER,\n        useFactory: () => {\n          if (this.rethrowApplicationTickErrors) {\n            const handler = inject(TestBedApplicationErrorHandler);\n            return (e: unknown) => {\n              handler.handleError(e);\n            };\n          } else {\n            const userErrorHandler = inject(ErrorHandler);\n            const ngZone = inject(NgZone);\n            return (e: unknown) => ngZone.runOutsideAngular(() => userErrorHandler.handleError(e));\n          }\n        },\n      },\n      ...this.providers,\n      ...this.providerOverrides,\n    ];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n\n    compileNgModuleDefs(\n      this.testModuleType,\n      {\n        declarations: this.declarations,\n        imports,\n        schemas: this.schemas,\n        providers,\n      },\n      /* allowDuplicateDeclarationsInRoot */ true,\n    );\n\n    this.applyProviderOverridesInScope(this.testModuleType);\n  }\n\n  get injector(): Injector {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n\n    const providers: StaticProvider[] = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS, []);\n    compilerOptions.forEach((opts) => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n    if (this.compilerProviders !== null) {\n      providers.push(...(this.compilerProviders as StaticProvider[]));\n    }\n\n    this._injector = Injector.create({providers, parent: this.platform.injector});\n    return this._injector;\n  }\n\n  // get overrides for a specific provider (if any)\n  private getSingleProviderOverrides(provider: Provider): Provider | null {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n\n  private getProviderOverrides(\n    providers?: Array<Provider | InternalEnvironmentProviders>,\n  ): Provider[] {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    // There are two flattening operations here. The inner flattenProviders() operates on the\n    // metadata's providers and applies a mapping function which retrieves overrides for each\n    // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n    // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n    return flatten(\n      flattenProviders(\n        providers,\n        (provider: Provider) => this.getSingleProviderOverrides(provider) || [],\n      ),\n    );\n  }\n\n  private getOverriddenProviders(\n    providers?: Array<Provider | InternalEnvironmentProviders>,\n  ): Provider[] {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n\n    const flattenedProviders = flattenProviders(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final: Provider[] = [];\n    const seenOverriddenProviders = new Set<Provider>();\n\n    // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n    forEachRight(overriddenProviders, (provider: any) => {\n      const token: any = getProviderToken(provider);\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token);\n          // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n          final.unshift({...provider, multi: false});\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n\n  private hasProviderOverrides(\n    providers?: Array<Provider | InternalEnvironmentProviders>,\n  ): boolean {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n\n  private patchDefWithProviderOverrides(declaration: Type<any>, field: string): void {\n    const def = (declaration as any)[field];\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n\n      const resolver = def.providersResolver;\n      const processProvidersFn = (providers: Provider[]) => this.getOverriddenProviders(providers);\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n      def.providersResolver = (ngDef: DirectiveDef<any>) => resolver(ngDef, processProvidersFn);\n    }\n  }\n}\n\nfunction initResolvers(): Resolvers {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver(),\n  };\n}\n\nfunction isStandaloneComponent<T>(value: Type<T>): value is ComponentType<T> {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\n\nfunction getComponentDef(value: ComponentType<unknown>): ComponentDef<unknown>;\nfunction getComponentDef(value: Type<unknown>): ComponentDef<unknown> | null;\nfunction getComponentDef(value: Type<unknown>): ComponentDef<unknown> | null {\n  return (value as any).ɵcmp ?? null;\n}\n\nfunction hasNgModuleDef<T>(value: Type<T>): value is NgModuleType<T> {\n  return value.hasOwnProperty('ɵmod');\n}\n\nfunction isNgModule<T>(value: Type<T>): boolean {\n  return hasNgModuleDef(value);\n}\n\nfunction maybeUnwrapFn<T>(maybeFn: (() => T) | T): T {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\n\nfunction flatten<T>(values: any[]): T[] {\n  const out: T[] = [];\n  values.forEach((value) => {\n    if (Array.isArray(value)) {\n      out.push(...flatten<T>(value));\n    } else {\n      out.push(value);\n    }\n  });\n  return out;\n}\n\nfunction identityFn<T>(value: T): T {\n  return value;\n}\n\nfunction flattenProviders<T>(\n  providers: Array<Provider | InternalEnvironmentProviders>,\n  mapFn: (provider: Provider) => T,\n): T[];\nfunction flattenProviders(providers: Array<Provider | InternalEnvironmentProviders>): Provider[];\nfunction flattenProviders(\n  providers: Array<Provider | InternalEnvironmentProviders>,\n  mapFn: (provider: Provider) => any = identityFn,\n): any[] {\n  const out: any[] = [];\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      out.push(...flattenProviders(provider, mapFn));\n    } else {\n      out.push(mapFn(provider));\n    }\n  }\n  return out;\n}\n\nfunction getProviderField(provider: Provider, field: string) {\n  return provider && typeof provider === 'object' && (provider as any)[field];\n}\n\nfunction getProviderToken(provider: Provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\n\nfunction isModuleWithProviders(value: any): value is ModuleWithProviders<any> {\n  return value.hasOwnProperty('ngModule');\n}\n\nfunction forEachRight<T>(values: T[], fn: (value: T, idx: number) => void): void {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\n\nfunction invalidTypeError(name: string, expectedType: string): Error {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\n\nclass R3TestCompiler implements Compiler {\n  constructor(private testBed: TestBedCompiler) {}\n\n  compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T> {\n    this.testBed._compileNgModuleSync(moduleType);\n    return new R3NgModuleFactory(moduleType);\n  }\n\n  async compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>> {\n    await this.testBed._compileNgModuleAsync(moduleType);\n    return new R3NgModuleFactory(moduleType);\n  }\n\n  compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T> {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType as NgModuleType<T>);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n\n  async compileModuleAndAllComponentsAsync<T>(\n    moduleType: Type<T>,\n  ): Promise<ModuleWithComponentFactories<T>> {\n    const ngModuleFactory = await this.compileModuleAsync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType as NgModuleType<T>);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n\n  clearCache(): void {}\n\n  clearCacheFor(type: Type<any>): void {}\n\n  getModuleId(moduleType: Type<any>): string | undefined {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n    return (meta && meta.id) || undefined;\n  }\n}\n"]}