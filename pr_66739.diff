diff --git a/packages/language-service/api.ts b/packages/language-service/api.ts
index d493b6328fd5..a0d1722c2ad7 100644
--- a/packages/language-service/api.ts
+++ b/packages/language-service/api.ts
@@ -139,6 +139,8 @@ export interface NgLanguageService extends ts.LanguageService {
 
   getTokenTypeFromClassification(classification: number): number | undefined;
   getTokenModifierFromClassification(classification: number): number;
+
+  getSelectionRangeAtPosition(fileName: string, position: number): ts.SelectionRange | undefined;
 }
 
 export function isNgLanguageService(
diff --git a/packages/language-service/src/language_service.ts b/packages/language-service/src/language_service.ts
index 80d0c2b7f5ff..b2fae430e980 100644
--- a/packages/language-service/src/language_service.ts
+++ b/packages/language-service/src/language_service.ts
@@ -41,6 +41,7 @@ import {getOutliningSpans} from './outlining_spans';
 import {QuickInfoBuilder} from './quick_info';
 import {ReferencesBuilder, RenameBuilder} from './references_and_rename';
 import {createLocationKey} from './references_and_rename_utils';
+import {getSelectionRangeAtPosition} from './selection_range';
 import {getSignatureHelp} from './signature_help';
 import {
   getTargetAtPosition,
@@ -300,6 +301,12 @@ export class LanguageService {
     });
   }
 
+  getSelectionRangeAtPosition(fileName: string, position: number): ts.SelectionRange | undefined {
+    return this.withCompilerAndPerfTracing(PerfPhase.LsReferencesAndRenames, (compiler) => {
+      return getSelectionRangeAtPosition(compiler, fileName, position);
+    });
+  }
+
   private getCompletionBuilder(
     fileName: string,
     position: number,
diff --git a/packages/language-service/src/selection_range.ts b/packages/language-service/src/selection_range.ts
new file mode 100644
index 000000000000..c10ae5870966
--- /dev/null
+++ b/packages/language-service/src/selection_range.ts
@@ -0,0 +1,1115 @@
+/**
+ * @license
+ * Copyright Google LLC All Rights Reserved.
+ *
+ * Use of this source code is governed by an MIT-style license that can be
+ * found in the LICENSE file at https://angular.dev/license
+ */
+
+import {
+  AST,
+  ASTWithSource,
+  BindingPipe,
+  Call,
+  ImplicitReceiver,
+  Interpolation,
+  LiteralPrimitive,
+  ParseSourceSpan,
+  RecursiveAstVisitor,
+  SafeCall,
+  TemplateLiteral,
+  TemplateLiteralElement,
+  ThisReceiver,
+  TmplAstBoundAttribute,
+  TmplAstBoundDeferredTrigger,
+  TmplAstBoundEvent,
+  TmplAstBoundText,
+  TmplAstComponent,
+  TmplAstContent,
+  TmplAstDeferredBlock,
+  TmplAstDeferredBlockError,
+  TmplAstDeferredBlockLoading,
+  TmplAstDeferredBlockPlaceholder,
+  TmplAstDeferredTrigger,
+  TmplAstDirective,
+  TmplAstElement,
+  TmplAstForLoopBlock,
+  TmplAstForLoopBlockEmpty,
+  TmplAstHostElement,
+  TmplAstIcu,
+  TmplAstIfBlock,
+  TmplAstIfBlockBranch,
+  TmplAstLetDeclaration,
+  TmplAstNode,
+  TmplAstReference,
+  TmplAstSwitchBlock,
+  TmplAstSwitchBlockCase,
+  TmplAstSwitchBlockCaseGroup,
+  TmplAstTemplate,
+  TmplAstText,
+  TmplAstTextAttribute,
+  TmplAstUnknownBlock,
+  TmplAstVariable,
+  TmplAstViewportDeferredTrigger,
+  TmplAstVisitor,
+} from '@angular/compiler';
+import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';
+import ts from 'typescript';
+
+import {getTypeCheckInfoAtPosition, isWithin} from './utils';
+
+// ============================================================================
+// Helper Types and Interfaces
+// ============================================================================
+
+/**
+ * Represents a span of text in the template.
+ */
+interface Span {
+  start: number;
+  end: number;
+}
+
+/**
+ * Represents a node in the selection path with its span.
+ */
+interface PathEntry {
+  node: TmplAstNode | AST | null;
+  span: Span;
+}
+
+// ============================================================================
+// Position Snapping (like TypeScript's positionShouldSnapToNode)
+// ============================================================================
+
+/**
+ * Check if the position should "snap" to the given span.
+ * Like TypeScript, positions immediately after a token count too,
+ * unless that position belongs to the next token. This makes selections
+ * able to snap to preceding tokens when the cursor is on the tail end.
+ *
+ * @param position The cursor position
+ * @param span The span to check
+ * @param nextSpanStart The start of the next sibling span (if any)
+ */
+function positionShouldSnapToSpan(position: number, span: Span, nextSpanStart?: number): boolean {
+  // Position is strictly within the span
+  if (position >= span.start && position < span.end) {
+    return true;
+  }
+  // Position is at the end of the span - snap if no next sibling starts here
+  if (position === span.end) {
+    return nextSpanStart === undefined || nextSpanStart > position;
+  }
+  return false;
+}
+
+/**
+ * Get selection ranges at the given position in an Angular template.
+ *
+ * Selection ranges provide smart selection expansion: select text → expand to element →
+ * expand to parent → expand to block.
+ */
+export function getSelectionRangeAtPosition(
+  compiler: NgCompiler,
+  fileName: string,
+  position: number,
+): ts.SelectionRange | undefined {
+  const typeCheckInfo = getTypeCheckInfoAtPosition(fileName, position, compiler);
+  if (typeCheckInfo === undefined) {
+    return undefined;
+  }
+
+  // Get the path from the root to the node at the position
+  const path = SelectionRangeVisitor.visitTemplate(typeCheckInfo.nodes, position);
+
+  if (path.length === 0) {
+    return undefined;
+  }
+
+  // Build the selection range chain from innermost to outermost
+  return buildSelectionRangeChain(path);
+}
+
+/**
+ * Build a chain of selection ranges from the path entries.
+ * The innermost node is the first in the chain, with `parent` pointing to outer ranges.
+ */
+function buildSelectionRangeChain(path: PathEntry[]): ts.SelectionRange | undefined {
+  if (path.length === 0) {
+    return undefined;
+  }
+
+  let current: ts.SelectionRange | undefined;
+
+  // Process from outermost to innermost, so we can build the parent chain correctly
+  // Filter out duplicate spans and zero-length spans to avoid redundant selection steps
+  const seenSpans = new Set<string>();
+
+  for (let i = 0; i < path.length; i++) {
+    const entry = path[i];
+    const spanKey = `${entry.span.start}-${entry.span.end}`;
+
+    // Skip zero-length spans (e.g., implicit receiver)
+    if (entry.span.start === entry.span.end) {
+      continue;
+    }
+
+    // Skip duplicate spans
+    if (seenSpans.has(spanKey)) {
+      continue;
+    }
+    seenSpans.add(spanKey);
+
+    const range: ts.SelectionRange = {
+      textSpan: {
+        start: entry.span.start,
+        length: entry.span.end - entry.span.start,
+      },
+      parent: current,
+    };
+
+    current = range;
+  }
+
+  return current;
+}
+
+/**
+ * Get the source span for a node as a simple Span object.
+ */
+function getNodeSpan(node: TmplAstNode | AST): Span | undefined {
+  if (node instanceof AST) {
+    // AST nodes have AbsoluteSourceSpan which has start/end as numbers
+    const span = node.sourceSpan;
+    return {start: span.start, end: span.end};
+  }
+
+  // For elements and templates, use the full span from start to end tag
+  if (node instanceof TmplAstElement || node instanceof TmplAstTemplate) {
+    // Full element span including both tags
+    return {start: node.sourceSpan.start.offset, end: node.sourceSpan.end.offset};
+  }
+
+  if (node instanceof TmplAstComponent) {
+    return {start: node.sourceSpan.start.offset, end: node.sourceSpan.end.offset};
+  }
+
+  if (node instanceof TmplAstDirective) {
+    return {start: node.sourceSpan.start.offset, end: node.sourceSpan.end.offset};
+  }
+
+  // For control flow blocks
+  if (
+    node instanceof TmplAstIfBlock ||
+    node instanceof TmplAstIfBlockBranch ||
+    node instanceof TmplAstForLoopBlock ||
+    node instanceof TmplAstForLoopBlockEmpty ||
+    node instanceof TmplAstSwitchBlock ||
+    node instanceof TmplAstSwitchBlockCase ||
+    node instanceof TmplAstSwitchBlockCaseGroup ||
+    node instanceof TmplAstDeferredBlock ||
+    node instanceof TmplAstDeferredBlockPlaceholder ||
+    node instanceof TmplAstDeferredBlockLoading ||
+    node instanceof TmplAstDeferredBlockError ||
+    node instanceof TmplAstDeferredTrigger
+  ) {
+    return {start: node.sourceSpan.start.offset, end: node.sourceSpan.end.offset};
+  }
+
+  // For text nodes
+  if (node instanceof TmplAstText || node instanceof TmplAstBoundText) {
+    return {start: node.sourceSpan.start.offset, end: node.sourceSpan.end.offset};
+  }
+
+  // For text attributes, compute a more accurate span
+  // Angular's sourceSpan may include trailing `>` or whitespace in some cases
+  if (node instanceof TmplAstTextAttribute) {
+    // If we have valueSpan, compute span from keySpan start to valueSpan end + closing quote
+    if (node.keySpan && node.valueSpan) {
+      const start = node.keySpan.start.offset;
+      // valueSpan doesn't include the quotes, so add 1 for the closing quote
+      const end = node.valueSpan.end.offset + 1;
+      return {start, end};
+    }
+    // If attribute has no value (e.g., `disabled`), use keySpan
+    if (node.keySpan && !node.valueSpan) {
+      return {start: node.keySpan.start.offset, end: node.keySpan.end.offset};
+    }
+    // Fallback to sourceSpan
+    return {start: node.sourceSpan.start.offset, end: node.sourceSpan.end.offset};
+  }
+
+  // For bound attributes and events
+  if (node instanceof TmplAstBoundAttribute || node instanceof TmplAstBoundEvent) {
+    return {start: node.sourceSpan.start.offset, end: node.sourceSpan.end.offset};
+  }
+
+  // For template variables and references
+  if (node instanceof TmplAstVariable || node instanceof TmplAstReference) {
+    return {start: node.sourceSpan.start.offset, end: node.sourceSpan.end.offset};
+  }
+
+  // For @let declarations
+  if (node instanceof TmplAstLetDeclaration) {
+    return {start: node.sourceSpan.start.offset, end: node.sourceSpan.end.offset};
+  }
+
+  return undefined;
+}
+
+/**
+ * Compute the content span (between start tag and end tag) for an element.
+ */
+function getElementContentSpan(
+  element: TmplAstElement | TmplAstTemplate | TmplAstComponent,
+): Span | undefined {
+  // Self-closing elements have no content
+  if (
+    (element instanceof TmplAstElement || element instanceof TmplAstComponent) &&
+    element.isSelfClosing
+  ) {
+    return undefined;
+  }
+
+  // If there's no end tag, no content span
+  if (!element.endSourceSpan) {
+    return undefined;
+  }
+
+  // Content is between the end of start tag and the start of end tag
+  const start = element.startSourceSpan.end.offset;
+  const end = element.endSourceSpan.start.offset;
+
+  // If start >= end, there's no content
+  if (start >= end) {
+    return undefined;
+  }
+
+  return {start, end};
+}
+
+/**
+ * Compute the combined span of all siblings at a given level.
+ * This is used to add an intermediate "all siblings" selection step.
+ */
+function getSiblingsSpan(siblings: TmplAstNode[], currentNode: TmplAstNode): Span | undefined {
+  if (siblings.length <= 1) {
+    return undefined;
+  }
+
+  let start = Infinity;
+  let end = -Infinity;
+
+  for (const sibling of siblings) {
+    const span = getNodeSpan(sibling);
+    if (span) {
+      start = Math.min(start, span.start);
+      end = Math.max(end, span.end);
+    }
+  }
+
+  if (start === Infinity || end === -Infinity) {
+    return undefined;
+  }
+
+  // Only return if different from the current node's span
+  const currentSpan = getNodeSpan(currentNode);
+  if (currentSpan && currentSpan.start === start && currentSpan.end === end) {
+    return undefined;
+  }
+
+  return {start, end};
+}
+
+// ============================================================================
+// Expression Visitor (extends RecursiveAstVisitor for automatic dispatch)
+// ============================================================================
+
+/**
+ * Expression-level visitor for selection range.
+ *
+ * Extends `RecursiveAstVisitor` so that all expression types (`Binary`,
+ * `Conditional`, `BindingPipe`, `PrefixNot`, `Unary`, `Call`, `SafeCall`,
+ * `LiteralArray`, `LiteralMap`, etc.) get automatic position-based recursion
+ * via the centralized `visit()` override.
+ *
+ * Only overrides expression types that need special span-insertion behaviour:
+ * property chains, string literal inner spans, template literal `${...}`,
+ * and `Interpolation` dispatch.
+ */
+class SelectionRangeExpressionVisitor extends RecursiveAstVisitor {
+  readonly path: PathEntry[] = [];
+
+  constructor(private readonly position: number) {
+    super();
+  }
+
+  // ------------------------------------------------------------------
+  // Central dispatch – position filtering + path recording
+  // ------------------------------------------------------------------
+
+  override visit(ast: AST, context?: any): any {
+    // Unwrap ASTWithSource first (like CombinedRecursiveAstVisitor)
+    if (ast instanceof ASTWithSource) {
+      const outerSpan = ast.sourceSpan;
+      if (!isWithin(this.position, outerSpan)) return;
+      this.path.push({node: ast, span: {start: outerSpan.start, end: outerSpan.end}});
+      return this.visit(ast.ast, context);
+    }
+
+    // Skip ImplicitReceiver/ThisReceiver - never selectable (some contexts give non-zero spans)
+    if (ast instanceof ImplicitReceiver) return;
+
+    const span = ast.sourceSpan;
+    if (!isWithin(this.position, span)) return;
+
+    // Skip zero-length spans
+    if (span.start !== span.end) {
+      this.path.push({node: ast, span: {start: span.start, end: span.end}});
+    }
+
+    // Dispatch to visitBinary, visitCall, visitConditional, etc.
+    // Each visit method calls this.visit() on children,
+    // which re-enters this override for position checking.
+    return ast.visit(this, context);
+  }
+
+  // ------------------------------------------------------------------
+  // Special cases that need custom behaviour
+  // ------------------------------------------------------------------
+
+  // Property reads (PropertyRead, SafePropertyRead, KeyedRead, SafeKeyedRead)
+  // use RecursiveAstVisitor's default traversal. The visit() override above
+  // already filters by isWithin(position, span), so only receivers that
+  // contain the cursor are added to the path - producing a correct chain:
+  //   cursor on "city"    → user.address.city
+  //   cursor on "address" → user.address → user.address.city
+  //   cursor on "user"    → user → user.address → user.address.city
+
+  /**
+   * Pipes: add intermediate span for pipe name + args.
+   * For `now() | date:'short'`, produces:
+   *   short → 'short' → date:'short' → now() | date:'short'
+   *
+   * For multiple args like `date:'short':'pl'`:
+   *   pl → 'pl' → date:'short':'pl' → now() | date:'short':'pl'
+   */
+  override visitPipe(ast: BindingPipe, context: any): any {
+    // Compute the pipe name (+ args) region span: `date:'short'`
+    const pipeNameStart = ast.nameSpan.start;
+    const lastArgEnd =
+      ast.args.length > 0 ? ast.args[ast.args.length - 1].sourceSpan.end : ast.nameSpan.end;
+
+    // Only add intermediate spans if cursor is within the pipe name + args region
+    if (this.position >= pipeNameStart && this.position <= lastArgEnd) {
+      // Add full pipe-region span: `date:'short'` (only if different from just the name)
+      if (lastArgEnd > ast.nameSpan.end) {
+        this.path.push({node: null, span: {start: pipeNameStart, end: lastArgEnd}});
+      }
+      // Add pipe name span: `date` — only if cursor is actually on the pipe name
+      if (
+        ast.nameSpan.end > ast.nameSpan.start &&
+        this.position >= ast.nameSpan.start &&
+        this.position <= ast.nameSpan.end
+      ) {
+        this.path.push({
+          node: null,
+          span: {start: ast.nameSpan.start, end: ast.nameSpan.end},
+        });
+      }
+    }
+
+    // Continue recursion into exp and args
+    this.visit(ast.exp, context);
+    this.visitAll(ast.args, context);
+  }
+
+  /**
+   * Calls: add intermediate span for arguments list.
+   * For `fn(a, b, c)`, produces: b → a, b, c → fn(a, b, c)
+   * Matches TypeScript's smart selection behaviour.
+   */
+  override visitCall(ast: Call, context: any): any {
+    this.addCallArgumentsSpan(ast);
+    this.visit(ast.receiver, context);
+    this.visitAll(ast.args, context);
+  }
+
+  override visitSafeCall(ast: SafeCall, context: any): any {
+    this.addCallArgumentsSpan(ast);
+    this.visit(ast.receiver, context);
+    this.visitAll(ast.args, context);
+  }
+
+  private addCallArgumentsSpan(ast: Call | SafeCall): void {
+    if (ast.args.length > 0) {
+      const argSpan = ast.argumentSpan;
+      if (
+        argSpan.end > argSpan.start &&
+        this.position >= argSpan.start &&
+        this.position <= argSpan.end
+      ) {
+        this.path.push({node: null, span: {start: argSpan.start, end: argSpan.end}});
+      }
+    }
+  }
+
+  /**
+   * String literals: add inner span (without quotes).
+   * For `'hello'`, produces: `hello` → `'hello'`
+   */
+  override visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {
+    if (typeof ast.value === 'string') {
+      const span = ast.sourceSpan;
+      if (span.end - span.start >= 2) {
+        this.path.push({
+          node: null,
+          span: {start: span.start + 1, end: span.end - 1},
+        });
+      }
+    }
+  }
+
+  /**
+   * Template literals: add `${...}` wrapper spans around the active expression.
+   */
+  override visitTemplateLiteral(ast: TemplateLiteral, context: any): any {
+    for (let i = 0; i < ast.expressions.length; i++) {
+      const expr = ast.expressions[i];
+      if (isWithin(this.position, expr.sourceSpan)) {
+        // Compute ${...} wrapper span using element boundaries
+        let templateExprStart = expr.sourceSpan.start - 2; // `${`
+        let templateExprEnd = expr.sourceSpan.end + 1; // `}`
+        if (ast.elements[i]) {
+          templateExprStart = ast.elements[i].sourceSpan.end;
+        }
+        if (ast.elements[i + 1]) {
+          templateExprEnd = ast.elements[i + 1].sourceSpan.start;
+        }
+        this.path.push({node: null, span: {start: templateExprStart, end: templateExprEnd}});
+        this.visit(expr, context);
+        break;
+      }
+    }
+  }
+
+  /**
+   * Interpolation: find and visit the specific expression containing position.
+   */
+  override visitInterpolation(ast: Interpolation, context: any): any {
+    for (const expr of ast.expressions) {
+      if (isWithin(this.position, expr.sourceSpan)) {
+        this.visit(expr, context);
+        break;
+      }
+    }
+  }
+}
+
+// ============================================================================
+// Template Visitor (custom TmplAstVisitor with position snapping & siblings)
+// ============================================================================
+
+/**
+ * Visitor to collect the path from root to the deepest node containing the position.
+ * Now returns PathEntry[] with spans for each level, including intermediate spans.
+ */
+class SelectionRangeVisitor implements TmplAstVisitor {
+  readonly path: PathEntry[] = [];
+  private currentChildren: TmplAstNode[] = [];
+
+  static visitTemplate(template: TmplAstNode[], position: number): PathEntry[] {
+    const visitor = new SelectionRangeVisitor(position);
+    visitor.currentChildren = template;
+    visitor.visitAll(template);
+    return visitor.path;
+  }
+
+  private constructor(private readonly position: number) {}
+
+  /**
+   * Get an accurate span for an attribute, avoiding the issue where Angular's
+   * sourceSpan may include trailing '>' or whitespace for the last attribute.
+   */
+  private getAccurateAttributeSpan(
+    attr: TmplAstTextAttribute | TmplAstBoundAttribute | TmplAstBoundEvent,
+  ): Span {
+    // For TextAttribute, compute span from keySpan to valueSpan end + closing quote
+    if (attr instanceof TmplAstTextAttribute) {
+      if (attr.keySpan && attr.valueSpan) {
+        return {
+          start: attr.keySpan.start.offset,
+          end: attr.valueSpan.end.offset + 1, // +1 for closing quote
+        };
+      }
+      if (attr.keySpan && !attr.valueSpan) {
+        return {start: attr.keySpan.start.offset, end: attr.keySpan.end.offset};
+      }
+    }
+    // For BoundAttribute and BoundEvent, sourceSpan is generally accurate
+    return {start: attr.sourceSpan.start.offset, end: attr.sourceSpan.end.offset};
+  }
+
+  visit(node: TmplAstNode) {
+    // Use position snapping like TypeScript's smartSelection.ts
+    // This allows positions at the end of a token to snap to that token
+    const nodeSpan = getNodeSpan(node);
+    if (!nodeSpan || !positionShouldSnapToSpan(this.position, nodeSpan)) {
+      return;
+    }
+
+    // Add intermediate "all siblings" span if there are multiple siblings
+    const siblingsSpan = getSiblingsSpan(this.currentChildren, node);
+    if (siblingsSpan) {
+      this.path.push({node: null, span: siblingsSpan});
+    }
+
+    // Add the node's span
+    if (nodeSpan) {
+      this.path.push({node, span: nodeSpan});
+    }
+
+    node.visit(this);
+  }
+
+  visitElement(element: TmplAstElement): void {
+    // Add content span (between start and end tags) before visiting children
+    // But only if content span is different from all children combined span
+    if (element.children.length > 1) {
+      const contentSpan = getElementContentSpan(element);
+      const childrenSpan = getSiblingsSpan(element.children, element.children[0]);
+      // Add content span only if it's different from children combined span
+      if (
+        contentSpan &&
+        (!childrenSpan ||
+          contentSpan.start !== childrenSpan.start ||
+          contentSpan.end !== childrenSpan.end)
+      ) {
+        this.path.push({node: null, span: contentSpan});
+      }
+    }
+
+    // Add attribute sibling grouping span (all attributes together)
+    const allAttributes = [...element.attributes, ...element.inputs, ...element.outputs];
+    if (allAttributes.length > 1) {
+      let minStart = Infinity;
+      let maxEnd = -Infinity;
+
+      for (const attr of allAttributes) {
+        // Use accurate span calculation to avoid including trailing '>' or whitespace
+        const span = this.getAccurateAttributeSpan(attr);
+        minStart = Math.min(minStart, span.start);
+        maxEnd = Math.max(maxEnd, span.end);
+      }
+
+      // Only add if position is within the attributes region
+      if (this.position >= minStart && this.position < maxEnd) {
+        this.path.push({node: null, span: {start: minStart, end: maxEnd}});
+      }
+    }
+
+    this.visitAll(element.attributes);
+    this.visitAll(element.inputs);
+    this.visitAll(element.outputs);
+    this.visitAll(element.references);
+
+    const savedChildren = this.currentChildren;
+    this.currentChildren = element.children;
+    this.visitAll(element.children);
+    this.currentChildren = savedChildren;
+  }
+
+  visitTemplate(template: TmplAstTemplate): void {
+    // Add content span before visiting children
+    const contentSpan = getElementContentSpan(template);
+    if (contentSpan && template.children.length > 0) {
+      this.path.push({node: null, span: contentSpan});
+    }
+
+    // Add attribute sibling grouping span (all attributes together)
+    const allAttributes = [
+      ...template.templateAttrs,
+      ...template.attributes,
+      ...template.inputs,
+      ...template.outputs,
+    ];
+    if (allAttributes.length > 1) {
+      let minStart = Infinity;
+      let maxEnd = -Infinity;
+
+      for (const attr of allAttributes) {
+        const span = attr.sourceSpan;
+        minStart = Math.min(minStart, span.start.offset);
+        maxEnd = Math.max(maxEnd, span.end.offset);
+      }
+
+      // Only add if position is within the attributes region
+      if (this.position >= minStart && this.position < maxEnd) {
+        this.path.push({node: null, span: {start: minStart, end: maxEnd}});
+      }
+    }
+
+    this.visitAll(template.templateAttrs);
+    this.visitAll(template.attributes);
+    this.visitAll(template.inputs);
+    this.visitAll(template.outputs);
+    this.visitAll(template.variables);
+    this.visitAll(template.references);
+
+    const savedChildren = this.currentChildren;
+    this.currentChildren = template.children;
+    this.visitAll(template.children);
+    this.currentChildren = savedChildren;
+  }
+
+  visitComponent(component: TmplAstComponent): void {
+    // Add content span (between start and end tags) before visiting children
+    if (component.children.length > 1) {
+      const contentSpan = getElementContentSpan(component);
+      const childrenSpan = getSiblingsSpan(component.children, component.children[0]);
+      // Add content span only if it's different from children combined span
+      if (
+        contentSpan &&
+        (!childrenSpan ||
+          contentSpan.start !== childrenSpan.start ||
+          contentSpan.end !== childrenSpan.end)
+      ) {
+        this.path.push({node: null, span: contentSpan});
+      }
+    }
+
+    // Add attribute sibling grouping span (all attributes together)
+    const allAttributes = [...component.attributes, ...component.inputs, ...component.outputs];
+    if (allAttributes.length > 1) {
+      let minStart = Infinity;
+      let maxEnd = -Infinity;
+
+      for (const attr of allAttributes) {
+        const span = attr.sourceSpan;
+        minStart = Math.min(minStart, span.start.offset);
+        maxEnd = Math.max(maxEnd, span.end.offset);
+      }
+
+      // Only add if position is within the attributes region
+      if (this.position >= minStart && this.position < maxEnd) {
+        this.path.push({node: null, span: {start: minStart, end: maxEnd}});
+      }
+    }
+
+    this.visitAll(component.attributes);
+    this.visitAll(component.inputs);
+    this.visitAll(component.outputs);
+    this.visitAll(component.references);
+
+    const savedChildren = this.currentChildren;
+    this.currentChildren = component.children;
+    this.visitAll(component.children);
+    this.currentChildren = savedChildren;
+  }
+
+  visitDirective(directive: TmplAstDirective): void {
+    this.visitAll(directive.attributes);
+    this.visitAll(directive.inputs);
+    this.visitAll(directive.outputs);
+  }
+
+  visitHostElement(hostElement: TmplAstHostElement): void {}
+
+  visitContent(content: TmplAstContent): void {}
+
+  visitVariable(variable: TmplAstVariable): void {}
+
+  visitReference(reference: TmplAstReference): void {}
+
+  visitTextAttribute(attribute: TmplAstTextAttribute): void {
+    // Add the attribute key span (just the attribute name)
+    // This allows selecting just "style" in style="color: red"
+    // Only add if the cursor is within the key span
+    if (attribute.keySpan) {
+      const keySpan = {
+        start: attribute.keySpan.start.offset,
+        end: attribute.keySpan.end.offset,
+      };
+      if (positionShouldSnapToSpan(this.position, keySpan)) {
+        this.path.push({node: null, span: keySpan});
+      }
+    }
+
+    // Add the attribute value span (just the value inside quotes)
+    // For id="name", this allows selecting just "name"
+    // Note: For style/class attributes, CSS LSP delegation in the server handler
+    // provides granular selection within the value
+    if (attribute.valueSpan) {
+      const valueSpan = {
+        start: attribute.valueSpan.start.offset,
+        end: attribute.valueSpan.end.offset,
+      };
+      // Only add if cursor is within the value span
+      if (positionShouldSnapToSpan(this.position, valueSpan)) {
+        this.path.push({node: null, span: valueSpan});
+      }
+    }
+  }
+
+  visitBoundAttribute(attribute: TmplAstBoundAttribute): void {
+    // Only add the attribute key span if the cursor is within it.
+    // Adding it unconditionally violates LSP SelectionRange containment:
+    // parent.range must contain this.range. If cursor is in the expression,
+    // the keySpan is disjoint and must not appear in the parent chain.
+    if (attribute.keySpan) {
+      const keySpan = {
+        start: attribute.keySpan.start.offset,
+        end: attribute.keySpan.end.offset,
+      };
+      if (positionShouldSnapToSpan(this.position, keySpan)) {
+        this.path.push({node: null, span: keySpan});
+      }
+    }
+
+    // Visit the expression value (adds innermost node)
+    // When cursor is on expression: expression → full attribute → element
+    // When cursor is on key: key → full attribute → element
+    this.visitExpression(attribute.value);
+  }
+
+  visitBoundEvent(event: TmplAstBoundEvent): void {
+    // Only add the event key span if the cursor is within it.
+    // Adding it unconditionally violates LSP SelectionRange containment:
+    // parent.range must contain this.range. If cursor is in the handler,
+    // the keySpan is disjoint and must not appear in the parent chain.
+    if (event.keySpan) {
+      const keySpan = {
+        start: event.keySpan.start.offset,
+        end: event.keySpan.end.offset,
+      };
+      if (positionShouldSnapToSpan(this.position, keySpan)) {
+        this.path.push({node: null, span: keySpan});
+      }
+    }
+
+    // Visit the handler expression (adds innermost node)
+    // When cursor is on handler: expression → full event → element
+    // When cursor is on key: key → full event → element
+    this.visitExpression(event.handler);
+  }
+
+  visitText(text: TmplAstText): void {
+    // Add word-level selection within the text node
+    // This provides more granular steps to "win" against HTML provider's merging
+    this.addWordAndLineSpans(text.value, {
+      start: text.sourceSpan.start.offset,
+      end: text.sourceSpan.end.offset,
+    });
+  }
+
+  visitBoundText(text: TmplAstBoundText): void {
+    this.visitExpression(text.value);
+  }
+
+  /**
+   * Add word-level and line-level spans for text content.
+   * This fills in gaps that VS Code's smart select would otherwise fill with
+   * built-in HTML provider's ranges, preventing inconsistent merge hierarchies.
+   *
+   * Note: Spans are pushed in order from outer to inner because the path is built
+   * outermost-to-innermost. So line (larger) is pushed before word (smaller).
+   */
+  private addWordAndLineSpans(textContent: string, textSpan: Span): void {
+    const relativePos = this.position - textSpan.start;
+    if (relativePos < 0 || relativePos > textContent.length) {
+      return;
+    }
+
+    // Find line boundaries at the cursor position (content on same line)
+    // Line is pushed FIRST because it's larger (outer) than word
+    const lineBounds = this.findLineAtPosition(textContent, relativePos);
+    if (lineBounds) {
+      this.path.push({
+        node: null,
+        span: {
+          start: textSpan.start + lineBounds.start,
+          end: textSpan.start + lineBounds.end,
+        },
+      });
+    }
+
+    // Find word boundaries at the cursor position
+    // Word is pushed AFTER line because it's smaller (inner)
+    const wordBounds = this.findWordAtPosition(textContent, relativePos);
+    if (
+      wordBounds &&
+      (!lineBounds || wordBounds.start !== lineBounds.start || wordBounds.end !== lineBounds.end)
+    ) {
+      this.path.push({
+        node: null,
+        span: {
+          start: textSpan.start + wordBounds.start,
+          end: textSpan.start + wordBounds.end,
+        },
+      });
+    }
+  }
+
+  /**
+   * Find the word at the given position in the text.
+   * Optimized: scans from position instead of regex over entire text.
+   */
+  private findWordAtPosition(
+    text: string,
+    position: number,
+  ): {start: number; end: number} | undefined {
+    if (position < 0 || position > text.length) {
+      return undefined;
+    }
+
+    // Check if position is on a word character
+    const isWordChar = (c: string) => /[\w\-]/.test(c);
+
+    // If cursor is between chars, check the char before it
+    if (position === text.length || !isWordChar(text[position])) {
+      if (position > 0 && isWordChar(text[position - 1])) {
+        // Cursor is at end of word, adjust position
+        position = position - 1;
+      } else {
+        return undefined;
+      }
+    }
+
+    // Scan left to find word start
+    let start = position;
+    while (start > 0 && isWordChar(text[start - 1])) {
+      start--;
+    }
+
+    // Scan right to find word end
+    let end = position;
+    while (end < text.length && isWordChar(text[end])) {
+      end++;
+    }
+
+    if (start === end) {
+      return undefined;
+    }
+
+    return {start, end};
+  }
+
+  /**
+   * Find the line content at the given position (trimmed, without leading/trailing whitespace).
+   * Optimized: uses indexOf/lastIndexOf instead of character-by-character scan.
+   */
+  private findLineAtPosition(
+    text: string,
+    position: number,
+  ): {start: number; end: number} | undefined {
+    // Find line start using lastIndexOf (much faster than character scan)
+    const prevNewline = text.lastIndexOf('\n', position - 1);
+    const lineStart = prevNewline === -1 ? 0 : prevNewline + 1;
+
+    // Find line end using indexOf
+    const nextNewline = text.indexOf('\n', position);
+    const lineEnd = nextNewline === -1 ? text.length : nextNewline;
+
+    // Trim whitespace from the line content
+    const lineContent = text.substring(lineStart, lineEnd);
+    const trimmedStart = lineStart + (lineContent.length - lineContent.trimStart().length);
+    const trimmedEnd = lineEnd - (lineContent.length - lineContent.trimEnd().length);
+
+    if (trimmedStart >= trimmedEnd) {
+      return undefined;
+    }
+
+    return {start: trimmedStart, end: trimmedEnd};
+  }
+
+  visitIcu(icu: TmplAstIcu): void {
+    // ICU messages contain variables (like {count}) and placeholders
+    // For {count, plural, =0 {no items} =1 {one item} other {many items}}:
+    // - vars contains the bound expressions (e.g., the 'count' variable)
+    // - placeholders contains the case content
+
+    // Visit variable expressions (the values being switched on)
+    for (const varName of Object.keys(icu.vars)) {
+      const varNode = icu.vars[varName];
+      // varNode is a BoundText which contains an AST expression
+      if (varNode.value && isWithin(this.position, varNode.value.sourceSpan)) {
+        this.visitExpression(varNode.value);
+      }
+    }
+
+    // Visit placeholder content (the case branches)
+    for (const placeholderName of Object.keys(icu.placeholders)) {
+      const placeholder = icu.placeholders[placeholderName];
+      const span = placeholder.sourceSpan;
+      if (this.position >= span.start.offset && this.position < span.end.offset) {
+        // Add the placeholder span
+        this.path.push({node: placeholder, span: {start: span.start.offset, end: span.end.offset}});
+
+        // If it's a BoundText, visit the expression inside
+        if (placeholder instanceof TmplAstBoundText && placeholder.value) {
+          this.visitExpression(placeholder.value);
+        } else if (placeholder instanceof TmplAstText) {
+          // For plain text placeholders, add word/line spans
+          this.addWordAndLineSpans(placeholder.value, {
+            start: span.start.offset,
+            end: span.end.offset,
+          });
+        }
+      }
+    }
+  }
+
+  visitDeferredBlock(deferred: TmplAstDeferredBlock): void {
+    const savedChildren = this.currentChildren;
+    this.currentChildren = deferred.children;
+    this.visitAll(deferred.children);
+    this.currentChildren = savedChildren;
+
+    // Visit triggers (when, hover, timer, viewport, etc.)
+    this.visitDeferredBlockTriggers(deferred.triggers);
+    this.visitDeferredBlockTriggers(deferred.prefetchTriggers);
+    if ('hydrateTriggers' in deferred) {
+      this.visitDeferredBlockTriggers(
+        (deferred as {hydrateTriggers: typeof deferred.triggers}).hydrateTriggers,
+      );
+    }
+
+    if (deferred.placeholder) {
+      this.visit(deferred.placeholder);
+    }
+    if (deferred.loading) {
+      this.visit(deferred.loading);
+    }
+    if (deferred.error) {
+      this.visit(deferred.error);
+    }
+  }
+
+  /**
+   * Visit all defined triggers in a DeferredBlockTriggers object.
+   */
+  private visitDeferredBlockTriggers(
+    triggers: Readonly<{[key: string]: TmplAstDeferredTrigger | undefined}>,
+  ): void {
+    for (const key of Object.keys(triggers)) {
+      const trigger = triggers[key];
+      if (trigger) {
+        this.visit(trigger);
+      }
+    }
+  }
+
+  visitDeferredBlockPlaceholder(block: TmplAstDeferredBlockPlaceholder): void {
+    const savedChildren = this.currentChildren;
+    this.currentChildren = block.children;
+    this.visitAll(block.children);
+    this.currentChildren = savedChildren;
+  }
+
+  visitDeferredBlockError(block: TmplAstDeferredBlockError): void {
+    const savedChildren = this.currentChildren;
+    this.currentChildren = block.children;
+    this.visitAll(block.children);
+    this.currentChildren = savedChildren;
+  }
+
+  visitDeferredBlockLoading(block: TmplAstDeferredBlockLoading): void {
+    const savedChildren = this.currentChildren;
+    this.currentChildren = block.children;
+    this.visitAll(block.children);
+    this.currentChildren = savedChildren;
+  }
+
+  visitDeferredTrigger(trigger: TmplAstDeferredTrigger): void {
+    // For BoundDeferredTrigger (when condition), traverse the expression
+    // Example: @defer (when isReady) { ... }
+    if (trigger instanceof TmplAstBoundDeferredTrigger && trigger.value) {
+      if (isWithin(this.position, trigger.value.sourceSpan)) {
+        this.visitExpression(trigger.value);
+      }
+    }
+    // Other trigger types (timer, viewport, hover, etc.) don't have
+    // sub-expressions to traverse - their parameters are parsed values
+  }
+
+  visitSwitchBlock(block: TmplAstSwitchBlock): void {
+    this.visitExpression(block.expression);
+    const savedChildren = this.currentChildren;
+    this.currentChildren = block.groups as TmplAstNode[];
+    this.visitAll(block.groups);
+    this.currentChildren = savedChildren;
+  }
+
+  visitSwitchBlockCase(block: TmplAstSwitchBlockCase): void {
+    if (block.expression) {
+      this.visitExpression(block.expression);
+    }
+  }
+
+  visitSwitchBlockCaseGroup(group: TmplAstSwitchBlockCaseGroup): void {
+    this.visitAll(group.cases);
+    const savedChildren = this.currentChildren;
+    this.currentChildren = group.children;
+    this.visitAll(group.children);
+    this.currentChildren = savedChildren;
+  }
+
+  visitForLoopBlock(block: TmplAstForLoopBlock): void {
+    this.visitExpression(block.expression);
+    const savedChildren = this.currentChildren;
+    this.currentChildren = block.children;
+    this.visitAll(block.children);
+    this.currentChildren = savedChildren;
+    if (block.empty) {
+      this.visit(block.empty);
+    }
+  }
+
+  visitForLoopBlockEmpty(block: TmplAstForLoopBlockEmpty): void {
+    const savedChildren = this.currentChildren;
+    this.currentChildren = block.children;
+    this.visitAll(block.children);
+    this.currentChildren = savedChildren;
+  }
+
+  visitIfBlock(block: TmplAstIfBlock): void {
+    const savedChildren = this.currentChildren;
+    this.currentChildren = block.branches as TmplAstNode[];
+    this.visitAll(block.branches);
+    this.currentChildren = savedChildren;
+  }
+
+  visitIfBlockBranch(block: TmplAstIfBlockBranch): void {
+    if (block.expression) {
+      this.visitExpression(block.expression);
+    }
+    const savedChildren = this.currentChildren;
+    this.currentChildren = block.children;
+    this.visitAll(block.children);
+    this.currentChildren = savedChildren;
+  }
+
+  visitLetDeclaration(decl: TmplAstLetDeclaration): void {
+    this.visitExpression(decl.value);
+  }
+
+  visitUnknownBlock(block: TmplAstUnknownBlock): void {}
+
+  private visitAll(nodes: TmplAstNode[]): void {
+    for (const node of nodes) {
+      this.visit(node);
+    }
+  }
+
+  /**
+   * Delegate expression traversal to `SelectionRangeExpressionVisitor`,
+   * which extends `RecursiveAstVisitor` for automatic dispatch of all
+   * expression types with centralized position filtering.
+   */
+  private visitExpression(ast: AST): void {
+    const exprVisitor = new SelectionRangeExpressionVisitor(this.position);
+    exprVisitor.visit(ast);
+    this.path.push(...exprVisitor.path);
+  }
+}
diff --git a/packages/language-service/src/ts_plugin.ts b/packages/language-service/src/ts_plugin.ts
index 5fd6217fb1b0..3633448a1df9 100644
--- a/packages/language-service/src/ts_plugin.ts
+++ b/packages/language-service/src/ts_plugin.ts
@@ -118,6 +118,49 @@ export function create(info: ts.server.PluginCreateInfo): NgLanguageService {
     return ngLS.getRenameInfo(fileName, position);
   }
 
+  /**
+   * Get selection range for the Angular Language Service API.
+   *
+   * This method is called by the LSP server handler for `textDocument/selectionRange`.
+   * It handles both HTML templates and TypeScript files with inline templates.
+   *
+   * For HTML files / angularOnly mode: Uses Angular LS only
+   * For TS files: Tries Angular first (for inline templates), falls back to TypeScript
+   */
+  function getSelectionRangeAtPosition(
+    fileName: string,
+    position: number,
+  ): ts.SelectionRange | undefined {
+    if (angularOnly || !isTypeScriptFile(fileName)) {
+      return ngLS.getSelectionRangeAtPosition(fileName, position);
+    }
+    // For TypeScript files, try Angular first (handles inline templates),
+    // fall back to TypeScript for pure TS code
+    return (
+      ngLS.getSelectionRangeAtPosition(fileName, position) ??
+      tsLS.getSmartSelectionRange(fileName, position)
+    );
+  }
+
+  /**
+   * Get smart selection range for the TypeScript Plugin API.
+   *
+   * This method is required by the `ts.LanguageService` interface and is called
+   * by TypeScript when the plugin is loaded. TypeScript only calls this for TS/JS
+   * files, not HTML files.
+   *
+   * Tries Angular first (for inline templates), falls back to TypeScript for
+   * pure TypeScript code.
+   */
+  function getSmartSelectionRange(fileName: string, position: number): ts.SelectionRange {
+    // TypeScript only calls this for TS/JS files, not HTML
+    // Try Angular first (handles inline templates), fall back to TypeScript
+    return (
+      ngLS.getSelectionRangeAtPosition(fileName, position) ??
+      tsLS.getSmartSelectionRange(fileName, position)
+    );
+  }
+
   function getEncodedSemanticClassifications(
     fileName: string,
     span: ts.TextSpan,
@@ -358,6 +401,8 @@ export function create(info: ts.server.PluginCreateInfo): NgLanguageService {
     getReferencesAtPosition,
     findRenameLocations,
     getRenameInfo,
+    getSelectionRangeAtPosition,
+    getSmartSelectionRange,
     getEncodedSemanticClassifications,
     getTokenTypeFromClassification,
     getTokenModifierFromClassification,
diff --git a/packages/language-service/test/selection_range_spec.ts b/packages/language-service/test/selection_range_spec.ts
new file mode 100644
index 000000000000..9ac628b5a69e
--- /dev/null
+++ b/packages/language-service/test/selection_range_spec.ts
@@ -0,0 +1,2851 @@
+/**
+ * @license
+ * Copyright Google LLC All Rights Reserved.
+ *
+ * Use of this source code is governed by an MIT-style license that can be
+ * found in the LICENSE file at https://angular.dev/license
+ */
+
+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';
+import ts from 'typescript';
+
+import {LanguageServiceTestEnv} from '../testing';
+import {createModuleAndProjectWithDeclarations} from '../testing/src/util';
+
+/**
+ * Helper function to verify the exact expansion chain matches the expected sequence.
+ *
+ * @param selectionRange The starting selection range
+ * @param template The full template string (needed to extract text at each range)
+ * @param expectedChain Array of expected text values in order (innermost to outermost)
+ * @param templateOffset Optional offset if template is part of a larger file (for inline templates)
+ */
+function verifyExpansionChain(
+  selectionRange: ts.SelectionRange | undefined,
+  template: string,
+  expectedChain: string[],
+  templateOffset: number = 0,
+): void {
+  expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+  if (!selectionRange) return;
+
+  const actualChain: string[] = [];
+  let range: ts.SelectionRange | undefined = selectionRange;
+
+  while (range) {
+    const start = range.textSpan.start - templateOffset;
+    const length = range.textSpan.length;
+    const text = template.substring(start, start + length);
+    actualChain.push(text);
+    range = range.parent;
+  }
+
+  // Verify chain length
+  expect(actualChain.length)
+    .withContext(
+      `Expected ${expectedChain.length} steps but got ${actualChain.length}.\n` +
+        `Expected: ${JSON.stringify(expectedChain)}\n` +
+        `Actual: ${JSON.stringify(actualChain)}`,
+    )
+    .toBe(expectedChain.length);
+
+  // Verify each step
+  for (let i = 0; i < expectedChain.length; i++) {
+    expect(actualChain[i])
+      .withContext(
+        `Step ${i + 1}/${expectedChain.length} mismatch.\n` +
+          `Full expected chain: ${JSON.stringify(expectedChain)}\n` +
+          `Full actual chain: ${JSON.stringify(actualChain)}`,
+      )
+      .toBe(expectedChain[i]);
+  }
+}
+
+/**
+ * Describes a cursor position within a template for testing expansion chains.
+ */
+interface CursorSpec {
+  /** Label for test output (e.g. 'cursor on "city"') */
+  label: string;
+  /** Substring to find in template to place cursor. Position is the start of this substring. */
+  cursorAt: string;
+  /** Optional character offset from the start of cursorAt match (default: 0) */
+  offset?: number;
+  /** Expected expansion chain from innermost to outermost */
+  chain: string[];
+}
+
+/**
+ * Creates a component TS file that uses templateUrl for the given template.
+ * The component class body supports optional member declarations.
+ */
+/**
+ * Test selection range expansion for both external and inline (single-line) templates.
+ *
+ * For each cursor spec, verifies the expansion chain matches expectations in both modes.
+ * This avoids test duplication while ensuring both template forms produce identical results.
+ *
+ * @param env The test environment
+ * @param template The template HTML string. Must be a single line for inline mode to work.
+ * @param componentMembers Component class body (properties, methods)
+ * @param cursors Array of cursor positions and their expected expansion chains
+ * @param options Optional configuration for imports, standalone components, etc.
+ */
+function verifySelectionRanges(
+  env: LanguageServiceTestEnv,
+  template: string,
+  componentMembers: string,
+  cursors: CursorSpec[],
+  options?: {
+    /** Additional imports for the component module (e.g. ['NgStyle', 'NgIf']). Source: @angular/common */
+    imports?: string[];
+    /** When true, sets preserveWhitespaces: true in @Component decorator */
+    preserveWhitespaces?: boolean;
+  },
+): void {
+  const angularImports = options?.imports ?? [];
+  const importStatement =
+    angularImports.length > 0
+      ? `import {${angularImports.join(', ')}} from '@angular/common';`
+      : '';
+  const importsArray = angularImports.length > 0 ? `imports: [${angularImports.join(', ')}],` : '';
+  const preserveWS = options?.preserveWhitespaces ? 'preserveWhitespaces: true,' : '';
+
+  // --- External template mode ---
+  const externalFiles = {
+    'app.html': template,
+    'app.ts': `
+      import {Component} from '@angular/core';
+      ${importStatement}
+
+      @Component({
+        selector: 'my-app',
+        templateUrl: './app.html',
+        ${importsArray}
+        ${preserveWS}
+      })
+      export class AppComponent {
+        ${componentMembers}
+      }
+    `,
+  };
+
+  const externalProject = createModuleAndProjectWithDeclarations(env, 'test-ext', externalFiles);
+
+  for (const cursor of cursors) {
+    const matchIndex = template.indexOf(cursor.cursorAt);
+    expect(matchIndex)
+      .withContext(
+        `[external][${cursor.label}] cursorAt "${cursor.cursorAt}" not found in template`,
+      )
+      .toBeGreaterThanOrEqual(0);
+    const pos = matchIndex + (cursor.offset ?? 0);
+
+    const selectionRange = externalProject.getSelectionRangeAtPosition('app.html', pos);
+    verifyExpansionChain(selectionRange, template, cursor.chain);
+  }
+
+  // --- Inline template mode ---
+  {
+    // Use backticks so single quotes and newlines in template work without escaping.
+    // Only escape ${ (template literal interpolation), not bare $ (e.g. $event).
+    const escapedForBacktick = template
+      .replace(/\\/g, '\\\\')
+      .replace(/`/g, '\\`')
+      .replace(/\$\{/g, '\\${');
+    const inlineFiles = {
+      'app.ts': `
+        import {Component} from '@angular/core';
+        ${importStatement}
+
+        @Component({
+          selector: 'my-app',
+          template: \`${escapedForBacktick}\`,
+          ${importsArray}
+          ${preserveWS}
+        })
+        export class AppComponent {
+          ${componentMembers}
+        }
+      `,
+    };
+
+    const inlineProject = createModuleAndProjectWithDeclarations(env, 'test-inline', inlineFiles);
+    const appFile = inlineProject.openFile('app.ts');
+    // With backtick template, the raw content matches the template exactly (no escape chars)
+    const templateOffset = appFile.contents.indexOf(template);
+    expect(templateOffset)
+      .withContext(`[inline] Could not find template in generated TS file`)
+      .toBeGreaterThanOrEqual(0);
+
+    for (const cursor of cursors) {
+      const matchIndex = template.indexOf(cursor.cursorAt);
+      const pos = templateOffset + matchIndex + (cursor.offset ?? 0);
+
+      const selectionRange = inlineProject.getSelectionRangeAtPosition('app.ts', pos);
+      verifyExpansionChain(selectionRange, template, cursor.chain, templateOffset);
+    }
+  }
+}
+
+describe('selection range', () => {
+  let env: LanguageServiceTestEnv;
+
+  beforeEach(() => {
+    initMockFileSystem('Native');
+    env = LanguageServiceTestEnv.setup();
+  });
+
+  describe('external templates', () => {
+    it('should return selection range for element in external template', () => {
+      verifySelectionRanges(env, '<div>content</div>', '', [
+        {
+          label: 'content text',
+          cursorAt: 'content',
+          chain: ['content', '<div>content</div>'],
+        },
+      ]);
+    });
+
+    it('should return selection range for nested elements', () => {
+      verifySelectionRanges(env, '<div><span>nested</span></div>', '', [
+        {
+          label: 'nested text',
+          cursorAt: 'nested',
+          chain: ['nested', '<span>nested</span>', '<div><span>nested</span></div>'],
+        },
+      ]);
+    });
+  });
+
+  describe('inline templates', () => {
+    it('should handle template literals (backtick templates)', () => {
+      // Multiline template with nested elements — tests whitespace handling
+      const template = `
+              <section>
+                <article>content</article>
+              </section>
+            `;
+      verifySelectionRanges(env, template, '', [
+        {
+          label: 'cursor on content text inside article',
+          cursorAt: 'content',
+          chain: [
+            'content',
+            '<article>content</article>',
+            // Children span (whitespace + article + whitespace inside section)
+            `
+                <article>content</article>
+              `,
+            // Full section element
+            `<section>
+                <article>content</article>
+              </section>`,
+            // Full template (whitespace before section + section + whitespace after)
+            template,
+          ],
+        },
+      ]);
+    });
+
+    it('should work with @if control flow blocks in inline templates', () => {
+      const template = `
+              @if (show) {
+                <div>conditional content</div>
+              }
+            `;
+      // Manually compute the expected intermediate substrings:
+      const ifBody = `
+                <div>conditional content</div>
+              `;
+      const ifBlock = `@if (show) {
+                <div>conditional content</div>
+              }`;
+      // Root span: from start whitespace up to closing brace (the full meaningful content)
+      const rootSpan = template.substring(0, template.lastIndexOf('}') + 1);
+      verifySelectionRanges(env, template, `show = true;`, [
+        {
+          label: 'cursor on conditional text content',
+          cursorAt: 'conditional content',
+          chain: [
+            'conditional',
+            'conditional content',
+            '<div>conditional content</div>',
+            ifBody,
+            ifBlock,
+            rootSpan,
+          ],
+        },
+      ]);
+    });
+
+    it('should work with interpolation in inline templates', () => {
+      // name → siblings text → <span>
+      verifySelectionRanges(env, '<span>Hello {{name}}!</span>', `name = 'World';`, [
+        {
+          label: 'cursor on name in interpolation',
+          cursorAt: 'name',
+          chain: ['name', 'Hello {{name}}!', '<span>Hello {{name}}!</span>'],
+        },
+      ]);
+    });
+
+    it('should work with bound attributes in inline templates', () => {
+      // isActive → [class.active]="isActive" (full attr) → element
+      // keySpan (class.active) is NOT included when cursor is on the expression
+      verifySelectionRanges(
+        env,
+        '<div [class.active]="isActive">Content</div>',
+        `isActive = true;`,
+        [
+          {
+            label: 'cursor on isActive in class binding',
+            cursorAt: 'isActive"',
+            chain: [
+              'isActive',
+              '[class.active]="isActive"',
+              '<div [class.active]="isActive">Content</div>',
+            ],
+          },
+        ],
+      );
+    });
+
+    it('should return undefined for position outside template', () => {
+      const files = {
+        'app.ts': `
+          import {Component} from '@angular/core';
+
+          @Component({
+            selector: 'my-app',
+            template: '<div>content</div>',
+          })
+          export class AppComponent {
+            // Position here should not return selection range
+            someProperty = 'value';
+          }
+        `,
+      };
+
+      const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+      const appFile = project.openFile('app.ts');
+      // Position on "someProperty"
+      const propPos = appFile.contents.indexOf('someProperty');
+
+      const selectionRange = project.getSelectionRangeAtPosition('app.ts', propPos);
+
+      expect(selectionRange).toBeUndefined();
+    });
+
+    it('should handle inline template with complex element and multiple attributes', () => {
+      // Complex element with text attributes, bound attributes, and mixed content
+      const template =
+        '<div data-test="test1" [style.color]="color" style="border: 1px solid"><strong>TEST 1</strong><br>Actual: BLUE text</div>';
+      verifySelectionRanges(env, template, `color = 'blue';`, [
+        {
+          label: 'cursor on BLUE in text content',
+          cursorAt: 'BLUE',
+          chain: [
+            'BLUE',
+            'Actual: BLUE text',
+            '<strong>TEST 1</strong><br>Actual: BLUE text',
+            template,
+          ],
+        },
+      ]);
+    });
+
+    it('should expand through nested elements in backtick inline template', () => {
+      // Nested divs with style attributes — expansion from style attribute value
+      const template =
+        '<div style="padding: 20px;"><div style="margin: 10px;"><strong style="color: red;">TEXT</strong></div></div>';
+      verifySelectionRanges(env, template, '', [
+        {
+          label: 'cursor on color in strong style value',
+          cursorAt: 'color: red',
+          chain: [
+            'color: red;',
+            'style="color: red;"',
+            '<strong style="color: red;">TEXT</strong>',
+            '<div style="margin: 10px;"><strong style="color: red;">TEXT</strong></div>',
+            template,
+          ],
+        },
+      ]);
+    });
+
+    it('should handle multi-line opening tag in backtick inline template', () => {
+      // Multiline element with attributes on separate lines
+      const template = `<div
+              style="border: 1px solid black;">
+              Actual content
+            </div>`;
+      verifySelectionRanges(env, template, '', [
+        {
+          label: 'cursor on style keyword in multiline opening tag',
+          cursorAt: 'style',
+          chain: ['style', 'style="border: 1px solid black;"', template],
+        },
+      ]);
+    });
+
+    describe('sibling expansion', () => {
+      it('should include all siblings before parent element', () => {
+        // In <h1><span>a</span><span>b</span></h1>, selection should expand:
+        // a → <span>a</span> → <span>a</span><span>b</span> (siblings) → <h1>...</h1>
+        verifySelectionRanges(env, '<h1><span>a</span><span>b</span></h1>', '', [
+          {
+            label: 'cursor on a text inside first span',
+            cursorAt: '>a<',
+            offset: 1, // skip the '>' to land on 'a'
+            chain: [
+              'a',
+              '<span>a</span>',
+              '<span>a</span><span>b</span>',
+              '<h1><span>a</span><span>b</span></h1>',
+            ],
+          },
+        ]);
+      });
+
+      it('should expand interpolation before siblings content', () => {
+        // In <span>{{user.name}} - {{user.phone}}</span>, selection should expand:
+        // user → user.name → siblings text + interpolation → <span>...</span>
+        verifySelectionRanges(
+          env,
+          '<span>{{user.name}} - {{user.phone}}</span>',
+          `user = {name: 'John', phone: '123'};`,
+          [
+            {
+              label: 'cursor on user in user.name',
+              cursorAt: 'user.name',
+              chain: [
+                'user',
+                'user.name',
+                '{{user.name}} - {{user.phone}}',
+                '<span>{{user.name}} - {{user.phone}}</span>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle single child without redundant siblings span', () => {
+        // In <span>{{user.name}}</span>, with only one child, siblings span is skipped
+        verifySelectionRanges(env, '<span>{{user.name}}</span>', `user = {name: 'John'};`, [
+          {
+            label: 'cursor on name in user.name',
+            cursorAt: 'name',
+            chain: ['user.name', '{{user.name}}', '<span>{{user.name}}</span>'],
+          },
+        ]);
+      });
+
+      it('should work with multiple text nodes', () => {
+        // In <p>Hello {{name}}!</p>, text + interpolation are siblings
+        // name → combined siblings → <p>
+        verifySelectionRanges(env, '<p>Hello {{name}}!</p>', `name = 'World';`, [
+          {
+            label: 'cursor on name in interpolation',
+            cursorAt: 'name',
+            chain: ['name', 'Hello {{name}}!', '<p>Hello {{name}}!</p>'],
+          },
+        ]);
+      });
+
+      it('should expand through nested property access', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{user.address.city}}</span>',
+          `user = {address: {city: 'NYC'}};`,
+          [
+            {
+              label: 'cursor on city',
+              cursorAt: 'city',
+              chain: [
+                'user.address.city',
+                '{{user.address.city}}',
+                '<span>{{user.address.city}}</span>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle control flow blocks', () => {
+        verifySelectionRanges(env, '@if (show) { <span>content</span> }', `show = true;`, [
+          {
+            label: 'cursor on content',
+            cursorAt: 'content',
+            chain: [
+              'content',
+              '<span>content</span>',
+              ' <span>content</span> ',
+              '@if (show) { <span>content</span> }',
+            ],
+          },
+        ]);
+      });
+
+      it('should handle bound attributes', () => {
+        verifySelectionRanges(env, '<input [value]="userName">', `userName = 'test';`, [
+          {
+            label: 'cursor on userName',
+            cursorAt: 'userName',
+            chain: ['userName', '[value]="userName"', '<input [value]="userName">'],
+          },
+        ]);
+      });
+
+      it('should handle event handlers', () => {
+        verifySelectionRanges(
+          env,
+          '<button (click)="handleClick()">Click</button>',
+          `handleClick() {}`,
+          [
+            {
+              label: 'cursor on handleClick',
+              cursorAt: 'handleClick',
+              chain: [
+                'handleClick',
+                'handleClick()',
+                '(click)="handleClick()"',
+                '<button (click)="handleClick()">Click</button>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should group multiple attributes as siblings', () => {
+        verifySelectionRanges(
+          env,
+          '<input id="name" class="form-control" type="text" placeholder="Enter name">',
+          ``,
+          [
+            {
+              label: 'cursor on name value in id attribute',
+              cursorAt: 'name',
+              chain: [
+                'name',
+                'id="name"',
+                'id="name" class="form-control" type="text" placeholder="Enter name"',
+                '<input id="name" class="form-control" type="text" placeholder="Enter name">',
+              ],
+            },
+          ],
+        );
+      });
+    });
+  });
+
+  describe('control flow blocks', () => {
+    describe('@for blocks', () => {
+      it('should handle @for loop with track expression', () => {
+        const template = '@for (item of items; track item.id) { <div>{{item.name}}</div> }';
+        verifySelectionRanges(env, template, `items = [{id: 1, name: 'Item 1'}];`, [
+          {
+            label: 'cursor on item in item.name',
+            cursorAt: 'item.name',
+            chain: [
+              'item',
+              'item.name',
+              '{{item.name}}',
+              '<div>{{item.name}}</div>',
+              ' <div>{{item.name}}</div> ',
+              template,
+            ],
+          },
+        ]);
+      });
+
+      it('should handle @for with @empty block', () => {
+        // @for with @empty: cursor on text inside @empty block
+        const template = `@for (item of items; track item) {
+            <li>{{item}}</li>
+          } @empty {
+            <p>No items</p>
+          }`;
+        // Compute expected chain substrings from the template
+        const emptyContent = template.substring(
+          template.indexOf('{', template.indexOf('@empty')) + 1,
+          template.lastIndexOf('}'),
+        );
+        const emptyBlock = template.substring(template.indexOf('@empty'));
+
+        verifySelectionRanges(env, template, `items: string[] = [];`, [
+          {
+            label: 'cursor on No in empty block',
+            cursorAt: 'No items',
+            // No (word) → No items (text) → <p> → @empty content → @empty block → full @for
+            chain: ['No', 'No items', '<p>No items</p>', emptyContent, emptyBlock, template],
+          },
+        ]);
+      });
+
+      it('should handle nested @for loops', () => {
+        // Nested @for: cursor on property access inside inner loop
+        const template = `@for (row of rows; track row) {
+            @for (cell of row.cells; track cell) {
+              <span>{{cell.value}}</span>
+            }
+          }`;
+        // Compute expected chain substrings
+        const innerForIdx = template.indexOf('@for (cell');
+        const innerBraceOpen = template.indexOf('{', innerForIdx);
+        const innerBraceClose = template.indexOf(
+          '}',
+          template.indexOf('</span>') + '</span>'.length,
+        );
+        const innerForBody = template.substring(innerBraceOpen + 1, innerBraceClose);
+        const innerFor = template.substring(innerForIdx, innerBraceClose + 1);
+        const outerBraceOpen = template.indexOf('{');
+        const outerForBody = template.substring(outerBraceOpen + 1, innerBraceClose + 1);
+
+        verifySelectionRanges(env, template, `rows = [{cells: [{value: 'A1'}]}];`, [
+          {
+            label: 'cursor on cell in cell.value',
+            cursorAt: 'cell.value',
+            // cell → cell.value → {{cell.value}} → <span> → inner body → inner @for → outer body → outer @for
+            chain: [
+              'cell',
+              'cell.value',
+              '{{cell.value}}',
+              '<span>{{cell.value}}</span>',
+              innerForBody,
+              innerFor,
+              outerForBody,
+              template,
+            ],
+          },
+        ]);
+      });
+    });
+
+    describe('@switch blocks', () => {
+      it('should handle @switch with multiple @case blocks', () => {
+        // @switch with @case and @default: cursor on text inside first @case
+        const template = `@switch (status) {
+            @case ('active') { <span class="active">Active</span> }
+            @case ('inactive') { <span class="inactive">Inactive</span> }
+            @default { <span>Unknown</span> }
+          }`;
+        // Compute expected chain substrings
+        const caseOpenBrace = template.indexOf('{', template.indexOf("@case ('active')"));
+        const caseCloseBrace = template.indexOf('}', caseOpenBrace);
+        const caseBody = template.substring(caseOpenBrace + 1, caseCloseBrace);
+        const caseBlock = template.substring(
+          template.indexOf("@case ('active')"),
+          caseCloseBrace + 1,
+        );
+        const defaultCloseBrace = template.lastIndexOf('}', template.lastIndexOf('}') - 1);
+        const allCases = template.substring(template.indexOf('@case'), defaultCloseBrace + 1);
+
+        verifySelectionRanges(env, template, `status = 'active';`, [
+          {
+            label: 'cursor on Active text inside first @case',
+            cursorAt: '>Active<',
+            offset: 1,
+            // Active → <span> → @case body → @case block → all case groups → @switch
+            chain: [
+              'Active',
+              '<span class="active">Active</span>',
+              caseBody,
+              caseBlock,
+              allCases,
+              template,
+            ],
+          },
+        ]);
+      });
+
+      it('should handle @switch with expression in @case', () => {
+        // @switch with expression in @case: cursor on @case expression
+        const template = `@switch (value) {
+            @case (computedValue) { <div>Match</div> }
+          }`;
+        const caseBlock = template.substring(
+          template.indexOf('@case'),
+          template.indexOf('}', template.indexOf('Match</div>')) + 1,
+        );
+
+        verifySelectionRanges(env, template, `value = 1;\n        computedValue = 1;`, [
+          {
+            label: 'cursor on computedValue in @case condition',
+            cursorAt: 'computedValue',
+            // computedValue → @case block → @switch block
+            chain: ['computedValue', caseBlock, template],
+          },
+        ]);
+      });
+    });
+
+    describe('@defer blocks', () => {
+      it('should handle @defer with @loading and @error blocks', () => {
+        const template = `@defer {
+            <heavy-component />
+          } @loading {
+            <p>Loading...</p>
+          } @error {
+            <p>Error occurred</p>
+          }`;
+        const loadingBraceOpen = template.indexOf('{', template.indexOf('@loading'));
+        const loadingBraceClose = template.indexOf('}', template.indexOf('Loading...</p>'));
+        const loadingContent = template.substring(loadingBraceOpen + 1, loadingBraceClose);
+        const loadingBlock = template.substring(
+          template.indexOf('@loading'),
+          loadingBraceClose + 1,
+        );
+
+        verifySelectionRanges(env, template, '', [
+          {
+            label: 'cursor on Loading text inside @loading block',
+            cursorAt: 'Loading...',
+            // Loading (word) → Loading... (text) → <p> → @loading content → @loading → @defer
+            chain: [
+              'Loading',
+              'Loading...',
+              '<p>Loading...</p>',
+              loadingContent,
+              loadingBlock,
+              template,
+            ],
+          },
+        ]);
+      });
+
+      it('should handle @defer with @placeholder block', () => {
+        const template = `@defer {
+            <main-content />
+          } @placeholder (minimum 500ms) {
+            <p>Placeholder content</p>
+          }`;
+        const phBraceOpen = template.indexOf('{', template.indexOf('@placeholder'));
+        const phBraceClose = template.indexOf('}', template.indexOf('Placeholder content</p>'));
+        const phContent = template.substring(phBraceOpen + 1, phBraceClose);
+        const phBlock = template.substring(template.indexOf('@placeholder'), phBraceClose + 1);
+
+        verifySelectionRanges(env, template, '', [
+          {
+            label: 'cursor on Placeholder text inside @placeholder block',
+            cursorAt: 'Placeholder content',
+            // Placeholder (word) → Placeholder content (text) → <p> → content → @placeholder → @defer
+            chain: [
+              'Placeholder',
+              'Placeholder content',
+              '<p>Placeholder content</p>',
+              phContent,
+              phBlock,
+              template,
+            ],
+          },
+        ]);
+      });
+
+      it('should expand through @defer when trigger expression', () => {
+        const template = `@defer (when isReady) {
+            <heavy-component />
+          }`;
+        verifySelectionRanges(env, template, `isReady = false;`, [
+          {
+            label: 'cursor on isReady in when condition',
+            cursorAt: 'isReady',
+            // isReady → when isReady (trigger span) → @defer block
+            chain: ['isReady', 'when isReady', template],
+          },
+        ]);
+      });
+
+      it('should expand through @defer when trigger with property access', () => {
+        const template = `@defer (when data.isLoaded) {
+            <result-view [data]="data" />
+          }`;
+        verifySelectionRanges(env, template, `data = { isLoaded: false };`, [
+          {
+            label: 'cursor on isLoaded in when condition with property access',
+            cursorAt: 'isLoaded',
+            // Cursor on "isLoaded" is within the PropertyRead span for "data.isLoaded"
+            // data.isLoaded → when data.isLoaded (trigger) → @defer block
+            chain: ['data.isLoaded', 'when data.isLoaded', template],
+          },
+        ]);
+      });
+    });
+
+    describe('@if with @else', () => {
+      it('should handle @if with @else if and @else', () => {
+        const files = {
+          'app.html': `@if (condition1) {
+            <div>First</div>
+          } @else if (condition2) {
+            <div>Second</div>
+          } @else {
+            <div>Default</div>
+          }`,
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              condition1 = false;
+              condition2 = false;
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "Second" text
+        const secondPos = template.indexOf('>Second<') + 1;
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', secondPos);
+
+        // Second → <div>Second</div> → @else if branch body → @else if branch → all branches (siblings) → @if block
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be Second').toBe('Second');
+
+        // Verify outermost reaches the full @if block
+        let outermost = selectionRange;
+        while (outermost.parent) outermost = outermost.parent;
+        const outermostText = template.substring(
+          outermost.textSpan.start,
+          outermost.textSpan.start + outermost.textSpan.length,
+        );
+        expect(outermostText).withContext('Outermost should include @if').toContain('@if');
+        expect(outermostText).withContext('Outermost should include @else').toContain('@else');
+      });
+
+      it('should handle selection on @if condition expression', () => {
+        const files = {
+          'app.html': '@if (user.isLoggedIn && user.hasPermission) { <div>Content</div> }',
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              user = {isLoggedIn: true, hasPermission: true};
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "isLoggedIn" in the condition expression
+        const condPos = template.indexOf('isLoggedIn');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', condPos);
+
+        // user → user.isLoggedIn → user.isLoggedIn && user.hasPermission → @if branch → @if block
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        // Cursor is on 'isLoggedIn', so innermost should be 'user.isLoggedIn'
+        expect(innermostText)
+          .withContext('Innermost should be user.isLoggedIn')
+          .toBe('user.isLoggedIn');
+      });
+    });
+
+    describe('nested control flow', () => {
+      it('should handle @if inside @for inside @switch', () => {
+        const files = {
+          'app.html': `@switch (mode) {
+            @case ('list') {
+              @for (item of items; track item.id) {
+                @if (item.visible) {
+                  <span>{{item.name}}</span>
+                }
+              }
+            }
+          }`,
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              mode = 'list';
+              items = [{id: 1, name: 'Test', visible: true}];
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "item" in "item.name" interpolation
+        const itemPos = template.indexOf('item.name');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', itemPos);
+
+        // item → item.name → {{item.name}} → <span> → @if body → @if → @for body → @for → @case body → @case → @switch
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        // Verify innermost is 'item'
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be item').toBe('item');
+
+        // Verify chain depth for deeply nested control flow
+        let depth = 0;
+        let range: ts.SelectionRange | undefined = selectionRange;
+        while (range) {
+          depth++;
+          range = range.parent;
+        }
+        // Deep nesting needs at least: item → item.name → {{...}} → span → @if → @for → @case group → @switch
+        expect(depth)
+          .withContext('Should have at least 6 levels for deep nesting')
+          .toBeGreaterThanOrEqual(6);
+
+        // Verify outermost reaches @switch
+        let outermost = selectionRange;
+        while (outermost.parent) outermost = outermost.parent;
+        const outermostText = template.substring(
+          outermost.textSpan.start,
+          outermost.textSpan.start + outermost.textSpan.length,
+        );
+        expect(outermostText).withContext('Outermost should include @switch').toContain('@switch');
+      });
+    });
+  });
+
+  describe('expression patterns', () => {
+    describe('pipe expressions', () => {
+      it('should expand correctly from pipe argument, pipe name, and input expression', () => {
+        // Test the same template from 3 different cursor positions
+        verifySelectionRanges(
+          env,
+          `<span>{{ value | date:'short' }}</span>`,
+          `value = new Date();`,
+          [
+            {
+              label: 'cursor on pipe argument "short"',
+              cursorAt: 'short',
+              chain: [
+                'short',
+                `'short'`,
+                `date:'short'`,
+                `value | date:'short'`,
+                `{{ value | date:'short' }}`,
+                `<span>{{ value | date:'short' }}</span>`,
+              ],
+            },
+            {
+              label: 'cursor on pipe name "date"',
+              cursorAt: 'date',
+              chain: [
+                'date',
+                `date:'short'`,
+                `value | date:'short'`,
+                `{{ value | date:'short' }}`,
+                `<span>{{ value | date:'short' }}</span>`,
+              ],
+            },
+            {
+              label: 'cursor on input expression "value"',
+              cursorAt: 'value',
+              chain: [
+                'value',
+                `value | date:'short'`,
+                `{{ value | date:'short' }}`,
+                `<span>{{ value | date:'short' }}</span>`,
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should expand from pipe input through simple pipe to interpolation', () => {
+        verifySelectionRanges(env, `<span>{{ value | uppercase }}</span>`, `value = 'hello';`, [
+          {
+            label: 'cursor on "value"',
+            cursorAt: 'value',
+            chain: [
+              'value',
+              'value | uppercase',
+              '{{ value | uppercase }}',
+              '<span>{{ value | uppercase }}</span>',
+            ],
+          },
+          {
+            label: 'cursor on "uppercase"',
+            cursorAt: 'uppercase',
+            chain: [
+              'uppercase',
+              'value | uppercase',
+              '{{ value | uppercase }}',
+              '<span>{{ value | uppercase }}</span>',
+            ],
+          },
+        ]);
+      });
+
+      it('should handle pipe with multiple arguments', () => {
+        verifySelectionRanges(
+          env,
+          `<span>{{ birthday | date:'fullDate':'UTC' }}</span>`,
+          `birthday = new Date();`,
+          [
+            {
+              label: 'cursor on last arg "UTC"',
+              cursorAt: 'UTC',
+              chain: [
+                'UTC',
+                `'UTC'`,
+                `date:'fullDate':'UTC'`,
+                `birthday | date:'fullDate':'UTC'`,
+                `{{ birthday | date:'fullDate':'UTC' }}`,
+                `<span>{{ birthday | date:'fullDate':'UTC' }}</span>`,
+              ],
+            },
+            {
+              label: 'cursor on first arg "fullDate"',
+              cursorAt: 'fullDate',
+              chain: [
+                'fullDate',
+                `'fullDate'`,
+                `date:'fullDate':'UTC'`,
+                `birthday | date:'fullDate':'UTC'`,
+                `{{ birthday | date:'fullDate':'UTC' }}`,
+                `<span>{{ birthday | date:'fullDate':'UTC' }}</span>`,
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle chained pipes from input expression', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{ data | async | json }}</span>',
+          `data = null as any;`,
+          [
+            {
+              label: 'cursor on "data" input',
+              cursorAt: 'data',
+              chain: [
+                'data',
+                'data | async',
+                'data | async | json',
+                '{{ data | async | json }}',
+                '<span>{{ data | async | json }}</span>',
+              ],
+            },
+            {
+              label: 'cursor on "async" pipe',
+              cursorAt: 'async',
+              chain: [
+                'async',
+                'data | async',
+                'data | async | json',
+                '{{ data | async | json }}',
+                '<span>{{ data | async | json }}</span>',
+              ],
+            },
+            {
+              label: 'cursor on "json" pipe',
+              cursorAt: 'json',
+              chain: [
+                'json',
+                'data | async | json',
+                '{{ data | async | json }}',
+                '<span>{{ data | async | json }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('method calls', () => {
+      it('should expand from call argument through argument list to full call', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{ formatValue(value, "currency", 2) }}</span>',
+          `value = 100;
+        formatValue(v: number, type: string, decimals: number) { return v.toString(); }`,
+          [
+            {
+              label: 'cursor on currency string argument',
+              cursorAt: 'currency',
+              chain: [
+                'currency',
+                '"currency"',
+                'value, "currency", 2',
+                'formatValue(value, "currency", 2)',
+                '{{ formatValue(value, "currency", 2) }}',
+                '<span>{{ formatValue(value, "currency", 2) }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should expand from method name through property chain', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{ items.filter(isActive).map(getName).join(", ") }}</span>',
+          `items: any[] = [];
+        isActive = (x: any) => true;
+        getName = (x: any) => x.name;`,
+          [
+            {
+              label: 'cursor on filter in method chain',
+              cursorAt: 'filter',
+              chain: [
+                'items.filter',
+                'items.filter(isActive)',
+                'items.filter(isActive).map',
+                'items.filter(isActive).map(getName)',
+                'items.filter(isActive).map(getName).join',
+                'items.filter(isActive).map(getName).join(", ")',
+                '{{ items.filter(isActive).map(getName).join(", ") }}',
+                '<span>{{ items.filter(isActive).map(getName).join(", ") }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('conditional expressions', () => {
+      it('should handle ternary from condition, true branch, and false branch', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{ isActive ? "Active" : "Inactive" }}</span>',
+          `isActive = true;`,
+          [
+            {
+              label: 'cursor on condition "isActive"',
+              cursorAt: 'isActive',
+              chain: [
+                'isActive',
+                'isActive ? "Active" : "Inactive"',
+                '{{ isActive ? "Active" : "Inactive" }}',
+                '<span>{{ isActive ? "Active" : "Inactive" }}</span>',
+              ],
+            },
+            {
+              label: 'cursor on true branch "Active"',
+              cursorAt: '"Active"',
+              offset: 1,
+              chain: [
+                'Active',
+                '"Active"',
+                'isActive ? "Active" : "Inactive"',
+                '{{ isActive ? "Active" : "Inactive" }}',
+                '<span>{{ isActive ? "Active" : "Inactive" }}</span>',
+              ],
+            },
+            {
+              label: 'cursor on false branch "Inactive"',
+              cursorAt: '"Inactive"',
+              offset: 1,
+              chain: [
+                'Inactive',
+                '"Inactive"',
+                'isActive ? "Active" : "Inactive"',
+                '{{ isActive ? "Active" : "Inactive" }}',
+                '<span>{{ isActive ? "Active" : "Inactive" }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle nested ternary', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{ a ? b ? "AB" : "A" : "None" }}</span>',
+          `a = true;
+        b = true;`,
+          [
+            {
+              label: 'cursor on inner b',
+              cursorAt: ' b ',
+              offset: 1,
+              chain: [
+                'b',
+                'b ? "AB" : "A"',
+                'a ? b ? "AB" : "A" : "None"',
+                '{{ a ? b ? "AB" : "A" : "None" }}',
+                '<span>{{ a ? b ? "AB" : "A" : "None" }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle nullish coalescing from both sides', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{ user.name ?? "Anonymous" }}</span>',
+          `user = {name: null as string | null};`,
+          [
+            {
+              label: 'cursor on "user"',
+              cursorAt: 'user',
+              chain: [
+                'user',
+                'user.name',
+                'user.name ?? "Anonymous"',
+                '{{ user.name ?? "Anonymous" }}',
+                '<span>{{ user.name ?? "Anonymous" }}</span>',
+              ],
+            },
+            {
+              label: 'cursor on fallback "Anonymous"',
+              cursorAt: 'Anonymous',
+              chain: [
+                'Anonymous',
+                '"Anonymous"',
+                'user.name ?? "Anonymous"',
+                '{{ user.name ?? "Anonymous" }}',
+                '<span>{{ user.name ?? "Anonymous" }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('safe navigation', () => {
+      it('should expand through optional chaining from different positions', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{ user?.profile?.avatar?.url }}</span>',
+          `user: any = null;`,
+          [
+            {
+              label: 'cursor on intermediate "avatar"',
+              cursorAt: 'avatar',
+              chain: [
+                // Only nodes whose spans contain the cursor are included
+                'user?.profile?.avatar',
+                'user?.profile?.avatar?.url',
+                '{{ user?.profile?.avatar?.url }}',
+                '<span>{{ user?.profile?.avatar?.url }}</span>',
+              ],
+            },
+            {
+              label: 'cursor on leaf "url"',
+              cursorAt: 'url',
+              chain: [
+                'user?.profile?.avatar?.url',
+                '{{ user?.profile?.avatar?.url }}',
+                '<span>{{ user?.profile?.avatar?.url }}</span>',
+              ],
+            },
+            {
+              label: 'cursor on root "user"',
+              cursorAt: 'user',
+              chain: [
+                'user',
+                'user?.profile',
+                'user?.profile?.avatar',
+                'user?.profile?.avatar?.url',
+                '{{ user?.profile?.avatar?.url }}',
+                '<span>{{ user?.profile?.avatar?.url }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle safe method call', () => {
+        verifySelectionRanges(env, '<span>{{ user?.getName?.() }}</span>', `user: any = null;`, [
+          {
+            label: 'cursor on "getName"',
+            cursorAt: 'getName',
+            chain: [
+              // Cursor is on getName - user receiver doesn't contain cursor
+              'user?.getName',
+              'user?.getName?.()',
+              '{{ user?.getName?.() }}',
+              '<span>{{ user?.getName?.() }}</span>',
+            ],
+          },
+        ]);
+      });
+    });
+
+    describe('keyed access', () => {
+      it('should handle array index and bracket notation', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{ items[0].name }}</span>',
+          `items = [{name: 'First'}];`,
+          [
+            {
+              label: 'cursor on "items"',
+              cursorAt: 'items',
+              chain: [
+                'items',
+                'items[0]',
+                'items[0].name',
+                '{{ items[0].name }}',
+                '<span>{{ items[0].name }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle bracket notation with variable key', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{ translations[currentLang] }}</span>',
+          `translations: Record<string, string> = {};\n        currentLang = 'en';`,
+          [
+            {
+              label: 'cursor on key "currentLang"',
+              cursorAt: 'currentLang',
+              chain: [
+                'currentLang',
+                'translations[currentLang]',
+                '{{ translations[currentLang] }}',
+                '<span>{{ translations[currentLang] }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('literal expressions', () => {
+      it('should handle array literal in binding', () => {
+        verifySelectionRanges(env, '<app-list [items]="[1, 2, 3, 4, 5]"></app-list>', ``, [
+          {
+            label: 'cursor on array literal',
+            cursorAt: '[1,',
+            chain: [
+              '[1, 2, 3, 4, 5]',
+              '[items]="[1, 2, 3, 4, 5]"',
+              '<app-list [items]="[1, 2, 3, 4, 5]"></app-list>',
+            ],
+          },
+        ]);
+      });
+
+      it('should handle object literal in binding', () => {
+        verifySelectionRanges(
+          env,
+          `<app-config [options]="{theme: 'dark', size: 'large'}"></app-config>`,
+          ``,
+          [
+            {
+              label: 'cursor on theme key in object literal',
+              cursorAt: 'theme',
+              chain: [
+                "{theme: 'dark', size: 'large'}",
+                `[options]="{theme: 'dark', size: 'large'}"`,
+                `<app-config [options]="{theme: 'dark', size: 'large'}"></app-config>`,
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('arrow function expressions', () => {
+      it('should expand through arrow function body', () => {
+        verifySelectionRanges(env, `<div>{{ x => x * 2 }}</div>`, ``, [
+          {
+            label: 'cursor on x in body',
+            cursorAt: 'x * 2',
+            chain: ['x', 'x * 2', 'x => x * 2', '{{ x => x * 2 }}', '<div>{{ x => x * 2 }}</div>'],
+          },
+        ]);
+      });
+
+      it('should handle arrow function in property binding', () => {
+        verifySelectionRanges(
+          env,
+          `<button [disabled]="items.some(item => item.invalid)">Submit</button>`,
+          `items = [{invalid: false}];`,
+          [
+            {
+              label: 'cursor on item in item.invalid',
+              cursorAt: 'item.invalid',
+              chain: [
+                'item',
+                'item.invalid',
+                'item => item.invalid',
+                'items.some(item => item.invalid)',
+                '[disabled]="items.some(item => item.invalid)"',
+                '<button [disabled]="items.some(item => item.invalid)">Submit</button>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('pipe expressions', () => {
+      it('should expand through pipe chains from input expression', () => {
+        verifySelectionRanges(
+          env,
+          `<div>{{ name | uppercase | slice:0:5 }}</div>`,
+          `name = 'Angular';`,
+          [
+            {
+              label: 'cursor on name',
+              cursorAt: 'name',
+              chain: [
+                'name',
+                'name | uppercase',
+                'name | uppercase | slice:0:5',
+                '{{ name | uppercase | slice:0:5 }}',
+                '<div>{{ name | uppercase | slice:0:5 }}</div>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should expand from pipe argument in chained pipes', () => {
+        verifySelectionRanges(
+          env,
+          `<div>{{ name | uppercase | slice:0:5 }}</div>`,
+          `name = 'Angular';`,
+          [
+            {
+              label: 'cursor on 5 (second arg to slice pipe)',
+              cursorAt: ':5',
+              offset: 1,
+              chain: [
+                '5',
+                'slice:0:5',
+                'name | uppercase | slice:0:5',
+                '{{ name | uppercase | slice:0:5 }}',
+                '<div>{{ name | uppercase | slice:0:5 }}</div>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('literal expressions', () => {
+      it('should expand through array literals', () => {
+        verifySelectionRanges(env, `<div [items]="[1, 2, 3]"></div>`, ``, [
+          {
+            label: 'cursor on first element',
+            cursorAt: '1',
+            chain: ['1', '[1, 2, 3]', '[items]="[1, 2, 3]"', '<div [items]="[1, 2, 3]"></div>'],
+          },
+        ]);
+      });
+
+      it('should expand through object literals', () => {
+        verifySelectionRanges(env, `<div [config]="{theme: 'dark', size: 10}"></div>`, ``, [
+          {
+            label: 'cursor on dark string literal',
+            cursorAt: "'dark'",
+            chain: [
+              'dark',
+              "'dark'",
+              "{theme: 'dark', size: 10}",
+              `[config]="{theme: 'dark', size: 10}"`,
+              `<div [config]="{theme: 'dark', size: 10}"></div>`,
+            ],
+          },
+        ]);
+      });
+    });
+
+    describe('unary expressions', () => {
+      it('should expand through prefix not', () => {
+        // *ngIf desugars in the template AST. The chain walks through the desugared attribute.
+        // isHidden → !isHidden → ngIf="!isHidden (partial attr) → Content → element
+        // keySpan (ngIf) is NOT included when cursor is on the expression
+        verifySelectionRanges(env, '<div *ngIf="!isHidden">Content</div>', `isHidden = false;`, [
+          {
+            label: 'cursor on isHidden in *ngIf',
+            cursorAt: 'isHidden',
+            chain: [
+              'isHidden',
+              '!isHidden',
+              'ngIf="!isHidden',
+              'Content',
+              '<div *ngIf="!isHidden">Content</div>',
+            ],
+          },
+        ]);
+      });
+    });
+
+    describe('non-null assertion', () => {
+      it('should expand through non-null assertion', () => {
+        // NonNullAssert(user).name — cursor on "name" lands on the PropertyRead
+        // The chain shows user!.name (whole expression) directly since cursor is on the property
+        verifySelectionRanges(env, '<span>{{user!.name}}</span>', `user: any;`, [
+          {
+            label: 'cursor on name in user!.name',
+            cursorAt: 'name',
+            chain: ['user!.name', '{{user!.name}}', '<span>{{user!.name}}</span>'],
+          },
+        ]);
+      });
+    });
+
+    describe('binary expressions', () => {
+      it('should expand through arithmetic with precedence', () => {
+        // a + b * c: Binary(+, a, Binary(*, b, c))
+        // Cursor on b: b → b * c (inner Binary) → a + b * c (outer Binary) → interpolation → element
+        verifySelectionRanges(env, '<span>{{a + b * c}}</span>', `a = 1; b = 2; c = 3;`, [
+          {
+            label: 'cursor on b in b * c',
+            cursorAt: 'b * c',
+            chain: ['b', 'b * c', 'a + b * c', '{{a + b * c}}', '<span>{{a + b * c}}</span>'],
+          },
+        ]);
+      });
+
+      it('should expand through comparison operator', () => {
+        // count > 10 in a bound attribute binding
+        verifySelectionRanges(env, '<div [hidden]="count > 10">Content</div>', `count = 5;`, [
+          {
+            label: 'cursor on count in count > 10',
+            cursorAt: 'count',
+            chain: [
+              'count',
+              'count > 10',
+              '[hidden]="count > 10"',
+              '<div [hidden]="count > 10">Content</div>',
+            ],
+          },
+        ]);
+      });
+
+      it('should expand through logical AND', () => {
+        // Structural directive with logical AND — desugars like *ngIf
+        // keySpan (ngIf) is NOT included when cursor is on the expression
+        verifySelectionRanges(
+          env,
+          '<div *ngIf="isA && isB">Visible</div>',
+          `isA = true; isB = true;`,
+          [
+            {
+              label: 'cursor on isB in logical AND',
+              cursorAt: 'isB',
+              chain: [
+                'isB',
+                'isA && isB',
+                'ngIf="isA && isB',
+                'Visible',
+                '<div *ngIf="isA && isB">Visible</div>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should expand through nullish coalescing chain', () => {
+        // a ?? b ?? c: left-associative Binary(??, Binary(??, a, b), c)
+        // Cursor on b: b → a ?? b (inner Binary) → a ?? b ?? c (outer) → interpolation → element
+        verifySelectionRanges(
+          env,
+          '<span>{{a ?? b ?? c}}</span>',
+          `a: string | null = null; b: string | null = null; c = 'default';`,
+          [
+            {
+              label: 'cursor on b in nullish coalescing chain',
+              cursorAt: ' b ',
+              offset: 1,
+              chain: [
+                'b',
+                'a ?? b',
+                'a ?? b ?? c',
+                '{{a ?? b ?? c}}',
+                '<span>{{a ?? b ?? c}}</span>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('parenthesized expressions', () => {
+      it('should expand through parenthesized expression', () => {
+        // (a + b) * c: parentheses create an intermediate grouping step
+        // a → a + b (inner Binary) → (a + b) (parens) → (a + b) * c (outer Binary) → interpolation → element
+        verifySelectionRanges(env, '<span>{{(a + b) * c}}</span>', `a = 1; b = 2; c = 3;`, [
+          {
+            label: 'cursor on a in (a + b)',
+            cursorAt: 'a + b',
+            chain: [
+              'a',
+              'a + b',
+              '(a + b)',
+              '(a + b) * c',
+              '{{(a + b) * c}}',
+              '<span>{{(a + b) * c}}</span>',
+            ],
+          },
+        ]);
+      });
+    });
+
+    describe('chain expressions', () => {
+      it('should expand through semicolon chain in event', () => {
+        // Event binding with multiple statements separated by semicolons
+        // doA → doA() (Call) → doA(); doB() (Chain) → full attr → element
+        // keySpan (click) NOT included when cursor is on the handler expression
+        verifySelectionRanges(
+          env,
+          '<button (click)="doA(); doB()">Click</button>',
+          `doA() {} doB() {}`,
+          [
+            {
+              label: 'cursor on doA in semicolon chain',
+              cursorAt: 'doA',
+              chain: [
+                'doA',
+                'doA()',
+                'doA(); doB()',
+                '(click)="doA(); doB()"',
+                '<button (click)="doA(); doB()">Click</button>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('edge cases', () => {
+      it('should handle empty interpolation', () => {
+        // Empty interpolation {{}} has no expression nodes, just the interpolation itself
+        verifySelectionRanges(env, '<span>{{}}</span>', '', [
+          {
+            label: 'cursor inside empty interpolation',
+            cursorAt: '{{}}',
+            offset: 2,
+            chain: ['{{}}', '<span>{{}}</span>'],
+          },
+        ]);
+      });
+
+      it('should handle self-closing element with binding', () => {
+        // Self-closing element: expression → full attr → element
+        // keySpan (value) NOT included when cursor is on the expression
+        verifySelectionRanges(env, '<input [value]="name" />', `name = 'test';`, [
+          {
+            label: 'cursor on name in self-closing input',
+            cursorAt: 'name"',
+            chain: ['name', '[value]="name"', '<input [value]="name" />'],
+          },
+        ]);
+      });
+
+      it('should handle template reference variable', () => {
+        // Reference variable #myInput used in sibling interpolation
+        verifySelectionRanges(env, '<input #myInput><span>{{myInput.value}}</span>', ``, [
+          {
+            label: 'cursor on myInput in interpolation',
+            cursorAt: 'myInput.value',
+            chain: [
+              'myInput',
+              'myInput.value',
+              '{{myInput.value}}',
+              '<span>{{myInput.value}}</span>',
+              '<input #myInput><span>{{myInput.value}}</span>',
+            ],
+          },
+        ]);
+      });
+
+      it('should handle deeply nested elements', () => {
+        // 5-level nesting: each level becomes a step in the chain
+        verifySelectionRanges(
+          env,
+          '<div><section><article><p><span>deep</span></p></article></section></div>',
+          '',
+          [
+            {
+              label: 'cursor on deep in deeply nested span',
+              cursorAt: 'deep',
+              chain: [
+                'deep',
+                '<span>deep</span>',
+                '<p><span>deep</span></p>',
+                '<article><p><span>deep</span></p></article>',
+                '<section><article><p><span>deep</span></p></article></section>',
+                '<div><section><article><p><span>deep</span></p></article></section></div>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle multiple bindings on same element', () => {
+        // Element with multiple bindings: each binding has its own chain ending at the element
+        // keySpan NOT included when cursor is on the expression
+        const template =
+          '<div [title]="titleVal" [hidden]="isHidden" (click)="onClick()">Text</div>';
+        verifySelectionRanges(env, template, `titleVal = 'hi'; isHidden = false; onClick() {}`, [
+          {
+            label: 'cursor on titleVal in title binding',
+            cursorAt: 'titleVal',
+            chain: [
+              'titleVal',
+              '[title]="titleVal"',
+              '[title]="titleVal" [hidden]="isHidden" (click)="onClick()"',
+              template,
+            ],
+          },
+          {
+            label: 'cursor on isHidden in hidden binding',
+            cursorAt: 'isHidden',
+            chain: [
+              'isHidden',
+              '[hidden]="isHidden"',
+              '[title]="titleVal" [hidden]="isHidden" (click)="onClick()"',
+              template,
+            ],
+          },
+        ]);
+      });
+
+      it('should handle @let declaration', () => {
+        // @let creates a template variable — cursor on usage in interpolation
+        verifySelectionRanges(
+          env,
+          '@let total = price * quantity; <span>{{total}}</span>',
+          `price = 10; quantity = 3;`,
+          [
+            {
+              label: 'cursor on total in interpolation',
+              cursorAt: '{{total}}',
+              offset: 2,
+              chain: [
+                'total',
+                '{{total}}',
+                '<span>{{total}}</span>',
+                '@let total = price * quantity; <span>{{total}}</span>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+  });
+
+  describe('binding patterns', () => {
+    describe('two-way binding', () => {
+      it('should handle banana-in-a-box syntax', () => {
+        verifySelectionRanges(env, '<input [(ngModel)]="userName">', `userName = '';`, [
+          {
+            label: 'cursor on userName',
+            cursorAt: 'userName',
+            chain: ['userName', '[(ngModel)]="userName"', '<input [(ngModel)]="userName">'],
+          },
+        ]);
+      });
+    });
+
+    describe('class and style bindings', () => {
+      it('should handle [class.name] binding', () => {
+        verifySelectionRanges(
+          env,
+          '<div [class.active]="isActive" [class.disabled]="isDisabled">Content</div>',
+          `isActive = true;
+        isDisabled = false;`,
+          [
+            {
+              label: 'cursor on isActive',
+              cursorAt: 'isActive',
+              chain: [
+                'isActive',
+                '[class.active]="isActive"',
+                '[class.active]="isActive" [class.disabled]="isDisabled"',
+                '<div [class.active]="isActive" [class.disabled]="isDisabled">Content</div>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle [style.property] binding', () => {
+        verifySelectionRanges(
+          env,
+          '<div [style.width.px]="containerWidth" [style.background-color]="bgColor">Content</div>',
+          `containerWidth = 200;
+        bgColor = 'blue';`,
+          [
+            {
+              label: 'cursor on containerWidth',
+              cursorAt: 'containerWidth',
+              chain: [
+                'containerWidth',
+                '[style.width.px]="containerWidth"',
+                '[style.width.px]="containerWidth" [style.background-color]="bgColor"',
+                '<div [style.width.px]="containerWidth" [style.background-color]="bgColor">Content</div>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('attribute bindings', () => {
+      it('should handle [attr.name] binding', () => {
+        verifySelectionRanges(
+          env,
+          '<button [attr.aria-label]="buttonLabel" [attr.data-testid]="testId">Click</button>',
+          `buttonLabel = 'Submit form';
+        testId = 'submit-btn';`,
+          [
+            {
+              label: 'cursor on buttonLabel',
+              cursorAt: 'buttonLabel',
+              chain: [
+                'buttonLabel',
+                '[attr.aria-label]="buttonLabel"',
+                '[attr.aria-label]="buttonLabel" [attr.data-testid]="testId"',
+                '<button [attr.aria-label]="buttonLabel" [attr.data-testid]="testId">Click</button>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+  });
+
+  describe('template features', () => {
+    describe('template references', () => {
+      it('should handle template reference variable', () => {
+        const files = {
+          'app.html':
+            '<input #nameInput type="text"><button (click)="greet(nameInput.value)">Greet</button>',
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              greet(name: string) { console.log('Hello', name); }
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "nameInput" in the event handler expression
+        const refPos = template.indexOf('nameInput.value');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', refPos);
+
+        // nameInput → nameInput.value → args span → greet(nameInput.value) → click key → event binding → siblings → element
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        // Verify innermost is nameInput
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText)
+          .withContext('Innermost should contain nameInput')
+          .toContain('nameInput');
+      });
+
+      it('should handle reference on ng-template', () => {
+        const files = {
+          'app.html': `
+            <ng-template #loadingTemplate>
+              <p>Loading...</p>
+            </ng-template>
+            <div *ngIf="data; else loadingTemplate">{{data}}</div>
+          `,
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              data: string | null = null;
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "Loading..."
+        const loadingPos = template.indexOf('Loading...');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', loadingPos);
+
+        // Loading → Loading... → <p>Loading...</p> → ng-template content → ng-template element
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be word Loading').toContain('Loading');
+      });
+    });
+
+    describe('@let declarations', () => {
+      it('should handle @let with expression', () => {
+        const files = {
+          'app.html': `@let fullName = firstName + ' ' + lastName;
+            <span>{{fullName}}</span>`,
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              firstName = 'John';
+              lastName = 'Doe';
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "firstName" in @let
+        const namePos = template.indexOf('firstName');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', namePos);
+
+        // firstName is inside a Binary expression: firstName + ' ' + lastName
+        // firstName → firstName + ' ' → firstName + ' ' + lastName → @let declaration → root
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be firstName').toBe('firstName');
+      });
+
+      it('should handle @let with pipe and usage', () => {
+        const files = {
+          'app.html': `@let upperName = name | uppercase;
+            <div>{{upperName}}</div>`,
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              name = 'test';
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "upperName" usage in interpolation
+        const usagePos = template.indexOf('{{upperName}}') + 2;
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', usagePos);
+
+        // upperName → {{upperName}} → ... → root siblings
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be upperName').toBe('upperName');
+      });
+    });
+
+    describe('structural directives', () => {
+      it('should handle *ngIf with as syntax', () => {
+        const files = {
+          'app.html': '<div *ngIf="user$ | async as user">Welcome, {{user.name}}</div>',
+          'app.ts': `
+            import {Component} from '@angular/core';
+            import {of} from 'rxjs';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              user$ = of({name: 'John'});
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "user" in "user.name" interpolation
+        const namePos = template.indexOf('user.name');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', namePos);
+
+        // user → user.name → children siblings → element
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be user').toBe('user');
+      });
+
+      it('should handle *ngFor with multiple local variables', () => {
+        const files = {
+          'app.html': `<li *ngFor="let item of items; index as i; first as isFirst; last as isLast; trackBy: trackFn">
+            {{i}}: {{item.name}} {{isFirst ? '(first)' : ''}} {{isLast ? '(last)' : ''}}
+          </li>`,
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              items = [{id: 1, name: 'A'}, {id: 2, name: 'B'}];
+              trackFn(index: number, item: any) { return item.id; }
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "isFirst" in interpolation
+        const firstPos = template.indexOf('{{isFirst') + 2;
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', firstPos);
+
+        // isFirst → ternary expression → siblings → element
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be isFirst').toBe('isFirst');
+      });
+    });
+  });
+
+  describe('complex scenarios', () => {
+    describe('deeply nested templates', () => {
+      it('should handle 5+ levels of nesting', () => {
+        const files = {
+          'app.html': `
+            <div class="level-1">
+              <section class="level-2">
+                <article class="level-3">
+                  <div class="level-4">
+                    <span class="level-5">Deep content</span>
+                  </div>
+                </article>
+              </section>
+            </div>
+          `,
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {}
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "Deep content"
+        const contentPos = template.indexOf('Deep content');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', contentPos);
+
+        // Verify innermost is "Deep" (word), outermost is the full template
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be word Deep').toBe('Deep');
+
+        // Verify chain depth: word → text → span → div → article → section → div → root
+        let depth = 0;
+        let range: ts.SelectionRange | undefined = selectionRange;
+        while (range) {
+          depth++;
+          range = range.parent;
+        }
+        expect(depth)
+          .withContext('Should have at least 5 levels for deep nesting')
+          .toBeGreaterThanOrEqual(5);
+      });
+    });
+
+    describe('mixed content', () => {
+      it('should handle elements with mixed text, interpolation and elements', () => {
+        verifySelectionRanges(
+          env,
+          '<p>Hello <strong>{{user.name}}</strong>, welcome to <em>{{siteName}}</em>!</p>',
+          `user = {name: 'John'};
+        siteName = 'My App';`,
+          [
+            {
+              label: 'cursor on user in user.name',
+              cursorAt: 'user.name',
+              chain: [
+                'user',
+                'user.name',
+                '{{user.name}}',
+                '<strong>{{user.name}}</strong>',
+                'Hello <strong>{{user.name}}</strong>, welcome to <em>{{siteName}}</em>!',
+                '<p>Hello <strong>{{user.name}}</strong>, welcome to <em>{{siteName}}</em>!</p>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('component inputs with complex expressions', () => {
+      it('should handle input with function call returning object', () => {
+        verifySelectionRanges(
+          env,
+          '<app-config [settings]="getSettings({theme: currentTheme, locale: userLocale})"></app-config>',
+          `currentTheme = 'dark';
+        userLocale = 'en-US';
+        getSettings(opts: any) { return opts; }`,
+          [
+            {
+              label: 'cursor on currentTheme',
+              cursorAt: 'currentTheme',
+              chain: [
+                'currentTheme',
+                '{theme: currentTheme, locale: userLocale}',
+                'getSettings({theme: currentTheme, locale: userLocale})',
+                '[settings]="getSettings({theme: currentTheme, locale: userLocale})"',
+                '<app-config [settings]="getSettings({theme: currentTheme, locale: userLocale})"></app-config>',
+              ],
+            },
+          ],
+        );
+      });
+    });
+
+    describe('event handlers with complex expressions', () => {
+      it('should handle event with ternary and method call', () => {
+        verifySelectionRanges(
+          env,
+          '<button (click)="isEnabled ? handleClick($event, item.id) : noOp()">Action</button>',
+          `isEnabled = true;
+        item = {id: 1};
+        handleClick(event: Event, id: number) {}
+        noOp() {}`,
+          [
+            {
+              label: 'cursor on handleClick',
+              cursorAt: 'handleClick',
+              chain: [
+                'handleClick',
+                'handleClick($event, item.id)',
+                'isEnabled ? handleClick($event, item.id) : noOp()',
+                '(click)="isEnabled ? handleClick($event, item.id) : noOp()"',
+                '<button (click)="isEnabled ? handleClick($event, item.id) : noOp()">Action</button>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle event with arrow function', () => {
+        const files = {
+          'app.html':
+            '<div *ngFor="let item of items"><button (click)="remove(item)">Remove</button></div>',
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              items = [1, 2, 3];
+              remove(item: number) { this.items = this.items.filter(i => i !== item); }
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "remove" in (click)="remove(item)"
+        const removePos = template.indexOf('remove(item)');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', removePos);
+
+        // remove → remove(item) → click key → event binding → element → children → outer div
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be remove').toBe('remove');
+      });
+    });
+
+    describe('ICU messages', () => {
+      it('should handle basic plural ICU message', () => {
+        const files = {
+          'app.html':
+            '<span i18n>{count, plural, =0 {no items} =1 {one item} other {{{count}} items}}</span>',
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              count = 5;
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "items" text in the "other" case
+        const itemsPos = template.indexOf('}} items}') + 3;
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', itemsPos);
+
+        // ICU messages have complex structure - verify we get a selection
+        expect(selectionRange)
+          .withContext('Selection range should be defined for ICU content')
+          .toBeDefined();
+      });
+
+      it('should expand within ICU variable expression', () => {
+        const files = {
+          'app.html':
+            '<span i18n>{count, plural, =0 {none} =1 {one} other {many}}</span><p>Count: {{count}}</p>',
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              count = 5;
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "count" in the regular interpolation {{count}}
+        const countPos = template.indexOf('{{count}}') + 2;
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', countPos);
+
+        // count → {{count}} → Count: {{count}} text → <p>Count: {{count}}</p> → siblings → root
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be count').toBe('count');
+      });
+
+      it('should handle select ICU message', () => {
+        const files = {
+          'app.html': '<span i18n>{gender, select, male {He} female {She} other {They}}</span>',
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {
+              gender = 'male';
+            }
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "She" in the female case
+        const shePos = template.indexOf('She');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', shePos);
+
+        // ICU select messages - verify selection exists
+        expect(selectionRange)
+          .withContext('Selection range should be defined for ICU select')
+          .toBeDefined();
+      });
+    });
+
+    describe('edge cases', () => {
+      it('should handle empty element', () => {
+        const files = {
+          'app.html': '<div></div>',
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {}
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position inside empty div (offset 4 is between > and <)
+        const pos = 4;
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', pos);
+
+        // Position 4 is at the start of </div> - cursor should snap to the empty element
+        // For an empty element, we might get just the element span or undefined
+        if (selectionRange) {
+          const text = template.substring(
+            selectionRange.textSpan.start,
+            selectionRange.textSpan.start + selectionRange.textSpan.length,
+          );
+          expect(text).withContext('If range exists, should be the element').toContain('div');
+        }
+      });
+
+      it('should handle self-closing element', () => {
+        verifySelectionRanges(env, '<input type="text" [value]="name" />', `name = '';`, [
+          {
+            label: 'cursor on name in [value]',
+            cursorAt: 'name',
+            chain: [
+              'name',
+              '[value]="name"',
+              'type="text" [value]="name"',
+              '<input type="text" [value]="name" />',
+            ],
+          },
+        ]);
+      });
+
+      it('should handle multiple interpolations in single text node', () => {
+        verifySelectionRanges(
+          env,
+          '<span>{{a}} + {{b}} = {{a + b}}</span>',
+          `a = 1;
+        b = 2;`,
+          [
+            {
+              label: 'cursor on first a in {{a}}',
+              cursorAt: '{{a}}',
+              offset: 2,
+              chain: ['a', '{{a}} + {{b}} = {{a + b}}', '<span>{{a}} + {{b}} = {{a + b}}</span>'],
+            },
+          ],
+        );
+      });
+
+      it('should handle whitespace-only text nodes', () => {
+        const files = {
+          'app.html': `<div>
+            <span>Content</span>
+          </div>`,
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {}
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        const template = files['app.html'];
+        // Position on "Content" inside <span>
+        const contentPos = template.indexOf('Content');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', contentPos);
+
+        // Content → <span>Content</span> → children (whitespace text nodes are siblings) → <div>
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be Content').toBe('Content');
+      });
+
+      it('should handle attribute with empty value', () => {
+        verifySelectionRanges(env, '<input disabled="">', ``, [
+          {
+            label: 'cursor on disabled',
+            cursorAt: 'disabled',
+            chain: ['disabled', 'disabled=""', '<input disabled="">'],
+          },
+        ]);
+      });
+    });
+
+    describe('element content selection bug', () => {
+      it('should NOT include part of opening tag when selecting content', () => {
+        // Bug reproduction: selecting text inside element content should expand to:
+        // text → element containing text → children grouped → full element
+        // NOT: text → partial opening tag + content
+        verifySelectionRanges(
+          env,
+          '<div data-test-id="test1" style="border: 1px solid"><strong>BLUE text</strong><br>More content</div>',
+          ``,
+          [
+            {
+              label: 'cursor on BLUE',
+              cursorAt: 'BLUE',
+              chain: [
+                'BLUE', // Word at cursor
+                'BLUE text', // Text node (line is same, deduplicated)
+                '<strong>BLUE text</strong>', // Strong element
+                '<strong>BLUE text</strong><br>More content', // Siblings grouped
+                '<div data-test-id="test1" style="border: 1px solid"><strong>BLUE text</strong><br>More content</div>', // Full element
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should handle complex element with many attributes and bound properties', () => {
+        // Complex template similar to user's bug report — many attributes + NgStyle
+        const template = `<div data-test-id="test1" myDirectiveA [style.backgroundColor]="'rgb(0, 0, 255)'" [style.color]="'rgb(255, 255, 0)'" [ngStyle]="{'border': '5px solid green'}" [style]="{'padding': '20px', 'margin': '10px'}" style="border: 1px 2px 3px var(--help);"><strong>TEST 1: Template</strong><br>Expected: BLUE background<br>Actual: This should be BLUE with YELLOW text</div>`;
+        verifySelectionRanges(
+          env,
+          template,
+          '',
+          [
+            {
+              label: 'cursor on should in text content (not in attributes)',
+              cursorAt: 'should be BLUE',
+              chain: [
+                'should',
+                'Actual: This should be BLUE with YELLOW text',
+                '<strong>TEST 1: Template</strong><br>Expected: BLUE background<br>Actual: This should be BLUE with YELLOW text',
+                template,
+              ],
+            },
+          ],
+          {imports: ['NgStyle']},
+        );
+      });
+
+      it('should handle multiline template similar to user bug report', () => {
+        // Template with newlines — similar to the user's actual template
+        const template = `<div data-test-id="test1" myDirectiveA 
+[style.backgroundColor]="'rgb(0, 0, 255)'" 
+[style.color]="'rgb(255, 255, 0)'" 
+[ngStyle]="{'border': '5px solid green'}" 
+[style]="{'padding': '20px', 'margin': '10px'}" 
+style="border: 1px 2px 3px var(--help);">
+<strong>TEST 1: Template [style.backgroundColor]</strong><br>
+Expected: BLUE background rgb(0, 0, 255)<br>
+Expected: YELLOW text rgb(255, 255, 0)<br>
+Actual: This should be BLUE with YELLOW text ← TEMPLATE WINS
+</div>`;
+
+        verifySelectionRanges(
+          env,
+          template,
+          '',
+          [
+            {
+              label: 'cursor on should in multiline text content',
+              cursorAt: 'should be BLUE',
+              chain: [
+                'should',
+                'Actual: This should be BLUE with YELLOW text ← TEMPLATE WINS',
+                '\nActual: This should be BLUE with YELLOW text ← TEMPLATE WINS\n',
+                '\n<strong>TEST 1: Template [style.backgroundColor]</strong><br>\nExpected: BLUE background rgb(0, 0, 255)<br>\nExpected: YELLOW text rgb(255, 255, 0)<br>\nActual: This should be BLUE with YELLOW text ← TEMPLATE WINS\n',
+                template,
+              ],
+            },
+          ],
+          {imports: ['NgStyle']},
+        );
+      });
+    });
+
+    describe('inline style and class attributes', () => {
+      // NOTE: Granular CSS selection (individual properties, values) is handled by
+      // CSS LSP delegation at the VS Code server level, not in the core language service.
+      // These tests verify the core Angular AST selection behavior.
+
+      it('should select full style attribute value', () => {
+        verifySelectionRanges(env, '<div style="color: red; background: blue">Content</div>', ``, [
+          {
+            label: 'cursor on red in style value',
+            cursorAt: 'red',
+            chain: [
+              'color: red; background: blue', // Full style value (core LS)
+              'style="color: red; background: blue"', // Full attribute
+              '<div style="color: red; background: blue">Content</div>', // Full element
+            ],
+          },
+        ]);
+      });
+
+      it('should select full class attribute value', () => {
+        verifySelectionRanges(env, '<div class="foo bar baz">Content</div>', ``, [
+          {
+            label: 'cursor on bar in class value',
+            cursorAt: 'bar',
+            chain: [
+              'foo bar baz', // Full class value (core LS)
+              'class="foo bar baz"', // Full attribute
+              '<div class="foo bar baz">Content</div>', // Full element
+            ],
+          },
+        ]);
+      });
+    });
+
+    describe('nested plain elements', () => {
+      it('should expand through nested divs when cursor is on style attribute', () => {
+        // Reproduces bug where expanding from style attribute skips parent elements
+        verifySelectionRanges(
+          env,
+          '<div style="padding: 20px;"><div style="margin: 10px;"><strong style="color: red;">TEXT</strong></div></div>',
+          ``,
+          [
+            {
+              label: 'cursor on color: red value',
+              cursorAt: 'color: red',
+              chain: [
+                'color: red;', // attribute value
+                'style="color: red;"', // full attribute
+                '<strong style="color: red;">TEXT</strong>', // strong element
+                '<div style="margin: 10px;"><strong style="color: red;">TEXT</strong></div>', // inner div
+                '<div style="padding: 20px;"><div style="margin: 10px;"><strong style="color: red;">TEXT</strong></div></div>', // outer div
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should not skip parent elements for deeply nested elements', () => {
+        verifySelectionRanges(
+          env,
+          '<div id="outer"><h2>Title</h2><div id="inner"><strong style="color: #080;">PASS</strong><br>Info text</div></div>',
+          ``,
+          [
+            {
+              label: 'cursor on PASS',
+              cursorAt: 'PASS',
+              chain: [
+                'PASS',
+                '<strong style="color: #080;">PASS</strong>',
+                '<strong style="color: #080;">PASS</strong><br>Info text',
+                '<div id="inner"><strong style="color: #080;">PASS</strong><br>Info text</div>',
+                '<h2>Title</h2><div id="inner"><strong style="color: #080;">PASS</strong><br>Info text</div>',
+                '<div id="outer"><h2>Title</h2><div id="inner"><strong style="color: #080;">PASS</strong><br>Info text</div></div>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should expand correctly from text content in multi-line element', () => {
+        // This reproduces the user's bug where expansion from text content inside
+        // a multi-line element incorrectly starts at the last attribute instead of <div>
+        const template = `<div 
+      data-test-id="test1"
+      style="border: 1px solid;">
+      <strong>TEST 1</strong><br>
+      Expected: YELLOW text
+    </div>`;
+        const files = {
+          'app.html': template,
+          'app.ts': `
+            import {Component} from '@angular/core';
+
+            @Component({
+              selector: 'my-app',
+              templateUrl: './app.html',
+            })
+            export class AppComponent {}
+          `,
+        };
+
+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);
+        // Position on "YELLOW" text (inside the element content)
+        const yellowPos = template.indexOf('YELLOW');
+
+        const selectionRange = project.getSelectionRangeAtPosition('app.html', yellowPos);
+
+        // YELLOW (word) → line → text node → content span → full element
+        expect(selectionRange).withContext('Selection range should be defined').toBeDefined();
+        if (!selectionRange) return;
+
+        const innermostText = template.substring(
+          selectionRange.textSpan.start,
+          selectionRange.textSpan.start + selectionRange.textSpan.length,
+        );
+        expect(innermostText).withContext('Innermost should be word YELLOW').toBe('YELLOW');
+
+        // Verify outermost reaches the full element starting with <div
+        let outermost = selectionRange;
+        while (outermost.parent) outermost = outermost.parent;
+        const outermostText = template.substring(
+          outermost.textSpan.start,
+          outermost.textSpan.start + outermost.textSpan.length,
+        );
+        expect(outermostText.startsWith('<div'))
+          .withContext(
+            `Outermost should start with '<div', got: "${outermostText.substring(0, 50)}"`,
+          )
+          .toBe(true);
+        expect(outermostText.endsWith('</div>'))
+          .withContext(`Outermost should end with '</div>'`)
+          .toBe(true);
+      });
+    });
+
+    describe('user expectation tests', () => {
+      it('should expand from property in simple interpolation to full element', () => {
+        verifySelectionRanges(env, `<h1>{{ title }}</h1>`, `title = 'Hello';`, [
+          {
+            label: 'cursor on title',
+            cursorAt: 'title',
+            chain: ['title', '{{ title }}', '<h1>{{ title }}</h1>'],
+          },
+        ]);
+      });
+
+      it('should expand from signal call through interpolation', () => {
+        verifySelectionRanges(env, `<p>Count: {{ count() }}</p>`, `count = signal(0);`, [
+          {
+            label: 'cursor on count',
+            cursorAt: 'count',
+            chain: [
+              'count',
+              'count()',
+              // Implementation includes full text content (text + interpolation)
+              'Count: {{ count() }}',
+              '<p>Count: {{ count() }}</p>',
+            ],
+          },
+        ]);
+      });
+
+      it('should expand from property in event handler', () => {
+        verifySelectionRanges(env, `<button (click)="onClick()">Go</button>`, `onClick() {}`, [
+          {
+            label: 'cursor on onClick',
+            cursorAt: 'onClick',
+            chain: [
+              'onClick',
+              'onClick()',
+              '(click)="onClick()"',
+              '<button (click)="onClick()">Go</button>',
+            ],
+          },
+        ]);
+      });
+
+      it('should expand through nested property access', () => {
+        verifySelectionRanges(
+          env,
+          `<span>{{ user.address.city }}</span>`,
+          `user = {address: {city: 'NYC'}};`,
+          [
+            {
+              label: 'cursor on city (deepest property)',
+              cursorAt: 'city',
+              chain: [
+                // Only the innermost node containing cursor is included
+                'user.address.city',
+                '{{ user.address.city }}',
+                '<span>{{ user.address.city }}</span>',
+              ],
+            },
+            {
+              label: 'cursor on address (middle property)',
+              cursorAt: 'address',
+              chain: [
+                // cursor on address: user.address contains cursor, then outer
+                'user.address',
+                'user.address.city',
+                '{{ user.address.city }}',
+                '<span>{{ user.address.city }}</span>',
+              ],
+            },
+            {
+              label: 'cursor on user (root property)',
+              cursorAt: 'user',
+              chain: [
+                'user',
+                'user.address',
+                'user.address.city',
+                '{{ user.address.city }}',
+                '<span>{{ user.address.city }}</span>',
+              ],
+            },
+          ],
+        );
+      });
+
+      it('should expand from bound attribute value to full attribute to element', () => {
+        verifySelectionRanges(env, `<div [class]="classes"></div>`, `classes = 'active';`, [
+          {
+            label: 'cursor on classes',
+            cursorAt: 'classes',
+            chain: ['classes', '[class]="classes"', '<div [class]="classes"></div>'],
+          },
+        ]);
+      });
+
+      it('should expand from text content through parent elements', () => {
+        const template = `<main>\n  <section>\n    <p>Hello World</p>\n  </section>\n</main>`;
+        // Use verifySelectionRanges to test BOTH external (.html) and inline (backtick) templates
+        verifySelectionRanges(env, template, ``, [
+          {
+            label: 'cursor on Hello in nested multiline',
+            cursorAt: 'Hello',
+            chain: [
+              'Hello',
+              'Hello World',
+              '<p>Hello World</p>',
+              '\n    <p>Hello World</p>\n  ',
+              '<section>\n    <p>Hello World</p>\n  </section>',
+              '\n  <section>\n    <p>Hello World</p>\n  </section>\n',
+              '<main>\n  <section>\n    <p>Hello World</p>\n  </section>\n</main>',
+            ],
+          },
+        ]);
+      });
+
+      it('should handle multiline template with interpolation in inline mode', () => {
+        verifySelectionRanges(env, `<div>\n  <span>{{ value }}</span>\n</div>`, `value = 42;`, [
+          {
+            label: 'cursor on value in multiline template',
+            cursorAt: 'value',
+            chain: [
+              'value',
+              '{{ value }}',
+              '<span>{{ value }}</span>',
+              '\n  <span>{{ value }}</span>\n',
+              '<div>\n  <span>{{ value }}</span>\n</div>',
+            ],
+          },
+        ]);
+      });
+    });
+  });
+
+  describe('preserveWhitespaces', () => {
+    it('should produce identical chain for compact templates regardless of preserveWhitespaces', () => {
+      // For compact single-line templates, preserveWhitespaces has no effect
+      verifySelectionRanges(
+        env,
+        `<div><span>text</span></div>`,
+        ``,
+        [
+          {
+            label: 'compact template with preserveWhitespaces',
+            cursorAt: 'text',
+            chain: ['text', '<span>text</span>', '<div><span>text</span></div>'],
+          },
+        ],
+        {preserveWhitespaces: true},
+      );
+    });
+
+    it('should include whitespace text nodes as siblings when preserveWhitespaces is true', () => {
+      // With preserveWhitespaces: true, the newlines/indentation become Text nodes,
+      // which affects the sibling span (all children grouped together).
+      const template = `<div>\n  <span>content</span>\n</div>`;
+      verifySelectionRanges(
+        env,
+        template,
+        ``,
+        [
+          {
+            label: 'whitespace-preserved multiline',
+            cursorAt: 'content',
+            chain: [
+              'content',
+              '<span>content</span>',
+              '\n  <span>content</span>\n',
+              '<div>\n  <span>content</span>\n</div>',
+            ],
+          },
+        ],
+        {preserveWhitespaces: true},
+      );
+    });
+
+    it('should handle interpolation in whitespace-preserved template', () => {
+      // With preserveWhitespaces, the interpolation is embedded in a larger text block
+      // that includes surrounding whitespace, so {{ name }} is not a separate step.
+      const template = `<div>\n  {{ name }}\n</div>`;
+      verifySelectionRanges(
+        env,
+        template,
+        `name = 'test';`,
+        [
+          {
+            label: 'interpolation with preserved whitespace',
+            cursorAt: 'name',
+            chain: ['name', '\n  {{ name }}\n', '<div>\n  {{ name }}\n</div>'],
+          },
+        ],
+        {preserveWhitespaces: true},
+      );
+    });
+  });
+});
diff --git a/packages/language-service/testing/src/project.ts b/packages/language-service/testing/src/project.ts
index 41b3d9660bb6..2ea6a69001f4 100644
--- a/packages/language-service/testing/src/project.ts
+++ b/packages/language-service/testing/src/project.ts
@@ -302,6 +302,14 @@ export class Project {
     const fileName = absoluteFrom(`/${this.name}/${projectFileName}`);
     return [...this.ngLS.getSemanticDiagnostics(fileName)];
   }
+
+  getSelectionRangeAtPosition(
+    projectFileName: string,
+    position: number,
+  ): ts.SelectionRange | undefined {
+    const fileName = absoluteFrom(`/${this.name}/${projectFileName}`);
+    return this.ngLS.getSelectionRangeAtPosition(fileName, position);
+  }
 }
 
 function getClassOrError(sf: ts.SourceFile, name: string): ts.ClassDeclaration {
diff --git a/vscode-ng-language-service/client/src/client.ts b/vscode-ng-language-service/client/src/client.ts
index 32aaab9cc62d..72e5d11aad42 100644
--- a/vscode-ng-language-service/client/src/client.ts
+++ b/vscode-ng-language-service/client/src/client.ts
@@ -254,6 +254,28 @@ export class AngularLanguageClient implements vscode.Disposable {
             return next(document, position, token);
           }
         },
+        provideSelectionRanges: async (
+          document: vscode.TextDocument,
+          positions: readonly vscode.Position[],
+          token: vscode.CancellationToken,
+          next: lsp.ProvideSelectionRangeSignature,
+        ) => {
+          if (!(await this.isInAngularProject(document))) {
+            return;
+          }
+          // For TypeScript files, only provide selection ranges when cursor is
+          // inside an Angular decorator field (e.g., inline template).
+          // For HTML files, always provide selection ranges.
+          if (document.languageId === 'typescript') {
+            const anyPositionInTemplate = positions.some((pos) =>
+              isNotTypescriptOrSupportedDecoratorField(document, pos),
+            );
+            if (!anyPositionInTemplate) {
+              return;
+            }
+          }
+          return next(document, positions, token);
+        },
       },
     };
   }
diff --git a/vscode-ng-language-service/server/src/handlers/initialization.ts b/vscode-ng-language-service/server/src/handlers/initialization.ts
index 133944a53afd..a6461ae32f89 100644
--- a/vscode-ng-language-service/server/src/handlers/initialization.ts
+++ b/vscode-ng-language-service/server/src/handlers/initialization.ts
@@ -19,6 +19,7 @@ export function onInitialize(session: Session, params: lsp.InitializeParams): ls
   return {
     capabilities: {
       foldingRangeProvider: true,
+      selectionRangeProvider: true,
       codeLensProvider: {resolveProvider: true},
       textDocumentSync: lsp.TextDocumentSyncKind.Incremental,
       completionProvider: {
diff --git a/vscode-ng-language-service/server/src/handlers/selection_range.ts b/vscode-ng-language-service/server/src/handlers/selection_range.ts
new file mode 100644
index 000000000000..0a7a61bf48b2
--- /dev/null
+++ b/vscode-ng-language-service/server/src/handlers/selection_range.ts
@@ -0,0 +1,70 @@
+/*!
+ * @license
+ * Copyright Google LLC All Rights Reserved.
+ *
+ * Use of this source code is governed by an MIT-style license that can be
+ * found in the LICENSE file at https://angular.dev/license
+ */
+import * as lsp from 'vscode-languageserver';
+
+import {Session} from '../session';
+import {lspPositionToTsPosition, tsTextSpanToLspRange} from '../utils';
+
+/**
+ * Handle the `textDocument/selectionRange` LSP request.
+ *
+ * Selection ranges provide smart selection expansion: select text → expand to element →
+ * expand to parent → expand to block.
+ */
+export function onSelectionRange(
+  session: Session,
+  params: lsp.SelectionRangeParams,
+): lsp.SelectionRange[] | null {
+  const lsInfo = session.getLSAndScriptInfo(params.textDocument);
+  if (lsInfo === null) {
+    return null;
+  }
+
+  const {languageService, scriptInfo} = lsInfo;
+  const results: lsp.SelectionRange[] = [];
+
+  for (const position of params.positions) {
+    const offset = lspPositionToTsPosition(scriptInfo, position);
+    const selectionRange = languageService.getSelectionRangeAtPosition(scriptInfo.fileName, offset);
+
+    if (selectionRange) {
+      const lspRange = convertSelectionRange(selectionRange, scriptInfo);
+      if (lspRange) {
+        results.push(lspRange);
+      }
+    }
+  }
+
+  return results.length > 0 ? results : null;
+}
+
+/**
+ * Convert a TypeScript SelectionRange to an LSP SelectionRange.
+ */
+function convertSelectionRange(
+  tsRange: {
+    textSpan: {start: number; length: number};
+    parent?: {textSpan: {start: number; length: number}; parent?: any};
+  },
+  scriptInfo: any,
+): lsp.SelectionRange | undefined {
+  const range = tsTextSpanToLspRange(scriptInfo, tsRange.textSpan);
+  if (!range) {
+    return undefined;
+  }
+
+  let parent: lsp.SelectionRange | undefined;
+  if (tsRange.parent) {
+    parent = convertSelectionRange(tsRange.parent, scriptInfo);
+  }
+
+  return {
+    range,
+    parent,
+  };
+}
diff --git a/vscode-ng-language-service/server/src/session.ts b/vscode-ng-language-service/server/src/session.ts
index 6374e718abd3..0cb15f599d60 100644
--- a/vscode-ng-language-service/server/src/session.ts
+++ b/vscode-ng-language-service/server/src/session.ts
@@ -43,6 +43,7 @@ import {onHover} from './handlers/hover';
 import {onInitialize} from './handlers/initialization';
 import {onLinkedEditingRange} from './handlers/linked_editing_range';
 import {onRenameRequest, onPrepareRename} from './handlers/rename';
+import {onSelectionRange} from './handlers/selection_range';
 import {onSignatureHelp} from './handlers/signature';
 import {onGetTcb} from './handlers/tcb';
 import {onGetTemplateLocationForComponent, isInAngularProject} from './handlers/template_info';
@@ -238,6 +239,7 @@ export class Session {
     conn.onHover((p) => onHover(this, p));
     conn.onFoldingRanges((p) => onFoldingRanges(this, p));
     conn.languages.onLinkedEditingRange((p) => onLinkedEditingRange(this, p));
+    conn.onSelectionRanges((p) => onSelectionRange(this, p));
     conn.onCompletion((p) => onCompletion(this, p));
     conn.onCompletionResolve((p) => onCompletionResolve(this, p));
     conn.onRequest(GetComponentsWithTemplateFile, (p) => getComponentsWithTemplateFile(this, p));
