## API Report File for "@angular/localize_tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbsoluteFsPath } from '@angular/compiler-cli/private/localize';
import { Element as Element_2 } from '@angular/compiler';
import { Logger } from '@angular/compiler-cli/private/localize';
import { MessageId } from '../../../../../index';
import { NodePath } from '@babel/core';
import { ParseError } from '@angular/compiler';
import { PathManipulation } from '@angular/compiler-cli/private/localize';
import { PluginObj } from '@babel/core';
import { ReadonlyFileSystem } from '@angular/compiler-cli/private/localize';
import { types } from '@babel/core';
import { ɵParsedMessage } from '../../../index';
import { ɵParsedMessage as ɵParsedMessage_2 } from '../../../../index';
import { ɵParsedTranslation } from '../../index';
import { ɵParsedTranslation as ɵParsedTranslation_2 } from '../../../../index';
import { ɵParsedTranslation as ɵParsedTranslation_3 } from '../../../../../index';
import { ɵSourceLocation } from '../../index';
import { ɵSourceMessage } from '../../../../../index';

// @public
export class ArbTranslationParser implements TranslationParser<ArbJsonObject> {
    // (undocumented)
    analyze(_filePath: string, contents: string): ParseAnalysis<ArbJsonObject>;
    // (undocumented)
    parse(_filePath: string, contents: string, arb?: ArbJsonObject): ParsedTranslationBundle;
}

// @public
export class ArbTranslationSerializer implements TranslationSerializer {
    constructor(sourceLocale: string, basePath: AbsoluteFsPath, fs: PathManipulation);
    // (undocumented)
    serialize(messages: ɵParsedMessage_2[]): string;
}

// @public
export function buildLocalizeReplacement(messageParts: TemplateStringsArray, substitutions: readonly types.Expression[]): types.Expression;

// @public
export function checkDuplicateMessages(fs: PathManipulation, messages: ɵParsedMessage[], duplicateMessageHandling: DiagnosticHandlingStrategy, basePath: AbsoluteFsPath): Diagnostics;

// @public
export type DiagnosticHandlingStrategy = 'error' | 'warning' | 'ignore';

// @public
export class Diagnostics {
    // (undocumented)
    add(type: DiagnosticHandlingStrategy, message: string): void;
    // (undocumented)
    error(message: string): void;
    // (undocumented)
    formatDiagnostics(message: string): string;
    // (undocumented)
    get hasErrors(): boolean;
    // (undocumented)
    merge(other: Diagnostics): void;
    // (undocumented)
    readonly messages: {
        type: 'warning' | 'error';
        message: string;
    }[];
    // (undocumented)
    warn(message: string): void;
}

// @public
export function isGlobalIdentifier(identifier: NodePath<types.Identifier>): boolean;

// @public
export class LegacyMessageIdMigrationSerializer implements TranslationSerializer {
    constructor(_diagnostics: Diagnostics);
    // (undocumented)
    serialize(messages: ɵParsedMessage_2[]): string;
}

// @public
export function makeEs2015TranslatePlugin(diagnostics: Diagnostics, translations: Record<string, ɵParsedTranslation_2>, input?: TranslatePluginOptions, fs?: PathManipulation): PluginObj;

// @public
export function makeEs5TranslatePlugin(diagnostics: Diagnostics, translations: Record<string, ɵParsedTranslation_2>, input?: TranslatePluginOptions, fs?: PathManipulation): PluginObj;

// @public
export function makeLocalePlugin(locale: string, input?: TranslatePluginOptions): PluginObj;

// @public
export class MessageExtractor {
    constructor(fs: ReadonlyFileSystem, logger: Logger, input: ExtractionOptions);
    // (undocumented)
    extractMessages(filename: string): ɵParsedMessage[];
}

// @public
export class SimpleJsonTranslationParser implements TranslationParser<SimpleJsonFile> {
    // (undocumented)
    analyze(filePath: string, contents: string): ParseAnalysis<SimpleJsonFile>;
    // (undocumented)
    parse(_filePath: string, contents: string, json?: SimpleJsonFile): ParsedTranslationBundle;
}

// @public
export class SimpleJsonTranslationSerializer implements TranslationSerializer {
    constructor(sourceLocale: string);
    // (undocumented)
    serialize(messages: ɵParsedMessage_2[]): string;
}

// @public
export function translate(diagnostics: Diagnostics, translations: Record<string, ɵParsedTranslation>, messageParts: TemplateStringsArray, substitutions: readonly any[], missingTranslation: DiagnosticHandlingStrategy): [TemplateStringsArray, readonly any[]];

// @public
export function unwrapExpressionsFromTemplateLiteral(quasi: NodePath<types.TemplateLiteral>, fs?: PathManipulation): [types.Expression[], (ɵSourceLocation | undefined)[]];

// @public
export function unwrapMessagePartsFromLocalizeCall(call: NodePath<types.CallExpression>, fs?: PathManipulation): [TemplateStringsArray, (ɵSourceLocation | undefined)[]];

// @public
export function unwrapMessagePartsFromTemplateLiteral(elements: NodePath<types.TemplateElement>[], fs?: PathManipulation): [TemplateStringsArray, (ɵSourceLocation | undefined)[]];

// @public
export function unwrapSubstitutionsFromLocalizeCall(call: NodePath<types.CallExpression>, fs?: PathManipulation): [types.Expression[], (ɵSourceLocation | undefined)[]];

// @public
export class Xliff1TranslationParser implements TranslationParser<XmlTranslationParserHint> {
    // (undocumented)
    analyze(filePath: string, contents: string): ParseAnalysis<XmlTranslationParserHint>;
    // (undocumented)
    parse(filePath: string, contents: string, hint: XmlTranslationParserHint): ParsedTranslationBundle;
}

// @public
export class Xliff1TranslationSerializer implements TranslationSerializer {
    constructor(sourceLocale: string, basePath: AbsoluteFsPath, useLegacyIds: boolean, formatOptions?: FormatOptions, fs?: PathManipulation);
    // (undocumented)
    serialize(messages: ɵParsedMessage_2[]): string;
}

// @public
export class Xliff2TranslationParser implements TranslationParser<XmlTranslationParserHint> {
    // (undocumented)
    analyze(filePath: string, contents: string): ParseAnalysis<XmlTranslationParserHint>;
    // (undocumented)
    parse(filePath: string, contents: string, hint: XmlTranslationParserHint): ParsedTranslationBundle;
}

// @public
export class Xliff2TranslationSerializer implements TranslationSerializer {
    constructor(sourceLocale: string, basePath: AbsoluteFsPath, useLegacyIds: boolean, formatOptions?: FormatOptions, fs?: PathManipulation);
    // (undocumented)
    serialize(messages: ɵParsedMessage_2[]): string;
}

// @public
export class XmbTranslationSerializer implements TranslationSerializer {
    constructor(basePath: AbsoluteFsPath, useLegacyIds: boolean, fs?: PathManipulation);
    // (undocumented)
    serialize(messages: ɵParsedMessage_2[]): string;
}

// @public
export class XtbTranslationParser implements TranslationParser<XmlTranslationParserHint> {
    // (undocumented)
    analyze(filePath: string, contents: string): ParseAnalysis<XmlTranslationParserHint>;
    // (undocumented)
    parse(filePath: string, contents: string, hint: XmlTranslationParserHint): ParsedTranslationBundle;
}

// (No @packageDocumentation comment for this package)

```
