## API Report File for "@angular/forms_signals"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import { ControlValueAccessor } from '@angular/forms';
import { DestroyableInjector } from '@angular/core';
import { FormControlStatus } from '@angular/forms';
import { HttpResourceOptions } from '@angular/common/http';
import { HttpResourceRequest } from '@angular/common/http';
import * as i0 from '@angular/core';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { InputSignal } from '@angular/core';
import { ModelSignal } from '@angular/core';
import { NgControl } from '@angular/forms';
import { OutputRef } from '@angular/core';
import { ResourceRef } from '@angular/core';
import { Signal } from '@angular/core';
import { StandardSchemaV1 } from '@standard-schema/spec';
import { ValidationErrors } from '@angular/forms';
import { ValidatorFn } from '@angular/forms';
import { WritableSignal } from '@angular/core';
import { ɵCONTROL } from '@angular/core';
import { ɵControl } from '@angular/core';
import { ɵFieldState } from '@angular/core';

// @public
export function aggregateMetadata<TValue, TMetadataItem, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, key: AggregateMetadataKey<any, TMetadataItem>, logic: NoInfer<LogicFn<TValue, TMetadataItem, TPathKind>>): void;

// @public
export class AggregateMetadataKey<TAcc, TItem> {
    // (undocumented)
    readonly getInitial: () => TAcc;
    // (undocumented)
    readonly reduce: (acc: TAcc, item: TItem) => TAcc;
}

// @public
export function andMetadataKey(): AggregateMetadataKey<boolean, boolean>;

// @public
export function apply<TValue>(path: FieldPath<TValue>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyEach<TValue>(path: FieldPath<TValue[]>, schema: NoInfer<SchemaOrSchemaFn<TValue, PathKind.Item>>): void;

// @public
export function applyWhen<TValue>(path: FieldPath<TValue>, logic: LogicFn<TValue, boolean>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyWhenValue<TValue, TNarrowed extends TValue>(path: FieldPath<TValue>, predicate: (value: TValue) => value is TNarrowed, schema: SchemaOrSchemaFn<TNarrowed>): void;

// @public
export function applyWhenValue<TValue>(path: FieldPath<TValue>, predicate: (value: TValue) => boolean, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export type AsyncValidationResult<E extends ValidationError = ValidationError> = ValidationResult<E> | 'pending';

// @public
export interface AsyncValidatorOptions<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly factory: (params: Signal<TParams | undefined>) => ResourceRef<TResult | undefined>;
    readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;
    readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly params: (ctx: FieldContext<TValue, TPathKind>) => TParams;
}

// @public
export interface ChildFieldContext<TValue> extends RootFieldContext<TValue> {
    readonly key: Signal<string>;
}

// @public
export function createMetadataKey<TValue>(): MetadataKey<TValue>;

// @public
export function customError<E extends Partial<ValidationErrorWithField>>(obj: WithField<E>): CustomValidationError;

// @public
export function customError<E extends Partial<ValidationErrorWithField>>(obj?: E): WithoutField<CustomValidationError>;

// @public
export class CustomValidationError implements ValidationError {
    constructor(options?: ValidationErrorOptions);
    [key: PropertyKey]: unknown;
    readonly field: FieldTree<unknown>;
    readonly kind: string;
    readonly message?: string;
}

// @public
export function disabled<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic?: string | NoInfer<LogicFn<TValue, boolean | string, TPathKind>>): void;

// @public
export interface DisabledReason {
    readonly field: FieldTree<unknown>;
    readonly message?: string;
}

// @public
export function email<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<string, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export function emailError(options: WithField<ValidationErrorOptions>): EmailValidationError;

// @public
export function emailError(options?: ValidationErrorOptions): WithoutField<EmailValidationError>;

// @public
export class EmailValidationError extends _NgValidationError {
    // (undocumented)
    readonly kind = "email";
}

// @public
export const FIELD: InjectionToken<Field<unknown>>;

// @public
export class Field<T> implements ɵControl<T> {
    // (undocumented)
    readonly [ɵCONTROL]: undefined;
    // (undocumented)
    readonly field: i0.InputSignal<FieldTree<T>>;
    // (undocumented)
    readonly state: i0.Signal<FieldState<T, string | number>>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<Field<any>, "[field]", never, { "field": { "alias": "field"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<Field<any>, never>;
    ɵgetOrCreateNgControl(): InteropNgControl;
    // (undocumented)
    get ɵhasInteropControl(): boolean;
    // (undocumented)
    ɵinteropControlCreate(): void;
    // (undocumented)
    ɵinteropControlUpdate(): void;
    // (undocumented)
    ɵregister(): void;
}

// @public
export type FieldContext<TValue, TPathKind extends PathKind = PathKind.Root> = TPathKind extends PathKind.Item ? ItemFieldContext<TValue> : TPathKind extends PathKind.Child ? ChildFieldContext<TValue> : RootFieldContext<TValue>;

// @public
export type FieldPath<TValue, TPathKind extends PathKind = PathKind.Root> = {
    [ɵɵTYPE]: [TValue, TPathKind];
} & (TValue extends Array<unknown> ? unknown : TValue extends Record<string, any> ? {
    [K in keyof TValue]: MaybeFieldPath<TValue[K], PathKind.Child>;
} : unknown);

// @public
export interface FieldState<TValue, TKey extends string | number = string | number> extends ɵFieldState<TValue> {
    readonly dirty: Signal<boolean>;
    // (undocumented)
    readonly disabledReasons: Signal<readonly DisabledReason[]>;
    // (undocumented)
    readonly errors: Signal<ValidationErrorWithField[]>;
    readonly errorSummary: Signal<ValidationErrorWithField[]>;
    readonly fieldBindings: Signal<readonly Field<unknown>[]>;
    hasMetadata(key: MetadataKey<any> | AggregateMetadataKey<any, any>): boolean;
    readonly hidden: Signal<boolean>;
    readonly invalid: Signal<boolean>;
    readonly keyInParent: Signal<TKey>;
    metadata<M>(key: AggregateMetadataKey<M, any>): Signal<M>;
    metadata<M>(key: MetadataKey<M>): M | undefined;
    readonly pending: Signal<boolean>;
    reset(): void;
    readonly submitting: Signal<boolean>;
    readonly valid: Signal<boolean>;
}

// @public
export type FieldTree<TValue, TKey extends string | number = string | number> = (() => FieldState<TValue, TKey>) & (TValue extends Array<infer U> ? ReadonlyArrayLike<MaybeFieldTree<U, number>> : TValue extends Record<string, any> ? Subfields<TValue> : unknown);

// @public
export type FieldValidator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, ValidationResult<ValidationErrorWithoutField>, TPathKind>;

// @public
export function form<TValue>(model: WritableSignal<TValue>): FieldTree<TValue>;

// @public
export function form<TValue>(model: WritableSignal<TValue>, schemaOrOptions: SchemaOrSchemaFn<TValue> | FormOptions): FieldTree<TValue>;

// @public
export function form<TValue>(model: WritableSignal<TValue>, schema: SchemaOrSchemaFn<TValue>, options: FormOptions): FieldTree<TValue>;

// @public
export interface FormCheckboxControl extends FormUiControl {
    readonly checked: ModelSignal<boolean>;
    readonly value?: undefined;
}

// @public
export interface FormOptions {
    adapter?: FieldAdapter;
    injector?: Injector;
    // (undocumented)
    name?: string;
}

// @public
export interface FormUiControl {
    readonly dirty?: InputSignal<boolean>;
    readonly disabled?: InputSignal<boolean>;
    readonly disabledReasons?: InputSignal<readonly WithOptionalField<DisabledReason>[]>;
    readonly errors?: InputSignal<readonly WithOptionalField<ValidationError>[]>;
    readonly hidden?: InputSignal<boolean>;
    readonly invalid?: InputSignal<boolean>;
    readonly max?: InputSignal<number | undefined>;
    readonly maxLength?: InputSignal<number | undefined>;
    readonly min?: InputSignal<number | undefined>;
    readonly minLength?: InputSignal<number | undefined>;
    readonly name?: InputSignal<string>;
    readonly pattern?: InputSignal<readonly RegExp[]>;
    readonly pending?: InputSignal<boolean>;
    readonly readonly?: InputSignal<boolean>;
    readonly required?: InputSignal<boolean>;
    readonly touched?: ModelSignal<boolean> | InputSignal<boolean> | OutputRef<boolean>;
}

// @public
export interface FormValueControl<TValue> extends FormUiControl {
    readonly checked?: undefined;
    readonly value: ModelSignal<TValue>;
}

// @public
export function hidden<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export interface HttpValidatorOptions<TValue, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;
    readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly options?: HttpResourceOptions<TResult, unknown>;
    readonly request: ((ctx: FieldContext<TValue, TPathKind>) => string | undefined) | ((ctx: FieldContext<TValue, TPathKind>) => HttpResourceRequest | undefined);
}

// @public
export type IgnoreUnknownProperties<T> = T extends Record<PropertyKey, unknown> ? {
    [K in keyof T as RemoveStringIndexUnknownKey<K, T[K]>]: IgnoreUnknownProperties<T[K]>;
} : T;

// @public
export interface ItemFieldContext<TValue> extends ChildFieldContext<TValue> {
    readonly index: Signal<number>;
}

// @public
export function listMetadataKey<TItem>(): AggregateMetadataKey<TItem[], TItem | undefined>;

// @public
export type LogicFn<TValue, TReturn, TPathKind extends PathKind = PathKind.Root> = (ctx: FieldContext<TValue, TPathKind>) => TReturn;

// @public
export type MapToErrorsFn<TValue, TResult, TPathKind extends PathKind = PathKind.Root> = (result: TResult, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;

// @public
export const MAX: AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export function max<TValue extends number | null, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, maxValue: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export const MAX_LENGTH: AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export function maxError(max: number, options: WithField<ValidationErrorOptions>): MaxValidationError;

// @public
export function maxError(max: number, options?: ValidationErrorOptions): WithoutField<MaxValidationError>;

// @public
export function maxLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, maxLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export function maxLengthError(maxLength: number, options: WithField<ValidationErrorOptions>): MaxLengthValidationError;

// @public
export function maxLengthError(maxLength: number, options?: ValidationErrorOptions): WithoutField<MaxLengthValidationError>;

// @public
export class MaxLengthValidationError extends _NgValidationError {
    constructor(maxLength: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "maxLength";
    // (undocumented)
    readonly maxLength: number;
}

// @public
export function maxMetadataKey(): AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export class MaxValidationError extends _NgValidationError {
    constructor(max: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "max";
    // (undocumented)
    readonly max: number;
}

// @public
export type MaybeFieldPath<TValue, TPathKind extends PathKind = PathKind.Root> = (TValue & undefined) | FieldPath<Exclude<TValue, undefined>, TPathKind>;

// @public
export type MaybeFieldTree<TValue, TKey extends string | number = string | number> = (TValue & undefined) | FieldTree<Exclude<TValue, undefined>, TKey>;

// @public
export function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, factory: (ctx: FieldContext<TValue, TPathKind>) => TData): MetadataKey<TData>;

// @public
export function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, key: MetadataKey<TData>, factory: (ctx: FieldContext<TValue, TPathKind>) => TData): MetadataKey<TData>;

// @public
export class MetadataKey<TValue> {
}

// @public
export const MIN: AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export function min<TValue extends number | null, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, minValue: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export const MIN_LENGTH: AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export function minError(min: number, options: WithField<ValidationErrorOptions>): MinValidationError;

// @public
export function minError(min: number, options?: ValidationErrorOptions): WithoutField<MinValidationError>;

// @public
export function minLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, minLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export function minLengthError(minLength: number, options: WithField<ValidationErrorOptions>): MinLengthValidationError;

// @public
export function minLengthError(minLength: number, options?: ValidationErrorOptions): WithoutField<MinLengthValidationError>;

// @public
export class MinLengthValidationError extends _NgValidationError {
    constructor(minLength: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "minLength";
    // (undocumented)
    readonly minLength: number;
}

// @public
export function minMetadataKey(): AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export class MinValidationError extends _NgValidationError {
    constructor(min: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "min";
    // (undocumented)
    readonly min: number;
}

// @public
export const NgValidationError: abstract new () => NgValidationError;

// @public (undocumented)
export type NgValidationError = RequiredValidationError | MinValidationError | MaxValidationError | MinLengthValidationError | MaxLengthValidationError | PatternValidationError | EmailValidationError | StandardSchemaValidationError;

// @public
export type OneOrMany<T> = T | readonly T[];

// @public
export function orMetadataKey(): AggregateMetadataKey<boolean, boolean>;

// @public
export type PathKind = PathKind.Root | PathKind.Child | PathKind.Item;

// @public (undocumented)
export namespace PathKind {
    export interface Child extends PathKind.Root {
        // (undocumented)
        [ɵɵTYPE]: 'child' | 'item';
    }
    export interface Item extends PathKind.Child {
        // (undocumented)
        [ɵɵTYPE]: 'item';
    }
    export interface Root {
        [ɵɵTYPE]: 'root' | 'child' | 'item';
    }
}

// @public
export const PATTERN: AggregateMetadataKey<RegExp[], RegExp | undefined>;

// @public
export function pattern<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<string, TPathKind>, pattern: RegExp | LogicFn<string | undefined, RegExp | undefined, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export function patternError(pattern: RegExp, options: WithField<ValidationErrorOptions>): PatternValidationError;

// @public
export function patternError(pattern: RegExp, options?: ValidationErrorOptions): WithoutField<PatternValidationError>;

// @public
export class PatternValidationError extends _NgValidationError {
    constructor(pattern: RegExp, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "pattern";
    // (undocumented)
    readonly pattern: RegExp;
}

// @public
export function readonly<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic?: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export type ReadonlyArrayLike<T> = Pick<ReadonlyArray<T>, number | 'length' | typeof Symbol.iterator>;

// @public
export function reducedMetadataKey<TAcc, TItem>(reduce: (acc: TAcc, item: TItem) => TAcc, getInitial: () => TAcc): AggregateMetadataKey<TAcc, TItem>;

// @public
export type RemoveStringIndexUnknownKey<K, V> = string extends K ? unknown extends V ? never : K : K;

// @public
export const REQUIRED: AggregateMetadataKey<boolean, boolean>;

// @public
export function required<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind> & {
    when?: NoInfer<LogicFn<TValue, boolean, TPathKind>>;
}): void;

// @public
export function requiredError(options: WithField<ValidationErrorOptions>): RequiredValidationError;

// @public
export function requiredError(options?: ValidationErrorOptions): WithoutField<RequiredValidationError>;

// @public
export class RequiredValidationError extends _NgValidationError {
    // (undocumented)
    readonly kind = "required";
}

// @public
export interface RootFieldContext<TValue> {
    readonly field: FieldTree<TValue>;
    readonly fieldOf: <P>(p: FieldPath<P>) => FieldTree<P>;
    readonly state: FieldState<TValue>;
    readonly stateOf: <P>(p: FieldPath<P>) => FieldState<P>;
    readonly value: Signal<TValue>;
    readonly valueOf: <P>(p: FieldPath<P>) => P;
}

// @public
export type Schema<in TValue> = {
    [ɵɵTYPE]: SchemaFn<TValue, PathKind.Root>;
};

// @public
export function schema<TValue>(fn: SchemaFn<TValue>): Schema<TValue>;

// @public
export type SchemaFn<TValue, TPathKind extends PathKind = PathKind.Root> = (p: FieldPath<TValue, TPathKind>) => void;

// @public
export type SchemaOrSchemaFn<TValue, TPathKind extends PathKind = PathKind.Root> = Schema<TValue> | SchemaFn<TValue, TPathKind>;

// @public
export function standardSchemaError(issue: StandardSchemaV1.Issue, options: WithField<ValidationErrorOptions>): StandardSchemaValidationError;

// @public
export function standardSchemaError(issue: StandardSchemaV1.Issue, options?: ValidationErrorOptions): WithoutField<StandardSchemaValidationError>;

// @public
export class StandardSchemaValidationError extends _NgValidationError {
    constructor(issue: StandardSchemaV1.Issue, options?: ValidationErrorOptions);
    // (undocumented)
    readonly issue: StandardSchemaV1.Issue;
    // (undocumented)
    readonly kind = "standardSchema";
}

// @public
export type Subfields<TValue> = {
    readonly [K in keyof TValue as TValue[K] extends Function ? never : K]: MaybeFieldTree<TValue[K], string>;
};

// @public
export function submit<TValue>(form: FieldTree<TValue>, action: (form: FieldTree<TValue>) => Promise<TreeValidationResult>): Promise<void>;

// @public
export type SubmittedStatus = 'unsubmitted' | 'submitted' | 'submitting';

// @public
export type TreeValidationResult<E extends ValidationErrorWithOptionalField = ValidationErrorWithOptionalField> = ValidationSuccess | OneOrMany<E>;

// @public
export type TreeValidator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, TreeValidationResult, TPathKind>;

// @public
export function validate<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic: NoInfer<FieldValidator<TValue, TPathKind>>): void;

// @public
export function validateAsync<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, opts: AsyncValidatorOptions<TValue, TParams, TResult, TPathKind>): void;

// @public
export function validateHttp<TValue, TResult = unknown, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, opts: HttpValidatorOptions<TValue, TResult, TPathKind>): void;

// @public
export function validateStandardSchema<TSchema, TValue extends IgnoreUnknownProperties<TSchema>>(path: FieldPath<TValue>, schema: StandardSchemaV1<TSchema>): void;

// @public
export function validateTree<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic: NoInfer<TreeValidator<TValue, TPathKind>>): void;

// @public
export interface ValidationError {
    readonly kind: string;
    readonly message?: string;
}

// @public
export interface ValidationErrorWithField extends ValidationError {
    readonly field: FieldTree<unknown>;
}

// @public
export interface ValidationErrorWithOptionalField extends ValidationError {
    readonly field?: FieldTree<unknown>;
}

// @public
export interface ValidationErrorWithoutField extends ValidationError {
    readonly field?: never;
}

// @public
export type ValidationResult<E extends ValidationError = ValidationError> = ValidationSuccess | OneOrMany<E>;

// @public
export type ValidationSuccess = null | undefined | void;

// @public
export type Validator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, ValidationResult, TPathKind>;

// @public
export type WithField<T> = T & {
    field: FieldTree<unknown>;
};

// @public
export type WithOptionalField<T> = Omit<T, 'field'> & {
    field?: FieldTree<unknown>;
};

// @public
export type WithoutField<T> = T & {
    field: never;
};

// (No @packageDocumentation comment for this package)

```
