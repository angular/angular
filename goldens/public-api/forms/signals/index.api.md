## API Report File for "@angular/forms_signals"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import { ControlValueAccessor } from '@angular/forms';
import { FormControlStatus } from '@angular/forms';
import { HttpResourceOptions } from '@angular/common/http';
import { HttpResourceRequest } from '@angular/common/http';
import * as i0 from '@angular/core';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { InputSignal } from '@angular/core';
import { InputSignalWithTransform } from '@angular/core';
import { ModelSignal } from '@angular/core';
import { OutputRef } from '@angular/core';
import { Provider } from '@angular/core';
import { ResourceRef } from '@angular/core';
import { Signal } from '@angular/core';
import { StandardSchemaV1 } from '@standard-schema/spec';
import { ValidationErrors } from '@angular/forms';
import { ValidatorFn } from '@angular/forms';
import { WritableSignal } from '@angular/core';

// @public
export function apply<TValue>(path: SchemaPath<TValue>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyEach<TValue extends ReadonlyArray<any>>(path: SchemaPath<TValue>, schema: NoInfer<SchemaOrSchemaFn<TValue[number], PathKind.Item>>): void;

// @public (undocumented)
export function applyEach<TValue extends Object>(path: SchemaPath<TValue>, schema: NoInfer<SchemaOrSchemaFn<ItemType<TValue>, PathKind.Child>>): void;

// @public
export function applyWhen<TValue>(path: SchemaPath<TValue>, logic: LogicFn<TValue, boolean>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyWhenValue<TValue, TNarrowed extends TValue>(path: SchemaPath<TValue>, predicate: (value: TValue) => value is TNarrowed, schema: SchemaOrSchemaFn<TNarrowed>): void;

// @public
export function applyWhenValue<TValue>(path: SchemaPath<TValue>, predicate: (value: TValue) => boolean, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export type AsyncValidationResult<E extends ValidationError = ValidationError> = ValidationResult<E> | 'pending';

// @public
export interface AsyncValidatorOptions<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly factory: (params: Signal<TParams | undefined>) => ResourceRef<TResult | undefined>;
    readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;
    readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly params: (ctx: FieldContext<TValue, TPathKind>) => TParams;
}

// @public
export abstract class BaseNgValidationError implements ValidationError {
    constructor(options?: ValidationErrorOptions);
    readonly fieldTree: FieldTree<unknown>;
    readonly kind: string;
    readonly message?: string;
}

// @public
export interface ChildFieldContext<TValue> extends RootFieldContext<TValue> {
    readonly key: Signal<string>;
}

// @public
export type CompatFieldState<TControl extends AbstractControl, TKey extends string | number = string | number> = FieldState<TControl extends AbstractControl<unknown, infer TValue> ? TValue : never, TKey> & {
    control: Signal<TControl>;
};

// @public
export type CompatSchemaPath<TControl extends AbstractControl, TPathKind extends PathKind = PathKind.Root> = SchemaPath<TControl extends AbstractControl<unknown, infer TValue> ? TValue : never, SchemaPathRules.Unsupported, TPathKind> & {
    [ɵɵTYPE]: {
        control: TControl;
    };
};

// @public
export function createManagedMetadataKey<TRead, TWrite>(create: (s: Signal<TWrite | undefined>) => TRead): MetadataKey<TRead, TWrite, TWrite | undefined>;

// @public
export function createManagedMetadataKey<TRead, TWrite, TAcc>(create: (s: Signal<TAcc>) => TRead, reducer: MetadataReducer<TAcc, TWrite>): MetadataKey<TRead, TWrite, TAcc>;

// @public
export function createMetadataKey<TWrite>(): MetadataKey<Signal<TWrite | undefined>, TWrite, TWrite | undefined>;

// @public
export function createMetadataKey<TWrite, TAcc>(reducer: MetadataReducer<TAcc, TWrite>): MetadataKey<Signal<TAcc>, TWrite, TAcc>;

// @public
export function debounce<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, durationOrDebouncer: number | Debouncer<TValue, TPathKind>): void;

// @public
export type Debouncer<TValue, TPathKind extends PathKind = PathKind.Root> = (context: FieldContext<TValue, TPathKind>, abortSignal: AbortSignal) => Promise<void> | void;

// @public
export function disabled<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic?: string | NoInfer<LogicFn<TValue, boolean | string, TPathKind>>): void;

// @public
export interface DisabledReason {
    readonly fieldTree: FieldTree<unknown>;
    readonly message?: string;
}

// @public
export function email<TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<string, SchemaPathRules.Supported, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export function emailError(options: WithFieldTree<ValidationErrorOptions>): EmailValidationError;

// @public
export function emailError(options?: ValidationErrorOptions): WithoutFieldTree<EmailValidationError>;

// @public
export class EmailValidationError extends BaseNgValidationError {
    // (undocumented)
    readonly kind = "email";
}

// @public
export type Field<TValue, TKey extends string | number = string | number> = () => FieldState<TValue, TKey>;

// @public
export type FieldContext<TValue, TPathKind extends PathKind = PathKind.Root> = TPathKind extends PathKind.Item ? ItemFieldContext<TValue> : TPathKind extends PathKind.Child ? ChildFieldContext<TValue> : RootFieldContext<TValue>;

// @public
export interface FieldState<TValue, TKey extends string | number = string | number> {
    readonly controlValue: WritableSignal<TValue>;
    readonly dirty: Signal<boolean>;
    readonly disabled: Signal<boolean>;
    // (undocumented)
    readonly disabledReasons: Signal<readonly DisabledReason[]>;
    // (undocumented)
    readonly errors: Signal<ValidationError.WithFieldTree[]>;
    readonly errorSummary: Signal<ValidationError.WithFieldTree[]>;
    readonly fieldTree: FieldTree<unknown, TKey>;
    focusBoundControl(options?: FocusOptions): void;
    readonly formFieldBindings: Signal<readonly FormField<unknown>[]>;
    readonly hidden: Signal<boolean>;
    readonly invalid: Signal<boolean>;
    readonly keyInParent: Signal<TKey>;
    markAsDirty(): void;
    markAsTouched(): void;
    readonly max?: Signal<number | undefined>;
    readonly maxLength?: Signal<number | undefined>;
    metadata<M>(key: MetadataKey<M, any, any>): M | undefined;
    readonly min?: Signal<number | undefined>;
    readonly minLength?: Signal<number | undefined>;
    readonly name: Signal<string>;
    readonly pattern: Signal<readonly RegExp[]>;
    readonly pending: Signal<boolean>;
    readonly readonly: Signal<boolean>;
    readonly required: Signal<boolean>;
    reset(value?: TValue): void;
    readonly submitting: Signal<boolean>;
    readonly touched: Signal<boolean>;
    readonly valid: Signal<boolean>;
    readonly value: WritableSignal<TValue>;
}

// @public
export type FieldTree<TModel, TKey extends string | number = string | number> = (() => [
TModel
] extends [AbstractControl] ? CompatFieldState<TModel, TKey> : FieldState<TModel, TKey>) & (TModel extends AbstractControl ? object : TModel extends ReadonlyArray<infer U> ? ReadonlyArrayLike<MaybeFieldTree<U, number>> : TModel extends Record<string, any> ? Subfields<TModel> : object);

// @public
export type FieldValidator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, ValidationResult<ValidationError.WithoutFieldTree>, TPathKind>;

// @public
export function form<TModel>(model: WritableSignal<TModel>): FieldTree<TModel>;

// @public
export function form<TModel>(model: WritableSignal<TModel>, schemaOrOptions: SchemaOrSchemaFn<TModel> | FormOptions<TModel>): FieldTree<TModel>;

// @public
export function form<TModel>(model: WritableSignal<TModel>, schema: SchemaOrSchemaFn<TModel>, options: FormOptions<TModel>): FieldTree<TModel>;

// @public
export const FORM_FIELD: InjectionToken<FormField<unknown>>;

// @public
export interface FormCheckboxControl extends FormUiControl {
    readonly checked: ModelSignal<boolean>;
    readonly value?: undefined;
}

// @public
export class FormField<T> {
    readonly [ɵNgFieldDirective]: true;
    readonly element: HTMLElement;
    readonly errors: Signal<ValidationError.WithFieldTree[]>;
    // (undocumented)
    readonly field: i0.InputSignal<Field<T>>;
    focus(options?: FocusOptions): void;
    readonly injector: Injector;
    protected get interopNgControl(): InteropNgControl;
    registerAsBinding(bindingOptions?: FormFieldBindingOptions): void;
    readonly state: Signal<FieldState<T, string | number>>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormField<any>, "[formField]", ["formField"], { "field": { "alias": "formField"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<FormField<any>, never>;
}

// @public (undocumented)
export interface FormFieldBindingOptions {
    readonly focus?: (focusOptions?: FocusOptions) => void;
}

// @public
export interface FormOptions<TModel> {
    injector?: Injector;
    name?: string;
    submission?: FormSubmitOptions<TModel, unknown>;
}

// @public
export class FormRoot<T> {
    // (undocumented)
    readonly fieldTree: i0.InputSignal<FieldTree<T>>;
    // (undocumented)
    protected onSubmit(event: Event): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormRoot<any>, "form[formRoot]", never, { "fieldTree": { "alias": "formRoot"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<FormRoot<any>, never>;
}

// @public
export interface FormSubmitOptions<TRootModel, TSubmittedModel> {
    action: (field: FieldTree<TRootModel & TSubmittedModel>, detail: {
        root: FieldTree<TRootModel>;
        submitted: FieldTree<TSubmittedModel>;
    }) => Promise<TreeValidationResult>;
    ignoreValidators?: 'pending' | 'none' | 'all';
    onInvalid?: (field: FieldTree<TRootModel & TSubmittedModel>, detail: {
        root: FieldTree<TRootModel>;
        submitted: FieldTree<TSubmittedModel>;
    }) => void;
}

// @public
export interface FormUiControl {
    readonly dirty?: InputSignal<boolean> | InputSignalWithTransform<boolean, unknown>;
    readonly disabled?: InputSignal<boolean> | InputSignalWithTransform<boolean, unknown>;
    readonly disabledReasons?: InputSignal<readonly WithOptionalFieldTree<DisabledReason>[]> | InputSignalWithTransform<readonly WithOptionalFieldTree<DisabledReason>[], unknown>;
    readonly errors?: InputSignal<readonly ValidationError.WithOptionalFieldTree[]> | InputSignalWithTransform<readonly ValidationError.WithOptionalFieldTree[], unknown>;
    focus?(options?: FocusOptions): void;
    readonly hidden?: InputSignal<boolean> | InputSignalWithTransform<boolean, unknown>;
    readonly invalid?: InputSignal<boolean> | InputSignalWithTransform<boolean, unknown>;
    readonly max?: InputSignal<number | undefined> | InputSignalWithTransform<number | undefined, unknown>;
    readonly maxLength?: InputSignal<number | undefined> | InputSignalWithTransform<number | undefined, unknown>;
    readonly min?: InputSignal<number | undefined> | InputSignalWithTransform<number | undefined, unknown>;
    readonly minLength?: InputSignal<number | undefined> | InputSignalWithTransform<number | undefined, unknown>;
    readonly name?: InputSignal<string> | InputSignalWithTransform<string, unknown>;
    readonly pattern?: InputSignal<readonly RegExp[]> | InputSignalWithTransform<readonly RegExp[], unknown>;
    readonly pending?: InputSignal<boolean> | InputSignalWithTransform<boolean, unknown>;
    readonly readonly?: InputSignal<boolean> | InputSignalWithTransform<boolean, unknown>;
    readonly required?: InputSignal<boolean> | InputSignalWithTransform<boolean, unknown>;
    readonly touch?: OutputRef<void>;
    readonly touched?: InputSignal<boolean> | InputSignalWithTransform<boolean, unknown>;
}

// @public
export interface FormValueControl<TValue> extends FormUiControl {
    readonly checked?: undefined;
    readonly value: ModelSignal<TValue>;
}

// @public
export function hidden<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export interface HttpValidatorOptions<TValue, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;
    readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly options?: HttpResourceOptions<TResult, unknown>;
    readonly request: ((ctx: FieldContext<TValue, TPathKind>) => string | undefined) | ((ctx: FieldContext<TValue, TPathKind>) => HttpResourceRequest | undefined);
}

// @public
export type IgnoreUnknownProperties<T> = T extends Record<PropertyKey, unknown> ? {
    [K in keyof T as RemoveStringIndexUnknownKey<K, T[K]>]: IgnoreUnknownProperties<T[K]>;
} : T;

// @public
export interface ItemFieldContext<TValue> extends ChildFieldContext<TValue> {
    readonly index: Signal<number>;
}

// @public
export type ItemType<T extends Object> = T extends ReadonlyArray<any> ? T[number] : T[keyof T];

// @public
export type LogicFn<TValue, TReturn, TPathKind extends PathKind = PathKind.Root> = (ctx: FieldContext<TValue, TPathKind>) => TReturn;

// @public
export type MapToErrorsFn<TValue, TResult, TPathKind extends PathKind = PathKind.Root> = (result: TResult, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;

// @public
export const MAX: MetadataKey<Signal<number | undefined>, number | undefined, number | undefined>;

// @public
export function max<TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<number | string | null, SchemaPathRules.Supported, TPathKind>, maxValue: number | LogicFn<number | string | null, number | undefined, TPathKind>, config?: BaseValidatorConfig<number | string | null, TPathKind>): void;

// @public
export const MAX_LENGTH: MetadataKey<Signal<number | undefined>, number | undefined, number | undefined>;

// @public
export function maxError(max: number, options: WithFieldTree<ValidationErrorOptions>): MaxValidationError;

// @public
export function maxError(max: number, options?: ValidationErrorOptions): WithoutFieldTree<MaxValidationError>;

// @public
export function maxLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, maxLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export function maxLengthError(maxLength: number, options: WithFieldTree<ValidationErrorOptions>): MaxLengthValidationError;

// @public
export function maxLengthError(maxLength: number, options?: ValidationErrorOptions): WithoutFieldTree<MaxLengthValidationError>;

// @public
export class MaxLengthValidationError extends BaseNgValidationError {
    constructor(maxLength: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "maxLength";
    // (undocumented)
    readonly maxLength: number;
}

// @public
export class MaxValidationError extends BaseNgValidationError {
    constructor(max: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "max";
    // (undocumented)
    readonly max: number;
}

// @public
export type MaybeFieldTree<TModel, TKey extends string | number = string | number> = (TModel & undefined) | FieldTree<Exclude<TModel, undefined>, TKey>;

// @public
export type MaybeSchemaPathTree<TModel, TPathKind extends PathKind = PathKind.Root> = (TModel & undefined) | SchemaPathTree<Exclude<TModel, undefined>, TPathKind>;

// @public
export function metadata<TValue, TKey extends MetadataKey<any, any, any>, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, key: TKey, logic: NoInfer<LogicFn<TValue, MetadataSetterType<TKey>, TPathKind>>): TKey;

// @public
export class MetadataKey<TRead, TWrite, TAcc> {
    protected constructor(reducer: MetadataReducer<TAcc, TWrite>, create: ((s: Signal<TAcc>) => TRead) | undefined);
    // (undocumented)
    readonly create: ((s: Signal<TAcc>) => TRead) | undefined;
    // (undocumented)
    readonly reducer: MetadataReducer<TAcc, TWrite>;
}

// @public
export interface MetadataReducer<TAcc, TItem> {
    getInitial: () => TAcc;
    reduce: (acc: TAcc, item: TItem) => TAcc;
}

// @public (undocumented)
export const MetadataReducer: {
    readonly list: <TItem>() => MetadataReducer<TItem[], TItem | undefined>;
    readonly min: () => MetadataReducer<number | undefined, number | undefined>;
    readonly max: () => MetadataReducer<number | undefined, number | undefined>;
    readonly or: () => MetadataReducer<boolean, boolean>;
    readonly and: () => MetadataReducer<boolean, boolean>;
    readonly override: typeof override;
};

// @public
export type MetadataSetterType<TKey> = TKey extends MetadataKey<any, infer TWrite, any> ? TWrite : never;

// @public
export const MIN: MetadataKey<Signal<number | undefined>, number | undefined, number | undefined>;

// @public
export function min<TValue extends number | string | null, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, minValue: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export const MIN_LENGTH: MetadataKey<Signal<number | undefined>, number | undefined, number | undefined>;

// @public
export function minError(min: number, options: WithFieldTree<ValidationErrorOptions>): MinValidationError;

// @public
export function minError(min: number, options?: ValidationErrorOptions): WithoutFieldTree<MinValidationError>;

// @public
export function minLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, minLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export function minLengthError(minLength: number, options: WithFieldTree<ValidationErrorOptions>): MinLengthValidationError;

// @public
export function minLengthError(minLength: number, options?: ValidationErrorOptions): WithoutFieldTree<MinLengthValidationError>;

// @public
export class MinLengthValidationError extends BaseNgValidationError {
    constructor(minLength: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "minLength";
    // (undocumented)
    readonly minLength: number;
}

// @public
export class MinValidationError extends BaseNgValidationError {
    constructor(min: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "min";
    // (undocumented)
    readonly min: number;
}

// @public
export class NativeInputParseError extends BaseNgValidationError {
    // (undocumented)
    readonly kind = "parse";
}

// @public
export const NgValidationError: abstract new () => NgValidationError;

// @public (undocumented)
export type NgValidationError = RequiredValidationError | MinValidationError | MaxValidationError | MinLengthValidationError | MaxLengthValidationError | PatternValidationError | EmailValidationError | StandardSchemaValidationError | NativeInputParseError;

// @public
export type OneOrMany<T> = T | readonly T[];

// @public
export interface ParseResult<TValue> {
    readonly error?: OneOrMany<ValidationError.WithoutFieldTree>;
    readonly value?: TValue;
}

// @public
export type PathKind = PathKind.Root | PathKind.Child | PathKind.Item;

// @public (undocumented)
export namespace PathKind {
    export interface Child extends PathKind.Root {
        // (undocumented)
        [ɵɵTYPE]: 'child' | 'item';
    }
    export interface Item extends PathKind.Child {
        // (undocumented)
        [ɵɵTYPE]: 'item';
    }
    export interface Root {
        [ɵɵTYPE]: 'root' | 'child' | 'item';
    }
}

// @public
export const PATTERN: MetadataKey<Signal<RegExp[]>, RegExp | undefined, RegExp[]>;

// @public
export function pattern<TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<string, SchemaPathRules.Supported, TPathKind>, pattern: RegExp | LogicFn<string | undefined, RegExp | undefined, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export function patternError(pattern: RegExp, options: WithFieldTree<ValidationErrorOptions>): PatternValidationError;

// @public
export function patternError(pattern: RegExp, options?: ValidationErrorOptions): WithoutFieldTree<PatternValidationError>;

// @public
export class PatternValidationError extends BaseNgValidationError {
    constructor(pattern: RegExp, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "pattern";
    // (undocumented)
    readonly pattern: RegExp;
}

// @public
export function provideSignalFormsConfig(config: SignalFormsConfig): Provider[];

// @public
export function readonly<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic?: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export interface ReadonlyArrayLike<T> {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<T>;
    // (undocumented)
    readonly [n: number]: T;
    // (undocumented)
    readonly length: number;
}

// @public
export type RemoveStringIndexUnknownKey<K, V> = string extends K ? unknown extends V ? never : K : K;

// @public
export const REQUIRED: MetadataKey<Signal<boolean>, boolean, boolean>;

// @public
export function required<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind> & {
    when?: NoInfer<LogicFn<TValue, boolean, TPathKind>>;
}): void;

// @public
export function requiredError(options: WithFieldTree<ValidationErrorOptions>): RequiredValidationError;

// @public
export function requiredError(options?: ValidationErrorOptions): WithoutFieldTree<RequiredValidationError>;

// @public
export class RequiredValidationError extends BaseNgValidationError {
    // (undocumented)
    readonly kind = "required";
}

// @public
export interface RootFieldContext<TValue> {
    readonly fieldTree: FieldTree<TValue>;
    fieldTreeOf<PModel>(p: SchemaPathTree<PModel>): [PModel] extends [any] ? FieldTree<PModel> : never;
    readonly pathKeys: Signal<readonly string[]>;
    readonly state: FieldState<TValue>;
    stateOf<PControl extends AbstractControl>(p: CompatSchemaPath<PControl>): [PControl] extends [any] ? CompatFieldState<PControl> : never;
    // (undocumented)
    stateOf<PValue>(p: SchemaPath<PValue, SchemaPathRules>): [PValue] extends [any] ? FieldState<PValue> : never;
    readonly value: Signal<TValue>;
    valueOf<PValue>(p: SchemaPath<PValue, SchemaPathRules>): PValue;
}

// @public
export type Schema<in TModel> = {
    [ɵɵTYPE]: SchemaFn<TModel, PathKind.Root>;
};

// @public
export function schema<TValue>(fn: SchemaFn<TValue>): Schema<TValue>;

// @public
export type SchemaFn<TModel, TPathKind extends PathKind = PathKind.Root> = (p: SchemaPathTree<TModel, TPathKind>) => void;

// @public
export type SchemaOrSchemaFn<TModel, TPathKind extends PathKind = PathKind.Root> = Schema<TModel> | SchemaFn<TModel, TPathKind>;

// @public
export type SchemaPath<TValue, TSupportsRules extends SchemaPathRules = SchemaPathRules.Supported, TPathKind extends PathKind = PathKind.Root> = {
    [ɵɵTYPE]: {
        value: () => TValue;
        supportsRules: TSupportsRules;
        pathKind: TPathKind;
    };
};

// @public
export type SchemaPathRules = SchemaPathRules.Supported | SchemaPathRules.Unsupported;

// @public (undocumented)
export namespace SchemaPathRules {
    export type Supported = 1;
    export type Unsupported = 2;
}

// @public
export type SchemaPathTree<TModel, TPathKind extends PathKind = PathKind.Root> = ([TModel] extends [AbstractControl] ? CompatSchemaPath<TModel, TPathKind> : SchemaPath<TModel, SchemaPathRules.Supported, TPathKind>) & ([TModel] extends [AbstractControl] ? unknown : [
TModel
] extends [ReadonlyArray<any>] ? unknown : TModel extends Record<string, any> ? {
    [K in keyof TModel]: MaybeSchemaPathTree<TModel[K], PathKind.Child>;
} : unknown);

// @public
export interface SignalFormsConfig {
    classes?: {
        [className: string]: (state: FormField<unknown>) => boolean;
    };
}

// @public
export function standardSchemaError(issue: StandardSchemaV1.Issue, options: WithFieldTree<ValidationErrorOptions>): StandardSchemaValidationError;

// @public
export function standardSchemaError(issue: StandardSchemaV1.Issue, options?: ValidationErrorOptions): WithoutFieldTree<StandardSchemaValidationError>;

// @public
export class StandardSchemaValidationError extends BaseNgValidationError {
    constructor(issue: StandardSchemaV1.Issue, options?: ValidationErrorOptions);
    // (undocumented)
    readonly issue: StandardSchemaV1.Issue;
    // (undocumented)
    readonly kind = "standardSchema";
}

// @public
export type Subfields<TModel> = {
    readonly [K in keyof TModel as TModel[K] extends Function ? never : K]: MaybeFieldTree<TModel[K], string>;
} & {
    [Symbol.iterator](): Iterator<[string, MaybeFieldTree<TModel[keyof TModel], string>]>;
};

// @public
export function submit<TModel>(form: FieldTree<TModel>, options?: NoInfer<FormSubmitOptions<unknown, TModel>>): Promise<boolean>;

// @public (undocumented)
export function submit<TModel>(form: FieldTree<TModel>, action: NoInfer<FormSubmitOptions<unknown, TModel>['action']>): Promise<boolean>;

// @public
export function transformedValue<TValue, TRaw>(value: ModelSignal<TValue>, options: TransformedValueOptions<TValue, TRaw>): TransformedValueSignal<TRaw>;

// @public
export interface TransformedValueOptions<TValue, TRaw> {
    format: (value: TValue) => TRaw;
    parse: (rawValue: TRaw) => ParseResult<TValue>;
}

// @public
export interface TransformedValueSignal<TRaw> extends WritableSignal<TRaw> {
    readonly parseErrors: Signal<readonly ValidationError.WithoutFieldTree[]>;
}

// @public
export type TreeValidationResult<E extends ValidationError.WithOptionalFieldTree = ValidationError.WithOptionalFieldTree> = ValidationSuccess | OneOrMany<E>;

// @public
export type TreeValidator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, TreeValidationResult, TPathKind>;

// @public
export function validate<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic: NoInfer<FieldValidator<TValue, TPathKind>>): void;

// @public
export function validateAsync<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, opts: AsyncValidatorOptions<TValue, TParams, TResult, TPathKind>): void;

// @public
export function validateHttp<TValue, TResult = unknown, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, opts: HttpValidatorOptions<TValue, TResult, TPathKind>): void;

// @public
export function validateStandardSchema<TSchema, TModel extends IgnoreUnknownProperties<TSchema>>(path: SchemaPath<TModel> & SchemaPathTree<TModel>, schema: StandardSchemaV1<TSchema> | LogicFn<TModel, StandardSchemaV1<unknown> | undefined>): void;

// @public
export function validateTree<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic: NoInfer<TreeValidator<TValue, TPathKind>>): void;

// @public
export interface ValidationError {
    readonly kind: string;
    readonly message?: string;
}

// @public (undocumented)
export namespace ValidationError {
    // @deprecated (undocumented)
    export type WithField = WithFieldTree;
    export interface WithFieldTree extends ValidationError {
        readonly fieldTree: FieldTree<unknown>;
        // (undocumented)
        readonly formField?: FormField<unknown>;
    }
    export interface WithFormField extends WithFieldTree {
        // (undocumented)
        readonly formField: FormField<unknown>;
    }
    // @deprecated (undocumented)
    export type WithOptionalField = WithOptionalFieldTree;
    export interface WithOptionalFieldTree extends ValidationError {
        readonly fieldTree?: FieldTree<unknown>;
    }
    // @deprecated (undocumented)
    export type WithoutField = WithoutFieldTree;
    export interface WithoutFieldTree extends ValidationError {
        readonly fieldTree?: never;
        // (undocumented)
        readonly formField?: never;
    }
}

// @public
export interface ValidationErrorOptions {
    message?: string;
}

// @public
export type ValidationResult<E extends ValidationError = ValidationError> = ValidationSuccess | OneOrMany<E>;

// @public
export type ValidationSuccess = null | undefined | void;

// @public
export type Validator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, ValidationResult, TPathKind>;

// @public @deprecated (undocumented)
export type WithField<T> = WithFieldTree<T>;

// @public
export type WithFieldTree<T> = T & {
    fieldTree: FieldTree<unknown>;
};

// @public @deprecated (undocumented)
export type WithOptionalField<T> = WithOptionalFieldTree<T>;

// @public
export type WithOptionalFieldTree<T> = Omit<T, 'fieldTree'> & {
    fieldTree?: FieldTree<unknown>;
};

// @public @deprecated (undocumented)
export type WithoutField<T> = WithoutFieldTree<T>;

// @public
export type WithoutFieldTree<T> = T & {
    fieldTree: never;
};

// (No @packageDocumentation comment for this package)

```
