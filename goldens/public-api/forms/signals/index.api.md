## API Report File for "@angular/forms_signals"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import * as _angular_forms from '@angular/forms';
import { ControlValueAccessor } from '@angular/forms';
import { DestroyableInjector } from '@angular/core';
import { FormControlStatus } from '@angular/forms';
import { HttpResourceOptions } from '@angular/common/http';
import { HttpResourceRequest } from '@angular/common/http';
import * as i0 from '@angular/core';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { InputSignal } from '@angular/core';
import { ModelSignal } from '@angular/core';
import { NgControl } from '@angular/forms';
import { OutputRef } from '@angular/core';
import { Provider } from '@angular/core';
import { ResourceRef } from '@angular/core';
import { Signal } from '@angular/core';
import { StandardSchemaV1 } from '@standard-schema/spec';
import { ValidationErrors } from '@angular/forms';
import { ValidatorFn } from '@angular/forms';
import { WritableSignal } from '@angular/core';
import { ɵCONTROL } from '@angular/core';
import { ɵControl } from '@angular/core';
import { ɵFieldState } from '@angular/core';
import { ɵInteropControl } from '@angular/core';

// @public
export function aggregateMetadata<TValue, TMetadataItem, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, key: AggregateMetadataKey<any, TMetadataItem>, logic: NoInfer<LogicFn<TValue, TMetadataItem, TPathKind>>): void;

// @public
export class AggregateMetadataKey<TAcc, TItem> {
    // (undocumented)
    readonly getInitial: () => TAcc;
    // (undocumented)
    readonly reduce: (acc: TAcc, item: TItem) => TAcc;
}

// @public
export function andMetadataKey(): AggregateMetadataKey<boolean, boolean>;

// @public
export function apply<TValue>(path: SchemaPath<TValue>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyEach<TValue extends ReadonlyArray<any>>(path: SchemaPath<TValue>, schema: NoInfer<SchemaOrSchemaFn<TValue[number], PathKind.Item>>): void;

// @public (undocumented)
export function applyEach<TValue extends Object>(path: SchemaPath<TValue>, schema: NoInfer<SchemaOrSchemaFn<ItemType<TValue>, PathKind.Child>>): void;

// @public
export function applyWhen<TValue>(path: SchemaPath<TValue>, logic: LogicFn<TValue, boolean>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyWhenValue<TValue, TNarrowed extends TValue>(path: SchemaPath<TValue>, predicate: (value: TValue) => value is TNarrowed, schema: SchemaOrSchemaFn<TNarrowed>): void;

// @public
export function applyWhenValue<TValue>(path: SchemaPath<TValue>, predicate: (value: TValue) => boolean, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export type AsyncValidationResult<E extends ValidationError = ValidationError> = ValidationResult<E> | 'pending';

// @public
export interface AsyncValidatorOptions<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly factory: (params: Signal<TParams | undefined>) => ResourceRef<TResult | undefined>;
    readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;
    readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly params: (ctx: FieldContext<TValue, TPathKind>) => TParams;
}

// @public
export interface ChildFieldContext<TValue> extends RootFieldContext<TValue> {
    readonly key: Signal<string>;
}

// @public
export type CompatFieldState<TControl extends AbstractControl, TKey extends string | number = string | number> = FieldState<TControl extends AbstractControl<unknown, infer TValue> ? TValue : never, TKey> & {
    control: Signal<TControl>;
};

// @public
export type CompatSchemaPath<TControl extends AbstractControl, TPathKind extends PathKind = PathKind.Root> = SchemaPath<TControl extends AbstractControl<unknown, infer TValue> ? TValue : never, SchemaPathRules.Unsupported, TPathKind> & {
    [ɵɵTYPE]: {
        control: TControl;
    };
};

// @public
export function createMetadataKey<TValue>(): MetadataKey<TValue>;

// @public
export function customError<E extends Partial<ValidationError.WithField>>(obj: WithField<E>): CustomValidationError;

// @public
export function customError<E extends Partial<ValidationError.WithField>>(obj?: E): WithoutField<CustomValidationError>;

// @public
export class CustomValidationError implements ValidationError {
    constructor(options?: ValidationErrorOptions);
    [key: PropertyKey]: unknown;
    readonly field: FieldTree<unknown>;
    readonly kind: string;
    readonly message?: string;
}

// @public
export function debounce<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, durationOrDebouncer: number | Debouncer<TValue, TPathKind>): void;

// @public
export type Debouncer<TValue, TPathKind extends PathKind = PathKind.Root> = (context: FieldContext<TValue, TPathKind>, abortSignal: AbortSignal) => Promise<void> | void;

// @public
export function disabled<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic?: string | NoInfer<LogicFn<TValue, boolean | string, TPathKind>>): void;

// @public
export interface DisabledReason {
    readonly field: FieldTree<unknown>;
    readonly message?: string;
}

// @public
export function email<TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<string, SchemaPathRules.Supported, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export function emailError(options: WithField<ValidationErrorOptions>): EmailValidationError;

// @public
export function emailError(options?: ValidationErrorOptions): WithoutField<EmailValidationError>;

// @public
export class EmailValidationError extends _NgValidationError {
    // (undocumented)
    readonly kind = "email";
}

// @public
export const FIELD: InjectionToken<Field<unknown>>;

// @public
export class Field<T> implements ɵControl<T> {
    // (undocumented)
    readonly [ɵCONTROL]: undefined;
    // (undocumented)
    readonly classes: (readonly [string, i0.Signal<boolean>])[];
    // (undocumented)
    readonly field: i0.InputSignal<FieldTree<T>>;
    protected getOrCreateNgControl(): InteropNgControl;
    // (undocumented)
    readonly state: i0.Signal<[T] extends [_angular_forms.AbstractControl<any, any, any>] ? CompatFieldState<T, string | number> : FieldState<T, string | number>>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<Field<any>, "[field]", never, { "field": { "alias": "field"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<Field<any>, never>;
    get ɵinteropControl(): ɵInteropControl | undefined;
    // (undocumented)
    ɵregister(): void;
}

// @public
export type FieldContext<TValue, TPathKind extends PathKind = PathKind.Root> = TPathKind extends PathKind.Item ? ItemFieldContext<TValue> : TPathKind extends PathKind.Child ? ChildFieldContext<TValue> : RootFieldContext<TValue>;

// @public
export interface FieldState<TValue, TKey extends string | number = string | number> extends ɵFieldState<TValue> {
    readonly dirty: Signal<boolean>;
    // (undocumented)
    readonly disabledReasons: Signal<readonly DisabledReason[]>;
    // (undocumented)
    readonly errors: Signal<ValidationError.WithField[]>;
    readonly errorSummary: Signal<ValidationError.WithField[]>;
    readonly fieldBindings: Signal<readonly Field<unknown>[]>;
    hasMetadata(key: MetadataKey<any> | AggregateMetadataKey<any, any>): boolean;
    readonly hidden: Signal<boolean>;
    readonly invalid: Signal<boolean>;
    readonly keyInParent: Signal<TKey>;
    metadata<M>(key: AggregateMetadataKey<M, any>): Signal<M>;
    metadata<M>(key: MetadataKey<M>): M | undefined;
    readonly pending: Signal<boolean>;
    reset(value?: TValue): void;
    readonly submitting: Signal<boolean>;
    readonly valid: Signal<boolean>;
}

// @public
export type FieldTree<TModel, TKey extends string | number = string | number> = (() => [TModel] extends [AbstractControl] ? CompatFieldState<TModel, TKey> : FieldState<TModel, TKey>) & ([TModel] extends [AbstractControl] ? object : [TModel] extends [Array<infer U>] ? ReadonlyArrayLike<MaybeFieldTree<U, number>> : TModel extends Record<string, any> ? Subfields<TModel> : object);

// @public
export type FieldValidator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, ValidationResult<ValidationError.WithoutField>, TPathKind>;

// @public
export function form<TModel>(model: WritableSignal<TModel>): FieldTree<TModel>;

// @public
export function form<TModel>(model: WritableSignal<TModel>, schemaOrOptions: SchemaOrSchemaFn<TModel> | FormOptions): FieldTree<TModel>;

// @public
export function form<TModel>(model: WritableSignal<TModel>, schema: SchemaOrSchemaFn<TModel>, options: FormOptions): FieldTree<TModel>;

// @public
export interface FormCheckboxControl extends FormUiControl {
    readonly checked: ModelSignal<boolean>;
    readonly value?: undefined;
}

// @public
export interface FormOptions {
    adapter?: FieldAdapter;
    injector?: Injector;
    // (undocumented)
    name?: string;
}

// @public
export interface FormUiControl {
    readonly dirty?: InputSignal<boolean>;
    readonly disabled?: InputSignal<boolean>;
    readonly disabledReasons?: InputSignal<readonly WithOptionalField<DisabledReason>[]>;
    readonly errors?: InputSignal<readonly WithOptionalField<ValidationError>[]>;
    readonly hidden?: InputSignal<boolean>;
    readonly invalid?: InputSignal<boolean>;
    readonly max?: InputSignal<number | undefined>;
    readonly maxLength?: InputSignal<number | undefined>;
    readonly min?: InputSignal<number | undefined>;
    readonly minLength?: InputSignal<number | undefined>;
    readonly name?: InputSignal<string>;
    readonly pattern?: InputSignal<readonly RegExp[]>;
    readonly pending?: InputSignal<boolean>;
    readonly readonly?: InputSignal<boolean>;
    readonly required?: InputSignal<boolean>;
    readonly touched?: ModelSignal<boolean> | InputSignal<boolean> | OutputRef<boolean>;
}

// @public
export interface FormValueControl<TValue> extends FormUiControl {
    readonly checked?: undefined;
    readonly value: ModelSignal<TValue>;
}

// @public
export function hidden<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export interface HttpValidatorOptions<TValue, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;
    readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly options?: HttpResourceOptions<TResult, unknown>;
    readonly request: ((ctx: FieldContext<TValue, TPathKind>) => string | undefined) | ((ctx: FieldContext<TValue, TPathKind>) => HttpResourceRequest | undefined);
}

// @public
export type IgnoreUnknownProperties<T> = T extends Record<PropertyKey, unknown> ? {
    [K in keyof T as RemoveStringIndexUnknownKey<K, T[K]>]: IgnoreUnknownProperties<T[K]>;
} : T;

// @public
export interface ItemFieldContext<TValue> extends ChildFieldContext<TValue> {
    readonly index: Signal<number>;
}

// @public
export type ItemType<T extends Object> = T extends ReadonlyArray<any> ? T[number] : T[keyof T];

// @public
export function listMetadataKey<TItem>(): AggregateMetadataKey<TItem[], TItem | undefined>;

// @public
export type LogicFn<TValue, TReturn, TPathKind extends PathKind = PathKind.Root> = (ctx: FieldContext<TValue, TPathKind>) => TReturn;

// @public
export type MapToErrorsFn<TValue, TResult, TPathKind extends PathKind = PathKind.Root> = (result: TResult, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;

// @public
export const MAX: AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export function max<TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<number | string | null, SchemaPathRules.Supported, TPathKind>, maxValue: number | LogicFn<number | string | null, number | undefined, TPathKind>, config?: BaseValidatorConfig<number | string | null, TPathKind>): void;

// @public
export const MAX_LENGTH: AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export function maxError(max: number, options: WithField<ValidationErrorOptions>): MaxValidationError;

// @public
export function maxError(max: number, options?: ValidationErrorOptions): WithoutField<MaxValidationError>;

// @public
export function maxLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, maxLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export function maxLengthError(maxLength: number, options: WithField<ValidationErrorOptions>): MaxLengthValidationError;

// @public
export function maxLengthError(maxLength: number, options?: ValidationErrorOptions): WithoutField<MaxLengthValidationError>;

// @public
export class MaxLengthValidationError extends _NgValidationError {
    constructor(maxLength: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "maxLength";
    // (undocumented)
    readonly maxLength: number;
}

// @public
export function maxMetadataKey(): AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export class MaxValidationError extends _NgValidationError {
    constructor(max: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "max";
    // (undocumented)
    readonly max: number;
}

// @public
export type MaybeFieldTree<TModel, TKey extends string | number = string | number> = (TModel & undefined) | FieldTree<Exclude<TModel, undefined>, TKey>;

// @public
export type MaybeSchemaPathTree<TModel, TPathKind extends PathKind = PathKind.Root> = (TModel & undefined) | SchemaPathTree<Exclude<TModel, undefined>, TPathKind>;

// @public
export function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, factory: (ctx: FieldContext<TValue, TPathKind>) => TData): MetadataKey<TData>;

// @public
export function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, key: MetadataKey<TData>, factory: (ctx: FieldContext<TValue, TPathKind>) => TData): MetadataKey<TData>;

// @public
export class MetadataKey<TValue> {
}

// @public
export const MIN: AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export function min<TValue extends number | string | null, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, minValue: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export const MIN_LENGTH: AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export function minError(min: number, options: WithField<ValidationErrorOptions>): MinValidationError;

// @public
export function minError(min: number, options?: ValidationErrorOptions): WithoutField<MinValidationError>;

// @public
export function minLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, minLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export function minLengthError(minLength: number, options: WithField<ValidationErrorOptions>): MinLengthValidationError;

// @public
export function minLengthError(minLength: number, options?: ValidationErrorOptions): WithoutField<MinLengthValidationError>;

// @public
export class MinLengthValidationError extends _NgValidationError {
    constructor(minLength: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "minLength";
    // (undocumented)
    readonly minLength: number;
}

// @public
export function minMetadataKey(): AggregateMetadataKey<number | undefined, number | undefined>;

// @public
export class MinValidationError extends _NgValidationError {
    constructor(min: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "min";
    // (undocumented)
    readonly min: number;
}

// @public
export const NgValidationError: abstract new () => NgValidationError;

// @public (undocumented)
export type NgValidationError = RequiredValidationError | MinValidationError | MaxValidationError | MinLengthValidationError | MaxLengthValidationError | PatternValidationError | EmailValidationError | StandardSchemaValidationError;

// @public
export type OneOrMany<T> = T | readonly T[];

// @public
export function orMetadataKey(): AggregateMetadataKey<boolean, boolean>;

// @public
export type PathKind = PathKind.Root | PathKind.Child | PathKind.Item;

// @public (undocumented)
export namespace PathKind {
    export interface Child extends PathKind.Root {
        // (undocumented)
        [ɵɵTYPE]: 'child' | 'item';
    }
    export interface Item extends PathKind.Child {
        // (undocumented)
        [ɵɵTYPE]: 'item';
    }
    export interface Root {
        [ɵɵTYPE]: 'root' | 'child' | 'item';
    }
}

// @public
export const PATTERN: AggregateMetadataKey<RegExp[], RegExp | undefined>;

// @public
export function pattern<TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<string, SchemaPathRules.Supported, TPathKind>, pattern: RegExp | LogicFn<string | undefined, RegExp | undefined, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export function patternError(pattern: RegExp, options: WithField<ValidationErrorOptions>): PatternValidationError;

// @public
export function patternError(pattern: RegExp, options?: ValidationErrorOptions): WithoutField<PatternValidationError>;

// @public
export class PatternValidationError extends _NgValidationError {
    constructor(pattern: RegExp, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "pattern";
    // (undocumented)
    readonly pattern: RegExp;
}

// @public
export function provideSignalFormsConfig(config: SignalFormsConfig): Provider[];

// @public
export function readonly<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic?: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export type ReadonlyArrayLike<T> = Pick<ReadonlyArray<T>, number | 'length' | typeof Symbol.iterator>;

// @public
export function reducedMetadataKey<TAcc, TItem>(reduce: (acc: TAcc, item: TItem) => TAcc, getInitial: NoInfer<() => TAcc>): AggregateMetadataKey<TAcc, TItem>;

// @public
export type RemoveStringIndexUnknownKey<K, V> = string extends K ? unknown extends V ? never : K : K;

// @public
export const REQUIRED: AggregateMetadataKey<boolean, boolean>;

// @public
export function required<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind> & {
    when?: NoInfer<LogicFn<TValue, boolean, TPathKind>>;
}): void;

// @public
export function requiredError(options: WithField<ValidationErrorOptions>): RequiredValidationError;

// @public
export function requiredError(options?: ValidationErrorOptions): WithoutField<RequiredValidationError>;

// @public
export class RequiredValidationError extends _NgValidationError {
    // (undocumented)
    readonly kind = "required";
}

// @public
export interface RootFieldContext<TValue> {
    readonly field: FieldTree<TValue>;
    fieldTreeOf<PModel>(p: SchemaPathTree<PModel>): FieldTree<PModel>;
    readonly pathKeys: Signal<readonly string[]>;
    readonly state: FieldState<TValue>;
    stateOf<PControl extends AbstractControl>(p: CompatSchemaPath<PControl>): CompatFieldState<PControl>;
    // (undocumented)
    stateOf<PValue>(p: SchemaPath<PValue, SchemaPathRules>): FieldState<PValue>;
    readonly value: Signal<TValue>;
    valueOf<PValue>(p: SchemaPath<PValue, SchemaPathRules>): PValue;
}

// @public
export type Schema<in TModel> = {
    [ɵɵTYPE]: SchemaFn<TModel, PathKind.Root>;
};

// @public
export function schema<TValue>(fn: SchemaFn<TValue>): Schema<TValue>;

// @public
export type SchemaFn<TModel, TPathKind extends PathKind = PathKind.Root> = (p: SchemaPathTree<TModel, TPathKind>) => void;

// @public
export type SchemaOrSchemaFn<TModel, TPathKind extends PathKind = PathKind.Root> = Schema<TModel> | SchemaFn<TModel, TPathKind>;

// @public
export type SchemaPath<TValue, TSupportsRules extends SchemaPathRules = SchemaPathRules.Supported, TPathKind extends PathKind = PathKind.Root> = {
    [ɵɵTYPE]: {
        value: () => TValue;
        supportsRules: TSupportsRules;
        pathKind: TPathKind;
    };
};

// @public
export type SchemaPathRules = SchemaPathRules.Supported | SchemaPathRules.Unsupported;

// @public (undocumented)
export namespace SchemaPathRules {
    export type Supported = 1;
    export type Unsupported = 2;
}

// @public
export type SchemaPathTree<TModel, TPathKind extends PathKind = PathKind.Root> = ([TModel] extends [AbstractControl] ? CompatSchemaPath<TModel, TPathKind> : SchemaPath<TModel, SchemaPathRules.Supported, TPathKind>) & (TModel extends AbstractControl ? unknown : TModel extends Array<any> ? unknown : TModel extends Record<string, any> ? {
    [K in keyof TModel]: MaybeSchemaPathTree<TModel[K], PathKind.Child>;
} : unknown);

// @public
export interface SignalFormsConfig {
    classes?: {
        [className: string]: (state: FieldState<unknown>) => boolean;
    };
}

// @public
export function standardSchemaError(issue: StandardSchemaV1.Issue, options: WithField<ValidationErrorOptions>): StandardSchemaValidationError;

// @public
export function standardSchemaError(issue: StandardSchemaV1.Issue, options?: ValidationErrorOptions): WithoutField<StandardSchemaValidationError>;

// @public
export class StandardSchemaValidationError extends _NgValidationError {
    constructor(issue: StandardSchemaV1.Issue, options?: ValidationErrorOptions);
    // (undocumented)
    readonly issue: StandardSchemaV1.Issue;
    // (undocumented)
    readonly kind = "standardSchema";
}

// @public
export type Subfields<TModel> = {
    readonly [K in keyof TModel as TModel[K] extends Function ? never : K]: MaybeFieldTree<TModel[K], string>;
} & {
    [Symbol.iterator](): Iterator<[string, MaybeFieldTree<TModel[keyof TModel], string>]>;
};

// @public
export function submit<TModel>(form: FieldTree<TModel>, action: (form: FieldTree<TModel>) => Promise<TreeValidationResult>): Promise<void>;

// @public
export type SubmittedStatus = 'unsubmitted' | 'submitted' | 'submitting';

// @public
export type TreeValidationResult<E extends ValidationError.WithOptionalField = ValidationError.WithOptionalField> = ValidationSuccess | OneOrMany<E>;

// @public
export type TreeValidator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, TreeValidationResult, TPathKind>;

// @public
export function validate<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic: NoInfer<FieldValidator<TValue, TPathKind>>): void;

// @public
export function validateAsync<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, opts: AsyncValidatorOptions<TValue, TParams, TResult, TPathKind>): void;

// @public
export function validateHttp<TValue, TResult = unknown, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, opts: HttpValidatorOptions<TValue, TResult, TPathKind>): void;

// @public
export function validateStandardSchema<TSchema, TModel extends IgnoreUnknownProperties<TSchema>>(path: SchemaPath<TModel> & SchemaPathTree<TModel>, schema: StandardSchemaV1<TSchema>): void;

// @public
export function validateTree<TValue, TPathKind extends PathKind = PathKind.Root>(path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>, logic: NoInfer<TreeValidator<TValue, TPathKind>>): void;

// @public
export interface ValidationError {
    readonly kind: string;
    readonly message?: string;
}

// @public (undocumented)
export namespace ValidationError {
    export interface WithField extends ValidationError {
        readonly field: FieldTree<unknown>;
    }
    export interface WithOptionalField extends ValidationError {
        readonly field?: FieldTree<unknown>;
    }
    export interface WithoutField extends ValidationError {
        readonly field?: never;
    }
}

// @public
export type ValidationResult<E extends ValidationError = ValidationError> = ValidationSuccess | OneOrMany<E>;

// @public
export type ValidationSuccess = null | undefined | void;

// @public
export type Validator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, ValidationResult, TPathKind>;

// @public
export type WithField<T> = T & {
    field: FieldTree<unknown>;
};

// @public
export type WithOptionalField<T> = Omit<T, 'field'> & {
    field?: FieldTree<unknown>;
};

// @public
export type WithoutField<T> = T & {
    field: never;
};

// (No @packageDocumentation comment for this package)

```
