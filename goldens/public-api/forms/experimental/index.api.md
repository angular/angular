## API Report File for "@angular/forms_experimental"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import { ControlValueAccessor } from '@angular/forms';
import { DestroyableInjector } from '@angular/core';
import { ElementRef } from '@angular/core';
import { HttpResourceOptions } from '@angular/common/http';
import { HttpResourceRequest } from '@angular/common/http';
import * as i0 from '@angular/core';
import { Injector } from '@angular/core';
import { InputSignal } from '@angular/core';
import { ModelSignal } from '@angular/core';
import { NgControl } from '@angular/forms';
import { OutputRef } from '@angular/core';
import { ResourceRef } from '@angular/core';
import { Signal } from '@angular/core';
import { StandardSchemaV1 } from '@standard-schema/spec';
import { ValidationErrors } from '@angular/forms';
import { ValidatorFn } from '@angular/forms';
import { WritableSignal } from '@angular/core';

// @public
export function addDefaultField<E extends ValidationError>(error: WithOptionalField<E>, field: Field<unknown>): E;

// @public (undocumented)
export function addDefaultField<E extends ValidationError>(errors: TreeValidationResult<E>, field: Field<unknown>): ValidationResult<E>;

// @public
export class AggregateProperty<TAcc, TItem> {
    protected constructor(reduce: (acc: TAcc, item: TItem) => TAcc, getInitial: () => TAcc);
    static and(): AggregateProperty<boolean, boolean>;
    // (undocumented)
    readonly getInitial: () => TAcc;
    static list<TItem>(): AggregateProperty<TItem[], TItem | undefined>;
    static max(): AggregateProperty<number | undefined, number | undefined>;
    static min(): AggregateProperty<number | undefined, number | undefined>;
    static or(): AggregateProperty<boolean, boolean>;
    // (undocumented)
    readonly reduce: (acc: TAcc, item: TItem) => TAcc;
    static reduce<TAcc, TItem>(reduce: (acc: TAcc, item: TItem) => TAcc, getInitial: () => TAcc): AggregateProperty<TAcc, TItem>;
}

// @public
export function aggregateProperty<TValue, TPropItem, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, prop: AggregateProperty<any, TPropItem>, logic: NoInfer<LogicFn<TValue, TPropItem, TPathKind>>): void;

// @public
export function apply<TValue>(path: FieldPath<TValue>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyEach<TValue>(path: FieldPath<TValue[]>, schema: NoInfer<SchemaOrSchemaFn<TValue, PathKind.Item>>): void;

// @public
export function applyWhen<TValue>(path: FieldPath<TValue>, logic: LogicFn<TValue, boolean>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyWhenValue<TValue, TNarrowed extends TValue>(path: FieldPath<TValue>, predicate: (value: TValue) => value is TNarrowed, schema: SchemaOrSchemaFn<TNarrowed>): void;

// @public
export function applyWhenValue<TValue>(path: FieldPath<TValue>, predicate: (value: TValue) => boolean, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export type AsyncValidationResult<E extends ValidationError = ValidationError> = ValidationResult<E> | 'pending';

// @public
export interface AsyncValidatorOptions<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly errors: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly factory: (params: Signal<TParams | undefined>) => ResourceRef<TResult | undefined>;
    readonly params: (ctx: FieldContext<TValue, TPathKind>) => TParams;
}

// @public (undocumented)
export interface BaseUiControl {
    // (undocumented)
    readonly disabled?: InputSignal<boolean | undefined>;
    // (undocumented)
    readonly errors?: InputSignal<readonly ValidationError[] | undefined>;
    // (undocumented)
    readonly max?: InputSignal<number | undefined>;
    // (undocumented)
    readonly maxLength?: InputSignal<number | undefined>;
    // (undocumented)
    readonly min?: InputSignal<number | undefined>;
    // (undocumented)
    readonly minLength?: InputSignal<number | undefined>;
    // (undocumented)
    readonly name?: InputSignal<string>;
    // (undocumented)
    readonly readonly?: InputSignal<boolean | undefined>;
    // (undocumented)
    readonly touch?: OutputRef<void>;
    // (undocumented)
    readonly touched?: InputSignal<boolean | undefined>;
    // (undocumented)
    readonly valid?: InputSignal<boolean | undefined>;
}

// @public
export interface ChildFieldContext<TValue> extends RootFieldContext<TValue> {
    readonly key: Signal<string>;
}

// @public (undocumented)
export class Control<T> {
    // (undocumented)
    get cva(): ControlValueAccessor | undefined;
    // (undocumented)
    readonly cvaArray: ControlValueAccessor[] | null;
    // (undocumented)
    readonly el: ElementRef<HTMLElement>;
    // (undocumented)
    readonly field: i0.WritableSignal<Field<T>>;
    // (undocumented)
    set _field(value: Field<T>);
    // (undocumented)
    readonly injector: Injector;
    // (undocumented)
    get ngControl(): NgControl;
    // (undocumented)
    readonly state: i0.Signal<FieldState<T, string | number>>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<Control<any>, "[control]", never, { "_field": { "alias": "control"; "required": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<Control<any>, never>;
}

// @public
export class CustomValidationError extends ValidationError {
    [key: PropertyKey]: unknown;
}

// @public
export function disabled<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic?: NoInfer<LogicFn<TValue, boolean | string, TPathKind>>): void;

// @public
export interface DisabledReason {
    readonly field: Field<unknown>;
    readonly reason?: string;
}

// @public
export function email<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<string, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export class EmailValidationError extends _NgValidationError {
    // (undocumented)
    readonly kind = "email";
}

// @public
export type Field<TValue, TKey extends string | number = string | number> = (() => FieldState<TValue, TKey>) & (TValue extends Array<infer U> ? ReadonlyArrayLike<MaybeField<U, number>> : TValue extends Record<string, any> ? Subfields<TValue> : unknown);

// @public
export type FieldContext<TValue, TPathKind extends PathKind = PathKind.Root> = TPathKind extends PathKind.Item ? ItemFieldContext<TValue> : TPathKind extends PathKind.Child ? ChildFieldContext<TValue> : RootFieldContext<TValue>;

// @public
export type FieldPath<TValue, TPathKind extends PathKind = PathKind.Root> = {
    [ɵɵTYPE]: [TValue, TPathKind];
} & (TValue extends Array<unknown> ? unknown : TValue extends Record<string, any> ? {
    [K in keyof TValue]: MaybeFieldPath<TValue[K], PathKind.Child>;
} : unknown);

// @public
export interface FieldState<TValue, TKey extends string | number = string | number> {
    readonly controls: Signal<readonly Control<unknown>[]>;
    readonly dirty: Signal<boolean>;
    readonly disabled: Signal<boolean>;
    readonly disabledReasons: Signal<readonly DisabledReason[]>;
    readonly errors: Signal<ValidationError[]>;
    hasProperty(key: Property<any> | AggregateProperty<any, any>): boolean;
    readonly hidden: Signal<boolean>;
    readonly invalid: Signal<boolean>;
    readonly keyInParent: Signal<TKey>;
    markAsDirty(): void;
    markAsTouched(): void;
    readonly name: Signal<string>;
    readonly pending: Signal<boolean>;
    property<M>(prop: AggregateProperty<M, any>): Signal<M>;
    property<M>(prop: Property<M>): M | undefined;
    readonly readonly: Signal<boolean>;
    reset(): void;
    readonly submitting: Signal<boolean>;
    readonly touched: Signal<boolean>;
    readonly valid: Signal<boolean>;
    readonly value: WritableSignal<TValue>;
}

// @public
export type FieldValidationResult<E extends ValidationError = ValidationError> = ValidationSuccess | OneOrMany<WithoutField<E>>;

// @public
export type FieldValidator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, FieldValidationResult, TPathKind>;

// @public
export function form<TValue>(model: WritableSignal<TValue>): Field<TValue>;

// @public
export function form<TValue>(model: WritableSignal<TValue>, schemaOrOptions: SchemaOrSchemaFn<TValue> | FormOptions): Field<TValue>;

// @public
export function form<TValue>(model: WritableSignal<TValue>, schema: SchemaOrSchemaFn<TValue>, options: FormOptions): Field<TValue>;

// @public (undocumented)
export interface FormCheckboxControl extends BaseUiControl {
    // (undocumented)
    readonly checked: ModelSignal<boolean>;
    // (undocumented)
    readonly value?: undefined;
}

// @public
export interface FormOptions {
    adapter?: FieldAdapter;
    injector?: Injector;
    // (undocumented)
    name?: string;
}

// @public (undocumented)
export interface FormValueControl<TValue> extends BaseUiControl {
    // (undocumented)
    readonly checked?: undefined;
    // (undocumented)
    readonly value: ModelSignal<TValue>;
}

// @public
export function hidden<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export interface HttpValidatorOptions<TValue, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly errors: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly options?: HttpResourceOptions<TResult, unknown>;
    readonly request: ((ctx: FieldContext<TValue, TPathKind>) => string | undefined) | ((ctx: FieldContext<TValue, TPathKind>) => HttpResourceRequest | undefined);
}

// @public (undocumented)
export class InteropNgControl implements Pick<NgControl, InteropSharedKeys | 'control' | 'valueAccessor'>, Pick<AbstractControl<unknown>, InteropSharedKeys | 'hasValidator'> {
    constructor(field: () => FieldState<unknown>);
    // (undocumented)
    readonly control: AbstractControl<any, any>;
    // (undocumented)
    get dirty(): boolean;
    // (undocumented)
    get disabled(): boolean;
    // (undocumented)
    get enabled(): boolean;
    // (undocumented)
    get errors(): ValidationErrors | null;
    // (undocumented)
    protected field: () => FieldState<unknown>;
    // (undocumented)
    hasValidator(validator: ValidatorFn): boolean;
    // (undocumented)
    get invalid(): boolean;
    // (undocumented)
    get pending(): boolean | null;
    // (undocumented)
    get pristine(): boolean;
    // (undocumented)
    get touched(): boolean;
    // (undocumented)
    get untouched(): boolean;
    // (undocumented)
    get valid(): boolean;
    // (undocumented)
    get value(): any;
    // (undocumented)
    valueAccessor: ControlValueAccessor | null;
}

// @public (undocumented)
export type InteropSharedKeys = 'value' | 'valid' | 'invalid' | 'touched' | 'untouched' | 'disabled' | 'enabled' | 'errors' | 'pristine' | 'dirty';

// @public
export interface ItemFieldContext<TValue> extends ChildFieldContext<TValue> {
    readonly index: Signal<number>;
}

// @public
export type LogicFn<TValue, TReturn, TPathKind extends PathKind = PathKind.Root> = (ctx: FieldContext<TValue, TPathKind>) => TReturn;

// @public
export type MapToErrorsFn<TValue, TResult, TPathKind extends PathKind = PathKind.Root> = (result: TResult, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;

// @public
export const MAX: AggregateProperty<number | undefined, number | undefined>;

// @public
export function max<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<number, TPathKind>, maxValue: number | LogicFn<number, number | undefined, TPathKind>, config?: BaseValidatorConfig<number, TPathKind>): void;

// @public
export const MAX_LENGTH: AggregateProperty<number | undefined, number | undefined>;

// @public
export function maxLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, maxLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export class MaxLengthValidationError extends _NgValidationError {
    constructor(maxLength: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "maxLength";
    // (undocumented)
    readonly maxLength: number;
}

// @public
export class MaxValidationError extends _NgValidationError {
    constructor(max: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "max";
    // (undocumented)
    readonly max: number;
}

// @public
export type MaybeField<TValue, TKey extends string | number = string | number> = (TValue & undefined) | Field<Exclude<TValue, undefined>, TKey>;

// @public
export type MaybeFieldPath<TValue, TPathKind extends PathKind = PathKind.Root> = (TValue & undefined) | FieldPath<Exclude<TValue, undefined>, TPathKind>;

// @public
export const MIN: AggregateProperty<number | undefined, number | undefined>;

// @public
export function min<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<number, TPathKind>, minValue: number | LogicFn<number, number | undefined, TPathKind>, config?: BaseValidatorConfig<number, TPathKind>): void;

// @public
export const MIN_LENGTH: AggregateProperty<number | undefined, number | undefined>;

// @public
export function minLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, minLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export class MinLengthValidationError extends _NgValidationError {
    constructor(minLength: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "minLength";
    // (undocumented)
    readonly minLength: number;
}

// @public
export class MinValidationError extends _NgValidationError {
    constructor(min: number, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "min";
    // (undocumented)
    readonly min: number;
}

// @public
export type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};

// @public
export const NgValidationError: abstract new () => NgValidationError;

// @public (undocumented)
export type NgValidationError = RequiredValidationError | MinValidationError | MaxValidationError | MinLengthValidationError | MaxLengthValidationError | PatternValidationError | EmailValidationError | StandardSchemaValidationError;

// @public
export type OneOrMany<T> = T | readonly T[];

// @public
export namespace PathKind {
    export interface Child extends PathKind.Root {
        // (undocumented)
        [ɵɵTYPE]: 'child' | 'item';
    }
    export interface Item extends PathKind.Child {
        // (undocumented)
        [ɵɵTYPE]: 'item';
    }
    export interface Root {
        [ɵɵTYPE]: 'root' | 'child' | 'item';
    }
}

// @public (undocumented)
export type PathKind = PathKind.Root | PathKind.Child | PathKind.Item;

// @public
export const PATTERN: AggregateProperty<RegExp[], RegExp | undefined>;

// @public
export function pattern<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<string, TPathKind>, pattern: RegExp | LogicFn<string | undefined, RegExp | undefined, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export class PatternValidationError extends _NgValidationError {
    constructor(pattern: RegExp, options?: ValidationErrorOptions);
    // (undocumented)
    readonly kind = "pattern";
    // (undocumented)
    readonly pattern: RegExp;
}

// @public
export class Property<TValue> {
    protected constructor();
    static create<TValue>(): Property<TValue>;
}

// @public
export function property<TValue, TData, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, factory: (ctx: FieldContext<TValue, TPathKind>) => TData): Property<TData>;

// @public
export function property<TValue, TData, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, prop: Property<TData>, factory: (ctx: FieldContext<TValue, TPathKind>) => TData): Property<TData>;

// @public
export function readonly<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic?: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export type ReadonlyArrayLike<T> = Pick<ReadonlyArray<T>, number | 'length' | typeof Symbol.iterator>;

// @public
export const REQUIRED: AggregateProperty<boolean, boolean>;

// @public
export function required<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind> & {
    emptyPredicate?: (value: TValue) => boolean;
    when?: NoInfer<LogicFn<TValue, boolean, TPathKind>>;
}): void;

// @public
export class RequiredValidationError extends _NgValidationError {
    // (undocumented)
    readonly kind = "required";
}

// @public
export interface RootFieldContext<TValue> {
    readonly field: Field<TValue>;
    readonly fieldOf: <P>(p: FieldPath<P>) => Field<P>;
    readonly state: FieldState<TValue>;
    readonly stateOf: <P>(p: FieldPath<P>) => FieldState<P>;
    readonly value: Signal<TValue>;
    readonly valueOf: <P>(p: FieldPath<P>) => P;
}

// @public
export type Schema<in TValue> = {
    [ɵɵTYPE]: SchemaFn<TValue, PathKind.Root>;
};

// @public
export function schema<TValue>(fn: SchemaFn<TValue>): Schema<TValue>;

// @public
export type SchemaFn<TValue, TPathKind extends PathKind = PathKind.Root> = (p: FieldPath<TValue, TPathKind>) => void;

// @public
export type SchemaOrSchemaFn<TValue, TPathKind extends PathKind = PathKind.Root> = Schema<TValue> | SchemaFn<TValue, TPathKind>;

// @public
export class StandardSchemaValidationError extends _NgValidationError {
    constructor(issue: StandardSchemaV1.Issue, options?: ValidationErrorOptions);
    // (undocumented)
    readonly issue: StandardSchemaV1.Issue;
    // (undocumented)
    readonly kind = "standardSchema";
}

// @public
export type Subfields<TValue> = {
    readonly [K in keyof TValue as TValue[K] extends Function ? never : K]: MaybeField<TValue[K], string>;
};

// @public
export function submit<TValue>(form: Field<TValue>, action: (form: Field<TValue>) => Promise<TreeValidationResult>): Promise<void>;

// @public
export type SubmittedStatus = 'unsubmitted' | 'submitted' | 'submitting';

// @public
export type TreeValidationResult<E extends ValidationError = ValidationError> = ValidationSuccess | OneOrMany<WithOptionalField<E>>;

// @public
export type TreeValidator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, TreeValidationResult, TPathKind>;

// @public
export function validate<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic: NoInfer<FieldValidator<TValue, TPathKind>>): void;

// @public
export function validateAsync<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, opts: AsyncValidatorOptions<TValue, TParams, TResult, TPathKind>): void;

// @public
export function validateHttp<TValue, TResult = unknown, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, opts: HttpValidatorOptions<TValue, TResult, TPathKind>): void;

// @public
export function validateTree<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic: NoInfer<TreeValidator<TValue, TPathKind>>): void;

// @public
export abstract class ValidationError {
    [BRAND]: undefined;
    constructor(options?: ValidationErrorOptions);
    static custom<E extends Omit<Partial<ValidationError>, typeof BRAND>>(obj: WithField<E>): CustomValidationError;
    static custom<E extends Omit<Partial<ValidationError>, typeof BRAND>>(obj?: E): WithoutField<CustomValidationError>;
    static email(options: WithField<ValidationErrorOptions>): EmailValidationError;
    static email(options?: ValidationErrorOptions): WithoutField<EmailValidationError>;
    readonly field: Field<unknown>;
    readonly kind: string;
    static max(max: number, options: WithField<ValidationErrorOptions>): MaxValidationError;
    static max(max: number, options?: ValidationErrorOptions): WithoutField<MaxValidationError>;
    static maxLength(maxLength: number, options: WithField<ValidationErrorOptions>): MaxLengthValidationError;
    static maxLength(maxLength: number, options?: ValidationErrorOptions): WithoutField<MaxLengthValidationError>;
    readonly message?: string;
    static min(min: number, options: WithField<ValidationErrorOptions>): MinValidationError;
    static min(min: number, options?: ValidationErrorOptions): WithoutField<MinValidationError>;
    static minLength(minLength: number, options: WithField<ValidationErrorOptions>): MinLengthValidationError;
    static minLength(minLength: number, options?: ValidationErrorOptions): WithoutField<MinLengthValidationError>;
    static pattern(pattern: RegExp, options: WithField<ValidationErrorOptions>): PatternValidationError;
    static pattern(pattern: RegExp, options?: ValidationErrorOptions): WithoutField<PatternValidationError>;
    static required(options: WithField<ValidationErrorOptions>): RequiredValidationError;
    static required(options?: ValidationErrorOptions): WithoutField<RequiredValidationError>;
    static standardSchema(issue: StandardSchemaV1.Issue, options: WithField<ValidationErrorOptions>): StandardSchemaValidationError;
    static standardSchema(issue: StandardSchemaV1.Issue, options?: ValidationErrorOptions): WithoutField<StandardSchemaValidationError>;
}

// @public
export type ValidationResult<E extends ValidationError = ValidationError> = ValidationSuccess | OneOrMany<E>;

// @public
export type ValidationSuccess = null | undefined | void;

// @public
export type Validator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, ValidationResult, TPathKind>;

// @public
export type WithField<T> = T & {
    field: Field<unknown>;
};

// @public
export type WithOptionalField<T> = T & {
    field?: Field<unknown>;
};

// @public
export type WithoutField<T> = T & {
    field: never;
};

// (No @packageDocumentation comment for this package)

```
