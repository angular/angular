## API Report File for "@angular/forms_experimental"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import { ControlValueAccessor } from '@angular/forms';
import { ElementRef } from '@angular/core';
import { HttpResourceOptions } from '@angular/common/http';
import { HttpResourceRequest } from '@angular/common/http';
import * as i0 from '@angular/core';
import { Injector } from '@angular/core';
import { InputSignal } from '@angular/core';
import { ModelSignal } from '@angular/core';
import { NgControl } from '@angular/forms';
import { OutputRef } from '@angular/core';
import { ResourceRef } from '@angular/core';
import { Signal } from '@angular/core';
import { StandardSchemaV1 } from '@standard-schema/spec';
import { ValidationErrors } from '@angular/forms';
import { ValidatorFn } from '@angular/forms';
import { WritableSignal } from '@angular/core';

// @public
export class AggregateProperty<TAcc, TItem> {
    protected constructor(reduce: (acc: TAcc, item: TItem) => TAcc, getInitial: () => TAcc);
    static and(): AggregateProperty<boolean, boolean>;
    // (undocumented)
    readonly getInitial: () => TAcc;
    static list<TItem>(): AggregateProperty<TItem[], TItem | undefined>;
    static max(): AggregateProperty<number | undefined, number | undefined>;
    static min(): AggregateProperty<number | undefined, number | undefined>;
    static or(): AggregateProperty<boolean, boolean>;
    // (undocumented)
    readonly reduce: (acc: TAcc, item: TItem) => TAcc;
    static reduce<TAcc, TItem>(reduce: (acc: TAcc, item: TItem) => TAcc, getInitial: () => TAcc): AggregateProperty<TAcc, TItem>;
}

// @public
export function aggregateProperty<TValue, TPropItem, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, prop: AggregateProperty<any, TPropItem>, logic: NoInfer<LogicFn<TValue, TPropItem, TPathKind>>): void;

// @public
export function apply<TValue>(path: FieldPath<TValue>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyEach<TValue>(path: FieldPath<TValue[]>, schema: NoInfer<SchemaOrSchemaFn<TValue, PathKind.Item>>): void;

// @public
export function applyWhen<TValue>(path: FieldPath<TValue>, logic: LogicFn<TValue, boolean>, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export function applyWhenValue<TValue, TNarrowed extends TValue>(path: FieldPath<TValue>, predicate: (value: TValue) => value is TNarrowed, schema: NoInfer<SchemaOrSchemaFn<TNarrowed>>): void;

// @public
export function applyWhenValue<TValue>(path: FieldPath<TValue>, predicate: (value: TValue) => boolean, schema: NoInfer<SchemaOrSchemaFn<TValue>>): void;

// @public
export type AsyncValidationResult<E extends ValidationError = ValidationError> = TreeValidationResult<E> | 'pending';

// @public
export type AsyncValidationResultWithField = TreeValidationResultWithField | 'pending';

// @public
export interface AsyncValidatorOptions<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly errors: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly factory: (params: Signal<TParams | undefined>) => ResourceRef<TResult | undefined>;
    readonly params: (ctx: FieldContext<TValue, TPathKind>) => TParams;
}

// @public
export interface ChildFieldContext<TValue> extends RootFieldContext<TValue> {
    readonly key: Signal<string>;
}

// @public (undocumented)
export class Control<T> {
    // (undocumented)
    get cva(): ControlValueAccessor | undefined;
    // (undocumented)
    readonly cvaArray: ControlValueAccessor[] | null;
    // (undocumented)
    readonly el: ElementRef<HTMLElement>;
    // (undocumented)
    readonly field: InputSignal<Field<T>>;
    // (undocumented)
    readonly injector: Injector;
    // (undocumented)
    get ngControl(): NgControl;
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    readonly state: i0.Signal<FieldState<T, string | number>>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<Control<any>, "[control]", never, { "field": { "alias": "control"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<Control<any>, never>;
}

// @public
export function disabled<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic?: NoInfer<LogicFn<TValue, boolean | string, TPathKind>>): void;

// @public
export interface DisabledReason {
    readonly field: Field<unknown>;
    readonly reason?: string;
}

// @public
export function email<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<string, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export type Field<TValue, TKey extends string | number = string | number> = (() => FieldState<TValue, TKey>) & (TValue extends Array<infer U> ? Array<MaybeField<U, number>> : TValue extends Record<string, any> ? {
    [K in keyof TValue]: MaybeField<TValue[K], string>;
} : unknown);

// @public
export type FieldContext<TValue, TPathKind extends PathKind = PathKind.Root> = TPathKind extends PathKind.Item ? ItemFieldContext<TValue> : TPathKind extends PathKind.Child ? ChildFieldContext<TValue> : RootFieldContext<TValue>;

// @public
export type FieldPath<TValue, TPathKind extends PathKind = PathKind.Root> = {
    [ɵɵTYPE]: [TValue, TPathKind];
} & (TValue extends any[] ? {} : TValue extends Record<PropertyKey, any> ? {
    [K in keyof TValue]: FieldPath<TValue[K], PathKind.Child>;
} : {});

// @public
export interface FieldState<TValue, TKey extends string | number = string | number> {
    readonly dirty: Signal<boolean>;
    readonly disabled: Signal<boolean>;
    readonly disabledReasons: Signal<readonly DisabledReason[]>;
    readonly errors: Signal<ValidationError[]>;
    readonly invalid: Signal<boolean>;
    readonly keyInParent: Signal<TKey>;
    markAsDirty(): void;
    markAsTouched(): void;
    readonly pending: Signal<boolean>;
    property<M>(prop: AggregateProperty<M, any>): Signal<M>;
    property<M>(prop: Property<M>): M | undefined;
    readonly readonly: Signal<boolean>;
    reset(): void;
    readonly submitting: Signal<boolean>;
    readonly syncErrors: Signal<ValidationError[]>;
    readonly syncValid: Signal<boolean>;
    readonly touched: Signal<boolean>;
    readonly valid: Signal<boolean>;
    readonly value: WritableSignal<TValue>;
}

// @public
export function form<TValue>(model: WritableSignal<TValue>): Field<TValue>;

// @public
export function form<TValue>(model: WritableSignal<TValue>, schemaOrOptions: SchemaOrSchemaFn<TValue> | FormOptions): Field<TValue>;

// @public
export function form<TValue>(model: WritableSignal<TValue>, schema: SchemaOrSchemaFn<TValue>, options: FormOptions): Field<TValue>;

// @public
export interface FormOptions {
    injector?: Injector;
}

// @public (undocumented)
export interface FormUiControl<TValue> {
    // (undocumented)
    readonly disabled?: InputSignal<boolean | string | undefined>;
    // (undocumented)
    readonly errors?: InputSignal<readonly ValidationError[] | undefined>;
    // (undocumented)
    readonly readonly?: InputSignal<boolean | undefined>;
    // (undocumented)
    readonly touch?: OutputRef<void>;
    // (undocumented)
    readonly touched?: InputSignal<boolean | undefined>;
    // (undocumented)
    readonly valid?: InputSignal<boolean | undefined>;
    // (undocumented)
    readonly value: ModelSignal<TValue>;
}

// @public
export function hidden<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export interface HttpValidatorOptions<TValue, TResult, TPathKind extends PathKind = PathKind.Root> {
    readonly errors: MapToErrorsFn<TValue, TResult, TPathKind>;
    readonly options?: HttpResourceOptions<TResult, unknown>;
    readonly request: ((ctx: FieldContext<TValue, TPathKind>) => string | undefined) | ((ctx: FieldContext<TValue, TPathKind>) => HttpResourceRequest | undefined);
}

// @public (undocumented)
export class InteropNgControl implements Pick<NgControl, InteropSharedKeys | 'control' | 'valueAccessor'>, Pick<AbstractControl<unknown>, InteropSharedKeys | 'hasValidator'> {
    constructor(field: () => FieldState<unknown>);
    // (undocumented)
    readonly control: AbstractControl<any, any>;
    // (undocumented)
    get dirty(): boolean;
    // (undocumented)
    get disabled(): boolean;
    // (undocumented)
    get enabled(): boolean;
    // (undocumented)
    get errors(): ValidationErrors | null;
    // (undocumented)
    protected field: () => FieldState<unknown>;
    // (undocumented)
    hasValidator(validator: ValidatorFn): boolean;
    // (undocumented)
    get invalid(): boolean;
    // (undocumented)
    get pending(): boolean | null;
    // (undocumented)
    get pristine(): boolean;
    // (undocumented)
    get touched(): boolean;
    // (undocumented)
    get untouched(): boolean;
    // (undocumented)
    get valid(): boolean;
    // (undocumented)
    get value(): any;
    // (undocumented)
    valueAccessor: ControlValueAccessor | null;
}

// @public (undocumented)
export type InteropSharedKeys = 'value' | 'valid' | 'invalid' | 'touched' | 'untouched' | 'disabled' | 'enabled' | 'errors' | 'pristine' | 'dirty';

// @public
export interface ItemFieldContext<TValue> extends ChildFieldContext<TValue> {
    readonly index: Signal<number>;
}

// @public
export type LogicFn<TValue, TReturn, TPathKind extends PathKind = PathKind.Root> = (ctx: FieldContext<TValue, TPathKind>) => TReturn;

// @public
export type MapToErrorsFn<TValue, TResult, TPathKind extends PathKind = PathKind.Root> = (result: TResult, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;

// @public
export const MAX: AggregateProperty<number | undefined, number | undefined>;

// @public
export function max<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<number, TPathKind>, maxValue: number | LogicFn<number, number | undefined, TPathKind>, config?: BaseValidatorConfig<number, TPathKind>): void;

// @public
export const MAX_LENGTH: AggregateProperty<number | undefined, number | undefined>;

// @public
export function maxLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, maxLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export type MaybeField<TValue, TKey extends string | number = string | number> = (TValue & undefined) | Field<Exclude<TValue, undefined>, TKey>;

// @public
export const MIN: AggregateProperty<number | undefined, number | undefined>;

// @public
export function min<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<number, TPathKind>, minValue: number | LogicFn<number, number | undefined, TPathKind>, config?: BaseValidatorConfig<number, TPathKind>): void;

// @public
export const MIN_LENGTH: AggregateProperty<number | undefined, number | undefined>;

// @public
export function minLength<TValue extends ValueWithLengthOrSize, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, minLength: number | LogicFn<TValue, number | undefined, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind>): void;

// @public
export type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};

// @public
export namespace PathKind {
    export interface Child extends PathKind.Root {
        // (undocumented)
        [ɵɵTYPE]: 'child' | 'item';
    }
    export interface Item extends PathKind.Child {
        // (undocumented)
        [ɵɵTYPE]: 'item';
    }
    export interface Root {
        [ɵɵTYPE]: 'root' | 'child' | 'item';
    }
}

// @public (undocumented)
export type PathKind = PathKind.Root | PathKind.Child | PathKind.Item;

// @public
export const PATTERN: AggregateProperty<string[], string | undefined>;

// @public (undocumented)
export function pattern<TPathKind extends PathKind = PathKind.Root>(path: FieldPath<string, TPathKind>, pattern: string | LogicFn<string | undefined, string | undefined, TPathKind>, config?: BaseValidatorConfig<string, TPathKind>): void;

// @public
export class Property<TValue> {
    protected constructor();
    static create<TValue>(): Property<TValue>;
}

// @public
export function property<TValue, TData, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, factory: (ctx: FieldContext<TValue, TPathKind>) => TData): Property<TData>;

// @public
export function property<TValue, TData, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, prop: Property<TData>, factory: (ctx: FieldContext<TValue, TPathKind>) => TData): Property<TData>;

// @public
export function readonly<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic?: NoInfer<LogicFn<TValue, boolean, TPathKind>>): void;

// @public
export const REQUIRED: AggregateProperty<boolean, boolean>;

// @public
export function required<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, config?: BaseValidatorConfig<TValue, TPathKind> & {
    emptyPredicate?: (value: TValue) => boolean;
    when?: NoInfer<LogicFn<TValue, boolean, TPathKind>>;
}): void;

// @public
export interface RootFieldContext<TValue> {
    readonly field: Field<TValue>;
    readonly fieldOf: <P>(p: FieldPath<P>) => Field<P>;
    readonly state: FieldState<TValue>;
    readonly stateOf: <P>(p: FieldPath<P>) => FieldState<P>;
    readonly value: Signal<TValue>;
    readonly valueOf: <P>(p: FieldPath<P>) => P;
}

// @public
export type Schema<in TValue> = {
    [ɵɵTYPE]: SchemaFn<TValue, PathKind.Root>;
};

// @public
export function schema<TValue>(fn: SchemaFn<TValue>): Schema<TValue>;

// @public
export type SchemaFn<TValue, TPathKind extends PathKind = PathKind.Root> = (p: FieldPath<TValue, TPathKind>) => void;

// @public
export type SchemaOrSchemaFn<TValue, TPathKind extends PathKind = PathKind.Root> = Schema<TValue> | SchemaFn<TValue, TPathKind>;

// @public
export function submit<TValue>(form: Field<TValue>, action: (form: Field<TValue>) => Promise<(ValidationError | WithField<ValidationError>)[] | void>): Promise<void>;

// @public
export type SubmittedStatus = 'unsubmitted' | 'submitted' | 'submitting';

// @public
export type TreeValidationResult<E extends ValidationError = ValidationError> = readonly (E | WithField<E>)[] | E | WithField<E> | null | undefined;

// @public
export type TreeValidationResultWithField<E extends ValidationError = ValidationError> = readonly WithField<E>[] | WithField<E> | null | undefined;

// @public
export type TreeValidator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, TreeValidationResult, TPathKind>;

// @public
export function validate<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic: NoInfer<Validator<TValue, TPathKind>>): void;

// @public
export function validateAsync<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, opts: AsyncValidatorOptions<TValue, TParams, TResult, TPathKind>): void;

// @public
export function validateHttp<TValue, TResult = unknown, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, opts: HttpValidatorOptions<TValue, TResult, TPathKind>): void;

// @public
export function validateTree<TValue, TPathKind extends PathKind = PathKind.Root>(path: FieldPath<TValue, TPathKind>, logic: NoInfer<TreeValidator<TValue, TPathKind>>): void;

// @public
export type ValidationResult<E extends ValidationError = ValidationError> = readonly E[] | E | null | undefined;

// @public
export type Validator<TValue, TPathKind extends PathKind = PathKind.Root> = LogicFn<TValue, ValidationResult, TPathKind>;

// (No @packageDocumentation comment for this package)

```
