## API Report File for "@angular/router"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AfterContentInit } from '@angular/core';
import { ChangeDetectorRef } from '@angular/core';
import { ComponentRef } from '@angular/core';
import { ElementRef } from '@angular/core';
import { EnvironmentInjector } from '@angular/core';
import { EnvironmentProviders } from '@angular/core';
import { EventEmitter } from '@angular/core';
import * as i0 from '@angular/core';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { LocationStrategy } from '@angular/common';
import { Meta } from '@angular/platform-browser';
import { ModuleWithProviders } from '@angular/core';
import { NgModuleFactory } from '@angular/core';
import { Observable } from 'rxjs';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { Provider } from '@angular/core';
import { ProviderToken } from '@angular/core';
import { QueryList } from '@angular/core';
import { Renderer2 } from '@angular/core';
import { Signal } from '@angular/core';
import { SimpleChanges } from '@angular/core';
import { Title } from '@angular/platform-browser';
import { Type } from '@angular/core';
import { Version } from '@angular/core';

// @public
export class ActivatedRoute {
    get children(): ActivatedRoute[];
    component: Type<any> | null;
    data: Observable<Data>;
    get firstChild(): ActivatedRoute | null;
    fragment: Observable<string | null>;
    readonly nonIndex: Observable<boolean | undefined>;
    outlet: string;
    get paramMap(): Observable<ParamMap>;
    params: Observable<Params>;
    get parent(): ActivatedRoute | null;
    get pathFromRoot(): ActivatedRoute[];
    get queryParamMap(): Observable<ParamMap>;
    queryParams: Observable<Params>;
    get root(): ActivatedRoute;
    get routeConfig(): Route | null;
    snapshot: ActivatedRouteSnapshot;
    readonly title: Observable<string | undefined>;
    // (undocumented)
    toString(): string;
    url: Observable<UrlSegment[]>;
}

// @public
export class ActivatedRouteSnapshot {
    get children(): ActivatedRouteSnapshot[];
    component: Type<any> | null;
    data: Data;
    get firstChild(): ActivatedRouteSnapshot | null;
    fragment: string | null;
    get nonIndex(): boolean | undefined;
    outlet: string;
    // (undocumented)
    get paramMap(): ParamMap;
    params: Params;
    get parent(): ActivatedRouteSnapshot | null;
    get pathFromRoot(): ActivatedRouteSnapshot[];
    // (undocumented)
    get queryParamMap(): ParamMap;
    queryParams: Params;
    get root(): ActivatedRouteSnapshot;
    readonly routeConfig: Route | null;
    get title(): string | undefined;
    // (undocumented)
    toString(): string;
    url: UrlSegment[];
}

// @public
export class ActivationEnd {
    constructor(
    snapshot: ActivatedRouteSnapshot);
    // (undocumented)
    snapshot: ActivatedRouteSnapshot;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.ActivationEnd;
}

// @public
export class ActivationStart {
    constructor(
    snapshot: ActivatedRouteSnapshot);
    // (undocumented)
    snapshot: ActivatedRouteSnapshot;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.ActivationStart;
}

// @public
export abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {
    retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;
    shouldAttach(route: ActivatedRouteSnapshot): boolean;
    shouldDetach(route: ActivatedRouteSnapshot): boolean;
    shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;
    store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void;
}

// @public
export interface CanActivate {
    // (undocumented)
    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): MaybeAsync<GuardResult>;
}

// @public
export interface CanActivateChild {
    // (undocumented)
    canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): MaybeAsync<GuardResult>;
}

// @public
export type CanActivateChildFn = (childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot) => MaybeAsync<GuardResult>;

// @public
export type CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => MaybeAsync<GuardResult>;

// @public
export interface CanDeactivate<T> {
    // (undocumented)
    canDeactivate(component: T, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState: RouterStateSnapshot): MaybeAsync<GuardResult>;
}

// @public
export type CanDeactivateFn<T> = (component: T, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState: RouterStateSnapshot) => MaybeAsync<GuardResult>;

// @public @deprecated
export interface CanLoad {
    // (undocumented)
    canLoad(route: Route, segments: UrlSegment[]): MaybeAsync<GuardResult>;
}

// @public @deprecated
export type CanLoadFn = (route: Route, segments: UrlSegment[]) => MaybeAsync<GuardResult>;

// @public
export interface CanMatch {
    // (undocumented)
    canMatch(route: Route, segments: UrlSegment[]): MaybeAsync<GuardResult>;
}

// @public
export type CanMatchFn = (route: Route, segments: UrlSegment[]) => MaybeAsync<GuardResult>;

// @public
export class ChildActivationEnd {
    constructor(
    snapshot: ActivatedRouteSnapshot);
    // (undocumented)
    snapshot: ActivatedRouteSnapshot;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.ChildActivationEnd;
}

// @public
export class ChildActivationStart {
    constructor(
    snapshot: ActivatedRouteSnapshot);
    // (undocumented)
    snapshot: ActivatedRouteSnapshot;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.ChildActivationStart;
}

// @public
export class ChildrenOutletContexts {
    constructor(rootInjector: EnvironmentInjector);
    // (undocumented)
    getContext(childName: string): OutletContext | null;
    // (undocumented)
    getOrCreateContext(childName: string): OutletContext;
    onChildOutletCreated(childName: string, outlet: RouterOutletContract): void;
    onChildOutletDestroyed(childName: string): void;
    onOutletDeactivated(): Map<string, OutletContext>;
    // (undocumented)
    onOutletReAttached(contexts: Map<string, OutletContext>): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ChildrenOutletContexts, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<ChildrenOutletContexts>;
}

// @public
export type ComponentInputBindingFeature = RouterFeature<RouterFeatureKind.ComponentInputBindingFeature>;

// @public
export function convertToParamMap(params: Params): ParamMap;

// @public
export function createUrlTreeFromSnapshot(relativeTo: ActivatedRouteSnapshot, commands: readonly any[], queryParams?: Params | null, fragment?: string | null): UrlTree;

// @public
export type Data = {
    [key: string | symbol]: any;
};

// @public
export type DebugTracingFeature = RouterFeature<RouterFeatureKind.DebugTracingFeature>;

// @public
export interface DefaultExport<T> {
    default: T;
}

// @public
export class DefaultNonIndexStrategy extends NonIndexStrategy {
    constructor(meta: Meta);
    updateNonIndex(snapshot: RouterStateSnapshot): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultNonIndexStrategy, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<DefaultNonIndexStrategy>;
}

// @public
export class DefaultTitleStrategy extends TitleStrategy {
    constructor(title: Title);
    // (undocumented)
    readonly title: Title;
    updateTitle(snapshot: RouterStateSnapshot): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultTitleStrategy, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<DefaultTitleStrategy>;
}

// @public
export function defaultUrlMatcher(segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult | null;

// @public
export class DefaultUrlSerializer implements UrlSerializer {
    parse(url: string): UrlTree;
    serialize(tree: UrlTree): string;
}

// @public @deprecated
export type DeprecatedGuard = ProviderToken<any> | string;

// @public @deprecated
export type DeprecatedResolve = DeprecatedGuard | any;

// @public
export type DetachedRouteHandle = {};

// @public
export type DisabledInitialNavigationFeature = RouterFeature<RouterFeatureKind.DisabledInitialNavigationFeature>;

// @public
export type EnabledBlockingInitialNavigationFeature = RouterFeature<RouterFeatureKind.EnabledBlockingInitialNavigationFeature>;

// @public
type Event_2 = NavigationStart | NavigationEnd | NavigationCancel | NavigationError | RoutesRecognized | GuardsCheckStart | GuardsCheckEnd | RouteConfigLoadStart | RouteConfigLoadEnd | ChildActivationStart | ChildActivationEnd | ActivationStart | ActivationEnd | Scroll | ResolveStart | ResolveEnd | NavigationSkipped;
export { Event_2 as Event }

// @public
export enum EventType {
    // (undocumented)
    ActivationEnd = 14,
    // (undocumented)
    ActivationStart = 13,
    // (undocumented)
    ChildActivationEnd = 12,
    // (undocumented)
    ChildActivationStart = 11,
    // (undocumented)
    GuardsCheckEnd = 8,
    // (undocumented)
    GuardsCheckStart = 7,
    // (undocumented)
    NavigationCancel = 2,
    // (undocumented)
    NavigationEnd = 1,
    // (undocumented)
    NavigationError = 3,
    // (undocumented)
    NavigationSkipped = 16,
    // (undocumented)
    NavigationStart = 0,
    // (undocumented)
    ResolveEnd = 6,
    // (undocumented)
    ResolveStart = 5,
    // (undocumented)
    RouteConfigLoadEnd = 10,
    // (undocumented)
    RouteConfigLoadStart = 9,
    // (undocumented)
    RoutesRecognized = 4,
    // (undocumented)
    Scroll = 15
}

// @public
export interface ExtraOptions extends InMemoryScrollingOptions, RouterConfigOptions {
    bindToComponentInputs?: boolean;
    enableTracing?: boolean;
    enableViewTransitions?: boolean;
    errorHandler?: (error: any) => RedirectCommand | any;
    initialNavigation?: InitialNavigation;
    preloadingStrategy?: any;
    scrollOffset?: [number, number] | (() => [number, number]);
    useHash?: boolean;
}

// @public
export type GuardResult = boolean | UrlTree | RedirectCommand;

// @public
export class GuardsCheckEnd extends RouterEvent {
    constructor(
    id: number,
    url: string,
    urlAfterRedirects: string,
    state: RouterStateSnapshot,
    shouldActivate: boolean);
    // (undocumented)
    shouldActivate: boolean;
    // (undocumented)
    state: RouterStateSnapshot;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.GuardsCheckEnd;
    // (undocumented)
    urlAfterRedirects: string;
}

// @public
export class GuardsCheckStart extends RouterEvent {
    constructor(
    id: number,
    url: string,
    urlAfterRedirects: string,
    state: RouterStateSnapshot);
    // (undocumented)
    state: RouterStateSnapshot;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.GuardsCheckStart;
    // (undocumented)
    urlAfterRedirects: string;
}

// @public
export type InitialNavigation = 'disabled' | 'enabledBlocking' | 'enabledNonBlocking';

// @public
export type InitialNavigationFeature = EnabledBlockingInitialNavigationFeature | DisabledInitialNavigationFeature;

// @public
export type InMemoryScrollingFeature = RouterFeature<RouterFeatureKind.InMemoryScrollingFeature>;

// @public
export interface InMemoryScrollingOptions {
    anchorScrolling?: 'disabled' | 'enabled';
    scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';
}

// @public
export interface IsActiveMatchOptions {
    fragment: 'exact' | 'ignored';
    matrixParams: 'exact' | 'subset' | 'ignored';
    paths: 'exact' | 'subset';
    queryParams: 'exact' | 'subset' | 'ignored';
}

// @public
export type LoadChildren = LoadChildrenCallback;

// @public
export type LoadChildrenCallback = () => Type<any> | NgModuleFactory<any> | Routes | Observable<Type<any> | Routes | DefaultExport<Type<any>> | DefaultExport<Routes>> | Promise<NgModuleFactory<any> | Type<any> | Routes | DefaultExport<Type<any>> | DefaultExport<Routes>>;

// @public
export function mapToCanActivate(providers: Array<Type<CanActivate>>): CanActivateFn[];

// @public
export function mapToCanActivateChild(providers: Array<Type<CanActivateChild>>): CanActivateChildFn[];

// @public
export function mapToCanDeactivate<T = unknown>(providers: Array<Type<CanDeactivate<T>>>): CanDeactivateFn<T>[];

// @public
export function mapToCanMatch(providers: Array<Type<CanMatch>>): CanMatchFn[];

// @public
export function mapToResolve<T>(provider: Type<Resolve<T>>): ResolveFn<T>;

// @public
export type MaybeAsync<T> = T | Observable<T> | Promise<T>;

// @public
export interface Navigation {
    readonly abort: () => void;
    extractedUrl: UrlTree;
    extras: NavigationExtras;
    finalUrl?: UrlTree;
    id: number;
    initialUrl: UrlTree;
    previousNavigation: Navigation | null;
    trigger: NavigationTrigger;
}

// @public
export interface NavigationBehaviorOptions {
    readonly browserUrl?: UrlTree | string;
    readonly info?: unknown;
    onSameUrlNavigation?: OnSameUrlNavigation;
    replaceUrl?: boolean;
    skipLocationChange?: boolean;
    state?: {
        [k: string]: any;
    };
}

// @public
export class NavigationCancel extends RouterEvent {
    constructor(
    id: number,
    url: string,
    reason: string,
    code?: NavigationCancellationCode | undefined);
    readonly code?: NavigationCancellationCode | undefined;
    reason: string;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.NavigationCancel;
}

// @public
export enum NavigationCancellationCode {
    Aborted = 4,
    GuardRejected = 3,
    NoDataFromResolver = 2,
    Redirect = 0,
    SupersededByNewNavigation = 1
}

// @public
export class NavigationEnd extends RouterEvent {
    constructor(
    id: number,
    url: string,
    urlAfterRedirects: string);
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.NavigationEnd;
    // (undocumented)
    urlAfterRedirects: string;
}

// @public
export class NavigationError extends RouterEvent {
    constructor(
    id: number,
    url: string,
    error: any,
    target?: RouterStateSnapshot | undefined);
    // (undocumented)
    error: any;
    readonly target?: RouterStateSnapshot | undefined;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.NavigationError;
}

// @public
export type NavigationErrorHandlerFeature = RouterFeature<RouterFeatureKind.NavigationErrorHandlerFeature>;

// @public
export interface NavigationExtras extends UrlCreationOptions, NavigationBehaviorOptions {
}

// @public
export class NavigationSkipped extends RouterEvent {
    constructor(
    id: number,
    url: string,
    reason: string,
    code?: NavigationSkippedCode | undefined);
    readonly code?: NavigationSkippedCode | undefined;
    reason: string;
    // (undocumented)
    readonly type = EventType.NavigationSkipped;
}

// @public
export enum NavigationSkippedCode {
    IgnoredByUrlHandlingStrategy = 1,
    IgnoredSameUrlNavigation = 0
}

// @public
export class NavigationStart extends RouterEvent {
    constructor(
    id: number,
    url: string,
    navigationTrigger?: NavigationTrigger,
    restoredState?: {
        [k: string]: any;
        navigationId: number;
    } | null);
    navigationTrigger?: NavigationTrigger;
    restoredState?: {
        [k: string]: any;
        navigationId: number;
    } | null;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.NavigationStart;
}

// @public
export abstract class NonIndexStrategy {
    // (undocumented)
    buildNonIndex(snapshot: RouterStateSnapshot): boolean | undefined;
    getResolvedNonIndexForRoute(snapshot: ActivatedRouteSnapshot): boolean | undefined;
    abstract updateNonIndex(snapshot: RouterStateSnapshot): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NonIndexStrategy, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<NonIndexStrategy>;
}

// @public
export class NoPreloading implements PreloadingStrategy {
    // (undocumented)
    preload(route: Route, fn: () => Observable<any>): Observable<any>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NoPreloading, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<NoPreloading>;
}

// @public
export type OnSameUrlNavigation = 'reload' | 'ignore';

// @public
export class OutletContext {
    constructor(rootInjector: EnvironmentInjector);
    // (undocumented)
    attachRef: ComponentRef<any> | null;
    // (undocumented)
    children: ChildrenOutletContexts;
    // (undocumented)
    get injector(): EnvironmentInjector;
    // (undocumented)
    outlet: RouterOutletContract | null;
    // (undocumented)
    route: ActivatedRoute | null;
}

// @public
export interface ParamMap {
    get(name: string): string | null;
    getAll(name: string): string[];
    has(name: string): boolean;
    readonly keys: string[];
}

// @public
export type Params = {
    [key: string]: any;
};

// @public
export class PreloadAllModules implements PreloadingStrategy {
    // (undocumented)
    preload(route: Route, fn: () => Observable<any>): Observable<any>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<PreloadAllModules, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<PreloadAllModules>;
}

// @public
export type PreloadingFeature = RouterFeature<RouterFeatureKind.PreloadingFeature>;

// @public
export abstract class PreloadingStrategy {
    // (undocumented)
    abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;
}

// @public
export const PRIMARY_OUTLET = "primary";

// @public
export function provideRouter(routes: Routes, ...features: RouterFeatures[]): EnvironmentProviders;

// @public @deprecated
export function provideRoutes(routes: Routes): Provider[];

// @public
export type QueryParamsHandling = 'merge' | 'preserve' | 'replace' | '';

// @public
export class RedirectCommand {
    constructor(redirectTo: UrlTree, navigationBehaviorOptions?: NavigationBehaviorOptions | undefined);
    // (undocumented)
    readonly navigationBehaviorOptions?: NavigationBehaviorOptions | undefined;
    // (undocumented)
    readonly redirectTo: UrlTree;
}

// @public
export type RedirectFunction = (redirectData: Pick<ActivatedRouteSnapshot, 'routeConfig' | 'url' | 'params' | 'queryParams' | 'fragment' | 'data' | 'outlet' | 'title' | 'nonIndex'>) => MaybeAsync<string | UrlTree>;

// @public
export interface Resolve<T> {
    // (undocumented)
    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): MaybeAsync<T | RedirectCommand>;
}

// @public
export type ResolveData = {
    [key: string | symbol]: ResolveFn<unknown> | DeprecatedResolve;
};

// @public
export class ResolveEnd extends RouterEvent {
    constructor(
    id: number,
    url: string,
    urlAfterRedirects: string,
    state: RouterStateSnapshot);
    // (undocumented)
    state: RouterStateSnapshot;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.ResolveEnd;
    // (undocumented)
    urlAfterRedirects: string;
}

// @public
export type ResolveFn<T> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => MaybeAsync<T | RedirectCommand>;

// @public
export class ResolveStart extends RouterEvent {
    constructor(
    id: number,
    url: string,
    urlAfterRedirects: string,
    state: RouterStateSnapshot);
    // (undocumented)
    state: RouterStateSnapshot;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.ResolveStart;
    // (undocumented)
    urlAfterRedirects: string;
}

// @public
export interface Route {
    canActivate?: Array<CanActivateFn | DeprecatedGuard>;
    canActivateChild?: Array<CanActivateChildFn | DeprecatedGuard>;
    canDeactivate?: Array<CanDeactivateFn<any> | DeprecatedGuard>;
    // @deprecated
    canLoad?: Array<CanLoadFn | DeprecatedGuard>;
    canMatch?: Array<CanMatchFn | DeprecatedGuard>;
    children?: Routes;
    component?: Type<any>;
    data?: Data;
    loadChildren?: LoadChildren;
    loadComponent?: () => Type<unknown> | Observable<Type<unknown> | DefaultExport<Type<unknown>>> | Promise<Type<unknown> | DefaultExport<Type<unknown>>>;
    matcher?: UrlMatcher;
    nonIndex?: boolean | Type<Resolve<boolean>> | ResolveFn<boolean>;
    outlet?: string;
    path?: string;
    pathMatch?: 'prefix' | 'full';
    providers?: Array<Provider | EnvironmentProviders>;
    redirectTo?: string | RedirectFunction;
    resolve?: ResolveData;
    runGuardsAndResolvers?: RunGuardsAndResolvers;
    title?: string | Type<Resolve<string>> | ResolveFn<string>;
}

// @public
export class RouteConfigLoadEnd {
    constructor(
    route: Route);
    // (undocumented)
    route: Route;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.RouteConfigLoadEnd;
}

// @public
export class RouteConfigLoadStart {
    constructor(
    route: Route);
    // (undocumented)
    route: Route;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.RouteConfigLoadStart;
}

// @public
export class Router {
    constructor();
    readonly componentInputBindingEnabled: boolean;
    // (undocumented)
    config: Routes;
    createUrlTree(commands: readonly any[], navigationExtras?: UrlCreationOptions): UrlTree;
    dispose(): void;
    get events(): Observable<Event_2>;
    getCurrentNavigation(): Navigation | null;
    initialNavigation(): void;
    // @deprecated
    isActive(url: string | UrlTree, exact: boolean): boolean;
    isActive(url: string | UrlTree, matchOptions: IsActiveMatchOptions): boolean;
    get lastSuccessfulNavigation(): Navigation | null;
    navigate(commands: readonly any[], extras?: NavigationExtras): Promise<boolean>;
    navigateByUrl(url: string | UrlTree, extras?: NavigationBehaviorOptions): Promise<boolean>;
    navigated: boolean;
    ngOnDestroy(): void;
    // @deprecated
    onSameUrlNavigation: OnSameUrlNavigation;
    parseUrl(url: string): UrlTree;
    resetConfig(config: Routes): void;
    // @deprecated
    routeReuseStrategy: RouteReuseStrategy;
    get routerState(): RouterState;
    serializeUrl(url: UrlTree): string;
    setUpLocationChangeListener(): void;
    get url(): string;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<Router, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<Router>;
}

// @public
export const ROUTER_CONFIGURATION: InjectionToken<ExtraOptions>;

// @public
export const ROUTER_INITIALIZER: InjectionToken<(compRef: ComponentRef<any>) => void>;

// @public
export const ROUTER_OUTLET_DATA: InjectionToken<Signal<unknown>>;

// @public
export interface RouterConfigOptions {
    canceledNavigationResolution?: 'replace' | 'computed';
    defaultQueryParamsHandling?: QueryParamsHandling;
    onSameUrlNavigation?: OnSameUrlNavigation;
    paramsInheritanceStrategy?: 'emptyOnly' | 'always';
    resolveNavigationPromiseOnError?: boolean;
    urlUpdateStrategy?: 'deferred' | 'eager';
}

// @public
export type RouterConfigurationFeature = RouterFeature<RouterFeatureKind.RouterConfigurationFeature>;

// @public
export abstract class RouteReuseStrategy {
    abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;
    abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;
    abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;
    abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;
    abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<RouteReuseStrategy, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<RouteReuseStrategy>;
}

// @public
export class RouterEvent {
    constructor(
    id: number,
    url: string);
    id: number;
    url: string;
}

// @public
export interface RouterFeature<FeatureKind extends RouterFeatureKind> {
    // (undocumented)
    ɵkind: FeatureKind;
    // (undocumented)
    ɵproviders: Array<Provider | EnvironmentProviders>;
}

// @public
export type RouterFeatures = PreloadingFeature | DebugTracingFeature | InitialNavigationFeature | InMemoryScrollingFeature | RouterConfigurationFeature | NavigationErrorHandlerFeature | ComponentInputBindingFeature | ViewTransitionsFeature | RouterHashLocationFeature;

// @public
export type RouterHashLocationFeature = RouterFeature<RouterFeatureKind.RouterHashLocationFeature>;

// @public
class RouterLink implements OnChanges, OnDestroy {
    constructor(router: Router, route: ActivatedRoute, tabIndexAttribute: string | null | undefined, renderer: Renderer2, el: ElementRef, locationStrategy?: LocationStrategy | undefined);
    fragment?: string;
    get href(): string | null;
    set href(value: string | null);
    info?: unknown;
    // (undocumented)
    static ngAcceptInputType_preserveFragment: unknown;
    // (undocumented)
    static ngAcceptInputType_replaceUrl: unknown;
    // (undocumented)
    static ngAcceptInputType_skipLocationChange: unknown;
    ngOnChanges(changes?: SimpleChanges): void;
    ngOnDestroy(): any;
    onClick(button: number, ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean): boolean;
    preserveFragment: boolean;
    queryParams?: Params | null;
    queryParamsHandling?: QueryParamsHandling | null;
    // (undocumented)
    protected readonly reactiveHref: i0.WritableSignal<string | null>;
    relativeTo?: ActivatedRoute | null;
    replaceUrl: boolean;
    set routerLink(commandsOrUrlTree: readonly any[] | string | UrlTree | null | undefined);
    skipLocationChange: boolean;
    state?: {
        [k: string]: any;
    };
    target?: string;
    // (undocumented)
    get urlTree(): UrlTree | null;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<RouterLink, "[routerLink]", never, { "target": { "alias": "target"; "required": false; }; "queryParams": { "alias": "queryParams"; "required": false; }; "fragment": { "alias": "fragment"; "required": false; }; "queryParamsHandling": { "alias": "queryParamsHandling"; "required": false; }; "state": { "alias": "state"; "required": false; }; "info": { "alias": "info"; "required": false; }; "relativeTo": { "alias": "relativeTo"; "required": false; }; "preserveFragment": { "alias": "preserveFragment"; "required": false; }; "skipLocationChange": { "alias": "skipLocationChange"; "required": false; }; "replaceUrl": { "alias": "replaceUrl"; "required": false; }; "routerLink": { "alias": "routerLink"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterLink, [null, null, { attribute: "tabindex"; }, null, null, null]>;
}
export { RouterLink }
export { RouterLink as RouterLinkWithHref }

// @public
export class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit {
    constructor(router: Router, element: ElementRef, renderer: Renderer2, cdr: ChangeDetectorRef, link?: RouterLink | undefined);
    ariaCurrentWhenActive?: 'page' | 'step' | 'location' | 'date' | 'time' | true | false;
    // (undocumented)
    get isActive(): boolean;
    readonly isActiveChange: EventEmitter<boolean>;
    // (undocumented)
    links: QueryList<RouterLink>;
    ngAfterContentInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    // (undocumented)
    set routerLinkActive(data: string[] | string);
    routerLinkActiveOptions: {
        exact: boolean;
    } | IsActiveMatchOptions;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<RouterLinkActive, "[routerLinkActive]", ["routerLinkActive"], { "routerLinkActiveOptions": { "alias": "routerLinkActiveOptions"; "required": false; }; "ariaCurrentWhenActive": { "alias": "ariaCurrentWhenActive"; "required": false; }; "routerLinkActive": { "alias": "routerLinkActive"; "required": false; }; }, { "isActiveChange": "isActiveChange"; }, ["links"], never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterLinkActive, [null, null, null, null, { optional: true; }]>;
}

// @public
export class RouterModule {
    constructor();
    static forChild(routes: Routes): ModuleWithProviders<RouterModule>;
    static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterModule>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<RouterModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<RouterModule, never, [typeof RouterOutlet, typeof RouterLink, typeof RouterLinkActive, typeof ɵEmptyOutletComponent], [typeof RouterOutlet, typeof RouterLink, typeof RouterLinkActive, typeof ɵEmptyOutletComponent]>;
}

// @public
export class RouterOutlet implements OnDestroy, OnInit, RouterOutletContract {
    // (undocumented)
    get activatedRoute(): ActivatedRoute;
    // (undocumented)
    get activatedRouteData(): Data;
    // (undocumented)
    activateEvents: EventEmitter<any>;
    // (undocumented)
    activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector): void;
    attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void;
    attachEvents: EventEmitter<unknown>;
    // (undocumented)
    get component(): Object;
    // (undocumented)
    deactivate(): void;
    // (undocumented)
    deactivateEvents: EventEmitter<any>;
    detach(): ComponentRef<any>;
    detachEvents: EventEmitter<unknown>;
    // (undocumented)
    get isActivated(): boolean;
    name: string;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    ngOnInit(): void;
    readonly routerOutletData: i0.InputSignal<unknown>;
    readonly supportsBindingToComponentInputs = true;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<RouterOutlet, "router-outlet", ["outlet"], { "name": { "alias": "name"; "required": false; }; "routerOutletData": { "alias": "routerOutletData"; "required": false; "isSignal": true; }; }, { "activateEvents": "activate"; "deactivateEvents": "deactivate"; "attachEvents": "attach"; "detachEvents": "detach"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterOutlet, never>;
}

// @public
export interface RouterOutletContract {
    activatedRoute: ActivatedRoute | null;
    activatedRouteData: Data;
    activateEvents?: EventEmitter<unknown>;
    activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector): void;
    attach(ref: ComponentRef<unknown>, activatedRoute: ActivatedRoute): void;
    attachEvents?: EventEmitter<unknown>;
    component: Object | null;
    deactivate(): void;
    deactivateEvents?: EventEmitter<unknown>;
    detach(): ComponentRef<unknown>;
    detachEvents?: EventEmitter<unknown>;
    isActivated: boolean;
    readonly supportsBindingToComponentInputs?: true;
}

// @public
export class RouterPreloader implements OnDestroy {
    constructor(router: Router, injector: EnvironmentInjector, preloadingStrategy: PreloadingStrategy, loader: RouterConfigLoader);
    ngOnDestroy(): void;
    // (undocumented)
    preload(): Observable<any>;
    // (undocumented)
    setUpPreloading(): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterPreloader, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<RouterPreloader>;
}

// @public
export class RouterState extends Tree<ActivatedRoute> {
    snapshot: RouterStateSnapshot;
    // (undocumented)
    toString(): string;
}

// @public
export class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {
    // (undocumented)
    toString(): string;
    url: string;
}

// @public
export const ROUTES: InjectionToken<Route[][]>;

// @public
export type Routes = Route[];

// @public
export class RoutesRecognized extends RouterEvent {
    constructor(
    id: number,
    url: string,
    urlAfterRedirects: string,
    state: RouterStateSnapshot);
    // (undocumented)
    state: RouterStateSnapshot;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.RoutesRecognized;
    // (undocumented)
    urlAfterRedirects: string;
}

// @public
export type RunGuardsAndResolvers = 'pathParamsChange' | 'pathParamsOrQueryParamsChange' | 'paramsChange' | 'paramsOrQueryParamsChange' | 'always' | ((from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) => boolean);

// @public
export class Scroll {
    constructor(
    routerEvent: NavigationEnd | NavigationSkipped,
    position: [number, number] | null,
    anchor: string | null);
    // (undocumented)
    readonly anchor: string | null;
    // (undocumented)
    readonly position: [number, number] | null;
    // (undocumented)
    readonly routerEvent: NavigationEnd | NavigationSkipped;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type = EventType.Scroll;
}

// @public
export abstract class TitleStrategy {
    // (undocumented)
    buildTitle(snapshot: RouterStateSnapshot): string | undefined;
    getResolvedTitleForRoute(snapshot: ActivatedRouteSnapshot): any;
    abstract updateTitle(snapshot: RouterStateSnapshot): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<TitleStrategy, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<TitleStrategy>;
}

// @public
export interface UrlCreationOptions {
    fragment?: string;
    preserveFragment?: boolean;
    queryParams?: Params | null;
    queryParamsHandling?: QueryParamsHandling | null;
    relativeTo?: ActivatedRoute | null;
}

// @public
export abstract class UrlHandlingStrategy {
    abstract extract(url: UrlTree): UrlTree;
    abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;
    abstract shouldProcessUrl(url: UrlTree): boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<UrlHandlingStrategy, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<UrlHandlingStrategy>;
}

// @public
export type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) => UrlMatchResult | null;

// @public
export type UrlMatchResult = {
    consumed: UrlSegment[];
    posParams?: {
        [name: string]: UrlSegment;
    };
};

// @public
export class UrlSegment {
    constructor(
    path: string,
    parameters: {
        [name: string]: string;
    });
    // (undocumented)
    get parameterMap(): ParamMap;
    parameters: {
        [name: string]: string;
    };
    path: string;
    // (undocumented)
    toString(): string;
}

// @public
export class UrlSegmentGroup {
    constructor(
    segments: UrlSegment[],
    children: {
        [key: string]: UrlSegmentGroup;
    });
    children: {
        [key: string]: UrlSegmentGroup;
    };
    hasChildren(): boolean;
    get numberOfChildren(): number;
    parent: UrlSegmentGroup | null;
    segments: UrlSegment[];
    // (undocumented)
    toString(): string;
}

// @public
export abstract class UrlSerializer {
    abstract parse(url: string): UrlTree;
    abstract serialize(tree: UrlTree): string;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<UrlSerializer, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<UrlSerializer>;
}

// @public
export class UrlTree {
    constructor(
    root?: UrlSegmentGroup,
    queryParams?: Params,
    fragment?: string | null);
    fragment: string | null;
    // (undocumented)
    get queryParamMap(): ParamMap;
    queryParams: Params;
    root: UrlSegmentGroup;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export const VERSION: Version;

// @public
export interface ViewTransitionInfo {
    from: ActivatedRouteSnapshot;
    to: ActivatedRouteSnapshot;
    transition: ViewTransition;
}

// @public
export type ViewTransitionsFeature = RouterFeature<RouterFeatureKind.ViewTransitionsFeature>;

// @public
export interface ViewTransitionsFeatureOptions {
    onViewTransitionCreated?: (transitionInfo: ViewTransitionInfo) => void;
    skipInitialTransition?: boolean;
}

// @public
export function withComponentInputBinding(): ComponentInputBindingFeature;

// @public
export function withDebugTracing(): DebugTracingFeature;

// @public
export function withDisabledInitialNavigation(): DisabledInitialNavigationFeature;

// @public
export function withEnabledBlockingInitialNavigation(): EnabledBlockingInitialNavigationFeature;

// @public
export function withHashLocation(): RouterHashLocationFeature;

// @public
export function withInMemoryScrolling(options?: InMemoryScrollingOptions): InMemoryScrollingFeature;

// @public
export function withNavigationErrorHandler(handler: (error: NavigationError) => unknown | RedirectCommand): NavigationErrorHandlerFeature;

// @public
export function withPreloading(preloadingStrategy: Type<PreloadingStrategy>): PreloadingFeature;

// @public
export function withRouterConfig(options: RouterConfigOptions): RouterConfigurationFeature;

// @public
export function withViewTransitions(options?: ViewTransitionsFeatureOptions): ViewTransitionsFeature;

// (No @packageDocumentation comment for this package)

```
