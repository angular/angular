## API Report File for "@angular/core_primitives_signals"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export type ComputationFn<S, D> = (source: S, previous?: {
    source: S;
    value: D;
}) => D;

// @public
export interface ComputedNode<T> extends ReactiveNode, Consumer, Signal {
    computation: () => T;
    // (undocumented)
    equal: ValueEqualityFn<T>;
    error: unknown;
    value: T;
}

// @public
export interface Consumer {
    addProducer: (signal: Signal) => void;
}

// @public (undocumented)
export const CONSUMER_NODE: Consumer;

// @public
export function consumerAfterComputation(node: ReactiveNode | null, prevConsumer: Consumer | null): void;

// @public
export function consumerBeforeComputation(node: (ReactiveNode & Consumer) | null): Consumer | null;

// @public
export function consumerDestroy(node: ReactiveNode): void;

// @public (undocumented)
export function consumerMarkDirty(node: ReactiveNode): void;

// @public
export function consumerPollProducersForChange(node: ReactiveNode): boolean;

// @public
export function createComputed<T>(computation: () => T, equal?: ValueEqualityFn<T>): ComputedGetter<T>;

// @public (undocumented)
export function createLinkedSignal<S, D>(sourceFn: () => S, computationFn: ComputationFn<S, D>, equalityFn?: ValueEqualityFn<D>): LinkedSignalGetter<S, D>;

// @public
export function createSignal<T>(initialValue: T, equal?: ValueEqualityFn<T>): SignalGetter<T>;

// @public (undocumented)
export function createWatch(fn: (onCleanup: WatchCleanupRegisterFn) => void, schedule: (watch: Watch) => void, allowSignalWrites: boolean): Watch;

// @public
export function defaultEquals<T>(a: T, b: T): boolean;

// @public
export const getActiveConsumer: () => Consumer | null;

// @public (undocumented)
export function isInNotificationPhase(): boolean;

// @public (undocumented)
export function isReactive(value: unknown): value is Reactive;

// @public (undocumented)
export type LinkedSignalGetter<S, D> = (() => D) & {
    [SIGNAL]: LinkedSignalNode<S, D>;
};

// @public (undocumented)
export interface LinkedSignalNode<S, D> extends ReactiveNode, Consumer, Signal {
    computation: ComputationFn<S, D>;
    // (undocumented)
    equal: ValueEqualityFn<D>;
    error: unknown;
    source: () => S;
    sourceValue: S;
    value: D;
}

// @public (undocumented)
export function linkedSignalSetFn<S, D>(node: LinkedSignalNode<S, D>, newValue: D): void;

// @public (undocumented)
export function linkedSignalUpdateFn<S, D>(node: LinkedSignalNode<S, D>, updater: (value: D) => D): void;

// @public (undocumented)
export const PRODUCER_NODE: Signal;

// @public
export function producerAccessed<T>(node: ReactiveNode & Signal): void;

// @public
export function producerIncrementEpoch(): void;

// @public (undocumented)
export function producerMarkClean(node: ReactiveNode): void;

// @public
export function producerNotifyConsumers(node: ReactiveNode): void;

// @public
export function producerUpdatesAllowed(): boolean;

// @public
export function producerUpdateValueVersion(node: ReactiveNode): void;

// @public (undocumented)
export interface Reactive {
    // (undocumented)
    [SIGNAL]: ReactiveNode;
}

// @public (undocumented)
export const REACTIVE_NODE: ReactiveNode;

// @public
export interface ReactiveNode {
    consumerAllowSignalWrites: boolean;
    // (undocumented)
    readonly consumerIsAlwaysLive: boolean;
    // (undocumented)
    consumerMarkedDirty(node: unknown): void;
    consumerOnSignalRead(node: unknown): void;
    debugName?: string;
    dirty: boolean;
    hasInteropSignalDep: boolean;
    kind: string;
    lastCleanEpoch: Version;
    liveConsumerIndexOfThis: number[] | undefined;
    liveConsumerNode: ReactiveNode[] | undefined;
    nextProducerIndex: number;
    producerIndexOfThis: number[] | undefined;
    producerLastReadVersion: Version[] | undefined;
    producerMustRecompute(node: unknown): boolean;
    producerNode: ReactiveNode[] | undefined;
    producerOnAccess?(): void;
    // (undocumented)
    producerRecomputeValue(node: unknown): void;
    unwatched?(): void;
    version: Version;
    watched?(): void;
}

// @public (undocumented)
export function runPostSignalSetFn(): void;

// @public
export const setActiveConsumer: (consumer: Consumer | null) => Consumer | null;

// @public
export function setAlternateWeakRefImpl(impl: unknown): void;

// @public (undocumented)
export function setPostSignalSetFn(fn: (() => void) | null): (() => void) | null;

// @public (undocumented)
export function setThrowInvalidWriteToSignalError(fn: <T>(node: SignalNode<T>) => never): void;

// @public
export const SIGNAL: unique symbol;

// @public (undocumented)
export const SIGNAL_NODE: SignalNode<unknown>;

// @public (undocumented)
export interface SignalGetter<T> extends SignalBaseGetter<T> {
    // (undocumented)
    readonly [SIGNAL]: SignalNode<T>;
}

// @public (undocumented)
export interface SignalNode<T> extends ReactiveNode, Signal {
    // (undocumented)
    equal: ValueEqualityFn<T>;
    // (undocumented)
    value: T;
}

// @public (undocumented)
export function signalSetFn<T>(node: SignalNode<T>, newValue: T): void;

// @public (undocumented)
export function signalUpdateFn<T>(node: SignalNode<T>, updater: (value: T) => T): void;

// @public
export function untracked<T>(nonReactiveReadsFn: () => T): T;

// @public
export type ValueEqualityFn<T> = (a: T, b: T) => boolean;

// @public (undocumented)
export interface Watch {
    // (undocumented)
    [SIGNAL]: WatchNode;
    // (undocumented)
    cleanup(): void;
    destroy(): void;
    // (undocumented)
    notify(): void;
    run(): void;
}

// @public
export type WatchCleanupFn = () => void;

// @public
export type WatchCleanupRegisterFn = (cleanupFn: WatchCleanupFn) => void;

// (No @packageDocumentation comment for this package)

```
