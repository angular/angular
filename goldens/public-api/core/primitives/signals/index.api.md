## API Report File for "@angular/core_primitives_signals"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export interface ComputedNode<T> extends ReactiveNode {
    computation: () => T;
    // (undocumented)
    equal: ValueEqualityFn<T>;
    error: unknown;
    value: T;
}

// @public
export function consumerAfterComputation(node: ReactiveNode | null, prevConsumer: ReactiveNode | null): void;

// @public
export function consumerBeforeComputation(node: ReactiveNode | null): ReactiveNode | null;

// @public
export function consumerDestroy(node: ReactiveNode): void;

// @public (undocumented)
export function consumerMarkDirty(node: ReactiveNode): void;

// @public
export function consumerPollProducersForChange(node: ReactiveNode): boolean;

// @public
export function createComputed<T>(computation: () => T): ComputedGetter<T>;

// @public
export function createSignal<T>(initialValue: T): SignalGetter<T>;

// @public (undocumented)
export function createWatch(fn: (onCleanup: WatchCleanupRegisterFn) => void, schedule: (watch: Watch) => void, allowSignalWrites: boolean): Watch;

// @public
export function defaultEquals<T>(a: T, b: T): boolean;

// @public (undocumented)
export function getActiveConsumer(): ReactiveNode | null;

// @public (undocumented)
export function isInNotificationPhase(): boolean;

// @public (undocumented)
export function isReactive(value: unknown): value is Reactive;

// @public
export function producerAccessed(node: ReactiveNode): void;

// @public
export function producerIncrementEpoch(): void;

// @public
export function producerNotifyConsumers(node: ReactiveNode): void;

// @public
export function producerUpdatesAllowed(): boolean;

// @public
export function producerUpdateValueVersion(node: ReactiveNode): void;

// @public (undocumented)
export interface Reactive {
    // (undocumented)
    [SIGNAL]: ReactiveNode;
}

// @public (undocumented)
export const REACTIVE_NODE: ReactiveNode;

// @public
export interface ReactiveNode {
    consumerAllowSignalWrites: boolean;
    // (undocumented)
    readonly consumerIsAlwaysLive: boolean;
    // (undocumented)
    consumerMarkedDirty(node: unknown): void;
    consumerOnSignalRead(node: unknown): void;
    debugName?: string;
    dirty: boolean;
    lastCleanEpoch: Version;
    liveConsumerIndexOfThis: number[] | undefined;
    liveConsumerNode: ReactiveNode[] | undefined;
    nextProducerIndex: number;
    producerIndexOfThis: number[] | undefined;
    producerLastReadVersion: Version[] | undefined;
    producerMustRecompute(node: unknown): boolean;
    producerNode: ReactiveNode[] | undefined;
    // (undocumented)
    producerRecomputeValue(node: unknown): void;
    version: Version;
}

// @public (undocumented)
export function runPostSignalSetFn(): void;

// @public (undocumented)
export function setActiveConsumer(consumer: ReactiveNode | null): ReactiveNode | null;

// @public (undocumented)
export function setAlternateWeakRefImpl(impl: unknown): void;

// @public (undocumented)
export function setPostSignalSetFn(fn: (() => void) | null): (() => void) | null;

// @public (undocumented)
export function setThrowInvalidWriteToSignalError(fn: () => never): void;

// @public
export const SIGNAL: unique symbol;

// @public (undocumented)
export const SIGNAL_NODE: SignalNode<unknown>;

// @public (undocumented)
export interface SignalGetter<T> extends SignalBaseGetter<T> {
    // (undocumented)
    readonly [SIGNAL]: SignalNode<T>;
}

// @public (undocumented)
export interface SignalNode<T> extends ReactiveNode {
    // (undocumented)
    equal: ValueEqualityFn<T>;
    // (undocumented)
    value: T;
}

// @public (undocumented)
export function signalSetFn<T>(node: SignalNode<T>, newValue: T): void;

// @public (undocumented)
export function signalUpdateFn<T>(node: SignalNode<T>, updater: (value: T) => T): void;

// @public
export type ValueEqualityFn<T> = (a: T, b: T) => boolean;

// @public (undocumented)
export interface Watch {
    // (undocumented)
    [SIGNAL]: WatchNode;
    // (undocumented)
    cleanup(): void;
    destroy(): void;
    // (undocumented)
    notify(): void;
    run(): void;
}

// @public
export type WatchCleanupFn = () => void;

// @public
export type WatchCleanupRegisterFn = (cleanupFn: WatchCleanupFn) => void;

// (No @packageDocumentation comment for this package)

```
