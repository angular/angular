## API Report File for "@angular/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EnvironmentProviders as EnvironmentProviders_2 } from '@angular/core';
import { Observable } from 'rxjs';
import { SIGNAL } from '@angular/core/primitives/signals';
import { SignalNode } from '@angular/core/primitives/signals';
import { Subject } from 'rxjs';
import { Subscription } from 'rxjs';

// @public
export interface AbstractType<T> extends Function {
    // (undocumented)
    prototype: T;
}

// @public
export interface AfterContentChecked {
    ngAfterContentChecked(): void;
}

// @public
export interface AfterContentInit {
    ngAfterContentInit(): void;
}

// @public
export function afterNextRender<E = never, W = never, M = never>(spec: {
    earlyRead?: () => E;
    write?: (...args: ɵFirstAvailable<[E]>) => W;
    mixedReadWrite?: (...args: ɵFirstAvailable<[W, E]>) => M;
    read?: (...args: ɵFirstAvailable<[M, W, E]>) => void;
}, options?: Omit<AfterRenderOptions, 'phase'>): AfterRenderRef;

// @public
export function afterNextRender(callback: VoidFunction, options?: AfterRenderOptions): AfterRenderRef;

// @public
export function afterRender<E = never, W = never, M = never>(spec: {
    earlyRead?: () => E;
    write?: (...args: ɵFirstAvailable<[E]>) => W;
    mixedReadWrite?: (...args: ɵFirstAvailable<[W, E]>) => M;
    read?: (...args: ɵFirstAvailable<[M, W, E]>) => void;
}, options?: Omit<AfterRenderOptions, 'phase'>): AfterRenderRef;

// @public
export function afterRender(callback: VoidFunction, options?: AfterRenderOptions): AfterRenderRef;

// @public
export function afterRenderEffect(callback: (onCleanup: EffectCleanupRegisterFn) => void, options?: Omit<AfterRenderOptions, 'phase'>): AfterRenderRef;

// @public
export function afterRenderEffect<E = never, W = never, M = never>(spec: {
    earlyRead?: (onCleanup: EffectCleanupRegisterFn) => E;
    write?: (...args: [...ɵFirstAvailableSignal<[E]>, EffectCleanupRegisterFn]) => W;
    mixedReadWrite?: (...args: [...ɵFirstAvailableSignal<[W, E]>, EffectCleanupRegisterFn]) => M;
    read?: (...args: [...ɵFirstAvailableSignal<[M, W, E]>, EffectCleanupRegisterFn]) => void;
}, options?: Omit<AfterRenderOptions, 'phase'>): AfterRenderRef;

// @public
export interface AfterRenderOptions {
    injector?: Injector;
    manualCleanup?: boolean;
    // @deprecated
    phase?: AfterRenderPhase;
}

// @public @deprecated
export enum AfterRenderPhase {
    EarlyRead = 0,
    MixedReadWrite = 2,
    Read = 3,
    Write = 1
}

// @public
export interface AfterRenderRef {
    destroy(): void;
}

// @public
export interface AfterViewChecked {
    ngAfterViewChecked(): void;
}

// @public
export interface AfterViewInit {
    ngAfterViewInit(): void;
}

// @public
export const ANIMATION_MODULE_TYPE: InjectionToken<"NoopAnimations" | "BrowserAnimations">;

// @public
export const APP_BOOTSTRAP_LISTENER: InjectionToken<readonly ((compRef: ComponentRef<any>) => void)[]>;

// @public
export const APP_ID: InjectionToken<string>;

// @public @deprecated
export const APP_INITIALIZER: InjectionToken<readonly (() => Observable<unknown> | Promise<unknown> | void)[]>;

// @public
export interface ApplicationConfig {
    providers: Array<Provider | EnvironmentProviders>;
}

// @public
export class ApplicationInitStatus {
    constructor();
    // (undocumented)
    readonly done = false;
    // (undocumented)
    readonly donePromise: Promise<any>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ApplicationInitStatus, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<ApplicationInitStatus>;
}

// @public
export class ApplicationModule {
    constructor(appRef: ApplicationRef);
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ApplicationModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<ApplicationModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<ApplicationModule, never, never, never>;
}

// @public
export class ApplicationRef {
    constructor();
    attachView(viewRef: ViewRef): void;
    bootstrap<C>(component: Type<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;
    // @deprecated
    bootstrap<C>(componentFactory: ComponentFactory<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;
    readonly components: ComponentRef<any>[];
    readonly componentTypes: Type<any>[];
    destroy(): void;
    get destroyed(): boolean;
    detachView(viewRef: ViewRef): void;
    get injector(): EnvironmentInjector;
    readonly isStable: Observable<boolean>;
    onDestroy(callback: () => void): VoidFunction;
    tick(): void;
    get viewCount(): number;
    // (undocumented)
    whenStable(): Promise<void>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ApplicationRef, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<ApplicationRef>;
}

// @public (undocumented)
export function asNativeElements(debugEls: DebugElement[]): any;

// @public
export function assertInInjectionContext(debugFn: Function): void;

// @public
export function assertNotInReactiveContext(debugFn: Function, extraContext?: string): void;

// @public
export function assertPlatform(requiredToken: any): PlatformRef;

// @public
export interface Attribute {
    attributeName: string;
}

// @public
export const Attribute: AttributeDecorator;

// @public
export interface AttributeDecorator {
    (name: string): any;
    // (undocumented)
    new (name: string): Attribute;
}

// @public
export interface BaseResourceOptions<T, R> {
    defaultValue?: NoInfer<T>;
    equal?: ValueEqualityFn<T>;
    injector?: Injector;
    request?: () => R;
}

// @public
export function booleanAttribute(value: unknown): boolean;

// @public
export interface BootstrapOptions {
    // @deprecated
    ignoreChangesOutsideZone?: boolean;
    ngZone?: NgZone | 'zone.js' | 'noop';
    ngZoneEventCoalescing?: boolean;
    ngZoneRunCoalescing?: boolean;
}

// @public
export enum ChangeDetectionStrategy {
    Default = 1,
    OnPush = 0
}

// @public
export abstract class ChangeDetectorRef {
    // @deprecated
    abstract checkNoChanges(): void;
    abstract detach(): void;
    abstract detectChanges(): void;
    abstract markForCheck(): void;
    abstract reattach(): void;
}

// @public
export interface ClassProvider extends ClassSansProvider {
    multi?: boolean;
    provide: any;
}

// @public
export interface ClassSansProvider {
    useClass: Type<any>;
}

// @public @deprecated
export class Compiler {
    clearCache(): void;
    clearCacheFor(type: Type<any>): void;
    compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;
    compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;
    compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;
    compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;
    getModuleId(moduleType: Type<any>): string | undefined;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<Compiler, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<Compiler>;
}

// @public
export const COMPILER_OPTIONS: InjectionToken<CompilerOptions[]>;

// @public @deprecated
export abstract class CompilerFactory {
    // (undocumented)
    abstract createCompiler(options?: CompilerOptions[]): Compiler;
}

// @public
export type CompilerOptions = {
    defaultEncapsulation?: ViewEncapsulation;
    providers?: StaticProvider[];
    preserveWhitespaces?: boolean;
};

// @public
export interface Component extends Directive {
    animations?: any[];
    changeDetection?: ChangeDetectionStrategy;
    encapsulation?: ViewEncapsulation;
    imports?: (Type<any> | ReadonlyArray<any>)[];
    // @deprecated
    interpolation?: [string, string];
    // @deprecated
    moduleId?: string;
    preserveWhitespaces?: boolean;
    schemas?: SchemaMetadata[];
    standalone?: boolean;
    styles?: string | string[];
    styleUrl?: string;
    styleUrls?: string[];
    template?: string;
    templateUrl?: string;
    viewProviders?: Provider[];
}

// @public
export const Component: ComponentDecorator;

// @public
export interface ComponentDecorator {
    (obj: Component): TypeDecorator;
    new (obj: Component): Component;
}

// @public @deprecated
export abstract class ComponentFactory<C> {
    abstract get componentType(): Type<any>;
    abstract create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, environmentInjector?: EnvironmentInjector | NgModuleRef<any>): ComponentRef<C>;
    abstract get inputs(): {
        propName: string;
        templateName: string;
        transform?: (value: any) => any;
        isSignal: boolean;
    }[];
    abstract get ngContentSelectors(): string[];
    abstract get outputs(): {
        propName: string;
        templateName: string;
    }[];
    abstract get selector(): string;
}

// @public @deprecated
export abstract class ComponentFactoryResolver {
    // (undocumented)
    static NULL: ComponentFactoryResolver;
    abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;
}

// @public
export interface ComponentMirror<C> {
    get inputs(): ReadonlyArray<{
        readonly propName: string;
        readonly templateName: string;
        readonly transform?: (value: any) => any;
        readonly isSignal: boolean;
    }>;
    get isStandalone(): boolean;
    get ngContentSelectors(): ReadonlyArray<string>;
    get outputs(): ReadonlyArray<{
        readonly propName: string;
        readonly templateName: string;
    }>;
    get selector(): string;
    get type(): Type<C>;
}

// @public
export abstract class ComponentRef<C> {
    abstract get changeDetectorRef(): ChangeDetectorRef;
    abstract get componentType(): Type<any>;
    abstract destroy(): void;
    abstract get hostView(): ViewRef;
    abstract get injector(): Injector;
    abstract get instance(): C;
    abstract get location(): ElementRef;
    abstract onDestroy(callback: Function): void;
    abstract setInput(name: string, value: unknown): void;
}

// @public
export function computed<T>(computation: () => T, options?: CreateComputedOptions<T>): Signal<T>;

// @public
export interface ConstructorProvider extends ConstructorSansProvider {
    multi?: boolean;
    provide: Type<any>;
}

// @public
export interface ConstructorSansProvider {
    deps?: any[];
}

// @public
export type ContentChild = Query;

// @public
export const ContentChild: ContentChildDecorator;

// @public
export const contentChild: ContentChildFunction;

// @public
export interface ContentChildDecorator {
    (selector: ProviderToken<unknown> | Function | string, opts?: {
        descendants?: boolean;
        read?: any;
        static?: boolean;
    }): any;
    // (undocumented)
    new (selector: ProviderToken<unknown> | Function | string, opts?: {
        descendants?: boolean;
        read?: any;
        static?: boolean;
    }): ContentChild;
}

// @public
export interface ContentChildFunction {
    <LocatorT>(locator: ProviderToken<LocatorT> | string, opts?: {
        descendants?: boolean;
        read?: undefined;
        debugName?: string;
    }): Signal<LocatorT | undefined>;
    // (undocumented)
    <LocatorT, ReadT>(locator: ProviderToken<LocatorT> | string, opts: {
        descendants?: boolean;
        read: ProviderToken<ReadT>;
        debugName?: string;
    }): Signal<ReadT | undefined>;
    required: {
        <LocatorT>(locator: ProviderToken<LocatorT> | string, opts?: {
            descendants?: boolean;
            read?: undefined;
            debugName?: string;
        }): Signal<LocatorT>;
        <LocatorT, ReadT>(locator: ProviderToken<LocatorT> | string, opts: {
            descendants?: boolean;
            read: ProviderToken<ReadT>;
            debugName?: string;
        }): Signal<ReadT>;
    };
}

// @public
export type ContentChildren = Query;

// @public
export const ContentChildren: ContentChildrenDecorator;

// @public (undocumented)
export function contentChildren<LocatorT>(locator: ProviderToken<LocatorT> | string, opts?: {
    descendants?: boolean;
    read?: undefined;
    debugName?: string;
}): Signal<ReadonlyArray<LocatorT>>;

// @public (undocumented)
export function contentChildren<LocatorT, ReadT>(locator: ProviderToken<LocatorT> | string, opts: {
    descendants?: boolean;
    read: ProviderToken<ReadT>;
    debugName?: string;
}): Signal<ReadonlyArray<ReadT>>;

// @public
export interface ContentChildrenDecorator {
    (selector: ProviderToken<unknown> | Function | string, opts?: {
        descendants?: boolean;
        emitDistinctChangesOnly?: boolean;
        read?: any;
    }): any;
    // (undocumented)
    new (selector: ProviderToken<unknown> | Function | string, opts?: {
        descendants?: boolean;
        emitDistinctChangesOnly?: boolean;
        read?: any;
    }): Query;
}

// @public
export function createComponent<C>(component: Type<C>, options: {
    environmentInjector: EnvironmentInjector;
    hostElement?: Element;
    elementInjector?: Injector;
    projectableNodes?: Node[][];
}): ComponentRef<C>;

// @public
export interface CreateComputedOptions<T> {
    debugName?: string;
    equal?: ValueEqualityFn<T>;
}

// @public
export interface CreateEffectOptions {
    // @deprecated (undocumented)
    allowSignalWrites?: boolean;
    debugName?: string;
    forceRoot?: true;
    injector?: Injector;
    manualCleanup?: boolean;
}

// @public
export function createEnvironmentInjector(providers: Array<Provider | EnvironmentProviders>, parent: EnvironmentInjector, debugName?: string | null): EnvironmentInjector;

// @public
export function createNgModule<T>(ngModule: Type<T>, parentInjector?: Injector): NgModuleRef<T>;

// @public @deprecated
export const createNgModuleRef: typeof createNgModule;

// @public
export function createPlatform(injector: Injector): PlatformRef;

// @public
export function createPlatformFactory(parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null, name: string, providers?: StaticProvider[]): (extraProviders?: StaticProvider[]) => PlatformRef;

// @public
export interface CreateSignalOptions<T> {
    debugName?: string;
    equal?: ValueEqualityFn<T>;
}

// @public
export const CSP_NONCE: InjectionToken<string | null>;

// @public
export const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata;

// @public (undocumented)
export class DebugElement extends DebugNode {
    constructor(nativeNode: Element);
    get attributes(): {
        [key: string]: string | null;
    };
    get childNodes(): DebugNode[];
    get children(): DebugElement[];
    get classes(): {
        [key: string]: boolean;
    };
    get name(): string;
    get nativeElement(): any;
    get properties(): {
        [key: string]: any;
    };
    // (undocumented)
    query(predicate: Predicate<DebugElement>): DebugElement;
    // (undocumented)
    queryAll(predicate: Predicate<DebugElement>): DebugElement[];
    // (undocumented)
    queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];
    get styles(): {
        [key: string]: string | null;
    };
    triggerEventHandler(eventName: string, eventObj?: any): void;
}

// @public (undocumented)
export class DebugEventListener {
    constructor(name: string, callback: Function);
    // (undocumented)
    callback: Function;
    // (undocumented)
    name: string;
}

// @public (undocumented)
export class DebugNode {
    constructor(nativeNode: Node);
    get componentInstance(): any;
    get context(): any;
    get injector(): Injector;
    get listeners(): DebugEventListener[];
    readonly nativeNode: any;
    get parent(): DebugElement | null;
    get providerTokens(): any[];
    get references(): {
        [key: string]: any;
    };
}

// @public
export const DEFAULT_CURRENCY_CODE: InjectionToken<string>;

// @public @deprecated (undocumented)
export class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {
    constructor(trackByFn?: TrackByFunction<V>);
    // (undocumented)
    check(collection: NgIterable<V>): boolean;
    // (undocumented)
    readonly collection: V[] | Iterable<V> | null;
    // (undocumented)
    diff(collection: NgIterable<V> | null | undefined): DefaultIterableDiffer<V> | null;
    // (undocumented)
    forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    // (undocumented)
    forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void): void;
    // (undocumented)
    forEachItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    // (undocumented)
    forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    // (undocumented)
    forEachOperation(fn: (item: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;
    // (undocumented)
    forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    // (undocumented)
    forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    // (undocumented)
    get isDirty(): boolean;
    // (undocumented)
    readonly length: number;
    // (undocumented)
    onDestroy(): void;
}

// @public @deprecated (undocumented)
export const defineInjectable: typeof ɵɵdefineInjectable;

// @public
export function destroyPlatform(): void;

// @public
export abstract class DestroyRef {
    abstract onDestroy(callback: () => void): () => void;
}

// @public
export interface Directive {
    exportAs?: string;
    host?: {
        [key: string]: string;
    };
    hostDirectives?: (Type<unknown> | {
        directive: Type<unknown>;
        inputs?: string[];
        outputs?: string[];
    })[];
    inputs?: ({
        name: string;
        alias?: string;
        required?: boolean;
        transform?: (value: any) => any;
    } | string)[];
    jit?: true;
    outputs?: string[];
    providers?: Provider[];
    queries?: {
        [key: string]: any;
    };
    selector?: string;
    standalone?: boolean;
}

// @public
export const Directive: DirectiveDecorator;

// @public
export interface DirectiveDecorator {
    (obj?: Directive): TypeDecorator;
    new (obj?: Directive): Directive;
}

// @public
export interface DoBootstrap {
    // (undocumented)
    ngDoBootstrap(appRef: ApplicationRef): void;
}

// @public
export interface DoCheck {
    ngDoCheck(): void;
}

// @public
export function effect(effectFn: (onCleanup: EffectCleanupRegisterFn) => void, options?: CreateEffectOptions): EffectRef;

// @public
export type EffectCleanupFn = () => void;

// @public
export type EffectCleanupRegisterFn = (cleanupFn: EffectCleanupFn) => void;

// @public
export interface EffectRef {
    destroy(): void;
}

// @public
export class ElementRef<T = any> {
    constructor(nativeElement: T);
    nativeElement: T;
}

// @public
export abstract class EmbeddedViewRef<C> extends ViewRef {
    abstract context: C;
    abstract get rootNodes(): any[];
}

// @public
export function enableProdMode(): void;

// @public @deprecated
export const ENVIRONMENT_INITIALIZER: InjectionToken<readonly (() => void)[]>;

// @public
export abstract class EnvironmentInjector implements Injector {
    // (undocumented)
    abstract destroy(): void;
    abstract get<T>(token: ProviderToken<T>, notFoundValue: undefined, options: InjectOptions & {
        optional?: false;
    }): T;
    abstract get<T>(token: ProviderToken<T>, notFoundValue: null | undefined, options: InjectOptions): T | null;
    abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions): T;
    // @deprecated
    abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;
    // @deprecated (undocumented)
    abstract get(token: any, notFoundValue?: any): any;
    // @deprecated
    abstract runInContext<ReturnT>(fn: () => ReturnT): ReturnT;
}

// @public
export type EnvironmentProviders = {
    ɵbrand: 'EnvironmentProviders';
};

// @public
export class ErrorHandler {
    // (undocumented)
    handleError(error: any): void;
}

// @public
export interface EventEmitter<T> extends Subject<T>, OutputRef<T> {
    new (isAsync?: boolean): EventEmitter<T>;
    emit(value?: T): void;
    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;
    subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription;
}

// @public (undocumented)
export const EventEmitter: {
    new (isAsync?: boolean): EventEmitter<any>;
    new <T>(isAsync?: boolean): EventEmitter<T>;
    readonly prototype: EventEmitter<any>;
};

// @public
export interface ExistingProvider extends ExistingSansProvider {
    multi?: boolean;
    provide: any;
}

// @public
export interface ExistingSansProvider {
    useExisting: any;
}

// @public
export interface FactoryProvider extends FactorySansProvider {
    multi?: boolean;
    provide: any;
}

// @public
export interface FactorySansProvider {
    deps?: any[];
    useFactory: Function;
}

// @public
export function forwardRef(forwardRefFn: ForwardRefFn): Type<any>;

// @public
export interface ForwardRefFn {
    // (undocumented)
    (): any;
}

// @public (undocumented)
export function getDebugNode(nativeNode: any): DebugNode | null;

// @public @deprecated
export function getModuleFactory(id: string): NgModuleFactory<any>;

// @public
export function getNgModuleById<T>(id: string): Type<T>;

// @public
export function getPlatform(): PlatformRef | null;

// @public
export interface GetTestability {
    // (undocumented)
    addToWindow(registry: TestabilityRegistry): void;
    // (undocumented)
    findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;
}

// @public
export interface Host {
}

// @public
export const Host: HostDecorator;

// @public
export const HOST_TAG_NAME: InjectionToken<string>;

// @public
export class HostAttributeToken {
    constructor(attributeName: string);
    // (undocumented)
    toString(): string;
}

// @public
export interface HostBinding {
    hostPropertyName?: string;
}

// @public (undocumented)
export const HostBinding: HostBindingDecorator;

// @public
export interface HostBindingDecorator {
    (hostPropertyName?: string): any;
    // (undocumented)
    new (hostPropertyName?: string): any;
}

// @public
export interface HostDecorator {
    (): any;
    // (undocumented)
    new (): Host;
}

// @public
export interface HostListener {
    args?: string[];
    eventName?: string;
}

// @public (undocumented)
export const HostListener: HostListenerDecorator;

// @public
export interface HostListenerDecorator {
    (eventName: string, args?: string[]): any;
    // (undocumented)
    new (eventName: string, args?: string[]): any;
}

// @public @deprecated
export type ImportedNgModuleProviders = EnvironmentProviders;

// @public
export function importProvidersFrom(...sources: ImportProvidersSource[]): EnvironmentProviders;

// @public
export type ImportProvidersSource = Type<unknown> | ModuleWithProviders<unknown> | Array<ImportProvidersSource>;

// @public
export interface Inject {
    token: any;
}

// @public
export const Inject: InjectDecorator;

// @public (undocumented)
export function inject<T>(token: ProviderToken<T>): T;

// @public @deprecated (undocumented)
export function inject<T>(token: ProviderToken<T>, flags?: InjectFlags): T | null;

// @public (undocumented)
export function inject<T>(token: ProviderToken<T>, options: InjectOptions & {
    optional?: false;
}): T;

// @public (undocumented)
export function inject<T>(token: ProviderToken<T>, options: InjectOptions): T | null;

// @public (undocumented)
export function inject(token: HostAttributeToken): string;

// @public (undocumented)
export function inject(token: HostAttributeToken, options: {
    optional: true;
}): string | null;

// @public (undocumented)
export function inject(token: HostAttributeToken, options: {
    optional: false;
}): string;

// @public
export interface Injectable {
    providedIn?: Type<any> | 'root' | 'platform' | 'any' | null;
}

// @public
export const Injectable: InjectableDecorator;

// @public
export interface InjectableDecorator {
    (): TypeDecorator;
    // (undocumented)
    (options?: {
        providedIn: Type<any> | 'root' | 'platform' | 'any' | null;
    } & InjectableProvider): TypeDecorator;
    // (undocumented)
    new (): Injectable;
    // (undocumented)
    new (options?: {
        providedIn: Type<any> | 'root' | 'platform' | 'any' | null;
    } & InjectableProvider): Injectable;
}

// @public
export type InjectableProvider = ValueSansProvider | ExistingSansProvider | StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;

// @public
export interface InjectableType<T> extends Type<T> {
    ɵprov: unknown;
}

// @public
export interface InjectDecorator {
    (token: any): any;
    // (undocumented)
    new (token: any): Inject;
}

// @public @deprecated
export enum InjectFlags {
    Default = 0,
    Host = 1,
    Optional = 8,
    Self = 2,
    SkipSelf = 4
}

// @public
export class InjectionToken<T> {
    constructor(_desc: string, options?: {
        providedIn?: Type<any> | 'root' | 'platform' | 'any' | null;
        factory: () => T;
    });
    // (undocumented)
    protected _desc: string;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly ɵprov: unknown;
}

// @public
export interface InjectOptions {
    host?: boolean;
    optional?: boolean;
    self?: boolean;
    skipSelf?: boolean;
}

// @public
export const INJECTOR: InjectionToken<Injector>;

// @public
export abstract class Injector {
    // @deprecated (undocumented)
    static create(providers: StaticProvider[], parent?: Injector): Injector;
    static create(options: {
        providers: Array<Provider | StaticProvider>;
        parent?: Injector;
        name?: string;
    }): Injector;
    abstract get<T>(token: ProviderToken<T>, notFoundValue: undefined, options: InjectOptions & {
        optional?: false;
    }): T;
    abstract get<T>(token: ProviderToken<T>, notFoundValue: null | undefined, options: InjectOptions): T | null;
    abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions | InjectFlags): T;
    // @deprecated
    abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;
    // @deprecated (undocumented)
    abstract get(token: any, notFoundValue?: any): any;
    // (undocumented)
    static NULL: Injector;
    // (undocumented)
    static THROW_IF_NOT_FOUND: {};
    // (undocumented)
    static ɵprov: unknown;
}

// @public
export interface InjectorType<T> extends Type<T> {
    // (undocumented)
    ɵfac?: unknown;
    // (undocumented)
    ɵinj: unknown;
}

// @public
export interface Input {
    alias?: string;
    required?: boolean;
    transform?: (value: any) => any;
}

// @public (undocumented)
export const Input: InputDecorator;

// @public
export const input: InputFunction;

// @public (undocumented)
export interface InputDecorator {
    (arg?: string | Input): any;
    // (undocumented)
    new (arg?: string | Input): any;
}

// @public
export interface InputFunction {
    <T>(): InputSignal<T | undefined>;
    <T>(initialValue: T, opts?: InputOptionsWithoutTransform<T>): InputSignal<T>;
    <T>(initialValue: undefined, opts: InputOptionsWithoutTransform<T>): InputSignal<T | undefined>;
    <T, TransformT>(initialValue: T, opts: InputOptionsWithTransform<T, TransformT>): InputSignalWithTransform<T, TransformT>;
    <T, TransformT>(initialValue: undefined, opts: InputOptionsWithTransform<T | undefined, TransformT>): InputSignalWithTransform<T | undefined, TransformT>;
    required: {
        <T>(opts?: InputOptionsWithoutTransform<T>): InputSignal<T>;
        <T, TransformT>(opts: InputOptionsWithTransform<T, TransformT>): InputSignalWithTransform<T, TransformT>;
    };
}

// @public
export interface InputOptions<T, TransformT> {
    alias?: string;
    debugName?: string;
    transform?: (v: TransformT) => T;
}

// @public
export type InputOptionsWithoutTransform<T> = Omit<InputOptions<T, T>, 'transform'> & {
    transform?: undefined;
};

// @public
export type InputOptionsWithTransform<T, TransformT> = Required<Pick<InputOptions<T, TransformT>, 'transform'>> & InputOptions<T, TransformT>;

// @public
export interface InputSignal<T> extends InputSignalWithTransform<T, T> {
}

// @public
export interface InputSignalWithTransform<T, TransformT> extends Signal<T> {
    // (undocumented)
    [ɵINPUT_SIGNAL_BRAND_READ_TYPE]: T;
    // (undocumented)
    [ɵINPUT_SIGNAL_BRAND_WRITE_TYPE]: TransformT;
    // (undocumented)
    [SIGNAL]: ɵInputSignalNode<T, TransformT>;
}

// @public
export function isDevMode(): boolean;

// @public
export function isSignal(value: unknown): value is Signal<unknown>;

// @public
export function isStandalone(type: Type<unknown>): boolean;

// @public
export interface IterableChangeRecord<V> {
    readonly currentIndex: number | null;
    readonly item: V;
    readonly previousIndex: number | null;
    readonly trackById: any;
}

// @public
export interface IterableChanges<V> {
    forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;
    forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;
    forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;
    forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;
    forEachOperation(fn: (record: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;
    forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;
    forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;
}

// @public
export interface IterableDiffer<V> {
    diff(object: NgIterable<V> | undefined | null): IterableChanges<V> | null;
}

// @public
export interface IterableDifferFactory {
    // (undocumented)
    create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;
    // (undocumented)
    supports(objects: any): boolean;
}

// @public
export class IterableDiffers {
    constructor(factories: IterableDifferFactory[]);
    // (undocumented)
    static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers;
    static extend(factories: IterableDifferFactory[]): StaticProvider;
    // (undocumented)
    find(iterable: any): IterableDifferFactory;
    // (undocumented)
    static ɵprov: unknown;
}

// @public
export interface KeyValueChangeRecord<K, V> {
    readonly currentValue: V | null;
    readonly key: K;
    readonly previousValue: V | null;
}

// @public
export interface KeyValueChanges<K, V> {
    forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
}

// @public
export interface KeyValueDiffer<K, V> {
    diff(object: Map<K, V>): KeyValueChanges<K, V> | null;
    diff(object: {
        [key: string]: V;
    }): KeyValueChanges<string, V> | null;
}

// @public
export interface KeyValueDifferFactory {
    create<K, V>(): KeyValueDiffer<K, V>;
    supports(objects: any): boolean;
}

// @public
export class KeyValueDiffers {
    constructor(factories: KeyValueDifferFactory[]);
    // (undocumented)
    static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers;
    static extend<S>(factories: KeyValueDifferFactory[]): StaticProvider;
    // (undocumented)
    find(kv: any): KeyValueDifferFactory;
    // (undocumented)
    static ɵprov: unknown;
}

// @public
export function linkedSignal<D>(computation: () => D, options?: {
    equal?: ValueEqualityFn<NoInfer<D>>;
}): WritableSignal<D>;

// @public
export function linkedSignal<S, D>(options: {
    source: () => S;
    computation: (source: NoInfer<S>, previous?: {
        source: NoInfer<S>;
        value: NoInfer<D>;
    }) => D;
    equal?: ValueEqualityFn<NoInfer<D>>;
}): WritableSignal<D>;

// @public
export interface ListenerOptions {
    // (undocumented)
    capture?: boolean;
    // (undocumented)
    once?: boolean;
    // (undocumented)
    passive?: boolean;
}

// @public
export const LOCALE_ID: InjectionToken<string>;

// @public
export function makeEnvironmentProviders(providers: (Provider | EnvironmentProviders)[]): EnvironmentProviders;

// @public
export function makeStateKey<T = void>(key: string): StateKey<T>;

// @public
export function mergeApplicationConfig(...configs: ApplicationConfig[]): ApplicationConfig;

// @public
export enum MissingTranslationStrategy {
    // (undocumented)
    Error = 0,
    // (undocumented)
    Ignore = 2,
    // (undocumented)
    Warning = 1
}

// @public
export const model: ModelFunction;

// @public
export interface ModelFunction {
    <T>(): ModelSignal<T | undefined>;
    <T>(initialValue: T, opts?: ModelOptions): ModelSignal<T>;
    // (undocumented)
    required: {
        <T>(opts?: ModelOptions): ModelSignal<T>;
    };
}

// @public
export interface ModelOptions {
    alias?: string;
    debugName?: string;
}

// @public
export interface ModelSignal<T> extends WritableSignal<T>, InputSignal<T>, OutputRef<T> {
    // (undocumented)
    [SIGNAL]: ɵInputSignalNode<T, T>;
}

// @public @deprecated
export class ModuleWithComponentFactories<T> {
    constructor(ngModuleFactory: NgModuleFactory<T>, componentFactories: ComponentFactory<any>[]);
    // (undocumented)
    componentFactories: ComponentFactory<any>[];
    // (undocumented)
    ngModuleFactory: NgModuleFactory<T>;
}

// @public
export interface ModuleWithProviders<T> {
    // (undocumented)
    ngModule: Type<T>;
    // (undocumented)
    providers?: Array<Provider | EnvironmentProviders>;
}

// @public
export type NgIterable<T> = Array<T> | Iterable<T>;

// @public
export interface NgModule {
    bootstrap?: Array<Type<any> | any[]>;
    declarations?: Array<Type<any> | any[]>;
    exports?: Array<Type<any> | any[]>;
    id?: string;
    imports?: Array<Type<any> | ModuleWithProviders<{}> | any[]>;
    jit?: true;
    providers?: Array<Provider | EnvironmentProviders>;
    schemas?: Array<SchemaMetadata | any[]>;
}

// @public (undocumented)
export const NgModule: NgModuleDecorator;

// @public
export interface NgModuleDecorator {
    (obj?: NgModule): TypeDecorator;
    // (undocumented)
    new (obj?: NgModule): NgModule;
}

// @public @deprecated (undocumented)
export abstract class NgModuleFactory<T> {
    // (undocumented)
    abstract create(parentInjector: Injector | null): NgModuleRef<T>;
    // (undocumented)
    abstract get moduleType(): Type<T>;
}

// @public
export abstract class NgModuleRef<T> {
    // @deprecated
    abstract get componentFactoryResolver(): ComponentFactoryResolver;
    abstract destroy(): void;
    abstract get injector(): EnvironmentInjector;
    abstract get instance(): T;
    abstract onDestroy(callback: () => void): void;
}

// @public @deprecated
export class NgProbeToken {
    constructor(name: string, token: any);
    // (undocumented)
    name: string;
    // (undocumented)
    token: any;
}

// @public
export class NgZone {
    constructor(options: {
        enableLongStackTrace?: boolean;
        shouldCoalesceEventChangeDetection?: boolean;
        shouldCoalesceRunChangeDetection?: boolean;
    });
    static assertInAngularZone(): void;
    static assertNotInAngularZone(): void;
    // (undocumented)
    readonly hasPendingMacrotasks: boolean;
    // (undocumented)
    readonly hasPendingMicrotasks: boolean;
    static isInAngularZone(): boolean;
    readonly isStable: boolean;
    readonly onError: EventEmitter<any>;
    readonly onMicrotaskEmpty: EventEmitter<any>;
    readonly onStable: EventEmitter<any>;
    readonly onUnstable: EventEmitter<any>;
    run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;
    runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;
    runOutsideAngular<T>(fn: (...args: any[]) => T): T;
    runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T;
}

// @public
export interface NgZoneOptions {
    eventCoalescing?: boolean;
    // @deprecated
    ignoreChangesOutsideZone?: boolean;
    runCoalescing?: boolean;
}

// @public
export const NO_ERRORS_SCHEMA: SchemaMetadata;

// @public
export function numberAttribute(value: unknown, fallbackValue?: number): number;

// @public
export interface OnChanges {
    ngOnChanges(changes: SimpleChanges): void;
}

// @public
export interface OnDestroy {
    ngOnDestroy(): void;
}

// @public
export interface OnInit {
    ngOnInit(): void;
}

// @public
export interface Optional {
}

// @public
export const Optional: OptionalDecorator;

// @public
export interface OptionalDecorator {
    (): any;
    // (undocumented)
    new (): Optional;
}

// @public
export interface Output {
    alias?: string;
}

// @public (undocumented)
export const Output: OutputDecorator;

// @public
export function output<T = void>(opts?: OutputOptions): OutputEmitterRef<T>;

// @public
export interface OutputDecorator {
    (alias?: string): any;
    // (undocumented)
    new (alias?: string): any;
}

// @public
export class OutputEmitterRef<T> implements OutputRef<T> {
    constructor();
    emit(value: T): void;
    // (undocumented)
    subscribe(callback: (value: T) => void): OutputRefSubscription;
}

// @public
export interface OutputOptions {
    // (undocumented)
    alias?: string;
}

// @public
export interface OutputRef<T> {
    subscribe(callback: (value: T) => void): OutputRefSubscription;
}

// @public
export interface OutputRefSubscription {
    // (undocumented)
    unsubscribe(): void;
}

// @public @deprecated
export const PACKAGE_ROOT_URL: InjectionToken<string>;

// @public
export class PendingTasks {
    add(): () => void;
    run<T>(fn: () => Promise<T>): Promise<T>;
    // (undocumented)
    static ɵprov: unknown;
}

// @public
export interface Pipe {
    name: string;
    pure?: boolean;
    standalone?: boolean;
}

// @public (undocumented)
export const Pipe: PipeDecorator;

// @public
export interface PipeDecorator {
    (obj: Pipe): TypeDecorator;
    new (obj: Pipe): Pipe;
}

// @public
export interface PipeTransform {
    // (undocumented)
    transform(value: any, ...args: any[]): any;
}

// @public
export const PLATFORM_ID: InjectionToken<Object>;

// @public @deprecated
export const PLATFORM_INITIALIZER: InjectionToken<readonly (() => void)[]>;

// @public
export const platformCore: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;

// @public
export class PlatformRef {
    bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: (CompilerOptions & BootstrapOptions) | Array<CompilerOptions & BootstrapOptions>): Promise<NgModuleRef<M>>;
    // @deprecated
    bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions): Promise<NgModuleRef<M>>;
    destroy(): void;
    get destroyed(): boolean;
    get injector(): Injector;
    onDestroy(callback: () => void): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<PlatformRef, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<PlatformRef>;
}

// @public
export type Predicate<T> = (value: T) => boolean;

// @public
export interface PromiseResourceOptions<T, R> extends BaseResourceOptions<T, R> {
    loader: ResourceLoader<T, R>;
    stream?: never;
}

// @public
export function provideAppInitializer(initializerFn: () => Observable<unknown> | Promise<unknown> | void): EnvironmentProviders;

// @public
export function provideEnvironmentInitializer(initializerFn: () => void): EnvironmentProviders;

// @public
export function provideExperimentalCheckNoChangesForDebug(options: {
    interval?: number;
    useNgZoneOnStable?: boolean;
    exhaustive?: boolean;
}): EnvironmentProviders_2;

// @public
export function provideExperimentalZonelessChangeDetection(): EnvironmentProviders;

// @public
export function providePlatformInitializer(initializerFn: () => void): EnvironmentProviders;

// @public
export type Provider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | any[];

// @public
export type ProviderToken<T> = Type<T> | AbstractType<T> | InjectionToken<T>;

// @public
export function provideZoneChangeDetection(options?: NgZoneOptions): EnvironmentProviders;

// @public
export interface Query {
    // (undocumented)
    descendants: boolean;
    // (undocumented)
    emitDistinctChangesOnly: boolean;
    // (undocumented)
    first: boolean;
    // (undocumented)
    isViewQuery: boolean;
    // (undocumented)
    read: any;
    // (undocumented)
    selector: any;
    // (undocumented)
    static?: boolean;
}

// @public
export abstract class Query {
}

// @public
export class QueryList<T> implements Iterable<T> {
    // (undocumented)
    [Symbol.iterator]: () => Iterator<T>;
    constructor(_emitDistinctChangesOnly?: boolean);
    get changes(): Observable<any>;
    destroy(): void;
    // (undocumented)
    readonly dirty = true;
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S): S[];
    // (undocumented)
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown): T[];
    find(fn: (item: T, index: number, array: T[]) => boolean): T | undefined;
    // (undocumented)
    readonly first: T;
    forEach(fn: (item: T, index: number, array: T[]) => void): void;
    get(index: number): T | undefined;
    // (undocumented)
    readonly last: T;
    // (undocumented)
    readonly length: number;
    map<U>(fn: (item: T, index: number, array: T[]) => U): U[];
    notifyOnChanges(): void;
    reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U;
    reset(resultsTree: Array<T | any[]>, identityAccessor?: (value: T) => unknown): void;
    setDirty(): void;
    some(fn: (value: T, index: number, array: T[]) => boolean): boolean;
    toArray(): T[];
    // (undocumented)
    toString(): string;
}

// @public
export function reflectComponentType<C>(component: Type<C>): ComponentMirror<C> | null;

// @public
export abstract class Renderer2 {
    abstract addClass(el: any, name: string): void;
    abstract appendChild(parent: any, newChild: any): void;
    abstract createComment(value: string): any;
    abstract createElement(name: string, namespace?: string | null): any;
    abstract createText(value: string): any;
    abstract get data(): {
        [key: string]: any;
    };
    abstract destroy(): void;
    destroyNode: ((node: any) => void) | null;
    abstract insertBefore(parent: any, newChild: any, refChild: any, isMove?: boolean): void;
    abstract listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => boolean | void, options?: ListenerOptions): () => void;
    abstract nextSibling(node: any): any;
    abstract parentNode(node: any): any;
    abstract removeAttribute(el: any, name: string, namespace?: string | null): void;
    abstract removeChild(parent: any, oldChild: any, isHostElement?: boolean): void;
    abstract removeClass(el: any, name: string): void;
    abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;
    abstract selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any;
    abstract setAttribute(el: any, name: string, value: string, namespace?: string | null): void;
    abstract setProperty(el: any, name: string, value: any): void;
    abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;
    abstract setValue(node: any, value: string): void;
}

// @public
export abstract class RendererFactory2 {
    abstract begin?(): void;
    abstract createRenderer(hostElement: any, type: RendererType2 | null): Renderer2;
    abstract end?(): void;
    abstract whenRenderingDone?(): Promise<any>;
}

// @public
export enum RendererStyleFlags2 {
    DashCase = 2,
    Important = 1
}

// @public
export interface RendererType2 {
    data: {
        [kind: string]: any;
    };
    encapsulation: ViewEncapsulation;
    getExternalStyles?: ((encapsulationId?: string) => string[]) | null;
    id: string;
    styles: string[];
}

// @public
export const REQUEST: InjectionToken<Request | null>;

// @public
export const REQUEST_CONTEXT: InjectionToken<unknown>;

// @public
export function resolveForwardRef<T>(type: T): T;

// @public
export interface Resource<T> {
    readonly error: Signal<unknown>;
    hasValue(): this is Resource<Exclude<T, undefined>>;
    readonly isLoading: Signal<boolean>;
    reload(): boolean;
    readonly status: Signal<ResourceStatus>;
    readonly value: Signal<T>;
}

// @public
export function resource<T, R>(options: ResourceOptions<T, R> & {
    defaultValue: NoInfer<T>;
}): ResourceRef<T>;

// @public
export function resource<T, R>(options: ResourceOptions<T, R>): ResourceRef<T | undefined>;

// @public
export type ResourceLoader<T, R> = (param: ResourceLoaderParams<R>) => PromiseLike<T>;

// @public
export interface ResourceLoaderParams<R> {
    // (undocumented)
    abortSignal: AbortSignal;
    // (undocumented)
    previous: {
        status: ResourceStatus;
    };
    // (undocumented)
    request: Exclude<NoInfer<R>, undefined>;
}

// @public (undocumented)
export type ResourceOptions<T, R> = PromiseResourceOptions<T, R> | StreamingResourceOptions<T, R>;

// @public
export interface ResourceRef<T> extends WritableResource<T> {
    destroy(): void;
    // (undocumented)
    hasValue(): this is ResourceRef<Exclude<T, undefined>>;
}

// @public
export enum ResourceStatus {
    Error = 1,
    Idle = 0,
    Loading = 2,
    Local = 5,
    Reloading = 3,
    Resolved = 4
}

// @public
export type ResourceStreamingLoader<T, R> = (param: ResourceLoaderParams<R>) => PromiseLike<Signal<ResourceStreamItem<T>>>;

// @public (undocumented)
export type ResourceStreamItem<T> = {
    value: T;
} | {
    error: unknown;
};

// @public
export const RESPONSE_INIT: InjectionToken<ResponseInit | null>;

// @public
export function runInInjectionContext<ReturnT>(injector: Injector, fn: () => ReturnT): ReturnT;

// @public
export abstract class Sanitizer {
    // (undocumented)
    abstract sanitize(context: SecurityContext, value: {} | string | null): string | null;
    // (undocumented)
    static ɵprov: unknown;
}

// @public
export interface SchemaMetadata {
    // (undocumented)
    name: string;
}

// @public
export enum SecurityContext {
    // (undocumented)
    HTML = 1,
    // (undocumented)
    NONE = 0,
    // (undocumented)
    RESOURCE_URL = 5,
    // (undocumented)
    SCRIPT = 3,
    // (undocumented)
    STYLE = 2,
    // (undocumented)
    URL = 4
}

// @public
export interface Self {
}

// @public
export const Self: SelfDecorator;

// @public
export interface SelfDecorator {
    (): any;
    // (undocumented)
    new (): Self;
}

// @public
export function setTestabilityGetter(getter: GetTestability): void;

// @public
export type Signal<T> = (() => T) & {
    [SIGNAL]: unknown;
};

// @public
export function signal<T>(initialValue: T, options?: CreateSignalOptions<T>): WritableSignal<T>;

// @public
export class SimpleChange {
    constructor(previousValue: any, currentValue: any, firstChange: boolean);
    // (undocumented)
    currentValue: any;
    // (undocumented)
    firstChange: boolean;
    isFirstChange(): boolean;
    // (undocumented)
    previousValue: any;
}

// @public
export interface SimpleChanges {
    // (undocumented)
    [propName: string]: SimpleChange;
}

// @public
export interface SkipSelf {
}

// @public
export const SkipSelf: SkipSelfDecorator;

// @public
export interface SkipSelfDecorator {
    (): any;
    // (undocumented)
    new (): SkipSelf;
}

// @public
export type StateKey<T> = string & {
    __not_a_string: never;
    __value_type?: T;
};

// @public
export interface StaticClassProvider extends StaticClassSansProvider {
    multi?: boolean;
    provide: any;
}

// @public
export interface StaticClassSansProvider {
    deps: any[];
    useClass: Type<any>;
}

// @public
export type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[];

// @public
export interface StreamingResourceOptions<T, R> extends BaseResourceOptions<T, R> {
    loader?: never;
    stream: ResourceStreamingLoader<T, R>;
}

// @public
export abstract class TemplateRef<C> {
    abstract createEmbeddedView(context: C, injector?: Injector): EmbeddedViewRef<C>;
    abstract readonly elementRef: ElementRef;
}

// @public
export class Testability implements PublicTestability {
    constructor(_ngZone: NgZone, registry: TestabilityRegistry, testabilityGetter: GetTestability);
    findProviders(using: any, provider: string, exactMatch: boolean): any[];
    isStable(): boolean;
    whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<Testability, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<Testability>;
}

// @public
export class TestabilityRegistry {
    findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability | null;
    getAllRootElements(): any[];
    getAllTestabilities(): Testability[];
    getTestability(elem: any): Testability | null;
    registerApplication(token: any, testability: Testability): void;
    unregisterAllApplications(): void;
    unregisterApplication(token: any): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<TestabilityRegistry, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<TestabilityRegistry>;
}

// @public
export interface TrackByFunction<T> {
    // (undocumented)
    <U extends T>(index: number, item: T & U): any;
}

// @public
export class TransferState {
    get<T>(key: StateKey<T>, defaultValue: T): T;
    hasKey<T>(key: StateKey<T>): boolean;
    get isEmpty(): boolean;
    onSerialize<T>(key: StateKey<T>, callback: () => T): void;
    remove<T>(key: StateKey<T>): void;
    set<T>(key: StateKey<T>, value: T): void;
    toJson(): string;
    // (undocumented)
    static ɵprov: unknown;
}

// @public
export const TRANSLATIONS: InjectionToken<string>;

// @public
export const TRANSLATIONS_FORMAT: InjectionToken<string>;

// @public
export const Type: FunctionConstructor;

// @public (undocumented)
export interface Type<T> extends Function {
    // (undocumented)
    new (...args: any[]): T;
}

// @public
export interface TypeDecorator {
    <T extends Type<any>>(type: T): T;
    // (undocumented)
    (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;
    // (undocumented)
    (target: unknown, context: unknown): void;
}

// @public
export interface TypeProvider extends Type<any> {
}

// @public
export function untracked<T>(nonReactiveReadsFn: () => T): T;

// @public
export type ValueEqualityFn<T> = (a: T, b: T) => boolean;

// @public
export interface ValueProvider extends ValueSansProvider {
    multi?: boolean;
    provide: any;
}

// @public
export interface ValueSansProvider {
    useValue: any;
}

// @public (undocumented)
export const VERSION: Version;

// @public
export class Version {
    constructor(full: string);
    // (undocumented)
    full: string;
    // (undocumented)
    readonly major: string;
    // (undocumented)
    readonly minor: string;
    // (undocumented)
    readonly patch: string;
}

// @public
export type ViewChild = Query;

// @public
export const ViewChild: ViewChildDecorator;

// @public
export const viewChild: ViewChildFunction;

// @public
export interface ViewChildDecorator {
    (selector: ProviderToken<unknown> | Function | string, opts?: {
        read?: any;
        static?: boolean;
    }): any;
    // (undocumented)
    new (selector: ProviderToken<unknown> | Function | string, opts?: {
        read?: any;
        static?: boolean;
    }): ViewChild;
}

// @public
export interface ViewChildFunction {
    <LocatorT, ReadT>(locator: ProviderToken<LocatorT> | string, opts: {
        read: ProviderToken<ReadT>;
        debugName?: string;
    }): Signal<ReadT | undefined>;
    // (undocumented)
    <LocatorT>(locator: ProviderToken<LocatorT> | string, opts?: {
        debugName?: string;
    }): Signal<LocatorT | undefined>;
    required: {
        <LocatorT>(locator: ProviderToken<LocatorT> | string, opts?: {
            debugName?: string;
        }): Signal<LocatorT>;
        <LocatorT, ReadT>(locator: ProviderToken<LocatorT> | string, opts: {
            read: ProviderToken<ReadT>;
            debugName?: string;
        }): Signal<ReadT>;
    };
}

// @public
export type ViewChildren = Query;

// @public
export const ViewChildren: ViewChildrenDecorator;

// @public (undocumented)
export function viewChildren<LocatorT>(locator: ProviderToken<LocatorT> | string, opts?: {
    debugName?: string;
}): Signal<ReadonlyArray<LocatorT>>;

// @public (undocumented)
export function viewChildren<LocatorT, ReadT>(locator: ProviderToken<LocatorT> | string, opts: {
    read: ProviderToken<ReadT>;
    debugName?: string;
}): Signal<ReadonlyArray<ReadT>>;

// @public
export interface ViewChildrenDecorator {
    (selector: ProviderToken<unknown> | Function | string, opts?: {
        read?: any;
        emitDistinctChangesOnly?: boolean;
    }): any;
    // (undocumented)
    new (selector: ProviderToken<unknown> | Function | string, opts?: {
        read?: any;
        emitDistinctChangesOnly?: boolean;
    }): ViewChildren;
}

// @public
export abstract class ViewContainerRef {
    abstract clear(): void;
    abstract createComponent<C>(componentType: Type<C>, options?: {
        index?: number;
        injector?: Injector;
        ngModuleRef?: NgModuleRef<unknown>;
        environmentInjector?: EnvironmentInjector | NgModuleRef<unknown>;
        projectableNodes?: Node[][];
    }): ComponentRef<C>;
    // @deprecated
    abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][], environmentInjector?: EnvironmentInjector | NgModuleRef<any>): ComponentRef<C>;
    abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, options?: {
        index?: number;
        injector?: Injector;
    }): EmbeddedViewRef<C>;
    abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;
    abstract detach(index?: number): ViewRef | null;
    abstract get element(): ElementRef;
    abstract get(index: number): ViewRef | null;
    abstract indexOf(viewRef: ViewRef): number;
    abstract get injector(): Injector;
    abstract insert(viewRef: ViewRef, index?: number): ViewRef;
    abstract get length(): number;
    abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;
    // @deprecated (undocumented)
    abstract get parentInjector(): Injector;
    abstract remove(index?: number): void;
}

// @public
export enum ViewEncapsulation {
    Emulated = 0,
    None = 2,
    ShadowDom = 3
}

// @public
export abstract class ViewRef extends ChangeDetectorRef {
    abstract destroy(): void;
    abstract get destroyed(): boolean;
    abstract onDestroy(callback: Function): void;
}

// @public
export interface WritableResource<T> extends Resource<T> {
    // (undocumented)
    asReadonly(): Resource<T>;
    // (undocumented)
    hasValue(): this is WritableResource<Exclude<T, undefined>>;
    set(value: T): void;
    update(updater: (value: T) => T): void;
    // (undocumented)
    readonly value: WritableSignal<T>;
}

// @public
export interface WritableSignal<T> extends Signal<T> {
    // (undocumented)
    [ɵWRITABLE_SIGNAL]: T;
    asReadonly(): Signal<T>;
    set(value: T): void;
    update(updateFn: (value: T) => T): void;
}

// (No @packageDocumentation comment for this package)

```
