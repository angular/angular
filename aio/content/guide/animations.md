# Animation Basics

Animation provides the illusion of motion: elements change styling over time.

* Without animations, web page transitions can seem abrupt and jarring.

* Adding motion to your web application greatly enhances the user experience, giving users a chance to detect the application’s response to their own actions.

* Well-designed animations can make your application fun and easier to use. 

* Good user interfaces transition smoothly between states with engaging animations that intuitively call the user's attention to where it is needed.

Typically, animations involve multiple style _transformations_ over time – an HTML element can move, change color, grow or shrink, fade, or slide off the page. These changes can occur simultaneously or sequentially. You can control the timing of each of these transformations.

## Audience assumptions

Before starting with Angular animations, readers are advised to review the basic [Tutorial](tutorial) and [Architecture Overview](guide/architecture) sections.

## About Angular animations

Angular's animation system is built on CSS functionality, which means you can animate any property that the browser considers animatable. This includes positions, sizes, transforms, colors, borders, and more. The W3C maintains a list of animatable properties on its [CSS Transitions](https://www.w3.org/TR/css-transitions-1/) page.

The main Angular modules for animations are **@angular/animations** and **@angular/platform-browser**. 

If you want to create route-based animations that kick off when the user changes a URL, you’ll also need **@angular/router**. 

Check out this full-fledged animation [demo](http://animationsftw.in/#/) with accompanying [presentation](https://www.youtube.com/watch?v=JhNo3Wvj6UQ&feature=youtu.be&t=2h47m53s), shown at the AngularConnect conference in November 2017.

## How this document is organized

This document begins with simple concepts, and then builds on those to create more complex applications. 

Each section follows a similar pattern:

* Describes key concepts and activities, using simple illustrated English-language examples.

* Explains how to implement the functionality in Angular.

* Includes code samples and links to complete demo projects on Stackblitz. 

As of Angular 6, If the Web Animations API is not supported natively by the browser, then Angular will use CSS
keyframes as a fallback instead (automatically). This means that the polyfill is no longer required unless any
code uses [AnimationBuilder](/api/animations/AnimationBuilder). If your code does use AnimationBuilder, then
uncomment the `web-animations-js` polyfill from the `polyfills.ts` file generated by Angular CLI.
</div>


## Getting Started
 
 To make the code samples work, you’ll need to import the animation-specific modules along with standard Angular functionality. 
 
 ### Step 1: Dependencies

Add **@angular/animations** and **@angular/platform-browser** to `package.json`. Specify "latest" for all modules, not just the animations.

<code-example hideCopy language="json" title="package.json">
 {  
   "dependencies": {  
     "@angular/animations": "latest",  
     "@angular/platform-browser": "latest",  
     …  
   }  
 }  
 </code-example>

<div class="l-sub-section">

The code sample assumes that you are using the Angular CLI.
</div>

### Step 2: Enable Animations Module

Import `BrowserAnimationsModule` that introduces all the animation capabilities 
into your Angular root application module.

<code-example hideCopy language="typescript">

import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

@NgModule({
  imports: [BrowserAnimationsModule ],
  …

})

export class AppModule { 

}
</code-example>


<div class="l-sub-section">

The root application module is typically located in `src/app` and is named `app.module.ts`.
</div>

### Step 3: Import animation functions into component files 

In any component file that you plan to use animations, import specific animation functions from '@angular/animations'.

<code-example hideCopy language="typescript">

import { Component } from '@angular/core'; 
import { 
  trigger, 
  state, 
  style, 
  animate, 
  transition 
  … 
} from '@angular/animations'; 

</code-example>	

<!--
<code-example path="animations-guide/src/app/app.component.ts" title="src/app/app.component.ts" region="imports">
 </code-example> -->

<div class="l-sub-section">

Find the list of Angular animation function available under the Animation DSL section of this document.
</div>

### Step 4: Add animations: property inside @Component decorator

In the component file, add a property called `animations:` to the `@Component` decorator.

<code-example hideCopy language="typescript">

@Component ( {
   …
   animations: [
      // animation function calls go here
   ]
} )

</code-example>

<!-- 
<code-example path="animations-guide/src/app/app.component.ts" title="src/app/app.component.ts" region="decorator">

 </code-example>-->


## Simple transition

We’ll start with an animation example that changes a single HTML element from one state to another.
For example, a button can show as either `open` or `closed`, depending on the user's last action. When the button is in the "Open" state, it's visible and yellow. When it's "Closed" it's transparent and green. These attributes are set using ordinary CSS styles such as color and opacity. In Angular, they are set using the `style()` function.

Within Angular, these collections of _style_ attributes are called _states_, and each state can be associated with a name like `open` or `closed`.

<figure>
  <img src="generated/images/guide/animations/open-closed-500.png" alt="open and closed states">
</figure>

### Animation State and Styles
Angular's `state()` functions allows you to define different states that you can call at the end of each transition. It takes two arguments: the first argument accepts a unique name like `open` or `closed` and the second argument accepts a `style()` function.

The `style()` function allows you to define a set of styles to associate with a given state name.

Let us see how Angular's `state()` function works together with the `style⁣­(⁠)` function to set CSS style attributes.


<code-example hideCopy language="typescript">

state ('open', 
   style ({
     height: 200px, 
     opacity: 1, 
     background-color: 'yellow'})

</code-example>


<!-- <code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="state1">
 </code-example>-->

 In the above code snippet, you can see how states can allow multiple style attributes to be set all at the same time. When the button shows as `Open` it has several style attributes: a height of 200 pixels, an opacity of 1, and a color of yellow. The `style()` function describes what the style should be when the right conditions arise.

In the `closed` state, the button has a height of 100 pixels, an opacity of 0.5, and a background color of green. This example shows how states can allow multiple style attributes to be set all at the same time. 

<code-example hideCopy language="typescript">

state ('closed', 
   style ({
     height: 100px, 
     opacity: 0.5, 
     background-color: 'green'})

</code-example>

<!--<code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="state2">
 </code-example> -->

### Transitions and timing

In Angular, you can set multiple styles without any animation. However, without further refinement, the button will instantly transform with no fade, no shrinkage, or other visible indicator that a change is occurring. 

To make the change less abrupt, we need an animation _transition_ to describe the changes that occur between one state and another over a defined period of time. The `transition()` function accepts two arguments: the first argument accepts an expression that defines the direction between two transition states, and the second argument accepts an `animate()` function.

The `animate()` function allows you to define the length, delay, and easing of a transition. It also allows you to designate the style function for defining styles while the transitions are taking place, or the keyframes function for multi-step animations; both of which are placed in the second argument of the animate function.
For our example, let us provide a transition from `open` to `closed` state with a durations of 1s between transitions.

Note the arrow syntax used in the code snippet below. `=>` operator is used for unidirectional transitions, and `<=>` for bidirectional ones. Within the transition, `animate()` specifies how long the transition will take. In this case, the state change from open to closed takes one second, expressed here as '1s'.

<code-example hideCopy language="typescript">

transition ('open => closed', [
   animate ('1s') 
] )

</code-example>

<!--<code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="transition1">
 </code-example> -->

 We will also add a transition from `closed` to `open` state with a 0.5s duration.

<code-example hideCopy language="typescript">

transition ('closed => open', [
   animate ('0.5s') 
] )

</code-example>

<!--+<code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="transition2">
 </code-example>-->

 #### Notes on state-to-state transitions

* Styles defined using `state()` will persist after the animation has completed.

* You can include multiple state pairs within the same `transition()` argument:  
`transition( 'on => off, off => void' )

<div class="l-sub-section">

You can also define styles nested directly within the `transition()` function, with the following distinction between them:

* Use `state()` to define steady-state styles that are applied at the end of each transition. 

* Use `transition()` to define intermediate styles which create the illusion of motion during the animation.

* When animations are disabled, `transition()` styles can be skipped, but `state()` styles cannot. 

</div>

### Triggering the animation

We still need something to kick off the animation, so that it knows when to start. This is done through an animation trigger. The `trigger()` function collects the states and transitions, and gives the animation a name, so that you can attach it to the  triggering element in the HTML template. 

The `trigger()` function describes the property name that should be watched for changes. When that change occurs, the trigger specifies the actions to apply. These actions can be transitions, or, as we will see later on, other animation functions as well.

For our example, we'll name the trigger `openClose`, and attach it to the `button` element. The trigger describes the open and closed states, and the timings for the two transitions.  

<figure>
  <img src="generated/images/guide/animations/triggering-the-animation-500.png" alt="triggering the animation">
</figure>

Here's the trigger function that describes and names the new trigger: 

<code-example hideCopy language="typescript">

trigger ('openClose', [
   state ('open', style ({
      height: 200px,
      opacity: 1,
      background-color: 'yellow'}) ),
   state ('closed', style ({
      Height: 100px,
      Opacity: 0.5,
      background-color: 'green'}) ),
   transition ('open => closed', [
      animate ('1s')] ),
   transition ('closed => open', [
      animate ('500ms')] ),

</code-example>

<!-- <code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="trigger">
 </code-example>-->

<div class="l-sub-section">

Within each trigger() function call, an element can only be in one state at any given time. However, it is possible for multiple triggers to be active at once.
</div>

### Defining and attaching animations to the HTML template

Animations are  defined in the metadata of the component that controls the HTML element to be animated. Put the code that defines your animations under the `animations:` property within the `@Component` decorator:

<code-example hideCopy language="typescript">
@Component({
 selector: 'open-close-component',
 animations: [
   trigger('openClose', [
     state('open', style({
       height: '200px',
       opacity: 1,
       backgroundColor: 'yellow'
     })),
</code-example>

<!-- <code-example path="animations-guide/src/app/open-close.component.ts" title="src/app/open-close.component.ts" region="component">
+</code-example>-->

When you have defined an animation trigger for a component, you can attach it to an element in that component's template by wrapping the trigger name in brackets and preceeding it with an @ symbol. Then, you can bind it to a template expression using standard Angular property binding syntax as shown below:

<code-example hideCopy language="typescript">
&lt;div [@triggerName]="expression"&gt;...&lt;/div&gt;
</code-example>

where `triggerName` is the name of the trigger, and  `expression` evaluates to a defined animation state.  
The animation is executed or triggered when the expression value changes to a new state. 

<div class="l-sub-section">

The trigger is bound to the component in the component metadata, under the `@Component `decorator using the `animations:` property. In the HTML template, that same trigger appears under the HTML element to be animated. 

</div>

#### HTML template file
>**<button [ @openClose ] = 'expression' … />**

<!-- <code-example path="animations-guide/src/app/open-close.component.html" title="src/app/open-close.component.html" region="trigger">
+</code-example>-->


In the above code snippet, when the `isOpen` expression evaluates to a defined state: `open` or `closed`, it will notify the trigger `openClose` of a state change. It is then up to `openClose` code to handle the state change and kick off a state change animation.


For elements entering or leaving a page (inserted or removed  from the DOM), you can make the animation conditional – for example, use `*ngIf` with the animation trigger in the HTML template.

### Code sample, simple transition

Here are the code files discussed on the transition example.

<code-tabs>

 <code-pane title="src/app/open-close.component.ts" path="animations-guide/src/app/open-close.component.ts">
 </code-pane>

 <code-pane title="src/app/open-close.component.html" path="animations-guide/src/app/open-close.component.html">
 </code-pane>

</code-tabs>

### Summary

The simplest possible animation transition is between two states, using `style()`, `state()`,  with `animate()` for the timing. The animation kicks off using the `trigger()` function, which is also how the animation is tied to the HTML template. 


## Advanced techniques using transition()

In this section we are expanding on the basic transition example discussed above. We go into greater depth on callbacks, animation timing, some special states such as `wildcard *` and `void`, and show how these special states are used for elements entering and leaving a view.

### Duration, delay, and easing

The second argument of the transition fucntion is an `animate()` function that takes three arguments as a single string. This string may contain the following information:

>`animate ('duration delay easing')`

The first part, `duration`, is required. Duration can be expressed in milliseconds as a simple number without quotes, or in seconds with quotes and a time specifier. For example, a duration of a tenth of a second can be expressed as follows:

* As a plain number, in milliseconds: `100`

* In a string, as milliseconds: `'100ms'`

* In a string, as seconds: `'0.1s'`

The second argument, `delay`, has the same syntax as duration. For example:


* Wait for 100ms and then run for 200ms: `'0.2s 100ms'`


The third argument, `easing`, controls how the animation [accelerates and decelerates](http://easings.net/) during its runtime. For example, 'ease-in' causes the animation to begin slowly, and to pick up speed as it progresses.


* Wait for 100ms, run for 200ms. Use a deceleration curve to start out fast and slowly decelerate to a resting point:  
`'0.2s 100ms ease-out'`

* Run for 200ms, with no delay. Use a standard curve to start slow, accelerate in the middle, and then decelerate slowly at the end:  
`'0.2s ease-in-out'` 
* Start immediately, run for 200ms. Use a acceleration curve to start slow and end at full velocity:  
`'0.2s ease-in'`

<div class="l-sub-section">

NOTE: See the Angular Material Design web site’s topic on [Natural easing curves](https://material.io/guidelines/motion/duration-easing.html#duration-easing-natural-easing-curves) for general information on easing curves.
</div>

#### Valid values for easing

The `animate()` function takes the following valid values for easing:

* `ease-in`

* `ease-out`

* `ease-in-out`

* `linear`

* `cubic-bezier ( a , b , c , d )` where `a b c d` represent the four defined points needed for a Bezier curve as applied specifically to define web animation timings.


### Wildcard state *

An asterisk `*` or _wildcard_ matches any animation state. This is useful for defining transitions that apply regardless of the HTML element’s start or end state.

For example, a transition of  `open  => *` would apply when the element’s state changes from open to anything else. 

<figure>
  <img src="generated/images/guide/animations/wildcard-state-500.png" alt="wildcard state expressions">
</figure>

Here’s another code sample using the wildcard state together with our previous example using `open` and `closed` states. Instead of defining each state-to-state transition pair, we are now saying that any transition to `closed` takes 1 second, and any transition to `open` takes 0.5 seconds.

This allows us to add new states without having to add separate transitions for each one.

<code-example hideCopy language="typescript">
trigger ('openClose', [
   state ('open', style ({
      height: 200px,
      opacity: 1,
      background-color: 'yellow'}) ),
   state ('closed', style ({
      Height: 100px,
      Opacity: 0.5,
      background-color: 'green'}) ),
   transition ('* => closed', [
      animate ('1s')] ),
   transition ('* => open', [
      animate ('500ms')] ),
 </code-example>

Use a double arrow syntax to specify state-to-state transitions in both directions:

<code-example hideCopy language="typescript">
transition ('closed <=> open', [
      animate ('500ms')] ),
</code-example>

### Wildcard state with 3 states

In our two-state button example, the wildcard isn’t that useful because there are only 2 possible states, `open` and `closed`. Wildcard states are better when an element in one particular state has multiple potential states that it could change to. If our button could change from `open` to either `closed` or something like `inProgress`, using a wildcard state could potentially reduce the amount of coding you’d have to write.

<figure>
  <img src="generated/images/guide/animations/wildcard-3-states-500.png" alt="wildcard state with 3 states">
</figure>

In this example, we assume that all the transitions have a duration of 1 second.

<code-example hideCopy language="typescript">
   state ('open', style ({
      height: 200px,
      opacity: 1,
      background-color:'yellow'}) ),
   state ('closed', style ({
      height: 100px,
      opacity: 0.5,
      background-color: 'green'}) ),
   state ('inProgress', style ({
      height: 100px,
      opacity: 1,
      background-color: 'orange'}) ),
   transition ('* => *', [
      animate ('1s')] ),
</code-example>	

The `* => *` transition applies when any change between two states takes place. 

Transitions are matched in the order in which they are defined. Thus, you can apply other transitions on top of the  `* => *`  ("any-to-any") transition. For example, you can define style changes or animations that would apply just to `open  => closed`, or just  to `closed => open`, and then use `* => *` as a fallback for state pairings that aren't otherwise called out. 

To do this, list the more specific transitions _before_ the `* => *`. 

### Wildcard styles *

Use the wildcard `*` with a style setting to tell the animation to use whatever the current style value is, and animate with that. It's a fallback value that is used if the state that is being animated is not declared within the trigger.

<code-example hideCopy language="typescript">
transition ('* => open', [
   animate ('1s', 
      style ({ opacity: '*'}),
   ),
]),
</code-example>	

### Boolean values in transitions

If a trigger contains a Boolean value as a binding value, then this value can be matched using a `transition()` expression that compares `true` and `false`, or `1` and `0`.

In this example, the HTML template binds a `<div>` element to a trigger named `openClose`, with a status expression of `open`, with possible values of `true` and `false`. This is an alternative to the practice of simply creating two named states of open and close.

>**<div [ @openClose ]= 'open ? true : false' > … </div>**

In the component code, under the `@Component` metadata under the `animations:` property, when the state evaluates to `true`, meaning "open" in this case, the associated HTML element's height is a wildcard style or default, basically saying to use whatever height the element already had before the animation started. When the element is "closed", the element animates to a height of 0, which basically makes it invisible.

<code-example hideCopy language="typescript">
@Component ({
   … 
   animations: [
      trigger ( 'openClose', [
        state ( 'true', style ({ height: '*' })),
        state ( 'false', style ({ height: '0px' })),
        transition  ('false <=> true', animate ( 500 ))
   ])
</code-example>	

### Void state

A special state called `void` can apply when the HTML element is not attached to a view. For example, suppose we have a page where elements appear to fly in and out. You can use the void state in a transition to configure different transitions for entering and leaving based on each state.

<div class="l-sub-section">

For our purposes here, saying that an element is entering or leaving a view is equivalent to saying “inserted or removed from the DOM.” 

</div>

Up until this point, we haven’t had our single button enter or leave the page. We’ve assumed that the button starts out already on the page, and has three possible styles: open, closed, and inProgress.

Now we will add a new behavior: on initial page load, the button appears to fly onto the page from the left, entering in the `open` state. 

<code-example hideCopy language="typescript">
@Component ({
   animations: [
      trigger ( 'openClose',  [
              state ('open', style ({
            height: 200px,
            opacity: 1,
            background-color:'yellow'}) ),
         state ('closed', style ({
            height: 100px,
            opacity: 0.5,
            background-color: 'green'}) ),
         state ('inProgress', style ({
            height: 100px,
            opacity: 1,
            background-color: 'orange'}) ),
         transition ('open => *', [
            animate ('1s')] ),
//next bit was taken from existing doc
//hero-list-enter-leave-component.ts (excerpt)
           trigger('flyInOut', [  
         state('in',
           style({transform: 'translateX(0)'})),
//the void to wildcard is explained in next section
          transition('void => *', [
            style({transform: 'translateX(-100%)'}),
            animate(100)
          ]),
          transition('* => void', [
            animate(100,
              style({transform: 'translateX(100%)'}))
          ])
      ])
</code-example>	


### Combining wildcard and void states

You can combine wildcard and void states in a transition to define animations that enter and leave the page.

* A transition of `* =>` void applies when the element leaves a view, regardless of what state it was in before it left.

* A transition of `void => *` applies when the element enters a view, regardless of what state it  assumes when entering.

* The wildcard state `*` matches to _any_ state, including `void`.

#### :enter and :leave

The transitions for `void => *` and `* => void` have their own aliases, called `:enter` and `:leave`. These aliases are used by several animation functions. 

<code-example hideCopy language="typescript">
transition ( ':enter', [ ... ] );  // alias for void => *
transition ( ':leave', [ ... ] );  // alias for * => void
</code-example>	

HTML elements that are inserted or removed from a view use special enter and leave animations. It is harder to target an element that is entering, because it is not yet in the DOM. So, `:enter` is another point to lock onto an element and apply some style over time.

#### Use of *ngIf and *ngFor with :enter and :leave

The `:enter` transition runs when any `*ngIf` or `*ngFor` views are placed on the page, and `:leave` runs when those views are removed from the page. Let’s say that we have a special trigger for the enter and leave animation called `myInsertRemoveTrigger`.

The HTML template contains:

>**<div @myInsertRemoveTrigger *ngIf = 'expression'>**

In the component file, the enter transition first sets an initial opacity of 0, and then animates it to change that opacity to 1 as the element is inserted into the view:

<code-example hideCopy language="typescript">
trigger ('myInsertRemoveTrigger', [
   transition (':enter', [
       style ( { opacity: 0 } ), 
       animate ('1s', style ( { opacity: 1 } ),
       ] ),
   transition (':leave', [
      animate ('1s', style ( { opacity: 0 } )
   ] )
] )
</code-example>	

Note that this example does not need to use `state()`. 

#### :increment and :decrement in transitions

The `transition()` function takes additional selector values, `:increment` and `:decrement`. Use these to kick off a transition when a numeric value has increased or decreased in value.

<!-- example needed -->

## Advanced techniques in trigger() function
This section expands on advanced functions available while triggering an animation.

### Parent-Child Animations

Each time an animation is triggered in Angular, the parent animation always get priority and child animations are blocked. In order for a child animation to run, the parent animation must query each of the elements contatining child animations and then allow the animations to run using [animateChild](https://angular.io/api/animations/animateChild).

Normally, when an element within an HTML template has animations disabled using `@.disabled` host binding, animations are disabled on all inner elements as well.
However, selective child animations can still be run on a disabled parent in one of the following ways:

* A parent animation can use `query()` to collect inner elements located in disabled areas of the HTML template. Those elements can still animate.

* A sub-animation can be queried by a parent and then later animated with `animateChild()`.

#### Disabling an animation on an HTML element

A special animation control binding called `@.disabled` can be placed on an HTML element to disable animations on that element, as well as any inner animations for elements nested within the disabled element. When true, the `@.disabled` binding prevents all animations from rendering. 

The code sample below shows how to use this feature. Note that the HTML template code is embedded inside the component code in this example:

<code-example hideCopy language="typescript">
@Component ({
  selector: 'my-component',
  // HTML template code
  template: `
    &lt;div [ @.disabled ]= "isDisabled" >
      &lt;div [ @childAnimation ]= "exp" ></div>
    &lt;/div>
  `,
  animations: [
    trigger ( "childAnimation", [
      // ...
    ])
  ]
})

class MyComponent {
  isDisabled = true;
  exp = '...';
}
</code-example>
The `@childAnimation` trigger will not animate because the `@.disabled` binding (when true) prevents it from happening.

Note that `@.disabled` disables all animations running on the same element. You can't selectively disable multiple animations on a single element.

#### Disabling animations application-wide

To disable all animations for an entire Angular app, place the @.disabled host binding on the topmost Angular component.

<code-example hideCopy language="typescript">
import { Component, HostBinding } from '@angular/core';
@Component ({
  selector: 'app-component',
  templateUrl: 'app.component.html',
})
class AppComponent {
  @HostBinding ( '@.disabled' )
  public animationsDisabled = true;
}
</code-example>	

#### Multiple triggers and states active simultaneously

Within each trigger() function call, an element can only be in one state at any given time. However, it is possible for multiple triggers to be active at once.

<div class="l-sub-section">
Even if inner animations are disabled, a parent animation can still use query() for inner elements located in disabled areas of the HTML template and animate them. This is also the case for when a sub-animation is queried by a parent, and then later animated using animateChild().
</div>

### Animation callbacks

The animation `trigger()` function emits _callbacks_ when it starts and when it finishes. 

<code-example hideCopy language="typescript">
import {AnimationEvent} from '@angular/animations';
@Component ({
   animations: [
      trigger ( 'openClose',  […]
class openCloseComponent {
   onAnimationEvent ( event: AnimationEvent ) {…}
</code-example>	

In the HTML template, the animation event is passed back via `$event`, as `@trigger.start` and `@trigger.done`, where `trigger` is the name of the trigger being used. In our example, the trigger `openClose` appears as follows:

><div *ngIf = "expression"
>   @openClose {
>      (@openClose.start) = "onAnimationEvent ( $event )"
>      (@openClose.done) = "onAnimationEvent ( $event )"
>…</div>

A potential use for animation callbacks could be to cover for a slow API call, such as a database lookup. For example, the "InProgress" button could actually have its own looping animation where it pulsates or does some other visual motion while the back-end system operation finishes.

Then, another animation can be called when the current animation finishes. For example, the button goes from `inProgress` to the `closed` state when the API call is completed.

An animation can influence an end user to _perceive_ the operation as faster, even when it isn’t. Thus, a simple animation can be a cost-effective way to keep users happy, rather than seeking to improve the speed of a server call and having compensate for circumstances beyond your control, such as an unreliable network connection.

Callbacks can also serve as a debugging tool, for example in conjunction with `console.log()` to view the application’s progress in a browser’s Developer JavaScript Console. The following code snippet creates console log output for our original example, button that has 2 states of `open` and `closed`.

<code-example hideCopy language="typescript">
@Component ( {
   animations: [
      trigger ( 'openClose', [ … ] )
   ],
} )
class MyOpenCloseComponent {
   onAnimationEvent ( event: AnimationEvent ) {
  // syntax is event.triggerName
  // openClose is trigger name in this example 
      console.log ( event.openClose );
 // phaseName is start or done
      console.log ( event.phaseName  ); 
 // in our example, totalTime is 1000 or 1 second
      console.log ( event.totalTime  ); 
 // in our example, fromState is either open or closed
      console.log ( event.fromState  );  
 // in our example, toState either open or closed
      console.log ( event.toState  );
 // the HTML element itself, the button in this case
      console.log ( event.element  ); 
</code-example>

## Reusable Animations

Angular animation provides [AnimationOptions](https://angular.io/api/animations/AnimationOptions) to configure or override options for each of the step-based animation methods.

These methods are:

* `sequence([...], { /* options */ })`
* `group([...], { /* options */ })`
* `trigger([...], { /* options */ })`
* `transition([...], { /* options */ })`
* `query([...], { /* options */ })`

<code-example hideCopy language="typescript">
transition('open => closed', [style({
       height: 200 px
   }, {
       opacity: "{{ opacity }}"
   }, {
       backgroundcolor: 'yelow'
   }),
   animate("{{ time }}"),
], {
   time: "1s",
   opacity: "1"
})
</code-example>

In the above code snippet, both time and opacity inputs will be replaced during runtime.

[AnimationOptions](https://angular.io/api/animations/AnimationOptions) allow you to reuse an animation across different components. Create a reusable animation in a seperate .ts file  using the [animation()](https://angular.io/api/animations/animation) method and export it as a const variable. You can then reuse it in any of your app components using the [useAnimation()](https://angular.io/api/animations/useAnimation) API.

<code-example hideCopy language="typescript">
// inside animation.ts

import {animation, style, animate} from "@angular/animations";
export var transAnimation = animation([
 style({ height: "{{ height }}",
 opacity: "{{ opacity }}", backgroundcolor: "{{backgroundcolor}}" }),
 animate("{{ time }}" ])
</code-example>

In the above code snippet, `transAnimation` is made reusable by declaring it as an export variable.  You can import the reusable `transAnimation` in your component class and reuse it using the `useAnimation()` method as shown below:

<code-example hideCopy language="typescript">
// inside of @Component.animations...

import {useAnimation, transition} from "@angular/animations";
import {transAnimation} from "./animations";
transition('open => closed', [
 useAnimation(transAnimation, {
   height: 0,
   opacity: 1,
   backgroundcolor:'red',
   time: '1s' }) ])
</code-example>

## Keyframes

In the previous section we saw a simple two-state transition. Now we’ll create an animation with multiple steps run in sequence using keyframes. 

Angular’s `keyframe()` function is similar to keyframes in CSS. Keyframes allow several style changes within a single timing segment. For example, our button, instead of fading, could change color several times over a single 2-second timespan.

<figure>
  <img src="generated/images/guide/animations/keyframes-500.png" alt="keyframes">
</figure>

The code for the above might look like this:

<code-example hideCopy language="typescript">

animate ("2s", 
         keyframes([
            style ({ background-color: "blue"})
            style ({ background-color: "red"})
            style ({ background-color: "orange"})
         ])

</code-example>

<!-- <code-example path="animations-guide/src/app/status-slider.component.ts" title="src/app/status-slider.component.ts" region="keyframes">
 </code-example>-->

### Offset

Keyframes include an _offset_ that defines at which point in the animation each style change occurs. Offsets are relative measures from zero to one, marking the beginning and end of the animation respectively. 

Defining offsets for keyframes is optional. If you omit them, evenly spaced offsets are automatically assigned. For example, three keyframes without predefined offsets receive offsets 0, 0.5, and 1. Specifying an offset of 0.8 for the middle transition in the above example might look like this:

<figure>
  <img src="generated/images/guide/animations/keyframes-offset-500.png" alt="keyframes with offset">
</figure>

The code with offsets specified would be as follows:

<code-example hideCopy language="typescript">

animate ("2s", 
         keyframes([
            style ({ background-color: "blue", offset: 0})
            style ({ background-color: "red", offset: 0.8})
            style ({ background-color: "orange", offset: 1.0})
         ])

</code-example>

<!-- <code-example path="animations-guide/src/app/status-slider.component.ts" title="src/app/status-slider.component.ts" region="keyframesWithOffsets">
 </code-example>-->

You can combine keyframes together with duration, delay, and easing within a single animation.

### Keyframes with a pulsation

Here’s an example showing:

* The original open and closed states, with the original changes in height, color, and opacity, occurring over a timeframe of 1 second.

* A keyframes sequence inserted in the middle that causes the button to appear to pulsate irregularly over the course of that same 1-second timeframe.

<figure>
  <img src="generated/images/guide/animations/keyframes-pulsation-500.png" alt="keyframes with irregular pulsation">
</figure>

The code snippet for this animation might look like this:

<code-example hideCopy language="typescript">

@Component ({
        selector:  ' selectorName '
        templateUrl:  ' componentHtmlFile '
   animations: [
      trigger ( 'openClose',  [
      transition ('* => closed', [
         animate ('1s', keyframes ( [
            style ({ opacity: 0.1, offset: 0.1 })
            style ({ opacity: 0.6, offset: 0.2 })
            style ({ opacity: 1,   offset: 0.5 })
            style ({ opacity: 0.2, offset: 0.7 })
         ] ) 
      ] 
})

</code-example>	
<!--<code-example path="animations-guide/src/app/open-close.component.fake.ts" title="src/app/open-close.component.ts" region="trigger">
+</code-example> -->

<div class="l-sub-section">

The use of the wildcard state `*` under `transition()` in the above code snippet is described on the [Animation Basics Deep Dive](guide/animation-basics-deep-dive).
</div>

### Animatable properties and units

Angular's animation support builds on top of animations. Thus, you can animate any property that the browser considers animatable. This includes positions, sizes, transforms, colors, borders, and more. The W3C maintains a list of animatable properties on its [CSS Transitions](https://www.w3.org/TR/css-transitions-1/) page.

For positional properties with a numeric value, define a unit by providing the value as a string, in quotes, with the appropriate suffix:

* 50 pixels: `'50px'`

* Relative font size: `'3em'`

* Percentage: `'100%'`

If you don't provide a unit when specifying dimension, Angular assumes a default unit of pixels, or px:

* Expressing 50 pixels as `50` is the same as saying `'50px'`

### Automatic property calculation with *

Sometimes you don't know the value of a dimensional style property until runtime. For example, elements often have widths and heights that depend on their content and the screen size. These properties are often challenging to animate using CSS.

In these cases, you can use a special wildcard `*` property value under `style()`, so that the value of that particular style property is computed at runtime and then plugged into the animation.

In this example, we have a trigger called `shrinkOut`, used when an HTML element leaves the page. The animation takes whatever height the element has before it leaves, and animates from that height to zero:

<code-example hideCopy language="typescript">
animations: [
  trigger('shrinkOut', [
    state('in', style({height: '*'})),
    transition('* => void', [
      style({height: '*'}),
      animate(250, style({height: 0}))
    ])
  ])
]
</code-example>	


### Summary

The `keyframes()` function in Angular allows you to specify multiple interim styles within a single transition, with an optional offset to define at which point during the animation each style change occurs.

## Complex animation sequences

So far, we have been reviewing simple animations of single HTML elements. Angular also lets you animate coordinated sequences, such as an entire grid or list of elements as they enter and leave a page. You can choose to run multiple animations in parallel, or run discrete animations in sequential fashion, one following another.

Functions that control complex animation sequences are as follows:

* `query()` finds one or more inner HTML elements
* `stagger()` applies a cascading delay to animations for multiple elements
* `group()` runs multiple animation steps in parallel
* `sequence()` runs animation  steps one after another

### Animate multiple elements using query() and stagger() functions

The `query()` function allows you to find inner elements within the element that is being animated. It targets specific HTML elements within a parent component and applies animations specifically to each element individually. Angular intelligently handles setup, tear-down, and clean up as it coordinates the elements across the page. 

The `stagger()` function allows you to define a timing gap between each queried item that is animated and thus animates a bunch of elements with a delay between them.


This [demo](http://animationsftw.in/#/) shows an example of an animation involving multiple elements in a grid. The **Advanced** tab contains three image galleries, each consisting of a grid with tiled photo images. 

The page opens with an introductory sequence. To see the portion that is relevant to the above `query()` description, click **Advanced**. The entire grid for Gallery One cascades in, with a slight delay from row to row from the bottom up. Within each row, the elements slide down and fade into place starting from right to left.

### Page entry query stagger example

The page entry animation code is as follows:

<code-example hideCopy language="typescript">

trigger ('pageAnimations', [
  transition (':enter', [
    query ('.photo-record, .menu li, form', [
      style ({
        opacity: 0,
        transform: 'translateY (-100px)' }),
      stagger (-30, [
        animate ('500ms cubic-bezier(0.35, 0, 0.25, 1)',
          style ({ opacity: 1, transform: 'none' })
        )
      ])
    ])
  ])
])

</code-example>

This animation does the following:

* Use `query()` to look for any element entering or leaving the page. The query specifies elements meeting certain CSS class criteria.

* For each of these elements, use `style()` to set the same initial style for the element – make it invisible and using transform to move it out of position so that it can slide down into place.

* Use `stagger()` to delay each animation by 30 milliseconds, starting at the bottom of the page. 

* Animate each element in over 0.5 second using a custom-defined easing curve, simultaneously fading it in and un-transforming it at the same time.

In addition to the page animation that runs when you click **Advanced** from any other tab, there are additional animations when transitioning between Gallery Two, Gallery Three, and back to Gallery One again. You can review the code snippets embedded in the demo to see small differences in the `transition()` statements and animation parameters.

### Parallel animation using group() fucntion

You've seen how to add a delay between each successive animation. But you may also want to configure animations that happen in parallel. For example, you may want to animate two CSS properties of the same element but use a different easing function for each one. For this, you can use the
animation `group()` function. 

In the following example, using groups both on `enter:` and `leave:` allows for two different timing configurations. Both are applied to the same element in parallel, but run independently of each other:

<!--<code-example path="animations/src/app/hero-list-groups.component.ts" region="animationdef" title="hero-list-groups.component.ts (excerpt)" linenums="false"></code-example> -->

<div class="l-sub-section">

The `group()` function is used to group animation steps, rather than animated elements.
</div>


### Sequential vs. parallel animations

Complex animations can have many things happening at once. But what if you want to create an animation involving not just one, but several animations happening one after the other? 
Earlier we used `group()` to run multiple animations all at the same time, in parallel. 

A second function called `sequence()` lets you run those same animations one after the other. Within `sequence()`, the animation steps consist of either `style()` or `animate()` function calls. 

* Use `style()` to apply the provided styling data immediately.

* Use `animate()` to apply styling data over a given time interval.

### Filter animation example

Let’s take a look at another animation on this same demo page. In the upper left-hand corner of the **Advanced** page, enter some text into the “FILTER RESULTS” text box, such as “COOL” or “STYLE”.

The filter works real-time as you type. Elements (images) leave the page as the filter gets progressively stricter, when you type each new letter. The images successively re-enter the page, as you delete each letter in the filter box.

The HTML template contains a trigger called filterAnimation:

<code-example hideCopy language="typescript">
&lt;div [@filterAnimation]="totalItems"&gt;...&lt;/div&gt;
</code-example>

The component file contains 3 transitions:

<code-example hideCopy language="typescript">

trigger ( 'filterAnimation', [
  transition ( ':enter, [  ] ),
  transition ( ':increment', [
    query ( ':enter', [
      style ( { opacity: 0, width: '0px' } ),
      stagger( 50, [
        animate  ('300ms ease-out', style( { 
          opacity: 1, width: '*' } ) ),
      ]),
    ])
  ]),
  transition ( ':decrement', [
    query ( ':leave', [
      stagger ( 50, [
        animate ( '300ms ease-out', style( { 
           opacity: 0, width: '0px' } ) ),
      ]),
    ])
  ]),
])

</code-example>	

The animation does the following:

* Ignore any animations that are performed when the user first opens or navigates to this page. Since the filter narrows what is already there, it assumes that any HTML elements to be animated already exist in the DOM.

* Perform a filter match for matches. 

For each match:

* First, hide the element by making it completely transparent and infinitely narrow, by setting its opacity and width to 0.

* Animate in the element over 300 milliseconds. During the animation, the element assumes its default width and opacity.

* If there are multiple matching elements, stagger each element in starting at the top of the page, with a 50-millisecond delay between each element.

### Summary

Angular functions for animating multiple elements start with `query()` to find inner elements, for example gathering all images within a `<div>`. The remaining functions, `stagger()`, `group()`, and `sequence()`, apply cascades or allow you to control how multiple animation steps are applied.


## Animation DSL

Angular provides a domain-specific language (DSL) for animations. See @angular/animations module in the [API reference](api) for a listing and syntax of core functions and related data structures. 

Advanced animation features, including reusable animations, `animateChild()`, and route-based animations will be covered in separate guide. Route-based animations require additional modules and imports.

<table>

 <tr>
   <th style="vertical-align: top">
     Function name
   </th>

   <th style="vertical-align: top">
     What it does
   </th>
 </tr>

 <tr>
   <td><code>trigger()</code></td>
   <td>Kicks off the animation and serves as a container for all other animation function calls. HTML template binds to <code>triggerName</code>. Use the first argument to declare a unique trigger name. Uses array syntax.</td>
 </tr>

 <tr>
   <td><code>style()</code></td>
   <td>Defines one or more CSS styles to use in animations. Controls visual appearance of HTML elements during animations. Uses object syntax.</td>
 </tr>

 <tr>
   <td><code>state()</code></td>
   <td>Creates a named set of CSS styles which should be applied on successful transition to a given state. The state can then be referenced by name within other animation functions.</td>
 </tr>

 <tr>
   <td><code>animate()</code></td>
   <td>Specifies timing information for a transition. Optional values for delay and easing. Can contain <code>style()</code> calls within.</td>
 </tr>

 <tr>
   <td><code>transition()</code></td>
   <td>Defines animation sequence between 2 named states. Uses array syntax.</td>
 </tr>

 <tr>
   <td><code>keyframes()</code></td>
   <td>Allows a sequential change between styles within a specified time interval. Use within <code>animate()</code>. Can include multiple <code>style()</code> calls within each <code>keyframe()</code>. Uses array syntax.</td>
 </tr>

 <tr>
   <td><code>group()</code></td>
   <td>Specifies a group of animation steps (<em>inner animations</em>) to be run in parallel. Animation continues only after all inner animation steps have completed. Used within <code>sequence()</code> or <code>transition()</code></td>
 </tr>

 <tr>
   <td><code>query()</code></td>
   <td>Use to find one or more inner HTML elements within the current element. </td>
 </tr>

 <tr>
   <td><code>sequence()</code></td>
   <td>Specifies a list of animation steps that are run sequentially, one by one.</td>
 </tr>

 <tr>
   <td><code>stagger()</code></td>
   <td>Staggers the starting time for animations for multiple elements.</td>
 </tr>

 <tr>
   <td><code>animation()</code></td>
   <td>Produces a re-usable animation that can be invoked from elsewhere. Used together with <code>useAnimation()</code>.</td>
 </tr>

 <tr>
   <td><code>useAnimation()</code></td>
   <td>Activates a reusable animation. Used together with <code>animation()</code>.</td>
 </tr>

 <tr>
   <td><code>animateChild()</code></td>
   <td>Allows animations on child components to be run within the same timeframe as the parent.</td>
 </tr>

</table>
