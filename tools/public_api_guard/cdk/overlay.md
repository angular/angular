## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BooleanInput } from '@angular/cdk/coercion';
import { CdkScrollable } from '@angular/cdk/scrolling';
import { ComponentFactoryResolver } from '@angular/core';
import { ComponentPortal } from '@angular/cdk/portal';
import { ComponentRef } from '@angular/core';
import { ComponentType } from '@angular/cdk/portal';
import { Direction } from '@angular/cdk/bidi';
import { Directionality } from '@angular/cdk/bidi';
import { ElementRef } from '@angular/core';
import { EmbeddedViewRef } from '@angular/core';
import { EventEmitter } from '@angular/core';
import * as i0 from '@angular/core';
import * as i2 from '@angular/cdk/bidi';
import * as i3 from '@angular/cdk/portal';
import * as i4 from '@angular/cdk/scrolling';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { Location as Location_2 } from '@angular/common';
import { NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { Platform } from '@angular/cdk/platform';
import { Portal } from '@angular/cdk/portal';
import { PortalOutlet } from '@angular/cdk/portal';
import { ScrollDispatcher } from '@angular/cdk/scrolling';
import { SimpleChanges } from '@angular/core';
import { Subject } from 'rxjs';
import { TemplatePortal } from '@angular/cdk/portal';
import { TemplateRef } from '@angular/core';
import { ViewContainerRef } from '@angular/core';
import { ViewportRuler } from '@angular/cdk/scrolling';

// @public
export class BlockScrollStrategy implements ScrollStrategy {
    constructor(_viewportRuler: ViewportRuler, document: any);
    attach(): void;
    disable(): void;
    enable(): void;
}

// @public
const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;

// @public
const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    deps: (typeof Overlay)[];
    useFactory: typeof CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY;
};

// @public
function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => RepositionScrollStrategy;

// @public
export class CdkConnectedOverlay implements OnDestroy, OnChanges {
    constructor(_overlay: Overlay, templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef, scrollStrategyFactory: any, _dir: Directionality);
    readonly attach: EventEmitter<void>;
    backdropClass: string;
    readonly backdropClick: EventEmitter<MouseEvent>;
    readonly detach: EventEmitter<void>;
    get dir(): Direction;
    disableClose: boolean;
    get flexibleDimensions(): boolean;
    set flexibleDimensions(value: boolean);
    get growAfterOpen(): boolean;
    set growAfterOpen(value: boolean);
    get hasBackdrop(): any;
    set hasBackdrop(value: any);
    height: number | string;
    get lockPosition(): any;
    set lockPosition(value: any);
    minHeight: number | string;
    minWidth: number | string;
    // (undocumented)
    static ngAcceptInputType_flexibleDimensions: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_growAfterOpen: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_hasBackdrop: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_lockPosition: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_push: BooleanInput;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    get offsetX(): number;
    set offsetX(offsetX: number);
    get offsetY(): number;
    set offsetY(offsetY: number);
    open: boolean;
    origin: CdkOverlayOrigin;
    readonly overlayKeydown: EventEmitter<KeyboardEvent>;
    readonly overlayOutsideClick: EventEmitter<MouseEvent>;
    get overlayRef(): OverlayRef;
    panelClass: string | string[];
    readonly positionChange: EventEmitter<ConnectedOverlayPositionChange>;
    positions: ConnectedPosition[];
    positionStrategy: FlexibleConnectedPositionStrategy;
    get push(): boolean;
    set push(value: boolean);
    scrollStrategy: ScrollStrategy;
    transformOriginSelector: string;
    viewportMargin: number;
    width: number | string;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkConnectedOverlay, "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]", ["cdkConnectedOverlay"], { "origin": "cdkConnectedOverlayOrigin"; "positions": "cdkConnectedOverlayPositions"; "positionStrategy": "cdkConnectedOverlayPositionStrategy"; "offsetX": "cdkConnectedOverlayOffsetX"; "offsetY": "cdkConnectedOverlayOffsetY"; "width": "cdkConnectedOverlayWidth"; "height": "cdkConnectedOverlayHeight"; "minWidth": "cdkConnectedOverlayMinWidth"; "minHeight": "cdkConnectedOverlayMinHeight"; "backdropClass": "cdkConnectedOverlayBackdropClass"; "panelClass": "cdkConnectedOverlayPanelClass"; "viewportMargin": "cdkConnectedOverlayViewportMargin"; "scrollStrategy": "cdkConnectedOverlayScrollStrategy"; "open": "cdkConnectedOverlayOpen"; "disableClose": "cdkConnectedOverlayDisableClose"; "transformOriginSelector": "cdkConnectedOverlayTransformOriginOn"; "hasBackdrop": "cdkConnectedOverlayHasBackdrop"; "lockPosition": "cdkConnectedOverlayLockPosition"; "flexibleDimensions": "cdkConnectedOverlayFlexibleDimensions"; "growAfterOpen": "cdkConnectedOverlayGrowAfterOpen"; "push": "cdkConnectedOverlayPush"; }, { "backdropClick": "backdropClick"; "positionChange": "positionChange"; "attach": "attach"; "detach": "detach"; "overlayKeydown": "overlayKeydown"; "overlayOutsideClick": "overlayOutsideClick"; }, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkConnectedOverlay, [null, null, null, null, { optional: true; }]>;
}

// @public
export class CdkOverlayOrigin {
    constructor(
    elementRef: ElementRef);
    elementRef: ElementRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkOverlayOrigin, "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]", ["cdkOverlayOrigin"], {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkOverlayOrigin, never>;
}

export { CdkScrollable }

// @public
export class CloseScrollStrategy implements ScrollStrategy {
    constructor(_scrollDispatcher: ScrollDispatcher, _ngZone: NgZone, _viewportRuler: ViewportRuler, _config?: CloseScrollStrategyConfig | undefined);
    attach(overlayRef: OverlayReference): void;
    // (undocumented)
    detach(): void;
    disable(): void;
    enable(): void;
}

export { ComponentType }

// @public
export class ConnectedOverlayPositionChange {
    constructor(
    connectionPair: ConnectionPositionPair,
    scrollableViewProperties: ScrollingVisibility);
    connectionPair: ConnectionPositionPair;
    scrollableViewProperties: ScrollingVisibility;
}

// @public
export interface ConnectedPosition {
    // (undocumented)
    offsetX?: number;
    // (undocumented)
    offsetY?: number;
    // (undocumented)
    originX: 'start' | 'center' | 'end';
    // (undocumented)
    originY: 'top' | 'center' | 'bottom';
    // (undocumented)
    overlayX: 'start' | 'center' | 'end';
    // (undocumented)
    overlayY: 'top' | 'center' | 'bottom';
    // (undocumented)
    panelClass?: string | string[];
    // (undocumented)
    weight?: number;
}

// @public @deprecated
export class ConnectedPositionStrategy implements PositionStrategy {
    constructor(originPos: OriginConnectionPosition, overlayPos: OverlayConnectionPosition, connectedTo: ElementRef<HTMLElement>, viewportRuler: ViewportRuler, document: Document, platform: Platform, overlayContainer: OverlayContainer);
    apply(): void;
    attach(overlayRef: OverlayReference): void;
    detach(): void;
    dispose(): void;
    readonly onPositionChange: Observable<ConnectedOverlayPositionChange>;
    get positions(): ConnectionPositionPair[];
    _positionStrategy: FlexibleConnectedPositionStrategy;
    _preferredPositions: ConnectionPositionPair[];
    recalculateLastPosition(): void;
    setOrigin(origin: ElementRef): this;
    withDirection(dir: 'ltr' | 'rtl'): this;
    withFallbackPosition(originPos: OriginConnectionPosition, overlayPos: OverlayConnectionPosition, offsetX?: number, offsetY?: number): this;
    withLockedPosition(isLocked: boolean): this;
    withOffsetX(offset: number): this;
    withOffsetY(offset: number): this;
    withPositions(positions: ConnectionPositionPair[]): this;
    withScrollableContainers(scrollables: CdkScrollable[]): void;
}

// @public
export class ConnectionPositionPair {
    constructor(origin: OriginConnectionPosition, overlay: OverlayConnectionPosition,
    offsetX?: number | undefined,
    offsetY?: number | undefined,
    panelClass?: string | string[] | undefined);
    offsetX?: number | undefined;
    offsetY?: number | undefined;
    originX: HorizontalConnectionPos;
    originY: VerticalConnectionPos;
    overlayX: HorizontalConnectionPos;
    overlayY: VerticalConnectionPos;
    panelClass?: string | string[] | undefined;
}

// @public
export class FlexibleConnectedPositionStrategy implements PositionStrategy {
    constructor(connectedTo: FlexibleConnectedPositionStrategyOrigin, _viewportRuler: ViewportRuler, _document: Document, _platform: Platform, _overlayContainer: OverlayContainer);
    apply(): void;
    attach(overlayRef: OverlayReference): void;
    // (undocumented)
    detach(): void;
    dispose(): void;
    positionChanges: Observable<ConnectedOverlayPositionChange>;
    get positions(): ConnectionPositionPair[];
    _preferredPositions: ConnectionPositionPair[];
    reapplyLastPosition(): void;
    setOrigin(origin: FlexibleConnectedPositionStrategyOrigin): this;
    withDefaultOffsetX(offset: number): this;
    withDefaultOffsetY(offset: number): this;
    withFlexibleDimensions(flexibleDimensions?: boolean): this;
    withGrowAfterOpen(growAfterOpen?: boolean): this;
    withLockedPosition(isLocked?: boolean): this;
    withPositions(positions: ConnectedPosition[]): this;
    withPush(canPush?: boolean): this;
    withScrollableContainers(scrollables: CdkScrollable[]): this;
    withTransformOriginOn(selector: string): this;
    withViewportMargin(margin: number): this;
}

// @public
export type FlexibleConnectedPositionStrategyOrigin = ElementRef | Element | Point & {
    width?: number;
    height?: number;
};

// @public
export class FullscreenOverlayContainer extends OverlayContainer implements OnDestroy {
    constructor(_document: any, platform: Platform);
    // (undocumented)
    protected _createContainer(): void;
    getFullscreenElement(): Element;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<FullscreenOverlayContainer, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<FullscreenOverlayContainer>;
}

// @public
export class GlobalPositionStrategy implements PositionStrategy {
    apply(): void;
    // (undocumented)
    attach(overlayRef: OverlayReference): void;
    bottom(value?: string): this;
    centerHorizontally(offset?: string): this;
    centerVertically(offset?: string): this;
    dispose(): void;
    // @deprecated
    height(value?: string): this;
    left(value?: string): this;
    right(value?: string): this;
    top(value?: string): this;
    // @deprecated
    width(value?: string): this;
}

// @public
export type HorizontalConnectionPos = 'start' | 'center' | 'end';

// @public
export class NoopScrollStrategy implements ScrollStrategy {
    attach(): void;
    disable(): void;
    enable(): void;
}

// @public
export interface OriginConnectionPosition {
    // (undocumented)
    originX: HorizontalConnectionPos;
    // (undocumented)
    originY: VerticalConnectionPos;
}

// @public
export class Overlay {
    constructor(
    scrollStrategies: ScrollStrategyOptions, _overlayContainer: OverlayContainer, _componentFactoryResolver: ComponentFactoryResolver, _positionBuilder: OverlayPositionBuilder, _keyboardDispatcher: OverlayKeyboardDispatcher, _injector: Injector, _ngZone: NgZone, _document: any, _directionality: Directionality, _location: Location_2, _outsideClickDispatcher: OverlayOutsideClickDispatcher);
    create(config?: OverlayConfig): OverlayRef;
    position(): OverlayPositionBuilder;
    scrollStrategies: ScrollStrategyOptions;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<Overlay, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<Overlay>;
}

// @public
export class OverlayConfig {
    constructor(config?: OverlayConfig);
    backdropClass?: string | string[];
    direction?: Direction | Directionality;
    disposeOnNavigation?: boolean;
    hasBackdrop?: boolean;
    height?: number | string;
    maxHeight?: number | string;
    maxWidth?: number | string;
    minHeight?: number | string;
    minWidth?: number | string;
    panelClass?: string | string[];
    positionStrategy?: PositionStrategy;
    scrollStrategy?: ScrollStrategy;
    width?: number | string;
}

// @public
export interface OverlayConnectionPosition {
    // (undocumented)
    overlayX: HorizontalConnectionPos;
    // (undocumented)
    overlayY: VerticalConnectionPos;
}

// @public
export class OverlayContainer implements OnDestroy {
    constructor(document: any, _platform: Platform);
    // (undocumented)
    protected _containerElement: HTMLElement;
    protected _createContainer(): void;
    // (undocumented)
    protected _document: Document;
    getContainerElement(): HTMLElement;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    protected _platform: Platform;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayContainer, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<OverlayContainer>;
}

// @public
export class OverlayKeyboardDispatcher extends BaseOverlayDispatcher {
    constructor(document: any);
    add(overlayRef: OverlayReference): void;
    protected detach(): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayKeyboardDispatcher, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<OverlayKeyboardDispatcher>;
}

// @public (undocumented)
export class OverlayModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<OverlayModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<OverlayModule, [typeof i1.CdkConnectedOverlay, typeof i1.CdkOverlayOrigin], [typeof i2.BidiModule, typeof i3.PortalModule, typeof i4.ScrollingModule], [typeof i1.CdkConnectedOverlay, typeof i1.CdkOverlayOrigin, typeof i4.ScrollingModule]>;
}

// @public
export class OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {
    constructor(document: any, _platform: Platform);
    add(overlayRef: OverlayReference): void;
    protected detach(): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayOutsideClickDispatcher, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<OverlayOutsideClickDispatcher>;
}

// @public
export class OverlayPositionBuilder {
    constructor(_viewportRuler: ViewportRuler, _document: any, _platform: Platform, _overlayContainer: OverlayContainer);
    // @deprecated
    connectedTo(elementRef: ElementRef, originPos: OriginConnectionPosition, overlayPos: OverlayConnectionPosition): ConnectedPositionStrategy;
    flexibleConnectedTo(origin: FlexibleConnectedPositionStrategyOrigin): FlexibleConnectedPositionStrategy;
    global(): GlobalPositionStrategy;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<OverlayPositionBuilder, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<OverlayPositionBuilder>;
}

// @public
export class OverlayRef implements PortalOutlet, OverlayReference {
    constructor(_portalOutlet: PortalOutlet, _host: HTMLElement, _pane: HTMLElement, _config: ImmutableObject<OverlayConfig>, _ngZone: NgZone, _keyboardDispatcher: OverlayKeyboardDispatcher, _document: Document, _location: Location_2, _outsideClickDispatcher: OverlayOutsideClickDispatcher);
    addPanelClass(classes: string | string[]): void;
    // (undocumented)
    attach<T>(portal: ComponentPortal<T>): ComponentRef<T>;
    // (undocumented)
    attach<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;
    // (undocumented)
    attach(portal: any): any;
    attachments(): Observable<void>;
    backdropClick(): Observable<MouseEvent>;
    get backdropElement(): HTMLElement | null;
    detach(): any;
    detachBackdrop(): void;
    detachments(): Observable<void>;
    dispose(): void;
    getConfig(): OverlayConfig;
    getDirection(): Direction;
    hasAttached(): boolean;
    get hostElement(): HTMLElement;
    keydownEvents(): Observable<KeyboardEvent>;
    readonly _keydownEvents: Subject<KeyboardEvent>;
    outsidePointerEvents(): Observable<MouseEvent>;
    readonly _outsidePointerEvents: Subject<MouseEvent>;
    get overlayElement(): HTMLElement;
    removePanelClass(classes: string | string[]): void;
    setDirection(dir: Direction | Directionality): void;
    updatePosition(): void;
    updatePositionStrategy(strategy: PositionStrategy): void;
    updateScrollStrategy(strategy: ScrollStrategy): void;
    updateSize(sizeConfig: OverlaySizeConfig): void;
}

// @public
export interface OverlaySizeConfig {
    // (undocumented)
    height?: number | string;
    // (undocumented)
    maxHeight?: number | string;
    // (undocumented)
    maxWidth?: number | string;
    // (undocumented)
    minHeight?: number | string;
    // (undocumented)
    minWidth?: number | string;
    // (undocumented)
    width?: number | string;
}

// @public
export interface PositionStrategy {
    apply(): void;
    attach(overlayRef: OverlayReference): void;
    detach?(): void;
    dispose(): void;
}

// @public
export class RepositionScrollStrategy implements ScrollStrategy {
    constructor(_scrollDispatcher: ScrollDispatcher, _viewportRuler: ViewportRuler, _ngZone: NgZone, _config?: RepositionScrollStrategyConfig | undefined);
    attach(overlayRef: OverlayReference): void;
    // (undocumented)
    detach(): void;
    disable(): void;
    enable(): void;
}

// @public
export interface RepositionScrollStrategyConfig {
    autoClose?: boolean;
    scrollThrottle?: number;
}

export { ScrollDispatcher }

// @public
export class ScrollingVisibility {
    // (undocumented)
    isOriginClipped: boolean;
    // (undocumented)
    isOriginOutsideView: boolean;
    // (undocumented)
    isOverlayClipped: boolean;
    // (undocumented)
    isOverlayOutsideView: boolean;
}

// @public
export interface ScrollStrategy {
    attach: (overlayRef: OverlayReference) => void;
    detach?: () => void;
    disable: () => void;
    enable: () => void;
}

// @public
export class ScrollStrategyOptions {
    constructor(_scrollDispatcher: ScrollDispatcher, _viewportRuler: ViewportRuler, _ngZone: NgZone, document: any);
    block: () => BlockScrollStrategy;
    close: (config?: CloseScrollStrategyConfig | undefined) => CloseScrollStrategy;
    noop: () => NoopScrollStrategy;
    reposition: (config?: RepositionScrollStrategyConfig | undefined) => RepositionScrollStrategy;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ScrollStrategyOptions, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<ScrollStrategyOptions>;
}

// @public
export function validateHorizontalPosition(property: string, value: HorizontalConnectionPos): void;

// @public
export function validateVerticalPosition(property: string, value: VerticalConnectionPos): void;

// @public
export type VerticalConnectionPos = 'top' | 'center' | 'bottom';

export { ViewportRuler }

// (No @packageDocumentation comment for this package)

```
