## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AfterContentInit } from '@angular/core';
import { BooleanInput } from '@angular/cdk/coercion';
import { ConnectedPosition } from '@angular/cdk/overlay';
import { Directionality } from '@angular/cdk/bidi';
import { ElementRef } from '@angular/core';
import { EventEmitter } from '@angular/core';
import { FocusableOption } from '@angular/cdk/a11y';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { FocusOrigin } from '@angular/cdk/a11y';
import * as i0 from '@angular/core';
import * as i10 from '@angular/cdk/overlay';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { OnDestroy } from '@angular/core';
import { Optional } from '@angular/core';
import { Overlay } from '@angular/cdk/overlay';
import { OverlayRef } from '@angular/cdk/overlay';
import { QueryList } from '@angular/core';
import { Subject } from 'rxjs';
import { TemplatePortal } from '@angular/cdk/portal';
import { TemplateRef } from '@angular/core';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { ViewContainerRef } from '@angular/core';

// @public
export const CDK_MENU: InjectionToken<Menu>;

// @public
export class CdkContextMenuTrigger extends CdkMenuTriggerBase implements OnDestroy {
    constructor(
    injector: Injector,
    viewContainerRef: ViewContainerRef,
    _overlay: Overlay,
    _contextMenuTracker: ContextMenuTracker,
    menuStack: MenuStack,
    _directionality?: Directionality | undefined);
    close(): void;
    get disabled(): boolean;
    set disabled(value: BooleanInput);
    open(coordinates: ContextMenuCoordinates): void;
    _openOnContextMenu(event: MouseEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkContextMenuTrigger, "[cdkContextMenuTriggerFor]", ["cdkContextMenuTriggerFor"], { "menuTemplateRef": "cdkContextMenuTriggerFor"; "menuPosition": "cdkContextMenuPosition"; "disabled": "cdkContextMenuDisabled"; }, { "opened": "cdkContextMenuOpened"; "closed": "cdkContextMenuClosed"; }, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkContextMenuTrigger, [null, null, null, null, null, { optional: true; }]>;
}

// @public
export class CdkMenu extends CdkMenuBase implements AfterContentInit, OnDestroy {
    constructor(
    elementRef: ElementRef<HTMLElement>,
    ngZone: NgZone,
    menuStack: MenuStack,
    _parentTrigger?: CdkMenuTriggerBase | undefined,
    menuAim?: MenuAim,
    dir?: Directionality);
    readonly closed: EventEmitter<void>;
    _handleKeyEvent(event: KeyboardEvent): void;
    readonly isInline: boolean;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    readonly orientation = "vertical";
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenu, "[cdkMenu]", ["cdkMenu"], {}, { "closed": "closed"; }, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenu, [null, null, null, { optional: true; }, { optional: true; self: true; }, { optional: true; }]>;
}

// @public
export class CdkMenuBar extends CdkMenuBase implements AfterContentInit {
    constructor(
    elementRef: ElementRef<HTMLElement>,
    ngZone: NgZone,
    menuStack: MenuStack,
    menuAim?: MenuAim,
    dir?: Directionality);
    _handleKeyEvent(event: KeyboardEvent): void;
    readonly isInline = true;
    // (undocumented)
    ngAfterContentInit(): void;
    readonly orientation = "horizontal";
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuBar, "[cdkMenuBar]", ["cdkMenuBar"], {}, {}, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuBar, [null, null, null, { optional: true; self: true; }, { optional: true; }]>;
}

// @public
export abstract class CdkMenuBase extends CdkMenuGroup implements Menu, AfterContentInit, OnDestroy {
    protected constructor(
    elementRef: ElementRef<HTMLElement>,
    ngZone: NgZone,
    menuStack: MenuStack,
    menuAim?: MenuAim | undefined,
    dir?: Directionality | undefined);
    protected closeOpenMenu(menu: MenuStackItem, options?: {
        focusParentTrigger?: boolean;
    }): void;
    protected readonly destroyed: Subject<void>;
    protected readonly dir?: Directionality | undefined;
    focusFirstItem(focusOrigin?: FocusOrigin): void;
    focusLastItem(focusOrigin?: FocusOrigin): void;
    _getTabIndex(): 0 | -1 | null;
    id: string;
    isInline: boolean;
    readonly items: QueryList<CdkMenuItem>;
    protected keyManager: FocusKeyManager<CdkMenuItem>;
    protected readonly menuAim?: MenuAim | undefined;
    readonly menuStack: MenuStack;
    readonly nativeElement: HTMLElement;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    protected ngZone: NgZone;
    orientation: 'horizontal' | 'vertical';
    protected pointerTracker?: PointerFocusTracker<CdkMenuItem>;
    protected triggerItem?: CdkMenuItem;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuBase, never, never, { "id": "id"; }, {}, ["items"], never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuBase, [null, null, null, { optional: true; self: true; }, { optional: true; }]>;
}

// @public
export class CdkMenuGroup {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuGroup, "[cdkMenuGroup]", ["cdkMenuGroup"], {}, {}, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuGroup, never>;
}

// @public
export class CdkMenuItem implements FocusableOption, FocusableElement, Toggler, OnDestroy {
    constructor(
    _elementRef: ElementRef<HTMLElement>,
    _ngZone: NgZone,
    _menuStack: MenuStack,
    _parentMenu?: Menu | undefined,
    _menuAim?: MenuAim | undefined,
    _dir?: Directionality | undefined,
    _menuTrigger?: CdkMenuTrigger | undefined);
    protected closeOnSpacebarTrigger: boolean;
    protected readonly destroyed: Subject<void>;
    get disabled(): boolean;
    set disabled(value: BooleanInput);
    readonly _elementRef: ElementRef<HTMLElement>;
    focus(): void;
    getLabel(): string;
    getMenu(): Menu | undefined;
    getMenuTrigger(): CdkMenuTrigger | undefined;
    readonly hasMenu: boolean;
    isMenuOpen(): boolean;
    // (undocumented)
    ngOnDestroy(): void;
    _onKeydown(event: KeyboardEvent): void;
    _resetTabIndex(): void;
    _setTabIndex(event?: MouseEvent): void;
    _tabindex: 0 | -1;
    trigger(options?: {
        keepOpen: boolean;
    }): void;
    readonly triggered: EventEmitter<void>;
    typeaheadLabel: string | null;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItem, "[cdkMenuItem]", ["cdkMenuItem"], { "disabled": "cdkMenuItemDisabled"; "typeaheadLabel": "cdkMenuitemTypeaheadLabel"; }, { "triggered": "cdkMenuItemTriggered"; }, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItem, [null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; self: true; }]>;
}

// @public
export class CdkMenuItemCheckbox extends CdkMenuItemSelectable {
    trigger(options?: {
        keepOpen: boolean;
    }): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItemCheckbox, "[cdkMenuItemCheckbox]", ["cdkMenuItemCheckbox"], {}, {}, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItemCheckbox, never>;
}

// @public
export class CdkMenuItemRadio extends CdkMenuItemSelectable implements OnDestroy {
    constructor(
    element: ElementRef<HTMLElement>,
    ngZone: NgZone,
    _selectionDispatcher: UniqueSelectionDispatcher,
    menuStack: MenuStack,
    parentMenu?: Menu,
    menuAim?: MenuAim,
    dir?: Directionality,
    menuTrigger?: CdkMenuTrigger);
    // (undocumented)
    ngOnDestroy(): void;
    trigger(options?: {
        keepOpen: boolean;
    }): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItemRadio, "[cdkMenuItemRadio]", ["cdkMenuItemRadio"], {}, {}, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItemRadio, [null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; self: true; }]>;
}

// @public
export abstract class CdkMenuItemSelectable extends CdkMenuItem {
    get checked(): boolean;
    set checked(value: BooleanInput);
    protected closeOnSpacebarTrigger: boolean;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItemSelectable, never, never, { "checked": "cdkMenuItemChecked"; }, {}, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItemSelectable, never>;
}

// @public
export class CdkMenuModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<CdkMenuModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkMenuModule, [typeof i1.CdkMenuBar, typeof i2.CdkMenu, typeof i3.CdkMenuItem, typeof i4.CdkMenuItemRadio, typeof i5.CdkMenuItemCheckbox, typeof i6.CdkMenuTrigger, typeof i7.CdkMenuGroup, typeof i8.CdkContextMenuTrigger, typeof i9.CdkTargetMenuAim], [typeof i10.OverlayModule], [typeof i1.CdkMenuBar, typeof i2.CdkMenu, typeof i3.CdkMenuItem, typeof i4.CdkMenuItemRadio, typeof i5.CdkMenuItemCheckbox, typeof i6.CdkMenuTrigger, typeof i7.CdkMenuGroup, typeof i8.CdkContextMenuTrigger, typeof i9.CdkTargetMenuAim]>;
}

// @public
export class CdkMenuTrigger extends CdkMenuTriggerBase implements OnDestroy {
    constructor(
    injector: Injector,
    _elementRef: ElementRef<HTMLElement>,
    viewContainerRef: ViewContainerRef,
    _overlay: Overlay,
    _ngZone: NgZone,
    menuStack: MenuStack,
    _parentMenu?: Menu | undefined,
    _menuAim?: MenuAim | undefined,
    _directionality?: Directionality | undefined);
    close(): void;
    getMenu(): Menu | undefined;
    open(): void;
    _setHasFocus(hasFocus: boolean): void;
    toggle(): void;
    _toggleOnKeydown(event: KeyboardEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuTrigger, "[cdkMenuTriggerFor]", ["cdkMenuTriggerFor"], { "menuTemplateRef": "cdkMenuTriggerFor"; "menuPosition": "cdkMenuPosition"; }, { "opened": "cdkMenuOpened"; "closed": "cdkMenuClosed"; }, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuTrigger, [null, null, null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export abstract class CdkMenuTriggerBase implements OnDestroy {
    protected constructor(
    injector: Injector,
    viewContainerRef: ViewContainerRef,
    menuStack: MenuStack);
    protected childMenu?: Menu;
    readonly closed: EventEmitter<void>;
    protected readonly destroyed: Subject<void>;
    protected getMenuContentPortal(): TemplatePortal<any>;
    protected readonly injector: Injector;
    protected isElementInsideMenuStack(element: Element): boolean;
    isOpen(): boolean;
    menuPosition: ConnectedPosition[];
    protected readonly menuStack: MenuStack;
    menuTemplateRef: TemplateRef<unknown>;
    // (undocumented)
    ngOnDestroy(): void;
    readonly opened: EventEmitter<void>;
    protected overlayRef: OverlayRef | null;
    registerChildMenu(child: Menu): void;
    protected readonly stopOutsideClicksListener: Observable<void>;
    protected readonly viewContainerRef: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuTriggerBase, never, never, {}, {}, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuTriggerBase, never>;
}

// @public
export class CdkTargetMenuAim {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTargetMenuAim, "[cdkTargetMenuAim]", ["cdkTargetMenuAim"], {}, {}, never, never, false>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTargetMenuAim, never>;
}

// @public
export interface CloseOptions {
    focusNextOnEmpty?: FocusNext;
    focusParentTrigger?: boolean;
}

// @public
export type ContextMenuCoordinates = {
    x: number;
    y: number;
};

// @public
export class ContextMenuTracker {
    update(trigger: CdkContextMenuTrigger): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ContextMenuTracker, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<ContextMenuTracker>;
}

// @public
export interface FocusableElement {
    _elementRef: ElementRef<HTMLElement>;
}

// @public
export const enum FocusNext {
    // (undocumented)
    currentItem = 2,
    // (undocumented)
    nextItem = 0,
    // (undocumented)
    previousItem = 1
}

// @public
export interface Menu extends MenuStackItem {
    focusFirstItem(focusOrigin: FocusOrigin): void;
    focusLastItem(focusOrigin: FocusOrigin): void;
    id: string;
    nativeElement: HTMLElement;
    readonly orientation: 'horizontal' | 'vertical';
}

// @public
export const MENU_AIM: InjectionToken<MenuAim>;

// @public
export const MENU_STACK: InjectionToken<MenuStack>;

// @public
export const MENU_TRIGGER: InjectionToken<CdkMenuTriggerBase>;

// @public
export interface MenuAim {
    initialize(menu: Menu, pointerTracker: PointerFocusTracker<FocusableElement & Toggler>): void;
    toggle(doToggle: () => void): void;
}

// @public
export class MenuStack {
    close(lastItem: MenuStackItem, options?: CloseOptions): void;
    closeAll(options?: CloseOptions): void;
    readonly closed: Observable<MenuStackCloseEvent>;
    closeSubMenuOf(lastItem: MenuStackItem): boolean;
    readonly emptied: Observable<FocusNext | undefined>;
    readonly hasFocus: Observable<boolean>;
    hasInlineMenu(): boolean;
    readonly id: string;
    static inline(orientation: 'vertical' | 'horizontal'): MenuStack;
    inlineMenuOrientation(): "vertical" | "horizontal" | null;
    isEmpty(): boolean;
    length(): number;
    peek(): MenuStackItem | undefined;
    push(menu: MenuStackItem): void;
    setHasFocus(hasFocus: boolean): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MenuStack, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MenuStack>;
}

// @public
export interface MenuStackCloseEvent {
    focusParentTrigger?: boolean;
    item: MenuStackItem;
}

// @public
export interface MenuStackItem {
    menuStack?: MenuStack;
}

// @public
export const PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER: (orientation: 'vertical' | 'horizontal') => {
    provide: InjectionToken<MenuStack>;
    deps: Optional[][];
    useFactory: (parentMenuStack?: MenuStack | undefined) => MenuStack;
};

// @public
export const PARENT_OR_NEW_MENU_STACK_PROVIDER: {
    provide: InjectionToken<MenuStack>;
    deps: Optional[][];
    useFactory: (parentMenuStack?: MenuStack | undefined) => MenuStack;
};

// @public
export class PointerFocusTracker<T extends FocusableElement> {
    constructor(
    _items: QueryList<T>);
    activeElement?: T;
    destroy(): void;
    readonly entered: Observable<T>;
    readonly exited: Observable<T>;
    previousElement?: T;
}

// @public
export class TargetMenuAim implements MenuAim, OnDestroy {
    constructor(
    _ngZone: NgZone);
    initialize(menu: Menu, pointerTracker: PointerFocusTracker<FocusableElement & Toggler>): void;
    // (undocumented)
    ngOnDestroy(): void;
    toggle(doToggle: () => void): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<TargetMenuAim, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<TargetMenuAim>;
}

// @public
export interface Toggler {
    getMenu(): Menu | undefined;
}

// (No @packageDocumentation comment for this package)

```
