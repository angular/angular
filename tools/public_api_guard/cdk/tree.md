## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AfterContentChecked } from '@angular/core';
import { AfterContentInit } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { BooleanInput } from '@angular/cdk/coercion';
import { ChangeDetectorRef } from '@angular/core';
import { CollectionViewer } from '@angular/cdk/collections';
import { DataSource } from '@angular/cdk/collections';
import { Directionality } from '@angular/cdk/bidi';
import { DoCheck } from '@angular/core';
import { ElementRef } from '@angular/core';
import { FocusableOption } from '@angular/cdk/a11y';
import * as i0 from '@angular/core';
import { InjectionToken } from '@angular/core';
import { IterableDiffer } from '@angular/core';
import { IterableDiffers } from '@angular/core';
import { NumberInput } from '@angular/cdk/coercion';
import { Observable } from 'rxjs';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { QueryList } from '@angular/core';
import { SelectionModel } from '@angular/cdk/collections';
import { Subject } from 'rxjs';
import { TemplateRef } from '@angular/core';
import { TrackByFunction } from '@angular/core';
import { ViewContainerRef } from '@angular/core';

// @public
export abstract class BaseTreeControl<T, K = T> implements TreeControl<T, K> {
    collapse(dataNode: T): void;
    collapseAll(): void;
    collapseDescendants(dataNode: T): void;
    dataNodes: T[];
    expand(dataNode: T): void;
    abstract expandAll(): void;
    expandDescendants(dataNode: T): void;
    expansionModel: SelectionModel<K>;
    getChildren: (dataNode: T) => (Observable<T[]> | T[] | undefined | null);
    abstract getDescendants(dataNode: T): T[];
    getLevel: (dataNode: T) => number;
    isExpandable: (dataNode: T) => boolean;
    isExpanded(dataNode: T): boolean;
    toggle(dataNode: T): void;
    toggleDescendants(dataNode: T): void;
    trackBy?: (dataNode: T) => K;
    // (undocumented)
    protected _trackByValue(value: T | K): K;
}

// @public
export const CDK_TREE_NODE_OUTLET_NODE: InjectionToken<{}>;

// @public
export class CdkNestedTreeNode<T, K = T> extends CdkTreeNode<T, K> implements AfterContentInit, DoCheck, OnDestroy, OnInit {
    constructor(elementRef: ElementRef<HTMLElement>, tree: CdkTree<T, K>, _differs: IterableDiffers);
    protected _children: T[];
    protected _clear(): void;
    // (undocumented)
    protected _differs: IterableDiffers;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngDoCheck(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    nodeOutlet: QueryList<CdkTreeNodeOutlet>;
    protected updateChildrenNodes(children?: T[]): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkNestedTreeNode<any, any>, "cdk-nested-tree-node", ["cdkNestedTreeNode"], { "role": "role"; "disabled": "disabled"; "tabIndex": "tabIndex"; }, {}, ["nodeOutlet"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkNestedTreeNode<any, any>, never>;
}

// @public
export class CdkTree<T, K = T> implements AfterContentChecked, CollectionViewer, OnDestroy, OnInit {
    constructor(_differs: IterableDiffers, _changeDetectorRef: ChangeDetectorRef);
    get dataSource(): DataSource<T> | Observable<T[]> | T[];
    set dataSource(dataSource: DataSource<T> | Observable<T[]> | T[]);
    _getNodeDef(data: T, i: number): CdkTreeNodeDef<T>;
    insertNode(nodeData: T, index: number, viewContainer?: ViewContainerRef, parentData?: T): void;
    // (undocumented)
    ngAfterContentChecked(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    _nodeDefs: QueryList<CdkTreeNodeDef<T>>;
    // (undocumented)
    _nodeOutlet: CdkTreeNodeOutlet;
    renderNodeChanges(data: readonly T[], dataDiffer?: IterableDiffer<T>, viewContainer?: ViewContainerRef, parentData?: T): void;
    trackBy: TrackByFunction<T>;
    treeControl: TreeControl<T, K>;
    readonly viewChange: BehaviorSubject<{
        start: number;
        end: number;
    }>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<CdkTree<any, any>, "cdk-tree", ["cdkTree"], { "dataSource": "dataSource"; "treeControl": "treeControl"; "trackBy": "trackBy"; }, {}, ["_nodeDefs"], never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTree<any, any>, never>;
}

// @public (undocumented)
export class CdkTreeModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<CdkTreeModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkTreeModule, [typeof i1.CdkNestedTreeNode, typeof i2.CdkTreeNodeDef, typeof i3.CdkTreeNodePadding, typeof i4.CdkTreeNodeToggle, typeof i5.CdkTree, typeof i5.CdkTreeNode, typeof i6.CdkTreeNodeOutlet], never, [typeof i1.CdkNestedTreeNode, typeof i2.CdkTreeNodeDef, typeof i3.CdkTreeNodePadding, typeof i4.CdkTreeNodeToggle, typeof i5.CdkTree, typeof i5.CdkTreeNode, typeof i6.CdkTreeNodeOutlet]>;
}

// @public
export class CdkTreeNode<T, K = T> implements DoCheck, FocusableOption, OnDestroy, OnInit {
    constructor(_elementRef: ElementRef<HTMLElement>, _tree: CdkTree<T, K>);
    get data(): T;
    set data(value: T);
    // (undocumented)
    protected _data: T;
    readonly _dataChanges: Subject<void>;
    protected readonly _destroyed: Subject<void>;
    // (undocumented)
    protected _elementRef: ElementRef<HTMLElement>;
    focus(): void;
    // (undocumented)
    protected _isAriaExpanded: boolean;
    // (undocumented)
    get isExpanded(): boolean;
    // (undocumented)
    get level(): number;
    static mostRecentTreeNode: CdkTreeNode<any> | null;
    // (undocumented)
    ngDoCheck(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    // @deprecated
    get role(): 'treeitem' | 'group';
    set role(_role: 'treeitem' | 'group');
    // (undocumented)
    protected _setRoleFromData(): void;
    // (undocumented)
    protected _tree: CdkTree<T, K>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNode<any, any>, "cdk-tree-node", ["cdkTreeNode"], { "role": "role"; }, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNode<any, any>, never>;
}

// @public
export class CdkTreeNodeDef<T> {
    constructor(template: TemplateRef<any>);
    // (undocumented)
    template: TemplateRef<any>;
    when: (index: number, nodeData: T) => boolean;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeDef<any>, "[cdkTreeNodeDef]", never, { "when": "cdkTreeNodeDefWhen"; }, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeDef<any>, never>;
}

// @public
export class CdkTreeNodeOutlet {
    constructor(viewContainer: ViewContainerRef, _node?: any);
    // (undocumented)
    _node?: any;
    // (undocumented)
    viewContainer: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeOutlet, "[cdkTreeNodeOutlet]", never, {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeOutlet, [null, { optional: true; }]>;
}

// @public
export class CdkTreeNodeOutletContext<T> {
    $implicit: T;
    constructor(data: T);
    count?: number;
    index?: number;
    level: number;
}

// @public
export class CdkTreeNodePadding<T, K = T> implements OnDestroy {
    constructor(_treeNode: CdkTreeNode<T, K>, _tree: CdkTree<T, K>, _element: ElementRef<HTMLElement>, _dir: Directionality);
    get indent(): number | string;
    set indent(indent: number | string);
    // (undocumented)
    _indent: number;
    indentUnits: string;
    get level(): number;
    set level(value: number);
    // (undocumented)
    _level: number;
    // (undocumented)
    static ngAcceptInputType_level: NumberInput;
    // (undocumented)
    ngOnDestroy(): void;
    _paddingIndent(): string | null;
    protected _setIndentInput(indent: number | string): void;
    protected _setLevelInput(value: number): void;
    // (undocumented)
    _setPadding(forceChange?: boolean): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodePadding<any, any>, "[cdkTreeNodePadding]", never, { "level": "cdkTreeNodePadding"; "indent": "cdkTreeNodePaddingIndent"; }, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodePadding<any, any>, [null, null, null, { optional: true; }]>;
}

// @public
export class CdkTreeNodeToggle<T, K = T> {
    constructor(_tree: CdkTree<T, K>, _treeNode: CdkTreeNode<T, K>);
    // (undocumented)
    static ngAcceptInputType_recursive: BooleanInput;
    get recursive(): boolean;
    set recursive(value: boolean);
    // (undocumented)
    protected _recursive: boolean;
    // (undocumented)
    _toggle(event: Event): void;
    // (undocumented)
    protected _tree: CdkTree<T, K>;
    // (undocumented)
    protected _treeNode: CdkTreeNode<T, K>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeToggle<any, any>, "[cdkTreeNodeToggle]", never, { "recursive": "cdkTreeNodeToggleRecursive"; }, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeToggle<any, any>, never>;
}

// @public
export class FlatTreeControl<T, K = T> extends BaseTreeControl<T, K> {
    constructor(getLevel: (dataNode: T) => number, isExpandable: (dataNode: T) => boolean, options?: FlatTreeControlOptions<T, K> | undefined);
    expandAll(): void;
    getDescendants(dataNode: T): T[];
    // (undocumented)
    getLevel: (dataNode: T) => number;
    // (undocumented)
    isExpandable: (dataNode: T) => boolean;
    // (undocumented)
    options?: FlatTreeControlOptions<T, K> | undefined;
}

// @public
export interface FlatTreeControlOptions<T, K> {
    // (undocumented)
    trackBy?: (dataNode: T) => K;
}

// @public
export function getTreeControlFunctionsMissingError(): Error;

// @public
export function getTreeControlMissingError(): Error;

// @public
export function getTreeMissingMatchingNodeDefError(): Error;

// @public
export function getTreeMultipleDefaultNodeDefsError(): Error;

// @public
export function getTreeNoValidDataSourceError(): Error;

// @public
export class NestedTreeControl<T, K = T> extends BaseTreeControl<T, K> {
    constructor(getChildren: (dataNode: T) => (Observable<T[]> | T[] | undefined | null), options?: NestedTreeControlOptions<T, K> | undefined);
    expandAll(): void;
    // (undocumented)
    getChildren: (dataNode: T) => (Observable<T[]> | T[] | undefined | null);
    getDescendants(dataNode: T): T[];
    protected _getDescendants(descendants: T[], dataNode: T): void;
    // (undocumented)
    options?: NestedTreeControlOptions<T, K> | undefined;
}

// @public
export interface NestedTreeControlOptions<T, K> {
    // (undocumented)
    trackBy?: (dataNode: T) => K;
}

// @public
export interface TreeControl<T, K = T> {
    collapse(dataNode: T): void;
    collapseAll(): void;
    collapseDescendants(dataNode: T): void;
    dataNodes: T[];
    expand(dataNode: T): void;
    expandAll(): void;
    expandDescendants(dataNode: T): void;
    expansionModel: SelectionModel<K>;
    readonly getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null;
    getDescendants(dataNode: T): any[];
    readonly getLevel: (dataNode: T) => number;
    readonly isExpandable: (dataNode: T) => boolean;
    isExpanded(dataNode: T): boolean;
    toggle(dataNode: T): void;
    toggleDescendants(dataNode: T): void;
}

// (No @packageDocumentation comment for this package)

```
