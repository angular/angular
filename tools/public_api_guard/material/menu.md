## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractConstructor } from '@angular/material/core/common-behaviors/constructor';
import { AfterContentInit } from '@angular/core';
import { AfterViewInit } from '@angular/core';
import { AnimationEvent as AnimationEvent_2 } from '@angular/animations';
import { AnimationTriggerMetadata } from '@angular/animations';
import { ApplicationRef } from '@angular/core';
import { BooleanInput } from '@angular/cdk/coercion';
import { CanDisable } from '@angular/material/core';
import { CanDisableRipple } from '@angular/material/core';
import { ChangeDetectorRef } from '@angular/core';
import { ComponentFactoryResolver } from '@angular/core';
import { Constructor } from '@angular/material/core/common-behaviors/constructor';
import { Direction } from '@angular/cdk/bidi';
import { Directionality } from '@angular/cdk/bidi';
import { ElementRef } from '@angular/core';
import { EventEmitter } from '@angular/core';
import { FocusableOption } from '@angular/cdk/a11y';
import { FocusMonitor } from '@angular/cdk/a11y';
import { FocusOrigin } from '@angular/cdk/a11y';
import * as i0 from '@angular/core';
import * as i3 from '@angular/material/core';
import * as i6 from '@angular/common';
import * as i7 from '@angular/cdk/overlay';
import * as i8 from '@angular/cdk/scrolling';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { Overlay } from '@angular/cdk/overlay';
import { QueryList } from '@angular/core';
import { ScrollStrategy } from '@angular/cdk/overlay';
import { Subject } from 'rxjs';
import { TemplateRef } from '@angular/core';
import { ViewContainerRef } from '@angular/core';

// @public @deprecated (undocumented)
export const fadeInItems: AnimationTriggerMetadata;

// @public
export const MAT_MENU_CONTENT: InjectionToken<MatMenuContent>;

// @public
export const MAT_MENU_DEFAULT_OPTIONS: InjectionToken<MatMenuDefaultOptions>;

// @public
function MAT_MENU_DEFAULT_OPTIONS_FACTORY(): MatMenuDefaultOptions;

// @public
export const MAT_MENU_PANEL: InjectionToken<MatMenuPanel<any>>;

// @public
export const MAT_MENU_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;

// @public
function MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;

// @public
const MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    deps: (typeof Overlay)[];
    useFactory: typeof MAT_MENU_SCROLL_STRATEGY_FACTORY;
};

// @public
export class MatMenu extends _MatMenuBase {
    constructor(elementRef: ElementRef<HTMLElement>, ngZone: NgZone, defaultOptions: MatMenuDefaultOptions);
    // (undocumented)
    protected _baseElevation: number;
    // (undocumented)
    protected _elevationPrefix: string;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatMenu, "mat-menu", ["matMenu"], {}, {}, never, ["*"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenu, never>;
}

// @public
export const matMenuAnimations: {
    readonly transformMenu: AnimationTriggerMetadata;
    readonly fadeInItems: AnimationTriggerMetadata;
};

// @public
export class _MatMenuBase implements AfterContentInit, MatMenuPanel<MatMenuItem>, OnInit, OnDestroy {
    constructor(_elementRef: ElementRef<HTMLElement>, _ngZone: NgZone, _defaultOptions: MatMenuDefaultOptions);
    // (undocumented)
    addItem(_item: MatMenuItem): void;
    _allItems: QueryList<MatMenuItem>;
    readonly _animationDone: Subject<AnimationEvent_2>;
    ariaDescribedby: string;
    ariaLabel: string;
    ariaLabelledby: string;
    backdropClass: string;
    // (undocumented)
    protected _baseElevation: number;
    // @deprecated
    get classList(): string;
    set classList(classes: string);
    _classList: {
        [key: string]: boolean;
    };
    // @deprecated
    readonly close: EventEmitter<MenuCloseReason>;
    readonly closed: EventEmitter<MenuCloseReason>;
    direction: Direction;
    // (undocumented)
    protected _elevationPrefix: string;
    focusFirstItem(origin?: FocusOrigin): void;
    _handleKeydown(event: KeyboardEvent): void;
    get hasBackdrop(): boolean | undefined;
    set hasBackdrop(value: boolean | undefined);
    _hovered(): Observable<MatMenuItem>;
    _isAnimating: boolean;
    // @deprecated
    items: QueryList<MatMenuItem>;
    lazyContent: MatMenuContent;
    // (undocumented)
    static ngAcceptInputType_hasBackdrop: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_overlapTrigger: BooleanInput;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    _onAnimationDone(event: AnimationEvent_2): void;
    // (undocumented)
    _onAnimationStart(event: AnimationEvent_2): void;
    get overlapTrigger(): boolean;
    set overlapTrigger(value: boolean);
    overlayPanelClass: string | string[];
    _panelAnimationState: 'void' | 'enter';
    set panelClass(classes: string);
    // (undocumented)
    readonly panelId: string;
    parentMenu: MatMenuPanel | undefined;
    // @deprecated
    removeItem(_item: MatMenuItem): void;
    resetActiveItem(): void;
    _resetAnimation(): void;
    setElevation(depth: number): void;
    setPositionClasses(posX?: MenuPositionX, posY?: MenuPositionY): void;
    _startAnimation(): void;
    templateRef: TemplateRef<any>;
    get xPosition(): MenuPositionX;
    set xPosition(value: MenuPositionX);
    get yPosition(): MenuPositionY;
    set yPosition(value: MenuPositionY);
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<_MatMenuBase, never, never, { "backdropClass": "backdropClass"; "ariaLabel": "aria-label"; "ariaLabelledby": "aria-labelledby"; "ariaDescribedby": "aria-describedby"; "xPosition": "xPosition"; "yPosition": "yPosition"; "overlapTrigger": "overlapTrigger"; "hasBackdrop": "hasBackdrop"; "panelClass": "class"; "classList": "classList"; }, { "closed": "closed"; "close": "close"; }, ["lazyContent", "_allItems", "items"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<_MatMenuBase, never>;
}

// @public
export class MatMenuContent implements OnDestroy {
    constructor(_template: TemplateRef<any>, _componentFactoryResolver: ComponentFactoryResolver, _appRef: ApplicationRef, _injector: Injector, _viewContainerRef: ViewContainerRef, _document: any, _changeDetectorRef?: ChangeDetectorRef | undefined);
    attach(context?: any): void;
    readonly _attached: Subject<void>;
    detach(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatMenuContent, "ng-template[matMenuContent]", never, {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenuContent, never>;
}

// @public
export interface MatMenuDefaultOptions {
    backdropClass: string;
    hasBackdrop?: boolean;
    overlapTrigger: boolean;
    overlayPanelClass?: string | string[];
    xPosition: MenuPositionX;
    yPosition: MenuPositionY;
}

// @public
export class _MatMenuDirectivesModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<_MatMenuDirectivesModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<_MatMenuDirectivesModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<_MatMenuDirectivesModule, [typeof i1.MatMenuTrigger, typeof i2.MatMenuContent], never, [typeof i1.MatMenuTrigger, typeof i2.MatMenuContent, typeof i3.MatCommonModule]>;
}

// @public
export class MatMenuItem extends _MatMenuItemBase implements FocusableOption, CanDisable, CanDisableRipple, AfterViewInit, OnDestroy {
    constructor(_elementRef: ElementRef<HTMLElement>,
    _document?: any, _focusMonitor?: FocusMonitor | undefined, _parentMenu?: MatMenuPanel<MatMenuItem> | undefined);
    _checkDisabled(event: Event): void;
    focus(origin?: FocusOrigin, options?: FocusOptions): void;
    readonly _focused: Subject<MatMenuItem>;
    _getHostElement(): HTMLElement;
    getLabel(): string;
    _getTabIndex(): string;
    _handleMouseEnter(): void;
    _highlighted: boolean;
    readonly _hovered: Subject<MatMenuItem>;
    // (undocumented)
    static ngAcceptInputType_disabled: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_disableRipple: BooleanInput;
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    _parentMenu?: MatMenuPanel<MatMenuItem> | undefined;
    role: 'menuitem' | 'menuitemradio' | 'menuitemcheckbox';
    _triggersSubmenu: boolean;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatMenuItem, "[mat-menu-item]", ["matMenuItem"], { "disabled": "disabled"; "disableRipple": "disableRipple"; "role": "role"; }, {}, never, ["*"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenuItem, [null, null, null, { optional: true; }]>;
}

// @public (undocumented)
export class MatMenuModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenuModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatMenuModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatMenuModule, [typeof i4.MatMenu, typeof i5.MatMenuItem], [typeof i6.CommonModule, typeof i3.MatCommonModule, typeof i3.MatRippleModule, typeof i7.OverlayModule, typeof _MatMenuDirectivesModule], [typeof i8.CdkScrollableModule, typeof i3.MatCommonModule, typeof i4.MatMenu, typeof i5.MatMenuItem, typeof _MatMenuDirectivesModule]>;
}

// @public
export interface MatMenuPanel<T = any> {
    // @deprecated (undocumented)
    addItem?: (item: T) => void;
    // (undocumented)
    backdropClass?: string;
    // (undocumented)
    readonly close: EventEmitter<void | 'click' | 'keydown' | 'tab'>;
    // (undocumented)
    direction?: Direction;
    // (undocumented)
    focusFirstItem: (origin?: FocusOrigin) => void;
    // (undocumented)
    hasBackdrop?: boolean;
    // (undocumented)
    lazyContent?: MatMenuContent;
    // (undocumented)
    overlapTrigger: boolean;
    // (undocumented)
    overlayPanelClass?: string | string[];
    // (undocumented)
    readonly panelId?: string;
    // (undocumented)
    parentMenu?: MatMenuPanel | undefined;
    // @deprecated (undocumented)
    removeItem?: (item: T) => void;
    // (undocumented)
    resetActiveItem: () => void;
    // (undocumented)
    setElevation?(depth: number): void;
    // (undocumented)
    setPositionClasses?: (x: MenuPositionX, y: MenuPositionY) => void;
    // (undocumented)
    templateRef: TemplateRef<any>;
    // (undocumented)
    xPosition: MenuPositionX;
    // (undocumented)
    yPosition: MenuPositionY;
}

// @public
export class MatMenuTrigger implements AfterContentInit, OnDestroy {
    constructor(_overlay: Overlay, _element: ElementRef<HTMLElement>, _viewContainerRef: ViewContainerRef, scrollStrategy: any, parentMenu: MatMenuPanel, _menuItemInstance: MatMenuItem, _dir: Directionality, _focusMonitor?: FocusMonitor | undefined);
    closeMenu(): void;
    // @deprecated (undocumented)
    get _deprecatedMatMenuTriggerFor(): MatMenuPanel;
    set _deprecatedMatMenuTriggerFor(v: MatMenuPanel);
    get dir(): Direction;
    focus(origin?: FocusOrigin, options?: FocusOptions): void;
    _handleClick(event: MouseEvent): void;
    _handleKeydown(event: KeyboardEvent): void;
    _handleMousedown(event: MouseEvent): void;
    get menu(): MatMenuPanel;
    set menu(menu: MatMenuPanel);
    readonly menuClosed: EventEmitter<void>;
    menuData: any;
    get menuOpen(): boolean;
    readonly menuOpened: EventEmitter<void>;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // @deprecated
    readonly onMenuClose: EventEmitter<void>;
    // @deprecated
    readonly onMenuOpen: EventEmitter<void>;
    // (undocumented)
    _openedBy: Exclude<FocusOrigin, 'program' | null> | undefined;
    openMenu(): void;
    restoreFocus: boolean;
    toggleMenu(): void;
    triggersSubmenu(): boolean;
    updatePosition(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatMenuTrigger, "[mat-menu-trigger-for], [matMenuTriggerFor]", ["matMenuTrigger"], { "_deprecatedMatMenuTriggerFor": "mat-menu-trigger-for"; "menu": "matMenuTriggerFor"; "menuData": "matMenuTriggerData"; "restoreFocus": "matMenuTriggerRestoreFocus"; }, { "menuOpened": "menuOpened"; "onMenuOpen": "onMenuOpen"; "menuClosed": "menuClosed"; "onMenuClose": "onMenuClose"; }, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatMenuTrigger, [null, null, null, null, { optional: true; }, { optional: true; self: true; }, { optional: true; }, null]>;
}

// @public
const MENU_PANEL_TOP_PADDING = 8;

// @public
type MenuCloseReason = void | 'click' | 'keydown' | 'tab';

// @public
export type MenuPositionX = 'before' | 'after';

// @public (undocumented)
export type MenuPositionY = 'above' | 'below';

// @public @deprecated (undocumented)
export const transformMenu: AnimationTriggerMetadata;

// (No @packageDocumentation comment for this package)

```
